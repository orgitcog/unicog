{
  "total": 370,
  "by_priority": {
    "critical": 2,
    "high_priority": 44,
    "medium_priority": 307,
    "low_priority": 12,
    "informational": 5
  },
  "fixable_count": 45,
  "needs_research_count": 325,
  "categories": {
    "critical": [
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 115,
        "type": "TODO",
        "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
        "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n",
        "description": "Should this be a shared ptr to avoid memory leak?"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 124,
        "type": "TODO",
        "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
        "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n",
        "description": "Should this be a shared ptr to avoid memory leak?"
      }
    ],
    "high_priority": [
      {
        "file": "analyze_issue_examples.py",
        "line": 36,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",",
        "context": "        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n",
        "description": "URE calls us with broken handle!!\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 106,
        "type": "FIXME",
        "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
        "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n",
        "description": "Instances from Issue #74 - Sorted by Implementation Difficulty"
      },
      {
        "file": "find_actual_stubs.py",
        "line": 8,
        "type": "NotImplementedError",
        "content": "\"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"",
        "context": "from pathlib import Path\n\ndef find_stub_implementations(repo_root):\n    \"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"\n    stubs = []\n    \n    for pyfile in Path(repo_root).rglob(\"*.py\"):\n",
        "description": "NotImplementedError\"\"\""
      },
      {
        "file": "find_actual_stubs.py",
        "line": 59,
        "type": "NotImplementedError",
        "content": "elif 'raise NotImplementedError' in first_impl:",
        "context": "                            elif re.match(r'^\\s*\\.\\.\\.\\s*$', first_impl):\n                                is_stub = True\n                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n",
        "description": "raise NotImplementedError' in first_impl:"
      },
      {
        "file": "find_actual_stubs.py",
        "line": 61,
        "type": "NotImplementedError",
        "content": "stub_type = 'NotImplementedError'",
        "context": "                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n                                is_stub = True\n                                stub_type = 'return_none'\n",
        "description": "NotImplementedError'"
      },
      {
        "file": "find_placeholders.py",
        "line": 4,
        "type": "NotImplementedError",
        "content": "Finds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions",
        "context": "#!/usr/bin/env python3\n\"\"\"\nComprehensive Placeholder Detection Script\nFinds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions\n\"\"\"\nimport os\nimport re\n",
        "description": "NotImplementedError, stub implementations, and empty functions"
      },
      {
        "file": "find_placeholders.py",
        "line": 21,
        "type": "NotImplementedError",
        "content": "'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
        "context": "        self.patterns = {\n            'TODO': r'(//|#|;|/\\*)\\s*TODO[:\\s]',\n            'FIXME': r'(//|#|;|/\\*)\\s*(FIXME|XXX)[:\\s]',\n            'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',\n            'pass_only': r'def\\s+\\w+\\([^)]*\\):\\s*pass\\s*$',\n            'empty_function': r'def\\s+\\w+\\([^)]*\\):\\s*\\.\\.\\.\\s*$',\n            'stub': r'(//|#|;)\\s*STUB[:\\s]',\n",
        "description": "NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',"
      },
      {
        "file": "generate_progress_report.py",
        "line": 29,
        "type": "NotImplementedError",
        "content": "ni_count=analysis['by_type'].get('NotImplementedError', 0)",
        "context": "    fixme_count=analysis['by_type'].get('FIXME', 0)\n    todo_count=analysis['by_type'].get('TODO', 0)\n    stub_comment_count=analysis['by_type'].get('stub', 0)\n    ni_count=analysis['by_type'].get('NotImplementedError', 0)\n    stub_func_count=len(stubs)\n    total_fixes=impl_report['summary']['total_fixes_applied'] + feature_report['summary']['total_implementations']\n    obsolete_fixes_count=impl_report['summary']['by_type'].get('obsolete_comment', 0)\n",
        "description": "NotImplementedError', 0)"
      },
      {
        "file": "generate_progress_report.py",
        "line": 60,
        "type": "NotImplementedError",
        "content": "| **NotImplementedError** | {ni_count}    |",
        "context": "| **FIXME**             | {fixme_count} |\n| **TODO**              | {todo_count}  |\n| **Stub Comments**     | {stub_comment_count} |\n| **NotImplementedError** | {ni_count}    |\n| **Total**             | **{total_placeholders}** |\n\nAdditionally, **{stub_func_count}** actual stub functions (with `pass` or similar) were found, one of which was a candidate for implementation.\n",
        "description": "NotImplementedError** | {ni_count}    |"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 19,
        "type": "NotImplementedError",
        "content": "\"\"\"Add error handling where NotImplementedError is raised\"\"\"",
        "context": "        self.fixes_failed = []\n        \n    def implement_error_handling(self, filepath, line_num, context):\n        \"\"\"Add error handling where NotImplementedError is raised\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:\n                lines = f.readlines()\n",
        "description": "NotImplementedError is raised\"\"\""
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 28,
        "type": "NotImplementedError",
        "content": "# Check if it's a NotImplementedError",
        "context": "            if line_idx >= len(lines):\n                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n",
        "description": "NotImplementedError\n"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 29,
        "type": "NotImplementedError",
        "content": "if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
        "context": "                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n                for i in range(max(0, line_idx - 10), line_idx):\n",
        "description": "NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 42,
        "type": "TODO",
        "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
        "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n",
        "description": "Implement {func_name} functionality\\n'"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 152,
        "type": "NotImplementedError",
        "content": "# Filter for NotImplementedError and validation TODOs",
        "context": "    \n    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n",
        "description": "NotImplementedError and validation TODOs"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 153,
        "type": "NotImplementedError",
        "content": "not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']",
        "context": "    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n",
        "description": "NotImplementedError']"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 158,
        "type": "NotImplementedError",
        "content": "print(f\"Found {len(not_implemented)} NotImplementedError instances\")",
        "context": "                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n    \n    print(f\"Found {len(not_implemented)} NotImplementedError instances\")\n    print(f\"Found {len(validation_todos)} validation TODOs\")\n    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n",
        "description": "NotImplementedError instances\")"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 163,
        "type": "NotImplementedError",
        "content": "# Process NotImplementedError instances",
        "context": "    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n",
        "description": "NotImplementedError instances"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 164,
        "type": "NotImplementedError",
        "content": "print(\"\\nProcessing NotImplementedError instances...\")",
        "context": "    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n        print(f\"  {i}/{min(5, len(not_implemented))}: {placeholder['file']}:{placeholder['line']}\")\n",
        "description": "NotImplementedError instances...\")"
      },
      {
        "file": "implement_scheme_stubs.py",
        "line": 134,
        "type": "NotImplementedError",
        "content": "'NotImplementedError' in p['content']]",
        "context": "    # Find all 'not-implemented' throws\n    not_implemented = [p for p in data['detailed_placeholders'] \n                      if 'not-implemented' in p['content'].lower() or \n                      'NotImplementedError' in p['content']]\n    \n    print(f\"Found {len(not_implemented)} not-implemented stubs\")\n    \n",
        "description": "NotImplementedError' in p['content']]"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 83,
        "type": "TODO",
        "content": "echo \"   // TODO: Implement error handling for edge case X\"",
        "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n",
        "description": "Implement error handling for edge case X\""
      },
      {
        "file": "analyze_placeholders.py",
        "line": 15,
        "type": "NotImplementedError",
        "content": "'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),",
        "context": "    patterns = {\n        'FIXME': re.compile(r'(//|#)\\s*(XXX\\s+)?FIXME[:\\s]*(.*)', re.IGNORECASE),\n        'TODO': re.compile(r'(//|#)\\s*(XXX\\s+)?TODO[:\\s]*(.*)', re.IGNORECASE),\n        'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),\n        'stub': re.compile(r'(//|#)\\s*stub[:\\s]*(.*)', re.IGNORECASE),\n        'pass_placeholder': re.compile(r'pass\\s*#\\s*placeholder', re.IGNORECASE),\n        'empty_function': re.compile(r'^\\s*(def|void|int|bool|float|double)\\s+\\w+\\([^)]*\\)\\s*{\\s*}\\s*$'),\n",
        "description": "NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),"
      },
      {
        "file": "analyze_placeholders.py",
        "line": 106,
        "type": "NotImplementedError",
        "content": "# Check for NotImplementedError with description",
        "context": "        # Check if it has clear implementation hints\n        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n",
        "description": "NotImplementedError with description"
      },
      {
        "file": "analyze_placeholders.py",
        "line": 107,
        "type": "NotImplementedError",
        "content": "elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:",
        "context": "        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n            needs_research.append(p)\n",
        "description": "NotImplementedError' and len(p['description']) > 5:"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
        "line": 31,
        "type": "FIXME",
        "content": "// XXX FIXME: except for the error messages, most of this code is",
        "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n",
        "description": "except for the error messages, most of this code is"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
        "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n",
        "description": "Much of the onfusion below is due to a bug: if the"
      },
      {
        "file": "atomspace/opencog/atoms/core/TypedVariableLink.cc",
        "line": 56,
        "type": "FIXME",
        "content": "VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug",
        "context": "\t    DEFINED_TYPE_NODE != dtype and\n\t    TYPE_CHOICE != dtype and\n\t    TYPE_INTERSECTION_LINK != dtype and\n\t    VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug\n\t    SIGNATURE_LINK != dtype and\n\t    INTERVAL_LINK != dtype and\n\t    ARROW_LINK != dtype)\n",
        "description": "this is wrong; URE-bug"
      },
      {
        "file": "atomspace/opencog/atoms/core/Variables.cc",
        "line": 109,
        "type": "FIXME",
        "content": "// XXX FIXME URE calls us with broken handle!!",
        "context": " */\nvoid Variables::validate_vardecl(const Handle& hdecls)\n{\n\t// XXX FIXME URE calls us with broken handle!!\n\tif (nullptr == hdecls) return;\n\n\t// Expecting the declaration list to be either a single\n",
        "description": "URE calls us with broken handle!!"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1465,
        "type": "FIXME",
        "content": "// XXX FIXME: debug_log() above is more readable than the below.",
        "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n",
        "description": "debug_log() above is more readable than the below."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 692,
        "type": "TODO",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
        "description": "WARNING ERROR: builtin hardcoded shit!!!"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 696,
        "type": "TODO",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
        "description": "WARNING ERROR: builtin hardcoded shit!!!"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1134,
        "type": "TODO",
        "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
        "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
        "description": "to implement enum support, cut-n-paste from CTable"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1256,
        "type": "TODO",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
        "description": "implement timestamp support"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "FIXME",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
        "description": "this is a bug .. the user may have specified that"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1011,
        "type": "TODO",
        "content": "// TODO: implement support for enumerated types in the input.",
        "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
        "description": "implement support for enumerated types in the input."
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1283,
        "type": "TODO",
        "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
        "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
        "description": "this below is clearly unfinished, broken, etc."
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 141,
        "type": "FIXME",
        "content": "# else:  # FIXME: raise error / assert ?",
        "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n",
        "description": "raise error / assert ?"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 692,
        "type": "TODO",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
        "description": "WARNING ERROR: builtin hardcoded shit!!!"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 696,
        "type": "TODO",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
        "description": "WARNING ERROR: builtin hardcoded shit!!!"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1134,
        "type": "TODO",
        "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
        "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
        "description": "to implement enum support, cut-n-paste from CTable"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 1245,
        "type": "TODO",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
        "description": "implement timestamp support"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "FIXME",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
        "description": "this is a bug .. the user may have specified that"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1012,
        "type": "TODO",
        "content": "// TODO: implement support for enumerated types in the input.",
        "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
        "description": "implement support for enumerated types in the input."
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1284,
        "type": "TODO",
        "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
        "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
        "description": "this below is clearly unfinished, broken, etc."
      },
      {
        "file": "ure/opencog/ure/BetaDistribution.cc",
        "line": 33,
        "type": "TODO",
        "content": "// TODO should be replaced by tv->get_mode() once implemented",
        "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n",
        "description": "should be replaced by tv->get_mode() once implemented"
      }
    ],
    "medium_priority": [
      {
        "file": "analyze_issue_examples.py",
        "line": 14,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",",
        "context": "    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n",
        "description": ". Performance has not been recently measured; there\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 16,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",",
        "context": "        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n",
        "description": "maybe later someday, if/when this is needed.\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 17,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",",
        "context": "        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n",
        "description": "-- The recursive design of the depth() routine below makes\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 18,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n",
        "description": "Users should call StorageNode::add_nocheck() instead.\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 19,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n",
        "description": "this does a lot of wasteful string copying.\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 23,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",",
        "context": "        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n",
        "description": "\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 25,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",",
        "context": "        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n",
        "description": "can we fix cython to not do this, already?\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 26,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",",
        "context": "        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n",
        "description": ". Work around the despicable, horrible guile UTF8 handling.\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 28,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",",
        "context": "        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n",
        "description": "This lock is not needed, because in guile-2.2,\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 30,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",",
        "context": "        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n",
        "description": "Are the below needed?\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 32,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",",
        "context": "        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n",
        "description": ", more correct would be to loop over\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 33,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n",
        "description": "This update is not thread-safe.\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 35,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n",
        "description": "- fix this so it can also choose a single value\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 38,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",",
        "context": "        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n",
        "description": "The update here is not thread-safe...\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 42,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
        "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n",
        "description": "; we should be using ptm->isVariable() instead !?\","
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 44,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"",
        "context": "        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n    \n    # Categorize these specific examples\n",
        "description": "this is currently a weak stop-gap measure to handle\""
      },
      {
        "file": "entelechy_introspection.py",
        "line": 600,
        "type": "TODO",
        "content": "r'TODO.*list',  # TODO lists in docs",
        "context": "        \n        # Patterns to exclude (informational, not actionable)\n        exclude_patterns = [\n            r'TODO.*list',  # TODO lists in docs\n            r'GNU',         # GNU license references\n            r'Copyright',   # Copyright notices\n            r'from\\s+TODO', # References to TODO files/modules\n",
        "description": "lists in docs"
      },
      {
        "file": "entelechy_marker_analyzer.py",
        "line": 31,
        "type": "TODO",
        "content": "marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.",
        "context": "    \"\"\"Represents a single code marker (TODO, FIXME, etc.).\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n",
        "description": ", FIXME, STUB, PLACEHOLDER, etc."
      },
      {
        "file": "fixme_resolution_tracker.py",
        "line": 169,
        "type": "FIXME",
        "content": "report.append(\"# FIXME Resolution Progress Report\")",
        "context": "    def generate_next_steps_report(self) -> str:\n        \"\"\"Generate a report implementing the next steps from the catalog.\"\"\"\n        report = []\n        report.append(\"# FIXME Resolution Progress Report\")\n        report.append(f\"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"\")\n        \n",
        "description": "Resolution Progress Report\")"
      },
      {
        "file": "fragmentation_detector.py",
        "line": 22,
        "type": "TODO",
        "content": "marker_type: str  # TODO, FIXME, STUB",
        "context": "    \"\"\"Represents a specific code fragmentation\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n",
        "description": ", FIXME, STUB"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 250,
        "type": "FIXME",
        "content": "# FIXME Resolution Makefile Targets",
        "context": "        \n        makefile = self.repo_root / \"Makefile.fixme\"\n        makefile_content = dedent('''\n            # FIXME Resolution Makefile Targets\n            # Include this in your main Makefile with: include Makefile.fixme\n            \n            .PHONY: fixme-status fixme-easy-wins fixme-report fixme-setup\n",
        "description": "Resolution Makefile Targets"
      },
      {
        "file": "atomspace-restful/lib/zmq/zhelpers.hpp",
        "line": 31,
        "type": "TODO",
        "content": "// todo: package updated zmq.hpp",
        "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n",
        "description": "package updated zmq.hpp"
      },
      {
        "file": "atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "FIXME",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n",
        "description": "Should this moved to the atomspace repo and be part"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 1004,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
        "description": ". We would like to call"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 109,
        "type": "empty_function",
        "content": "void create(void) {}",
        "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
        "description": "\t\tvoid create(void) {}\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1371,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
        "description": ". We would like to call"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 136,
        "type": "empty_function",
        "content": "void create(void) {}",
        "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
        "description": "\t\tvoid create(void) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/csv/table_read.h",
        "line": 38,
        "type": "TODO",
        "content": "// TODO: Should this be a StringValue?",
        "context": "\nnamespace opencog {\n\n// TODO: Should this be a StringValue?\ntypedef std::vector<std::string> string_seq;\n\n/**\n",
        "description": "Should this be a StringValue?"
      },
      {
        "file": "atomspace-storage/opencog/persist/flow/FetchValueOfLink.cc",
        "line": 63,
        "type": "TODO",
        "content": "// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]",
        "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]\n\t// are executable, then they need to be executed, first, right?\n\t// Yes, they do. But, for just right now, we don't, to stay\n\t// compatible with ValueOfLink. See comments in that code.\n",
        "description": "FIXME ... if either of _outgoing[0] or _outgoing[1]"
      },
      {
        "file": "atomspace-storage/opencog/persist/flow/StoreValueOfLink.cc",
        "line": 61,
        "type": "TODO",
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Because that's the\n\t// usual intent. Else they'd be wrapped in a DontExecLink, right?\n\t// I'm confused.\n",
        "description": "FIXME ... if either of these are executable, then"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
        "line": 141,
        "type": "FIXME",
        "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
        "context": "// Get our configuration from the DefineLink we live in.\n// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n",
        "description": ". Using this ProxyParametersLink thing is a kind of"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
        "line": 195,
        "type": "FIXME",
        "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
        "context": "void WriteBufferProxy::updateValue(const Handle& atom, const Handle& key,\n                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n",
        "description": ". Buffering these naively, like this, voilates the"
      },
      {
        "file": "atomspace/opencog/atoms/base/Valuation.cc",
        "line": 50,
        "type": "TODO",
        "content": "// XXX TODO -- C++ smart pointers are not atomic; we really",
        "context": "\nvoid Valuation::setValue(const ValuePtr& v)\n{\n\t// XXX TODO -- C++ smart pointers are not atomic; we really\n\t// need to use a lock here, to avoid thread-races.\n\t_value = v;\n}\n",
        "description": "-- C++ smart pointers are not atomic; we really"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 79,
        "type": "FIXME",
        "content": "// XXX FIXME, this is to be removed, because UnionLink,",
        "context": "\t\t// well, in that case these are interpreted as intersection,\n\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n",
        "description": ", this is to be removed, because UnionLink,"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 93,
        "type": "FIXME",
        "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
        "context": "\t\t// want to forbid it in the future by maybe introducing a\n\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n",
        "description": "... Perhaps IntersectionLink, UnionLink will"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 110,
        "type": "FIXME",
        "content": "// XXX FIXME - fix this so it can also choose a single value",
        "context": "///           AtomZ\n///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n",
        "description": "- fix this so it can also choose a single value"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 143,
        "type": "TODO",
        "content": "// XXX TODO if execute() above returns FloatValue, use that!",
        "context": "\t\t\tif (hw->is_executable())\n\t\t\t\thw = HandleCast(hw->execute(as, silent));\n\n\t\t\t// XXX TODO if execute() above returns FloatValue, use that!\n\t\t\tNumberNodePtr nn(NumberNodeCast(hw));\n\t\t\tif (nullptr == nn) // goto uniform;\n\t\t\t\tthrow SyntaxException(TRACE_INFO,\n",
        "description": "if execute() above returns FloatValue, use that!"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 179,
        "type": "FIXME",
        "content": "// XXX FIXME, also allow a FloatValue!!",
        "context": "\t\tstd::vector<double> weights;\n\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n",
        "description": ", also allow a FloatValue!!"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 296,
        "type": "TODO",
        "content": "// TODO: the following has no unit test!!! Yet it introduces a",
        "context": "\t// Base case\n\tif (h->is_node())\n\t{\n\t\t// TODO: the following has no unit test!!! Yet it introduces a\n\t\t// bug covered by RewriteLinkUTest::test_consume_quotations_4(),\n\t\t// thus this code is disabled till a unit test it created for it\n\t\t// and we understand what it fixes and how it fixes.\n",
        "description": "the following has no unit test!!! Yet it introduces a"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 340,
        "type": "TODO",
        "content": "// TODO: generalize with when Unquote and Quote are apart",
        "context": "\t\t\t// A succession of (Unquote (Quote ..)) is an involution\n\t\t\t// and thus can be remove.\n\t\t\t//\n\t\t\t// TODO: generalize with when Unquote and Quote are apart\n\t\t\tif (child->get_type() == QUOTE_LINK)\n\t\t\t{\n\t\t\t\tquotation.update(child->get_type());\n",
        "description": "generalize with when Unquote and Quote are apart"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.h",
        "line": 224,
        "type": "TODO",
        "content": "// TODO: we probably want to",
        "context": "\t */\n\tHandle consume_quotations() const;\n\tstatic Handle consume_quotations(const Variables& variables, const Handle& h,\n\t                                 // TODO: we probably want to\n\t                                 // move quotation,\n\t                                 // needless_quotation,\n\t                                 // clause_root and more in\n",
        "description": "we probably want to"
      },
      {
        "file": "atomspace/opencog/atoms/core/TypeNode.h",
        "line": 90,
        "type": "TODO",
        "content": "// XXX TODO ... Some types are defined. In this case,",
        "context": "\tstatic void validate(const std::string& str)\n\t{\n\t\tType t = nameserver().getType(str);\n\t\t// XXX TODO ... Some types are defined. In this case,\n\t\t// verify that the string occurs as a name inside\n\t\t// some DefineLink... if it does, then it's valid.\n\t\t// If it does not, then it's invalid.\n",
        "description": "... Some types are defined. In this case,"
      },
      {
        "file": "atomspace/opencog/atoms/core/Variables.cc",
        "line": 437,
        "type": "TODO",
        "content": "// XXX TODO type-checking could be lazy; if the function is not",
        "context": "\t\t\t\"Incorrect number of arguments specified, expecting %lu got %lu\",\n\t\t\tvarseq.size(), args.size());\n\n\t// XXX TODO type-checking could be lazy; if the function is not\n\t// actually using one of the args, it's type should not be checked.\n\t// Viz., one of the arguments might be undefined, and that's OK,\n\t// if that argument is never actually used.  Fixing this requires a\n",
        "description": "type-checking could be lazy; if the function is not"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 288,
        "type": "TODO",
        "content": "// TODO: what about globs?",
        "context": "\t\t\treturn expr;\n\n\t\t// If it is a quoted or shadowed variable don't substitute.\n\t\t// TODO: what about globs?\n\t\tif (VARIABLE_NODE == t and not context_cp.is_free_variable(expr))\n\t\t\treturn expr;\n\n",
        "description": "what about globs?"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 598,
        "type": "FIXME",
        "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
        "context": "\t// We do this here, instead of in walk_tree(), because adding\n\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n",
        "description": "Can we defer the addition to the atomspace to an even"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 642,
        "type": "FIXME",
        "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
        "context": "\tif (expr->is_type(NODE) and expr->is_executable())\n\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n",
        "description": ", we need to get rid of this call entirely, and just"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 69,
        "type": "TODO",
        "content": "// TODO: Handle executable _outgoing[0] by executing it first.",
        "context": "\n\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n",
        "description": "Handle executable _outgoing[0] by executing it first."
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 70,
        "type": "TODO",
        "content": "// TODO: Support complex type signatures beyond simple TYPE_NODE.",
        "context": "\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n\t\tthrow InvalidParamException(TRACE_INFO,\n",
        "description": "Support complex type signatures beyond simple TYPE_NODE."
      },
      {
        "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
        "line": 615,
        "type": "TODO",
        "content": "// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,",
        "context": "\t{\n\t\tvex = _outgoing[1]->execute(as, silent);\n\n\t\t// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,\n\t\t// then we should construct another Queue as the return value,\n\t\t// and perform filtering on-demand.\n\t\tif (vex->is_type(LINK_VALUE))\n",
        "description": "FIXME -- if vex is a stream, e.g. a QueueValue,"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
        "line": 41,
        "type": "FIXME",
        "content": "/// XXX FIXME - in the future, some user is going to want to include",
        "context": "/// not typed, and there are *two* bodies, each body returning one\n/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n",
        "description": "- in the future, some user is going to want to include"
      },
      {
        "file": "atomspace/opencog/atoms/flow/ValueOfLink.cc",
        "line": 84,
        "type": "TODO",
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "\t// space; we can add the Atom there, and things will\n\t// trickle out properly in the end.\n\t//\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Yes, they do! We\n\t// can currently get away with not doing this for two reasons:\n\t// In all existing code, the first Atom is always an anchor,\n",
        "description": "FIXME ... if either of these are executable, then"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 549,
        "type": "TODO",
        "content": "/// TODO: it might be faster to use hash tables instead of rb-trees",
        "context": "/// think of any way of combining steps (2) and (3) that would avoid\n/// step (4) ... or even would reduce the work for stpe (4). Oh well.\n///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n",
        "description": "it might be faster to use hash tables instead of rb-trees"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 721,
        "type": "FIXME",
        "content": "// XXX FIXME this is really dumb, using a queue and then",
        "context": "\n\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n",
        "description": "this is really dumb, using a queue and then"
      },
      {
        "file": "atomspace/opencog/atoms/parallel/ExecuteThreadedLink.cc",
        "line": 59,
        "type": "TODO",
        "content": "/// XXX TODO: We could have a non-blocking version of this atom. We",
        "context": "/// Atoms in the set. If the NumberNode is present, then the number of\n/// threads is the smaller of the NumberNode and the seize of the Set.\n///\n/// XXX TODO: We could have a non-blocking version of this atom. We\n/// could just return the QueueValue immediately; the user could check\n/// to see if the queue is closed, to find out if the threads have\n/// finished.\n",
        "description": "We could have a non-blocking version of this atom. We"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 146,
        "type": "FIXME",
        "content": "// XXX FIXME, more correct would be to loop over",
        "context": "\t{\n\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n",
        "description": ", more correct would be to loop over"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 165,
        "type": "FIXME",
        "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
        "context": "\t\tunbundle_clauses(h);\n\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n",
        "description": ", this handles `absents`, `always` and `grouping`"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1039,
        "type": "FIXME",
        "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
        "context": "/// If the ImplicationLink is suitably simple, it can be added\n/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n",
        "description": "the code here assumes that the situation is indeed"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1255,
        "type": "FIXME",
        "content": "// XXX FIXME -- this is wrong. What we really want is to",
        "context": "\t\t\t_pat.have_evaluatables = true;\n\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n",
        "description": "-- this is wrong. What we really want is to"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
        "line": 80,
        "type": "TODO",
        "content": "// TODO: it would probably be more efficient to swap which of these",
        "context": "\tHandle _handle;\n\tHandle _quote;\n\n\t// TODO: it would probably be more efficient to swap which of these\n\t// two is weak, since I think _outgoing is requested far more often\n\t// than _parent, and having it run faster would be a performance win.\n\tPatternTermPtr _parent;\n",
        "description": "it would probably be more efficient to swap which of these"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternUtils.cc",
        "line": 55,
        "type": "FIXME",
        "content": "// XXX FIXME Are the below needed?",
        "context": "\t\t      or nameserver().isA(clause->getOutgoingAtom(0)->get_type(),\n\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n",
        "description": "Are the below needed?"
      },
      {
        "file": "atomspace/opencog/atoms/reduct/AccumulateLink.cc",
        "line": 71,
        "type": "TODO",
        "content": "// XXX TODO -- we could also handle vectors of strings, by",
        "context": "\t\treturn createFloatValue(acc);\n\t}\n\n\t// XXX TODO -- we could also handle vectors of strings, by\n\t// concatenating them into one long string.  However, for this\n\t// to be generally useful, we'd want to insert whitespace in\n\t// between. But how? One way would be to pass another argument\n",
        "description": "-- we could also handle vectors of strings, by"
      },
      {
        "file": "atomspace/opencog/atoms/reduct/DecimateLink.cc",
        "line": 65,
        "type": "FIXME",
        "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
        "context": "\t\treturn do_execute(vmask, vi);\n\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n",
        "description": "... both the NumberNode and the FloatValue variations"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 138,
        "type": "TODO",
        "content": "// TODO: this should probably be moved to a method on class Atom.",
        "context": "        }\n\n        // Check the values...\n        // TODO: this should probably be moved to a method on class Atom.\n        if (check_values)\n        {\n            HandleSet keys_first = atom_first->getKeys();\n",
        "description": "this should probably be moved to a method on class Atom."
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 272,
        "type": "FIXME",
        "content": "// Fixme maybe later someday, if/when this is needed.",
        "context": "\t// having one AtomSpace be placed as a member into many others,\n\t// except that we don't have any viable mechanisms for such multiple\n\t// membership, and so I don't know how to treat this right now.\n\t// Fixme maybe later someday, if/when this is needed.\n\tif (not (nullptr == _atom_space or as == nullptr))\n\t\tthrow RuntimeException(TRACE_INFO,\n\t\t\t\"At this time, an AtomSpace can only be placed in one other\\n\"\n",
        "description": "maybe later someday, if/when this is needed."
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 283,
        "type": "FIXME",
        "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
        "context": "}\n\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n",
        "description": "-- The recursive design of the depth() routine below makes"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.h",
        "line": 524,
        "type": "FIXME",
        "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
        "context": "\n    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n",
        "description": "Users should call StorageNode::add_nocheck() instead."
      },
      {
        "file": "atomspace/opencog/atomspace/Transient.cc",
        "line": 43,
        "type": "FIXME",
        "content": "/// XXX FIXME. Performance has not been recently measured; there",
        "context": "/// cheaper to just have a cache of empty atomspaces, hanging around,\n/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n",
        "description": ". Performance has not been recently measured; there"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 1427,
        "type": "FIXME",
        "content": "// XXX FIXME this does a lot of wasteful string copying.",
        "context": "\nvoid PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n",
        "description": "this does a lot of wasteful string copying."
      },
      {
        "file": "atomspace/opencog/guile/SchemeSmobAtom.cc",
        "line": 84,
        "type": "FIXME",
        "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
        "context": "\n/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n",
        "description": ". Work around the despicable, horrible guile UTF8 handling."
      },
      {
        "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 73,
        "type": "FIXME",
        "content": "// XXX FIXME: can we fix cython to not do this, already?",
        "context": "// NOTE HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n",
        "description": "can we fix cython to not do this, already?"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 126,
        "type": "FIXME",
        "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
        "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n",
        "description": "; we should be using ptm->isVariable() instead !?"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 382,
        "type": "TODO",
        "content": "// TODO -- weed out duplicates!",
        "context": "\t}\n\telse\n\t{\n\t\t// TODO -- weed out duplicates!\n\t}\n\treturn true;\n}\n",
        "description": "-- weed out duplicates!"
      },
      {
        "file": "atomspace/opencog/query/NextSearchMixin.cc",
        "line": 167,
        "type": "TODO",
        "content": "// XXX TODO ... Rather than counting the number of variables, we",
        "context": "// can be done in a direct fashion; it resembles the concept of\n// \"unit propagation\" in the DPLL algorithm.\n//\n// XXX TODO ... Rather than counting the number of variables, we\n// should instead look for one with the smallest incoming set.\n// That is because the very next thing that we do will be to\n// iterate over the incoming set of \"pursue\" ... so it could be\n",
        "description": "... Rather than counting the number of variables, we"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 284,
        "type": "FIXME",
        "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
        "context": "/// Compare the contents of a Present term in the pattern to the\n/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n",
        "description": "this is currently a weak stop-gap measure to handle"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1532,
        "type": "FIXME",
        "content": "// XXX FIXME - this is not very elegant. We should probably",
        "context": "\t// If this is some other rando variable that is not part of\n\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n",
        "description": "- this is not very elegant. We should probably"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1982,
        "type": "FIXME",
        "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
        "context": "/// form; see `explore_sparse_branches()`.\n///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n",
        "description": "Issue #3016 - Unification with unordered AndLinks"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2049,
        "type": "FIXME",
        "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
        "context": "/// functional group, and the glob will end up holding the moiety that\n/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n",
        "description": "Right now, this code handles graphs that have only one"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2065,
        "type": "TODO",
        "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
        "context": "{\n\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n",
        "description": "FIXME. The ptm needs to be decomposed into connected"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2223,
        "type": "FIXME",
        "content": "/// XXX FIXME -- do the above.",
        "context": "/// -- build a connectivity map, just like the one for clauses\n/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n",
        "description": "-- do the above."
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2445,
        "type": "TODO",
        "content": "// XXX TODO make sure that all variables in the clause have",
        "context": "\t\t                 << \"Parent has evaluatable but code path was expected to be unreachable. \"\n\t\t                 << \"Clause: \" << clause->getQuote()->to_string();\n\t\t// Continue with the evaluation anyway, but log the issue\n\t\t// XXX TODO make sure that all variables in the clause have\n\t\t// been grounded!  If they're not, something is badly wrong!\n\t\tlogmsg(\"Term inside evaluatable, move up to it's top:\",\n\t\t\t       clause->getQuote());\n",
        "description": "make sure that all variables in the clause have"
      },
      {
        "file": "atomspace/opencog/query/Recognizer.cc",
        "line": 126,
        "type": "TODO",
        "content": "// TODO: Change to something better if possible...",
        "context": "\t// mis-matched types are a dead-end.\n\tif (lpat->get_type() != lsoln->get_type()) return false;\n\n\t// TODO: Change to something better if possible...\n\t// What is happening here is to manually call the\n\t// fuzzy_match callback immediately if and only if\n\t// lsoln has one or more GlobNodes AND lpat and lsoln\n",
        "description": "Change to something better if possible..."
      },
      {
        "file": "atomspace/opencog/query/SatisfyMixin.cc",
        "line": 583,
        "type": "FIXME",
        "content": "// XXX FIXME terrible hack.",
        "context": "\t\t// pure absent is found.\n\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n",
        "description": "terrible hack."
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 551,
        "type": "TODO",
        "content": "// XXX TODO as discussed on the mailing list, we should perhaps first",
        "context": "\t//       Arg1Atom\n\t//       Arg2Atom\n\t//\n\t// XXX TODO as discussed on the mailing list, we should perhaps first\n\t// see if the following can be found in the atomspace:\n\t//\n\t//   EvaluationLink\n",
        "description": "as discussed on the mailing list, we should perhaps first"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 710,
        "type": "FIXME",
        "content": "// XXX FIXME: worse: this cannot possibly be right when",
        "context": "\t\t// possibilities?  And if they failed to do so, can we even do\n\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n",
        "description": "worse: this cannot possibly be right when"
      },
      {
        "file": "atomspace/tests/cython/atomspace/test_atomspace.py",
        "line": 362,
        "type": "FIXME",
        "content": "# XXX FIXME is testing the name of the bottom type",
        "context": "    def test_get_type_name(self):\n        self.assertEqual(get_type_name(types.Node), \"Node\")\n        self.assertEqual(get_type_name(2231), \"\")\n        # XXX FIXME is testing the name of the bottom type\n        # a sane thing to do?\n        self.assertEqual(get_type_name(types.NO_TYPE), \"*** Bottom Type! ***\")\n",
        "description": "is testing the name of the bottom type"
      },
      {
        "file": "cogserver/opencog/cogserver/server/CogServer.cc",
        "line": 125,
        "type": "FIXME",
        "content": "// XXX FIXME. terrible terrible hack. What we should be",
        "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n",
        "description": ". terrible terrible hack. What we should be"
      },
      {
        "file": "cogutil/opencog/util/zipf.h",
        "line": 90,
        "type": "empty_function",
        "content": "void reset() {}",
        "context": "\t\t\tif (-0.5 >= q)\n\t\t\t\tthrow std::runtime_error(\"Range error: Parameter q must be greater than -0.5!\");\n\t\t}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
        "description": "\t\tvoid reset() {}\n"
      },
      {
        "file": "cogutil/opencog/util/zipf.h",
        "line": 233,
        "type": "empty_function",
        "content": "void reset() {}",
        "context": "\t\t\t_q(q),\n\t\t\t_dist(_pdf.begin(), _pdf.end())\n\t\t{}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
        "description": "\t\tvoid reset() {}\n"
      },
      {
        "file": "components/core/atomspace-restful/lib/zmq/zhelpers.hpp",
        "line": 31,
        "type": "TODO",
        "content": "// todo: package updated zmq.hpp",
        "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n",
        "description": "package updated zmq.hpp"
      },
      {
        "file": "components/core/atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "FIXME",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n",
        "description": "Should this moved to the atomspace repo and be part"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 920,
        "type": "TODO",
        "content": "// XXX TODO - maybe load links depth-order...",
        "context": "{\n\tCHECK_OPEN;\n\t// First, load all the nodes ... then the links.\n\t// XXX TODO - maybe load links depth-order...\n\tloadAtoms(table, \"n@\");\n\tloadAtoms(table, \"l@\");\n}\n",
        "description": "- maybe load links depth-order..."
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 944,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
        "description": ". We would like to call"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 107,
        "type": "empty_function",
        "content": "void create(void) {}",
        "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
        "description": "\t\tvoid create(void) {}\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksDAG.cc",
        "line": 240,
        "type": "TODO",
        "content": "// XXX TODO: we should probably cache the results, instead of",
        "context": "void RocksStorage::makeOrder(Handle hasp,\n                             std::map<uint64_t, Handle>& order)\n{\n// XXX TODO: we should probably cache the results, instead of\n// recomputing every time!?\n\t// As long as there's a stack of Frames, just loop.\n\twhile (true)\n",
        "description": "we should probably cache the results, instead of"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1283,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
        "description": ". We would like to call"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX FIXME -- are open and close actually needed for anything?",
        "context": "    _storage = nullptr;\n}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n",
        "description": "-- are open and close actually needed for anything?"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 136,
        "type": "empty_function",
        "content": "void create(void) {}",
        "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
        "description": "\t\tvoid create(void) {}\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/Fuzzy.cc",
        "line": 81,
        "type": "TODO",
        "content": "// TODO: Extend to find similar links as well",
        "context": "    {\n        if (h->is_node())\n        {\n            // TODO: Extend to find similar links as well\n            if (lp->get_type() == SIMILARITY_LINK)\n                sl.emplace_back(lp->get_handle());\n\n",
        "description": "Extend to find similar links as well"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatchBasic.cc",
        "line": 106,
        "type": "TODO",
        "content": "// TODO: May use Truth Value instead",
        "context": "\tdouble similarity = common_nodes.size();\n\n\t// Roughly estimate how \"rare\" each node is by using 1 / incoming set size\n\t// TODO: May use Truth Value instead\n\t// for (const Handle& common_node : common_nodes)\n\t// \tsimilarity += 1.0 / common_node->getIncomingSetSize();\n\n",
        "description": "May use Truth Value instead"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 41,
        "type": "TODO",
        "content": "// TODO:",
        "context": "TruthValuePtr OpenPsiImplicator::check_satisfiability(const Handle& rule,\n    OpenPsiRules& opr)\n{\n  // TODO:\n  // Solve for multithreaded access. Create a rule class and lock\n  // the rule when updating the cache.\n\n",
        "description": ""
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 49,
        "type": "TODO",
        "content": "// TODO: Add cache per atomspace.",
        "context": "  Handle query_body = query->get_pattern().body;\n\n  // Always update cache to clear any previous result.\n  // TODO: Add cache per atomspace.\n  _satisfiability_cache.erase(query_body);\n  _pattern_seen.insert(query_body);\n\n",
        "description": "Add cache per atomspace."
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.h",
        "line": 44,
        "type": "TODO",
        "content": "// TODO Why would one need to reset during psi-loop?",
        "context": "  friend class OpenPsiSatisfier;\n\n  // Needed for resetting private cache.\n  // TODO Why would one need to reset during psi-loop?\n  friend class ::OpenPsiImplicatorUTest;\n\npublic:\n",
        "description": "Why would one need to reset during psi-loop?"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 101,
        "type": "TODO",
        "content": "// TODO But why make the add_category public then?",
        "context": "{\n  _as->add_link(MEMBER_LINK, rule, category);\n  // Add the category just in case it hasn't been declared.\n  // TODO But why make the add_category public then?\n  add_category(category);\n  _category_index[category].insert(rule);\n\n",
        "description": "But why make the add_category public then?"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 105,
        "type": "TODO",
        "content": "// TODO:add predicate to check for membership of category.",
        "context": "   * @param new_category The node reprsenting the new category.\n   * @return ConceptNode that represents the category.\n   */\n   // TODO:add predicate to check for membership of category.\n  Handle add_category(const Handle& new_category);\n\n  /**\n",
        "description": "add predicate to check for membership of category."
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 126,
        "type": "TODO",
        "content": "// TODO Should these entries be a member of Rules class?",
        "context": "   * where queryis a PatternLink that isn't added to the atomspace, and\n   * is used to check if the rule is satisfiable.\n   */\n  // TODO Should these entries be a member of Rules class?\n  typedef std::tuple<HandleSeq, Handle, Handle, PatternLinkPtr> PsiTuple;\n\n  /**\n",
        "description": "Should these entries be a member of Rules class?"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 136,
        "type": "TODO",
        "content": "// TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,",
        "context": "   */\n  std::map<Handle, PsiTuple> _psi_rules;\n\n  // TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,\n  // because it might hinder interoperability with other components that\n  // expect an explicit ontological representation. For historic reasons we\n  // continue using such convention but should be replaced with graph that\n",
        "description": "Using names that are prefixed with \"OpenPsi: \" might be a bad idea,"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 91,
        "type": "TODO",
        "content": "// TODO: Should this be a singleton? What could be the issues that need",
        "context": "  const Handle& goal, const TruthValuePtr stv, const Handle& category)\n{\n  AtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"psi-rule\");\n  // TODO: Should this be a singleton? What could be the issues that need\n  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n",
        "description": "Should this be a singleton? What could be the issues that need"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 95,
        "type": "TODO",
        "content": "// TODO: Add to multiple categories using scheme rest list.",
        "context": "  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n  // TODO: Add to multiple categories using scheme rest list.\n  openpsi_cache(asp.get()).add_to_category(rule, category);\n  return rule;\n}\n",
        "description": "Add to multiple categories using scheme rest list."
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 42,
        "type": "TODO",
        "content": "// TODO: Saperated component patterns aren't handled by this function",
        "context": "bool OpenPsiSatisfier::grounding(const HandleMap &var_soln,\n                                  const HandleMap &term_soln)\n{\n  // TODO: Saperated component patterns aren't handled by this function\n  // as PMCGroundings is used instead. Update to handle such cases.\n\n  // The psi-rule weight calculations could be done here.\n",
        "description": "Saperated component patterns aren't handled by this function"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 56,
        "type": "TODO",
        "content": "// TODO: If we are here it means the suggested groundings doesn't have",
        "context": "      }\n    }\n\n    // TODO: If we are here it means the suggested groundings doesn't have\n    // VariableNodes, and can be cached. This doesn't account for terms\n    // that are under QuoteLink, or other similar type links. How should\n    // such cases be handled?\n",
        "description": "If we are here it means the suggested groundings doesn't have"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 76,
        "type": "TODO",
        "content": "// TODO: This happens when InitiateSearchCB::no_search has groundings.",
        "context": "    _implicator -> _satisfiability_cache[_pattern_body] = var_soln;\n    return true;\n  } else {\n    // TODO: This happens when InitiateSearchCB::no_search has groundings.\n    // Cases for when this happens hasn't been tested yet. Explore the\n    // behavior and find a better solution. For now, log it and continue\n    // searching.\n",
        "description": "This happens when InitiateSearchCB::no_search has groundings."
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 93,
        "type": "FIXME",
        "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
        "context": "\tif (_in_server) return;\n\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n",
        "description": "This lock is not needed, because in guile-2.2,"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1028,
        "type": "TODO",
        "content": "// TODO: it would be nice to pass exceptions on through, but",
        "context": "\t}\n\texpr = scm_cons(sfunc, expr);\n\n\t// TODO: it would be nice to pass exceptions on through, but\n\t// this currently breaks unit tests.\n\t// if (_in_eval)\n\t//    return scm_eval(expr, scm_interaction_environment());\n",
        "description": "it would be nice to pass exceptions on through, but"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1057,
        "type": "FIXME",
        "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
        "context": "\t\t{\n\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n",
        "description": "-- idealy we should avoid catch-and-rethrow."
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1180,
        "type": "FIXME",
        "content": "// XXX FIXME only a subset is needed.",
        "context": "\nvoid SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n",
        "description": "only a subset is needed."
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 239,
        "type": "FIXME",
        "content": "// XXX FIXME this does not smell right; optionals should get",
        "context": "\n    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n",
        "description": "this does not smell right; optionals should get"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 268,
        "type": "FIXME",
        "content": "// XXX FIXME ... using an std::map would be more efficient.",
        "context": "    // remove repeated atoms from OR\n    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n",
        "description": "... using an std::map would be more efficient."
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictNode.cc",
        "line": 132,
        "type": "empty_function",
        "content": "void opencog_nlp_lgparse_init(void) {}",
        "context": "\n/* This allows guile to load this shared library */\nextern \"C\" {\n\tvoid opencog_nlp_lgparse_init(void) {}\n};\n",
        "description": "\tvoid opencog_nlp_lgparse_init(void) {}\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 46,
        "type": "FIXME",
        "content": "// FIXME XXX -- Optionals are handled incorrectly here;",
        "context": "\n    std::vector<LGDictExpContainer> subcontainers;\n\n    // FIXME XXX -- Optionals are handled incorrectly here;\n    // they are denoted by a null Exp pointer in an OR_list!\n    // Ignoring all the nulls is just ... wrong.\n#if (LINK_MAJOR_VERSION == 5) &&  (LINK_MINOR_VERSION < 7)\n",
        "description": "XXX -- Optionals are handled incorrectly here;"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 103,
        "type": "FIXME",
        "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
        "context": "\n    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n",
        "description": "-- if dn_head is null, then we should check regexes."
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 229,
        "type": "FIXME",
        "content": "// XXX FIXME. This should be part of the LgDictNode but since",
        "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n",
        "description": ". This should be part of the LgDictNode but since"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 338,
        "type": "FIXME",
        "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
        "context": "\t\t\tparse_options_set_linkage_limit(opts, max_linkages);\n\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n",
        "description": "-- We should fish parse options out of the atomspace."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "TODO",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n",
        "description": "would be nice to have a more Caml/Haskell style syntax here,"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "TODO",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n",
        "description": ""
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "TODO",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n",
        "description": ""
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/eval.cc",
        "line": 530,
        "type": "TODO",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return eval_throws_tree(bmap, exp_tr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
        "description": "contin_if should go away."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 336,
        "type": "TODO",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
        "description": "contin_if should go away."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "TODO",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n",
        "description": "-- replace this by cond"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "FIXME",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n",
        "description": ""
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "TODO",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n",
        "description": "sin(*(-1 x)) -> -sin(x)"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 100,
        "type": "TODO",
        "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
        "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n",
        "description": "I don't understand why this is not damaging contin_if  !??"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 667,
        "type": "stub",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
        "description": "// stub out, for performance."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 697,
        "type": "stub",
        "content": "// stubbed out for performance",
        "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
        "description": "// stubbed out for performance"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "TODO",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n",
        "description": ""
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 409,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 434,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 848,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1352,
        "type": "TODO",
        "content": "// XXX TODO, it would be easier if KLD took a sorted list",
        "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n",
        "description": ", it would be easier if KLD took a sorted list"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1366,
        "type": "TODO",
        "content": "// XXX TODO remove this print, for better performance.",
        "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n",
        "description": "remove this print, for better performance."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.cc",
        "line": 599,
        "type": "TODO",
        "content": "// XXX TODO the code below was modified to allow arg lists of",
        "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n",
        "description": "the code below was modified to allow arg lists of"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "TODO",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n",
        "description": "lambda"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "TODO",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n",
        "description": "DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "TODO",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n",
        "description": "re-enable that once best_possible_bscore is fixed"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "TODO",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n",
        "description": "I think it might be a little more efficent to use the"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem-params.cc",
        "line": 166,
        "type": "TODO",
        "content": "// XXX TODO: make this print correctly, instead of using brackets.",
        "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n",
        "description": "make this print correctly, instead of using brackets."
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n",
        "description": "TODO The structure below should be split into multiple"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "FIXME",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n",
        "description": "-- the multiple tables should be merged into one."
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "FIXME",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n",
        "description": ".. check that they all have the same signature."
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "FIXME",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n",
        "description": "we should use a pointer set for scored_combo_tree_set"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "TODO",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n",
        "description": "Make population cap size-sensitive to exemplar complexity."
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "FIXME",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n",
        "description": "looks to me like it++ can often be collaed twice within this loop!"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "FIXME",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n",
        "description": "should probably not recompute every time ..."
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "TODO",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n",
        "description": "we may want to output the visited status as well"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "TODO",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n",
        "description": "use the option of the output"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 201,
        "type": "TODO",
        "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
        "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n",
        "description": "-- trim the deme down, before sending, by using the worst acceptable score."
      },
      {
        "file": "components/learning/moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "TODO",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n",
        "description": "Improve generation tracking by getting actual number"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "TODO",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n",
        "description": "this should be a std::valarray not std::vector but I am too"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 110,
        "type": "TODO",
        "content": "// XXX TODO make sure this value is appropriately updated.",
        "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n",
        "description": "make sure this value is appropriately updated."
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 197,
        "type": "TODO",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n",
        "description": "work in a better way to identify convergence."
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 236,
        "type": "TODO",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n",
        "description": "Explanation"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 154,
        "type": "TODO",
        "content": "// TODO: pso description",
        "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n",
        "description": "pso description"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 315,
        "type": "TODO",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n",
        "description": "Wind dispersion, but test without first"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/star-anneal.cc",
        "line": 42,
        "type": "TODO",
        "content": "// XXX TODO the annealing temperature control code should be ported over",
        "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n",
        "description": "the annealing temperature control code should be ported over"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 316,
        "type": "TODO",
        "content": "/// TODO: measure and compare the resulting performance.",
        "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n",
        "description": "measure and compare the resulting performance."
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 489,
        "type": "TODO",
        "content": "// TODO: should bias the selection of these, so that",
        "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n",
        "description": "should bias the selection of these, so that"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 581,
        "type": "TODO",
        "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
        "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n",
        "description": "Benchmark and clarify optimal breakeven point across different problem sizes."
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 690,
        "type": "TODO",
        "content": "// XXX TODO: Is this really optimal?  The below adds an entire copy",
        "context": "        }\n    }\n\n    // XXX TODO: Is this really optimal?  The below adds an entire copy\n    // of the tree at it, which clearly increases the overall complexity.\n    // But is this really a wise thig to do? It seems gratuitous, and it's\n    // not obvious that knobs from this flipped tree will yeild benefits,\n",
        "description": "Is this really optimal?  The below adds an entire copy"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1181,
        "type": "TODO",
        "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
        "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n",
        "description": "should bias the selection of these (and possibly choose larger subtrees)"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1342,
        "type": "FIXME",
        "content": "//FIXME: now just attaches to the first output",
        "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n",
        "description": "now just attaches to the first output"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "FIXME",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n",
        "description": ", calling score_tree above does not throw the exception; this should be done"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 51,
        "type": "TODO",
        "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
        "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n",
        "description": "One might think that varying the stepsize, i.e. shrinking"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 236,
        "type": "TODO",
        "content": "// XXX TODO need to add support for \"term algebra\" knobs",
        "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n",
        "description": "need to add support for \"term algebra\" knobs"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "TODO",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n",
        "description": ""
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 486,
        "type": "TODO",
        "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n",
        "description": "-- should not return the penalties as part of the bscore,"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
        "line": 108,
        "type": "FIXME",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n",
        "description": "complexity_t should be a double not an int ..."
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 124,
        "type": "TODO",
        "content": "// XXX TODO should be a std::valarray not a vector.",
        "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n",
        "description": "should be a std::valarray not a vector."
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "TODO",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n",
        "description": "multipler other than 1 is not supported yet"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 32,
        "type": "FIXME",
        "content": "log = OrderedDict()  # FIXME: log \u00bb response",
        "context": "    algorithm = kwa('kmeans', 'clustering', **kwargs)\n    verbose = kwa('none', 'verbose', **kwargs)\n\n    log = OrderedDict()  # FIXME: log \u00bb response\n    log.update({'category_learner': 'v.0.7.81231'})\n\n    cdf = pd.DataFrame(columns = ['cluster', 'cluster_words'])\n",
        "description": "log \u00bb response"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 53,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            dim = vector_space_dim(links, dict_path, tmpath, dim_max, sv_min,\n                                   verbose)\n        except:  # FIXME\n            dim = dim_max\n        log.update({'vector_space_dim': dim})\n\n",
        "description": ""
      },
      {
        "file": "language-learning/src/grammar_learner/clustering.py",
        "line": 361,
        "type": "TODO",
        "content": "# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids",
        "context": "# 80809 update: (30,60,3,[3]) - old range + repeat / (120,30,3) -- search opt\n# 80825 random_clusters\n# 81022 refactoring\n# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids\n# 81231 cleanup\n# 90104 resolve Turtle MST LW crash: 1 cluster\n# 90209 group_links: add min_word_count to 80925 legacy version\n",
        "description": "n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 14,
        "type": "FIXME",
        "content": "nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?",
        "context": "    rights = Counter()  # right words in links\n    links = Counter()   # tuples: (left_word, right_word)\n    lw = Counter()      # linked words\n    nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?\n    nlws = set()        # a set of non-linked words in a sentence in a loop\n    nnlws = 0           # number of non-linked word occasions in all sentences\n    sentence = []       # a list of words (used within loops)\n",
        "description": "not used \u00bb DEL?"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 37,
        "type": "FIXME",
        "content": "nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned",
        "context": "                if len(nlws) > 0:  # indices of non-parsed words in sentence\n                    nnlws += len(nlws)  # number of non-linked words\n                    for j in nlws:\n                        nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned\n                    # nlws = set()\n                # sentence = []\n                # Count only parsed words (excluding ###LEFT-WALL### and .)\n",
        "description": "DEL? nlw not returned"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 116,
        "type": "TODO",
        "content": "# TODO: update sentence length count to parsed words?",
        "context": "# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n# TODO: update sentence length count to parsed words?\n",
        "description": "update sentence length count to parsed words?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 71,
        "type": "TODO",
        "content": "# TODO? sort by frequency?",
        "context": "        d = {x: (i + 1) for i, x in\n             enumerate(sorted(set([x for y in cats['disjuncts'] for x in y])))}\n        cats['djs'] = [set([d[x] for x in y]) for y in cats['disjuncts']]\n        # TODO? sort by frequency?\n\n    return cats, sorted(set(similarities), reverse = True)\n\n",
        "description": "? sort by frequency?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 90,
        "type": "TODO",
        "content": "# TODO? define order of children?",
        "context": "            return []\n        else:\n            x = []\n            # TODO? define order of children?\n            for j in children[i]:\n                x.append(j)\n                y = branch(j, children)\n",
        "description": "? define order of children?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 133,
        "type": "TODO",
        "content": "else:  # 81130: prune clusters with empty dj sets  # TODO: update",
        "context": "                    new_dj.append(ordnung.index(abs(index)) * sign(index))\n                new_rule.append(tuple(new_dj))\n            new_cats['disjuncts'][rule] = set(new_rule)\n        else:  # 81130: prune clusters with empty dj sets  # TODO: update\n            print(('rule', rule, '- 0 djs in new_cats[disjuncts][rule]:',\n                   new_cats['disjuncts'][rule]))\n\n",
        "description": "update"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 179,
        "type": "TODO",
        "content": "# TODO: list of merged clusters - to delete",
        "context": "    if aggregation == 'jaccard':\n        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n",
        "description": "list of merged clusters - to delete"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 180,
        "type": "TODO",
        "content": "# TODO: delete merged clusters",
        "context": "        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n        while z > 1 and threshold > aggr_threshold:\n",
        "description": "delete merged clusters"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 206,
        "type": "TODO",
        "content": "# TODO: delete merged clusters?",
        "context": "    cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n    sims = [x for x in similarities]  # if x < threshold]\n    threshold = max(sims) - 0.01\n    # TODO: delete merged clusters?\n\n    z = len(similarities)\n    while z > 1 and threshold > aggr_threshold:\n",
        "description": "delete merged clusters?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 215,
        "type": "TODO",
        "content": "# Renumber connectors in disjuncts # TODO: for all clusters?",
        "context": "        threshold = max(sims) - 0.01\n        z = len(sims)\n\n    # Renumber connectors in disjuncts # TODO: for all clusters?\n    clusters = [i for i, x in enumerate(cats['cluster'])\n                if i > 0 and x is not None]\n\n",
        "description": "for all clusters?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 277,
        "type": "TODO",
        "content": "# TODO: delete merged clusters?",
        "context": "        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        sims = [x for x in similarities]  # if x < threshold]\n        threshold = max(sims) - 0.01\n        # TODO: delete merged clusters?\n        z = len(similarities)\n        while z > 1 and threshold > aggr_threshold:\n            cats, similarities = aggregate(cats, threshold, jaccard, verbose)\n",
        "description": "delete merged clusters?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 342,
        "type": "TODO",
        "content": "# new_cluster_id = len(cats['top'])  # TODO?",
        "context": "    merges = [x for i, x in enumerate(merges) if i not in merged]\n    for mset in merges:\n        new_cluster_id = len(cats['parent'])\n        # new_cluster_id = len(cats['top'])  # TODO?\n        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n",
        "description": "?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 346,
        "type": "TODO",
        "content": "cats['parent'].append(0)  # TODO? append(None) & use top?",
        "context": "        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n        cats['parent'].append(0)  # TODO? append(None) & use top?\n        cats['children'].append(mset)\n        cats['words'].append(set())\n        cats['disjuncts'].append(set())\n",
        "description": "? append(None) & use top?"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 356,
        "type": "TODO",
        "content": "cats['parent'][cluster] = new_cluster_id  # TODO: don't change",
        "context": "\n        for cluster in mset:\n            cats['top'][cluster] = new_cluster_id  # 81123\n            cats['parent'][cluster] = new_cluster_id  # TODO: don't change\n            cats['words'][new_cluster_id].update(cats['words'][cluster])\n            cats['disjuncts'][new_cluster_id].update(cats['disjuncts'][cluster])\n            cats['djs'][new_cluster_id].update(cats['djs'][cluster])\n",
        "description": "don't change"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 414,
        "type": "TODO",
        "content": "# TODO: aggregate_cosine?",
        "context": "# 80725 POC 0.1-0.4 deleted, 0.5 restructured\n# 80802 poc05.py restructured, cats2list moved to category_learner.py,\n# cats2list copied to poc05.py for tmp compatibility\n# TODO: aggregate_cosine?\n# 80802 fix compatibility with dj_counts & max_disjuncts, delete ...05.py?\n# 81121 generalise_rules\n# 81217 FIXME? generalize_categories [F] with new reorder (Turtle tests)\n",
        "description": "aggregate_cosine?"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 27,
        "type": "FIXME",
        "content": "if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!",
        "context": "def calc_pmi(counts, cds):  # Calculates e^PMI; PMI without the log().\n    sum_w = np.array(counts.sum(axis=1))[:, 0]\n    sum_c = np.array(counts.sum(axis=0))[0, :]\n    if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!\n    sum_total = sum_c.sum()\n    sum_w = np.reciprocal(sum_w)\n    sum_c = np.reciprocal(sum_c)\n",
        "description": "cds = 1.0 ?!"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 138,
        "type": "FIXME",
        "content": "print('SVDEmbedding: transpose')    #FIXME:DEL",
        "context": "    # Context embeddings can be created with \"transpose\".\n    def __init__(self, path, normalize=True, eig=0.0, transpose=False):\n        if transpose:\n            print('SVDEmbedding: transpose')    #FIXME:DEL\n            ut = np.load(path + '.vt.npy')\n            self.wi, self.iw = load_vocabulary(path + '.contexts.vocab')\n        else:\n",
        "description": "DEL"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 358,
        "type": "TODO",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    logger.info(f'SVD matrix (3 files .npy) saved: {len(ut[0])} vectors, ut: {len(ut)} s: {len(s)} vt:{len(vt)}')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n",
        "description": "move code here, RAM2RAM"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 439,
        "type": "TODO",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    list2tsv(explicit.ic, svd_path + '.contexts.vocab')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n",
        "description": "move code here, RAM2RAM"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 641,
        "type": "FIXME",
        "content": "continue  # FIXME: check case",
        "context": "                     linkage, affinity, gen, ' ---', 'fail',\n                     ' ---', ' ---', ' ---', ' ---', ' ---', ' ---']\n            details.append(dline)\n            continue  # FIXME: check case\n        if kwargs['linkage_limit'] > 0:\n            start = time.time()\n            a, f1, precision, q = pqa_meter(re['grammar_file'],\n",
        "description": "check case"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 25,
        "type": "TODO",
        "content": "elif clustering == 'group':  # TODO: call ILE clustering?",
        "context": "            clustering = ('kmeans', 'k-means++', 10)\n        elif clustering in ['mean_shift', 'mean shift', 'meanshift']:\n            clustering = ('mean_shift', 2)  # Note: 'auto' bandwidth not yet implemented\n        elif clustering == 'group':  # TODO: call ILE clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n",
        "description": "call ILE clustering?"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 29,
        "type": "TODO",
        "content": "elif clustering == 'random':  # TODO: call random clustering?",
        "context": "            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n        elif clustering == 'random':  # TODO: call random clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'random not supported in skl_clustering'}, []\n",
        "description": "call random clustering?"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 56,
        "type": "TODO",
        "content": "# TODO: int / dict",
        "context": "            if len(clustering) > 3:  # connectivity\n                if type(clustering[3]) is int and clustering[3] > 0:\n                    neighbors = clustering[3]\n                    # TODO: int / dict \n                    connectivity = kneighbors_graph(cd, neighbors,\n                                                    include_self=False)\n            if len(clustering) > 4:  # compute_full_tree\n",
        "description": "int / dict "
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 111,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['silhouette_index'] = float(\n                silhouette_score(cd, labels, metric=clustering_metric[1]))\n        except:  # FIXME\n            metrics['silhouette_index'] = 0.0\n        try:\n            metrics['variance_ratio'] = float(\n",
        "description": ""
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 116,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['variance_ratio'] = float(\n                calinski_harabaz_score(cd, labels))\n        except:  # FIXME\n            metrics['variance_ratio'] = 0.0\n        # try:\n        #   metrics['davies_bouldin_score'] = float(\n",
        "description": ""
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 124,
        "type": "FIXME",
        "content": "except:  # else:  # FIXME",
        "context": "        # except: metrics['davies_bouldin_score'] = 0.0\n\n        return labels, metrics, centroids\n    except:  # else:  # FIXME\n        print('except: skl_clustering error')\n        return np.asarray(range(cd.shape[0])), \\\n               {'clustering': 'skl_clustering error'}, []\n",
        "description": ""
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 172,
        "type": "TODO",
        "content": "elif len(crange) == 3:  # TODO: replace with SGD?",
        "context": "                    l, m, c = skl_clustering(cd, crange[0], **kwargs)\n                    if m['silhouette_index'] > metrics['silhouette_index']:\n                        labels, metrics, centroids = l, m, c\n        elif len(crange) == 3:  # TODO: replace with SGD?\n            n_min = min(crange[0], crange[1])\n            n_max = max(crange[0], crange[1])\n            labels, metrics, centroids = \\\n",
        "description": "replace with SGD?"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 208,
        "type": "FIXME",
        "content": "# FIXME: try...except",
        "context": "# 181203 cleanup\n# 190118 cleanup: remove debug printing\n# 190425 fix n_clusters > n_words case\n# FIXME: try...except\n",
        "description": "try...except"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 70,
        "type": "TODO",
        "content": "#  TODO: To be reviewed and changed if necessary",
        "context": "                tree.append(['', m+1, cats[j][2], cats[j][3]])\n        else:\n            print('WTF?', k, v)\n    #  TODO: To be reviewed and changed if necessary\n    if verbose not in ['none', 'min']:\n        display(html_table([['Code', 'Parent', 'Id', 'Words']] + tree))\n\n",
        "description": "To be reviewed and changed if necessary"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 26,
        "type": "FIXME",
        "content": "def setUp(self):    # FIXME: should run before every test, but would not?!",
        "context": "\nclass TestGrammarLearner(unittest.TestCase):\n\n    def setUp(self):    # FIXME: should run before every test, but would not?!\n        input_parses = module_path + '/tests/data/POC-Turtle/MST_fixed_manually/'\n        batch_dir = module_path + '/output/Test_Grammar_Learner_' + str(UTC())[:10] + '/'\n        kwargs = {  # defaults\n",
        "description": "should run before every test, but would not?!"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 65,
        "type": "FIXME",
        "content": "# 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester",
        "context": "        # Additional (optional) parameters for parse_metrics (_abiity & _quality):\n        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n",
        "description": "changed in June 2018 Grammar Tester"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 310,
        "type": "FIXME",
        "content": "# FIXME: check with further test_grammar updates and delete.",
        "context": "            'verbose'       :   'min'\n        }\n        # Sometimes pqa_meter(with test_grammar updated 2018-10-19) returns pa,recall = 0,0\n        # FIXME: check with further test_grammar updates and delete.\n        x = 0.\n        n = 0\n        while x < 0.1 :\n",
        "description": "check with further test_grammar updates and delete."
      },
      {
        "file": "moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "TODO",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n",
        "description": "would be nice to have a more Caml/Haskell style syntax here,"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "TODO",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n",
        "description": ""
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "TODO",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n",
        "description": ""
      },
      {
        "file": "moses/moses/comboreduct/interpreter/eval.cc",
        "line": 563,
        "type": "TODO",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return eval_throws_tree(new_bmap, lambda_expr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
        "description": "contin_if should go away."
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 336,
        "type": "TODO",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
        "description": "contin_if should go away."
      },
      {
        "file": "moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "TODO",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n",
        "description": "-- replace this by cond"
      },
      {
        "file": "moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "FIXME",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n",
        "description": ""
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "TODO",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n",
        "description": "sin(*(-1 x)) -> -sin(x)"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 102,
        "type": "TODO",
        "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
        "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n",
        "description": "I don't understand why this is not damaging contin_if  !??"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 669,
        "type": "stub",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
        "description": "// stub out, for performance."
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 699,
        "type": "stub",
        "content": "// stubbed out for performance",
        "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
        "description": "// stubbed out for performance"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "TODO",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n",
        "description": ""
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 420,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 445,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 859,
        "type": "TODO",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n",
        "description": "replace this by the util p_norm function."
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1352,
        "type": "TODO",
        "content": "// XXX TODO, it would be easier if KLD took a sorted list",
        "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n",
        "description": ", it would be easier if KLD took a sorted list"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1366,
        "type": "TODO",
        "content": "// XXX TODO remove this print, for better performance.",
        "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n",
        "description": "remove this print, for better performance."
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.cc",
        "line": 627,
        "type": "TODO",
        "content": "// XXX TODO the code below was modified to allow arg lists of",
        "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n",
        "description": "the code below was modified to allow arg lists of"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "TODO",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n",
        "description": "lambda"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "TODO",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n",
        "description": "DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "TODO",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n",
        "description": "re-enable that once best_possible_bscore is fixed"
      },
      {
        "file": "moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "TODO",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n",
        "description": "I think it might be a little more efficent to use the"
      },
      {
        "file": "moses/moses/moses/main/problem-params.cc",
        "line": 169,
        "type": "TODO",
        "content": "// XXX TODO: make this print correctly, instead of using brackets.",
        "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n",
        "description": "make this print correctly, instead of using brackets."
      },
      {
        "file": "moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n",
        "description": "TODO The structure below should be split into multiple"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "FIXME",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n",
        "description": "-- the multiple tables should be merged into one."
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "FIXME",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n",
        "description": ".. check that they all have the same signature."
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "FIXME",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n",
        "description": "we should use a pointer set for scored_combo_tree_set"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "TODO",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n",
        "description": "Make population cap size-sensitive to exemplar complexity."
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "FIXME",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n",
        "description": "looks to me like it++ can often be collaed twice within this loop!"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "FIXME",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n",
        "description": "should probably not recompute every time ..."
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "TODO",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n",
        "description": "we may want to output the visited status as well"
      },
      {
        "file": "moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "TODO",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n",
        "description": "use the option of the output"
      },
      {
        "file": "moses/moses/moses/moses/moses_main.h",
        "line": 102,
        "type": "TODO",
        "content": "// XXX TODO this should be fixed, someday...",
        "context": "        // messages.  In fact, the mpi workers should not even have\n        // a printer at all, or use a null_printer.  Unfortunately,\n        // the current code structure makes this hard to implement.\n        // XXX TODO this should be fixed, someday...\n        if (is_mpi && metapop.size() == 0)\n            return;\n\n",
        "description": "this should be fixed, someday..."
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 202,
        "type": "TODO",
        "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
        "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n",
        "description": "-- trim the deme down, before sending, by using the worst acceptable score."
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 318,
        "type": "TODO",
        "content": "// XXX TODO should probably fetch max_time from somewhere...",
        "context": "            continue; // Continue to next exemplar\n        }\n\n        // XXX TODO should probably fetch max_time from somewhere...\n        time_t max_time = INT_MAX;\n        dex.optimize_demes(max_evals, max_time);\n\n",
        "description": "should probably fetch max_time from somewhere..."
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 616,
        "type": "TODO",
        "content": "// XXX TODO instead of overwritting the demeID it should be",
        "context": "        scored_combo_tree_set candidates;\n        stats.n_expansions ++;\n\n        // XXX TODO instead of overwritting the demeID it should be\n        // correctly defined by the worker and send back to the\n        // dispatcher. That way we can have the breadth_first\n        // componant of the demeID right.\n",
        "description": "instead of overwritting the demeID it should be"
      },
      {
        "file": "moses/moses/moses/moses/neighborhood_sampling.h",
        "line": 327,
        "type": "TODO",
        "content": "// XXX TODO, unroll the last tail call, just like the single-bit",
        "context": "        else\n        {\n            // Recursive call, moved for one position\n            // XXX TODO, unroll the last tail call, just like the single-bit\n            // knob case, below.\n            out = vary_n_knobs(fs, tmp_inst, dist, starting_index + 1, out, end);\n            // Left<->Right\n",
        "description": ", unroll the last tail call, just like the single-bit"
      },
      {
        "file": "moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "TODO",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n",
        "description": "Improve generation tracking by getting actual number"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "TODO",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n",
        "description": "this should be a std::valarray not std::vector but I am too"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 110,
        "type": "TODO",
        "content": "// XXX TODO make sure this value is appropriately updated.",
        "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n",
        "description": "make sure this value is appropriately updated."
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 198,
        "type": "TODO",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n",
        "description": "work in a better way to identify convergence."
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 237,
        "type": "TODO",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n",
        "description": "Explanation"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 347,
        "type": "TODO",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n",
        "description": "Wind dispersion, but test without first"
      },
      {
        "file": "moses/moses/moses/optimization/star-anneal.cc",
        "line": 44,
        "type": "TODO",
        "content": "// XXX TODO the annealing temperature control code should be ported over",
        "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n",
        "description": "the annealing temperature control code should be ported over"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 317,
        "type": "TODO",
        "content": "/// TODO: measure and compare the resulting performance.",
        "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n",
        "description": "measure and compare the resulting performance."
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 490,
        "type": "TODO",
        "content": "// TODO: should bias the selection of these, so that",
        "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n",
        "description": "should bias the selection of these, so that"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 582,
        "type": "TODO",
        "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
        "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n",
        "description": "Benchmark and clarify optimal breakeven point across different problem sizes."
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 691,
        "type": "TODO",
        "content": "// XXX TODO: Is this really optimal?  The below adds an entire copy",
        "context": "        }\n    }\n\n    // XXX TODO: Is this really optimal?  The below adds an entire copy\n    // of the tree at it, which clearly increases the overall complexity.\n    // But is this really a wise thig to do? It seems gratuitous, and it's\n    // not obvious that knobs from this flipped tree will yeild benefits,\n",
        "description": "Is this really optimal?  The below adds an entire copy"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1182,
        "type": "TODO",
        "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
        "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n",
        "description": "should bias the selection of these (and possibly choose larger subtrees)"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1343,
        "type": "FIXME",
        "content": "//FIXME: now just attaches to the first output",
        "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n",
        "description": "now just attaches to the first output"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "FIXME",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n",
        "description": ", calling score_tree above does not throw the exception; this should be done"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 51,
        "type": "TODO",
        "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
        "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n",
        "description": "One might think that varying the stepsize, i.e. shrinking"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 238,
        "type": "TODO",
        "content": "// XXX TODO need to add support for \"term algebra\" knobs",
        "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n",
        "description": "need to add support for \"term algebra\" knobs"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "TODO",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n",
        "description": ""
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 512,
        "type": "TODO",
        "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n",
        "description": "-- should not return the penalties as part of the bscore,"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 646,
        "type": "TODO",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the break-even-point for this ctable row.\nscore_t bep_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt * _true_total);\n    double best_possible_recall = 1.0 / _true_total;\n    return (best_possible_precision + best_possible_recall) / 2;\n",
        "description": "FIXME is this really correct?"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 655,
        "type": "TODO",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the difference for this ctable row.\nscore_t bep_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt);\n    double best_possible_recall = (0.0 < pos) ? 1.0 : 0.0;\n    return fabs(best_possible_precision - best_possible_recall);\n",
        "description": "FIXME is this really correct?"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 707,
        "type": "TODO",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "// generation of best-possible score.\nscore_t f_one_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    return 1.0;\n}\n\n",
        "description": "FIXME is this really correct?"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 714,
        "type": "TODO",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the f_one for this ctable row.\nscore_t f_one_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / cnt;\n    double best_possible_recall = 1.0;\n    double f_one = 2 * best_possible_precision * best_possible_recall\n",
        "description": "FIXME is this really correct?"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.cc",
        "line": 152,
        "type": "FIXME",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n",
        "description": "complexity_t should be a double not an int ..."
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 124,
        "type": "TODO",
        "content": "// XXX TODO should be a std::valarray not a vector.",
        "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n",
        "description": "should be a std::valarray not a vector."
      },
      {
        "file": "moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "TODO",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n",
        "description": "multipler other than 1 is not supported yet"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 128,
        "type": "stub",
        "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
        "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n",
        "description": "// Stub: minimal allocation for compatibility"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 129,
        "type": "stub",
        "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
        "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n",
        "description": "// Stub: minimal allocation for compatibility"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 136,
        "type": "stub",
        "content": "// Stub types when Link Grammar is not available",
        "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n",
        "description": "// Stub types when Link Grammar is not available"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 138,
        "type": "stub",
        "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
        "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n",
        "description": "// Stub: would be Dictionary if HAVE_LINK_GRAMMAR"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 139,
        "type": "stub",
        "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
        "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n",
        "description": "// Stub: would be Parse_Options if HAVE_LINK_GRAMMAR"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 48,
        "type": "TODO",
        "content": "// TODO: the notion of equality between 2 CHandles might one where",
        "context": "public:\n\t// Contextual Handle\n\t//\n\t// TODO: the notion of equality between 2 CHandles might one where\n\t// the Context isn't necessarily equal but where the 2 handles\n\t// (besides being equal) have the same quotation and same\n\t// (free inter shadow) variables.\n",
        "description": "the notion of equality between 2 CHandles might one where"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 159,
        "type": "TODO",
        "content": "// TODO: the type of a typed block is currently a handle of the",
        "context": "\t// the simplest satisfiable solution set.\n\tstatic const Partitions empty_partition_singleton;\n\n\t// TODO: the type of a typed block is currently a handle of the\n\t// variable or ground it is exists, instead of an actual type.\n\tstruct SolutionSet : Partitions\n\t{\n",
        "description": "the type of a typed block is currently a handle of the"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 188,
        "type": "TODO",
        "content": "// TODO: maybe we could simplify a great deal of code by replacing",
        "context": "\t// Subtitution values and their corresponding variable declaration\n\t// after substitution (cause some values may be variables).\n\t//\n\t// TODO: maybe we could simplify a great deal of code by replacing\n\t// Handle by Variables.\n\ttypedef std::map<HandleCHandleMap, Handle> TypedSubstitutions;\n\ttypedef std::pair<HandleCHandleMap, Handle> TypedSubstitution;\n",
        "description": "maybe we could simplify a great deal of code by replacing"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 521,
        "type": "TODO",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t// Memoization cache for unification results\n\tmutable std::map<std::pair<CHandle, CHandle>, SolutionSet> _unify_cache;\n\npublic:                         // TODO: being friend with UnifyUTest\n\t/**\n\t * Set Unify::_variables given the variable declarations of the\n\t * two terms to unify.\n",
        "description": "being friend with UnifyUTest"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 601,
        "type": "TODO",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t */\n\tSolutionSet mkvarsol(CHandle lhs, CHandle rhs) const;\n\npublic:                         // TODO: being friend with UnifyUTest\n                                // somehow doesn't work\n\t/**\n\t * Join 2 solution sets. Generate the product of all consistent\n",
        "description": "being friend with UnifyUTest"
      },
      {
        "file": "ure/opencog/ure/Rule.h",
        "line": 373,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\t// True if the rule has already been applied.\n\tbool _exhausted;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n\n\t// Return a copy of the rule with the variables alpha-converted\n",
        "description": "subdivide in smaller and shared mutexes"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 374,
        "type": "TODO",
        "content": "// TODO: is this merging necessary?",
        "context": "\tHandle nrewrite = expand_fcs_rewrite(nfcs_rewrite, rule.first);\n\n\t// Generate new vardecl\n\t// TODO: is this merging necessary?\n\tHandle merged_vardecl = merge_vardecl(nfcs_vardecl, rule_vardecl);\n\tHandle nvardecl = filter_vardecl(merged_vardecl, {npattern, nrewrite});\n\n",
        "description": "is this merging necessary?"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.h",
        "line": 72,
        "type": "TODO",
        "content": "// TODO: Maybe this should be moved to BackwardChainer",
        "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n",
        "description": "Maybe this should be moved to BackwardChainer"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
        "line": 288,
        "type": "TODO",
        "content": "// TODO: Maybe we could take advantage of the new read-only",
        "context": "\t// of concerns instead of the atoms themselves, and only modify\n\t// the atoms if there are existing results to copy back to _as.\n\t//\n\t// TODO: Maybe we could take advantage of the new read-only\n\t// capabilities of the AtomSpace.\n\tHandle hresult = HandleCast(fcs->execute(tmp_as.get()));\n\tHandleSeq results;\n",
        "description": "Maybe we could take advantage of the new read-only"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.h",
        "line": 232,
        "type": "TODO",
        "content": "// TODO: perhaps move that under BIT",
        "context": "\t// Structure holding the Back Inference Tree\n\tBIT _bit;\n\n\t// TODO: perhaps move that under BIT\n\tAndBITFitness _andbit_fitness;\n\n\t// In charge of recording the inference traces\n",
        "description": "perhaps move that under BIT"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/ControlPolicy.h",
        "line": 45,
        "type": "TODO",
        "content": "// TODO: maybe wrap that in a class, and use it in foward chainer",
        "context": "// selected rule fulfills the objective, which must be passed\n// to the BIT to calculate the and-BIT complexity.\n//\n// TODO: maybe wrap that in a class, and use it in foward chainer\ntypedef std::pair<RuleTypedSubstitutionPair, double> RuleSelection;\n\nclass ControlPolicy\n",
        "description": "maybe wrap that in a class, and use it in foward chainer"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 75,
        "type": "TODO",
        "content": "// TODO: we may want to move the arguments in its own class if it",
        "context": "\t\tTrace\n\t};\n\n\t// TODO: we may want to move the arguments in its own class if it\n\t// grows bigger.\n\tAndBITFitness(FitnessType ft=Uniform,\n\t              const std::set<ContentHash>& tr=std::set<ContentHash>());\n",
        "description": "we may want to move the arguments in its own class if it"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 92,
        "type": "TODO",
        "content": "// TODO: replace by class dedicated to hold the parameters",
        "context": "\tdouble operator()(const AndBIT& andbit) const;\n\nprivate:\n\t// TODO: replace by class dedicated to hold the parameters\n\tstd::set<ContentHash> _trace;\n};\n\n",
        "description": "replace by class dedicated to hold the parameters"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
        "line": 94,
        "type": "TODO",
        "content": "// TODO: the TV on the evaluation link should be more carefully",
        "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n",
        "description": "the TV on the evaluation link should be more carefully"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/FCStat.h",
        "line": 76,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tstd::vector<InferenceRecord> _inf_rec;\n\tAtomSpace* _trace_as;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n};\n\n",
        "description": "subdivide in smaller and shared mutexes"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 101,
        "type": "TODO",
        "content": "// TODO: For now the FC follows the old standard. We may move to",
        "context": "\n\t// Set rules.\n\t_rules = _config.get_rules();\n\t// TODO: For now the FC follows the old standard. We may move to\n\t// the new standard when all rules have been ported to the new one.\n\tfor (RulePtr rule : _rules)\n\t\trule->premises_as_clauses = true;\n",
        "description": "For now the FC follows the old standard. We may move to"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 165,
        "type": "TODO",
        "content": "// TODO: if creating/destroying threads is too expensive, use a thread",
        "context": "\twhile (not termination()) do_step(_iteration++);\n}\n\n// TODO: if creating/destroying threads is too expensive, use a thread\n// pool (see boost::asio::thread_pool).\nvoid ForwardChainer::do_steps_multithread()\n{\n",
        "description": "if creating/destroying threads is too expensive, use a thread"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 289,
        "type": "TODO",
        "content": "// TODO: This can be simplified but is let here until do_step is",
        "context": "\t\t// before being passed to the new source constructor, as this\n\t\t// one will take it into account.\n\t\t//\n\t\t// TODO: This can be simplified but is let here until do_step is\n\t\t// replaced by do_step_srpi.\n\t\tdouble weight = std::min(1.0, slc_sr.source->weight);\n\t\tdouble prob = success_plty / weight;\n",
        "description": "This can be simplified but is let here until do_step is"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 372,
        "type": "TODO",
        "content": "// TODO: refine mutex",
        "context": "\nSourcePtr ForwardChainer::select_source(const std::string& msgprfx)\n{\n\t// TODO: refine mutex\n\tstd::unique_lock<std::mutex> lock(_part_mutex);\n\n\tstd::vector<double> weights = _sources.get_weights();\n",
        "description": "refine mutex"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 409,
        "type": "TODO",
        "content": "// TODO: This has the effect of deallocating the rules, which",
        "context": "\t\tif (_config.get_retry_exhausted_sources()) {\n\t\t\ture_logger().debug() << msgprfx\n\t\t\t                     << \"Reset all exhausted flags to retry them\";\n\t\t\t// TODO: This has the effect of deallocating the rules, which\n\t\t\t// might cause a memory corruption if another thread is\n\t\t\t// attempting to apply that rule at the same time.\n\t\t\t_sources.reset_exhausted();\n",
        "description": "This has the effect of deallocating the rules, which"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 523,
        "type": "TODO",
        "content": "std::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine",
        "context": "\nRuleSet ForwardChainer::get_valid_rules(const Source& source)\n{\n\tstd::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine\n\n\t// Generate all valid rules\n\tRuleSet valid_rules;\n",
        "description": "refine"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 237,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\n\tbool _search_focus_set;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n",
        "description": "subdivide in smaller and shared mutexes"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 241,
        "type": "TODO",
        "content": "// TODO: use shared mutexes",
        "context": "\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n\t// TODO: use shared mutexes\n\tmutable std::mutex _rules_mutex;\n\n\t// Keep track of the number of threads to make sure\n",
        "description": "use shared mutexes"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.cc",
        "line": 48,
        "type": "TODO",
        "content": "// TODO:",
        "context": "\t// The minimum value is 1e-16 to not ignore completely the source\n\t// when the it is a default TV.\n\t//\n\t// TODO:\n\t// 1. Support more fitness functions\n\t// 2. Explicitely turn the fitness into a probability of success\n\tTruthValuePtr tv = bdy->getTruthValue();\n",
        "description": ""
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 54,
        "type": "TODO",
        "content": "// TODO: this class has thing in common with AndBIT, maybe their",
        "context": " *\n * 4. a flag call indicating if the source expansions have been exhausted.\n */\n// TODO: this class has thing in common with AndBIT, maybe their\n// common things could be placed in a parent class.\nclass Source : public boost::totally_ordered<Source>\n{\n",
        "description": "this class has thing in common with AndBIT, maybe their"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 151,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tRuleSet rules;\n\nprivate:\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n",
        "description": "subdivide in smaller and shared mutexes"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 165,
        "type": "TODO",
        "content": "// TODO: this class has things in common with BIT, maybe their common",
        "context": "/**\n * Population of sources to forwardly expand. Primary owner.\n */\n// TODO: this class has things in common with BIT, maybe their common\n// things could be placed in a parent class.\nclass SourceSet\n{\n",
        "description": "this class has things in common with BIT, maybe their common"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 223,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "private:\n\tconst UREConfig& _config;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n",
        "description": "subdivide in smaller and shared mutexes"
      }
    ],
    "low_priority": [
      {
        "file": "setup_fixme_environment.py",
        "line": 84,
        "type": "TODO",
        "content": "echo \"   // TODO(v2.0): Refactor to use new API\"",
        "context": "                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n            fi\n",
        "description": "(v2.0): Refactor to use new API\""
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 165,
        "type": "FIXME",
        "content": "// FIXME read above comment.",
        "context": "// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n\tsize_t pos = 0;\n",
        "description": "read above comment."
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 955,
        "type": "TODO",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n",
        "description": "could be simplified, optimized, etc"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1078,
        "type": "TODO",
        "content": "// TODO: this could definitely be optimized",
        "context": "\n    if (is_sparse) {\n        // fallback on the old loader\n        // TODO: this could definitely be optimized\n        OC_ASSERT(timestamp_feature.empty(), \"Timestamp feature not implemented\");\n        return istreamTable_OLD(in, tab, target_feature, ignore_features);\n    } else {\n",
        "description": "this could definitely be optimized"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 482,
        "type": "TODO",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n",
        "description": "Optimize statistics printing frequency to reduce output volume."
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 466,
        "type": "TODO",
        "content": "# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?",
        "context": "# Notes:\n\n# 80329 added vector_space_dim\n# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?\n# 90221 minor updates for Grammar Learner tutorial\n",
        "description": "refactor, control disk writes, ... PPMI \u21d2 +frequency?"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 33,
        "type": "TODO",
        "content": "# TODO: cleanup here or in a separate constructor?",
        "context": "            if us[-1] != '\\n' :  us += '\\n'\n        us += s\n        if us[-1] != '\\n' :  us += '\\n'\n    # TODO: cleanup here or in a separate constructor?\n    re = OrderedDict([('read_files', UTC()),\n                      ('input_path', kwargs['input_path']),\n                      ('read_files_number', len(files)),\n",
        "description": "cleanup here or in a separate constructor?"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 212,
        "type": "TODO",
        "content": "# TODO: Remove these commented lines in next cleanup cycle.",
        "context": "        }\n        re = learn_grammar(**kwargs)\n        # NOTE: Legacy test code commented out for historical reference.\n        # TODO: Remove these commented lines in next cleanup cycle.\n        # a, q, qa = pqa_meter(re['grammar_file'], outpath, cp, rp, **kwargs)\n        # print('parse-ability, parse-quality:', a, q)\n        # assert a*q > 0.99\n",
        "description": "Remove these commented lines in next cleanup cycle."
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 934,
        "type": "TODO",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n",
        "description": "could be simplified, optimized, etc"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 486,
        "type": "TODO",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n",
        "description": "Optimize statistics printing frequency to reduce output volume."
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 58,
        "type": "TODO",
        "content": "// TODO: could certainly be optimized by not systematically",
        "context": "\nvoid RuleSet::expand_meta_rules(AtomSpace& as)\n{\n\t// TODO: could certainly be optimized by not systematically\n\t// recollecting and re-instantiating meta-rules.\n\tRuleSet meta_rules;\n\tfor (RulePtr rule : *this) {\n",
        "description": "could certainly be optimized by not systematically"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 121,
        "type": "TODO",
        "content": "set_leaf2bitnode();         // TODO: might differ till needed to optimize",
        "context": "AndBIT::AndBIT(const Handle& f, double cpx, const AtomSpace* qas)\n\t: fcs(f), complexity(cpx), exhausted(false), queried_as(qas)\n{\n\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n",
        "description": "might differ till needed to optimize"
      }
    ],
    "informational": [
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 164,
        "type": "FIXME",
        "content": "/// XXX FIXME now I see how it can be done. The groupings should",
        "context": "/// to dribble in. Perhaps the engine search could be modified in some\n/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n",
        "description": "now I see how it can be done. The groupings should"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 68,
        "type": "TODO",
        "content": "// TODO: Test thoroughly, or develop an alternative. See discussion",
        "context": "      _psi_rules[rule] = std::make_tuple(context, action, goal, query);\n  } else {\n    // This is for backward compatability.\n    // TODO: Test thoroughly, or develop an alternative. See discussion\n    // @ https://github.com/opencog/opencog/pull/2899 for what the\n    // alternative might be.\n\n",
        "description": "Test thoroughly, or develop an alternative. See discussion"
      },
      {
        "file": "components/learning/moses/examples/example-progs/continmax.cc",
        "line": 67,
        "type": "TODO",
        "content": "// TODO: Expand documentation to match style of onemax/nmax examples.",
        "context": "// -- the number that is -log_2(epsilon) where epsilon is the smallest\n//    distinction between continuous variables what will be drawn.\n//\n// TODO: Expand documentation to match style of onemax/nmax examples.\n// Add parameter descriptions, usage examples, and expected output.\n\nint main(int argc, char** argv)\n",
        "description": "Expand documentation to match style of onemax/nmax examples."
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 112,
        "type": "TODO",
        "content": "# TODO: update - see GitHub issue?",
        "context": "\n# 80802 poc05 restructured: moved here from pparser.py\n# 80829,31 unpws, unlws\n# TODO: update - see GitHub issue?\n# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n",
        "description": "update - see GitHub issue?"
      },
      {
        "file": "unify/opencog/unify/atoms/UnifierLink.cc",
        "line": 141,
        "type": "FIXME",
        "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
        "context": "\t// I don't really understand what a solution set is.\n\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n",
        "description": ", Maybe. This seems to handle all of the cases I've"
      }
    ]
  },
  "fixable": [
    {
      "file": "analyze_issue_examples.py",
      "line": 106,
      "type": "FIXME",
      "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
      "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n",
      "description": "Instances from Issue #74 - Sorted by Implementation Difficulty",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 8,
      "type": "NotImplementedError",
      "content": "\"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"",
      "context": "from pathlib import Path\n\ndef find_stub_implementations(repo_root):\n    \"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"\n    stubs = []\n    \n    for pyfile in Path(repo_root).rglob(\"*.py\"):\n",
      "description": "NotImplementedError\"\"\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 59,
      "type": "NotImplementedError",
      "content": "elif 'raise NotImplementedError' in first_impl:",
      "context": "                            elif re.match(r'^\\s*\\.\\.\\.\\s*$', first_impl):\n                                is_stub = True\n                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n",
      "description": "raise NotImplementedError' in first_impl:",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 61,
      "type": "NotImplementedError",
      "content": "stub_type = 'NotImplementedError'",
      "context": "                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n                                is_stub = True\n                                stub_type = 'return_none'\n",
      "description": "NotImplementedError'",
      "reason": "Error with description"
    },
    {
      "file": "find_placeholders.py",
      "line": 4,
      "type": "NotImplementedError",
      "content": "Finds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions",
      "context": "#!/usr/bin/env python3\n\"\"\"\nComprehensive Placeholder Detection Script\nFinds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions\n\"\"\"\nimport os\nimport re\n",
      "description": "NotImplementedError, stub implementations, and empty functions",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_placeholders.py",
      "line": 21,
      "type": "NotImplementedError",
      "content": "'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
      "context": "        self.patterns = {\n            'TODO': r'(//|#|;|/\\*)\\s*TODO[:\\s]',\n            'FIXME': r'(//|#|;|/\\*)\\s*(FIXME|XXX)[:\\s]',\n            'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',\n            'pass_only': r'def\\s+\\w+\\([^)]*\\):\\s*pass\\s*$',\n            'empty_function': r'def\\s+\\w+\\([^)]*\\):\\s*\\.\\.\\.\\s*$',\n            'stub': r'(//|#|;)\\s*STUB[:\\s]',\n",
      "description": "NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
      "reason": "Has implementation hints"
    },
    {
      "file": "generate_progress_report.py",
      "line": 29,
      "type": "NotImplementedError",
      "content": "ni_count=analysis['by_type'].get('NotImplementedError', 0)",
      "context": "    fixme_count=analysis['by_type'].get('FIXME', 0)\n    todo_count=analysis['by_type'].get('TODO', 0)\n    stub_comment_count=analysis['by_type'].get('stub', 0)\n    ni_count=analysis['by_type'].get('NotImplementedError', 0)\n    stub_func_count=len(stubs)\n    total_fixes=impl_report['summary']['total_fixes_applied'] + feature_report['summary']['total_implementations']\n    obsolete_fixes_count=impl_report['summary']['by_type'].get('obsolete_comment', 0)\n",
      "description": "NotImplementedError', 0)",
      "reason": "Has implementation hints"
    },
    {
      "file": "generate_progress_report.py",
      "line": 60,
      "type": "NotImplementedError",
      "content": "| **NotImplementedError** | {ni_count}    |",
      "context": "| **FIXME**             | {fixme_count} |\n| **TODO**              | {todo_count}  |\n| **Stub Comments**     | {stub_comment_count} |\n| **NotImplementedError** | {ni_count}    |\n| **Total**             | **{total_placeholders}** |\n\nAdditionally, **{stub_func_count}** actual stub functions (with `pass` or similar) were found, one of which was a candidate for implementation.\n",
      "description": "NotImplementedError** | {ni_count}    |",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 19,
      "type": "NotImplementedError",
      "content": "\"\"\"Add error handling where NotImplementedError is raised\"\"\"",
      "context": "        self.fixes_failed = []\n        \n    def implement_error_handling(self, filepath, line_num, context):\n        \"\"\"Add error handling where NotImplementedError is raised\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:\n                lines = f.readlines()\n",
      "description": "NotImplementedError is raised\"\"\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 28,
      "type": "NotImplementedError",
      "content": "# Check if it's a NotImplementedError",
      "context": "            if line_idx >= len(lines):\n                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n",
      "description": "NotImplementedError\n",
      "reason": "Error with description"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 29,
      "type": "NotImplementedError",
      "content": "if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
      "context": "                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n                for i in range(max(0, line_idx - 10), line_idx):\n",
      "description": "NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 42,
      "type": "TODO",
      "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
      "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n",
      "description": "Implement {func_name} functionality\\n'",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 152,
      "type": "NotImplementedError",
      "content": "# Filter for NotImplementedError and validation TODOs",
      "context": "    \n    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n",
      "description": "NotImplementedError and validation TODOs",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 153,
      "type": "NotImplementedError",
      "content": "not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']",
      "context": "    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n",
      "description": "NotImplementedError']",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 158,
      "type": "NotImplementedError",
      "content": "print(f\"Found {len(not_implemented)} NotImplementedError instances\")",
      "context": "                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n    \n    print(f\"Found {len(not_implemented)} NotImplementedError instances\")\n    print(f\"Found {len(validation_todos)} validation TODOs\")\n    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n",
      "description": "NotImplementedError instances\")",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 163,
      "type": "NotImplementedError",
      "content": "# Process NotImplementedError instances",
      "context": "    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n",
      "description": "NotImplementedError instances",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 164,
      "type": "NotImplementedError",
      "content": "print(\"\\nProcessing NotImplementedError instances...\")",
      "context": "    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n        print(f\"  {i}/{min(5, len(not_implemented))}: {placeholder['file']}:{placeholder['line']}\")\n",
      "description": "NotImplementedError instances...\")",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_scheme_stubs.py",
      "line": 134,
      "type": "NotImplementedError",
      "content": "'NotImplementedError' in p['content']]",
      "context": "    # Find all 'not-implemented' throws\n    not_implemented = [p for p in data['detailed_placeholders'] \n                      if 'not-implemented' in p['content'].lower() or \n                      'NotImplementedError' in p['content']]\n    \n    print(f\"Found {len(not_implemented)} not-implemented stubs\")\n    \n",
      "description": "NotImplementedError' in p['content']]",
      "reason": "Has implementation hints"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 83,
      "type": "TODO",
      "content": "echo \"   // TODO: Implement error handling for edge case X\"",
      "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n",
      "description": "Implement error handling for edge case X\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 15,
      "type": "NotImplementedError",
      "content": "'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),",
      "context": "    patterns = {\n        'FIXME': re.compile(r'(//|#)\\s*(XXX\\s+)?FIXME[:\\s]*(.*)', re.IGNORECASE),\n        'TODO': re.compile(r'(//|#)\\s*(XXX\\s+)?TODO[:\\s]*(.*)', re.IGNORECASE),\n        'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),\n        'stub': re.compile(r'(//|#)\\s*stub[:\\s]*(.*)', re.IGNORECASE),\n        'pass_placeholder': re.compile(r'pass\\s*#\\s*placeholder', re.IGNORECASE),\n        'empty_function': re.compile(r'^\\s*(def|void|int|bool|float|double)\\s+\\w+\\([^)]*\\)\\s*{\\s*}\\s*$'),\n",
      "description": "NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 106,
      "type": "NotImplementedError",
      "content": "# Check for NotImplementedError with description",
      "context": "        # Check if it has clear implementation hints\n        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n",
      "description": "NotImplementedError with description",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 107,
      "type": "NotImplementedError",
      "content": "elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:",
      "context": "        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n            needs_research.append(p)\n",
      "description": "NotImplementedError' and len(p['description']) > 5:",
      "reason": "Has implementation hints"
    },
    {
      "file": "atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
      "line": 109,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
      "line": 136,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "cogutil/opencog/util/zipf.h",
      "line": 90,
      "type": "empty_function",
      "content": "void reset() {}",
      "context": "\t\t\tif (-0.5 >= q)\n\t\t\t\tthrow std::runtime_error(\"Range error: Parameter q must be greater than -0.5!\");\n\t\t}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
      "description": "\t\tvoid reset() {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "cogutil/opencog/util/zipf.h",
      "line": 233,
      "type": "empty_function",
      "content": "void reset() {}",
      "context": "\t\t\t_q(q),\n\t\t\t_dist(_pdf.begin(), _pdf.end())\n\t\t{}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
      "description": "\t\tvoid reset() {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
      "line": 107,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
      "line": 136,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictNode.cc",
      "line": 132,
      "type": "empty_function",
      "content": "void opencog_nlp_lgparse_init(void) {}",
      "context": "\n/* This allows guile to load this shared library */\nextern \"C\" {\n\tvoid opencog_nlp_lgparse_init(void) {}\n};\n",
      "description": "\tvoid opencog_nlp_lgparse_init(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 667,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
      "description": "// stub out, for performance.",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 697,
      "type": "stub",
      "content": "// stubbed out for performance",
      "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
      "description": "// stubbed out for performance",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable",
      "reason": "Has implementation hints"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1256,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support",
      "reason": "Has implementation hints"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1011,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input.",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 669,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
      "description": "// stub out, for performance.",
      "reason": "Simple stub implementation"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 699,
      "type": "stub",
      "content": "// stubbed out for performance",
      "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
      "description": "// stubbed out for performance",
      "reason": "Simple stub implementation"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 1245,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1012,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input.",
      "reason": "Has implementation hints"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 128,
      "type": "stub",
      "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
      "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n",
      "description": "// Stub: minimal allocation for compatibility",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 129,
      "type": "stub",
      "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
      "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n",
      "description": "// Stub: minimal allocation for compatibility",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 136,
      "type": "stub",
      "content": "// Stub types when Link Grammar is not available",
      "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n",
      "description": "// Stub types when Link Grammar is not available",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 138,
      "type": "stub",
      "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
      "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n",
      "description": "// Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 139,
      "type": "stub",
      "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
      "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n",
      "description": "// Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
      "reason": "Simple stub implementation"
    },
    {
      "file": "ure/opencog/ure/BetaDistribution.cc",
      "line": 33,
      "type": "TODO",
      "content": "// TODO should be replaced by tv->get_mode() once implemented",
      "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n",
      "description": "should be replaced by tv->get_mode() once implemented",
      "reason": "Has implementation hints"
    }
  ],
  "needs_research": [
    {
      "file": "analyze_issue_examples.py",
      "line": 14,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",",
      "context": "    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n",
      "description": ". Performance has not been recently measured; there\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 16,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",",
      "context": "        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n",
      "description": "maybe later someday, if/when this is needed.\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 17,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",",
      "context": "        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n",
      "description": "-- The recursive design of the depth() routine below makes\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 18,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",",
      "context": "        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n",
      "description": "Users should call StorageNode::add_nocheck() instead.\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 19,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",",
      "context": "        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n",
      "description": "this does a lot of wasteful string copying.\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 23,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",",
      "context": "        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n",
      "description": "\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 25,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",",
      "context": "        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n",
      "description": "can we fix cython to not do this, already?\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 26,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",",
      "context": "        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n",
      "description": ". Work around the despicable, horrible guile UTF8 handling.\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 28,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",",
      "context": "        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n",
      "description": "This lock is not needed, because in guile-2.2,\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 30,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",",
      "context": "        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n",
      "description": "Are the below needed?\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 32,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",",
      "context": "        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n",
      "description": ", more correct would be to loop over\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 33,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",",
      "context": "        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n",
      "description": "This update is not thread-safe.\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 35,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",",
      "context": "        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n",
      "description": "- fix this so it can also choose a single value\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 36,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",",
      "context": "        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n",
      "description": "URE calls us with broken handle!!\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 38,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",",
      "context": "        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n",
      "description": "The update here is not thread-safe...\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 42,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
      "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n",
      "description": "; we should be using ptm->isVariable() instead !?\","
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 44,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"",
      "context": "        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n    \n    # Categorize these specific examples\n",
      "description": "this is currently a weak stop-gap measure to handle\""
    },
    {
      "file": "entelechy_introspection.py",
      "line": 600,
      "type": "TODO",
      "content": "r'TODO.*list',  # TODO lists in docs",
      "context": "        \n        # Patterns to exclude (informational, not actionable)\n        exclude_patterns = [\n            r'TODO.*list',  # TODO lists in docs\n            r'GNU',         # GNU license references\n            r'Copyright',   # Copyright notices\n            r'from\\s+TODO', # References to TODO files/modules\n",
      "description": "lists in docs"
    },
    {
      "file": "entelechy_marker_analyzer.py",
      "line": 31,
      "type": "TODO",
      "content": "marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.",
      "context": "    \"\"\"Represents a single code marker (TODO, FIXME, etc.).\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n",
      "description": ", FIXME, STUB, PLACEHOLDER, etc."
    },
    {
      "file": "fixme_resolution_tracker.py",
      "line": 169,
      "type": "FIXME",
      "content": "report.append(\"# FIXME Resolution Progress Report\")",
      "context": "    def generate_next_steps_report(self) -> str:\n        \"\"\"Generate a report implementing the next steps from the catalog.\"\"\"\n        report = []\n        report.append(\"# FIXME Resolution Progress Report\")\n        report.append(f\"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"\")\n        \n",
      "description": "Resolution Progress Report\")"
    },
    {
      "file": "fragmentation_detector.py",
      "line": 22,
      "type": "TODO",
      "content": "marker_type: str  # TODO, FIXME, STUB",
      "context": "    \"\"\"Represents a specific code fragmentation\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n",
      "description": ", FIXME, STUB"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 84,
      "type": "TODO",
      "content": "echo \"   // TODO(v2.0): Refactor to use new API\"",
      "context": "                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n            fi\n",
      "description": "(v2.0): Refactor to use new API\""
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 250,
      "type": "FIXME",
      "content": "# FIXME Resolution Makefile Targets",
      "context": "        \n        makefile = self.repo_root / \"Makefile.fixme\"\n        makefile_content = dedent('''\n            # FIXME Resolution Makefile Targets\n            # Include this in your main Makefile with: include Makefile.fixme\n            \n            .PHONY: fixme-status fixme-easy-wins fixme-report fixme-setup\n",
      "description": "Resolution Makefile Targets"
    },
    {
      "file": "atomspace-restful/lib/zmq/zhelpers.hpp",
      "line": 31,
      "type": "TODO",
      "content": "// todo: package updated zmq.hpp",
      "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n",
      "description": "package updated zmq.hpp"
    },
    {
      "file": "atomspace-restful/opencog/python/web/api/utilities.py",
      "line": 17,
      "type": "FIXME",
      "content": "# FIXME: Should this moved to the atomspace repo and be part",
      "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n",
      "description": "Should this moved to the atomspace repo and be part"
    },
    {
      "file": "atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 1004,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
      "description": ". We would like to call"
    },
    {
      "file": "atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
      "line": 1371,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
      "description": ". We would like to call"
    },
    {
      "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
      "line": 31,
      "type": "FIXME",
      "content": "// XXX FIXME: except for the error messages, most of this code is",
      "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n",
      "description": "except for the error messages, most of this code is"
    },
    {
      "file": "atomspace-storage/opencog/persist/csv/table_read.h",
      "line": 38,
      "type": "TODO",
      "content": "// TODO: Should this be a StringValue?",
      "context": "\nnamespace opencog {\n\n// TODO: Should this be a StringValue?\ntypedef std::vector<std::string> string_seq;\n\n/**\n",
      "description": "Should this be a StringValue?"
    },
    {
      "file": "atomspace-storage/opencog/persist/flow/FetchValueOfLink.cc",
      "line": 63,
      "type": "TODO",
      "content": "// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]",
      "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]\n\t// are executable, then they need to be executed, first, right?\n\t// Yes, they do. But, for just right now, we don't, to stay\n\t// compatible with ValueOfLink. See comments in that code.\n",
      "description": "FIXME ... if either of _outgoing[0] or _outgoing[1]"
    },
    {
      "file": "atomspace-storage/opencog/persist/flow/StoreValueOfLink.cc",
      "line": 61,
      "type": "TODO",
      "content": "// XXX TODO FIXME ... if either of these are executable, then",
      "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Because that's the\n\t// usual intent. Else they'd be wrapped in a DontExecLink, right?\n\t// I'm confused.\n",
      "description": "FIXME ... if either of these are executable, then"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
      "line": 141,
      "type": "FIXME",
      "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
      "context": "// Get our configuration from the DefineLink we live in.\n// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n",
      "description": ". Using this ProxyParametersLink thing is a kind of"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
      "line": 195,
      "type": "FIXME",
      "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
      "context": "void WriteBufferProxy::updateValue(const Handle& atom, const Handle& key,\n                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n",
      "description": ". Buffering these naively, like this, voilates the"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 165,
      "type": "FIXME",
      "content": "// FIXME read above comment.",
      "context": "// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n\tsize_t pos = 0;\n",
      "description": "read above comment."
    },
    {
      "file": "atomspace/opencog/atoms/base/Valuation.cc",
      "line": 50,
      "type": "TODO",
      "content": "// XXX TODO -- C++ smart pointers are not atomic; we really",
      "context": "\nvoid Valuation::setValue(const ValuePtr& v)\n{\n\t// XXX TODO -- C++ smart pointers are not atomic; we really\n\t// need to use a lock here, to avoid thread-races.\n\t_value = v;\n}\n",
      "description": "-- C++ smart pointers are not atomic; we really"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
      "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n",
      "description": "Much of the onfusion below is due to a bug: if the"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 79,
      "type": "FIXME",
      "content": "// XXX FIXME, this is to be removed, because UnionLink,",
      "context": "\t\t// well, in that case these are interpreted as intersection,\n\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n",
      "description": ", this is to be removed, because UnionLink,"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 93,
      "type": "FIXME",
      "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
      "context": "\t\t// want to forbid it in the future by maybe introducing a\n\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n",
      "description": "... Perhaps IntersectionLink, UnionLink will"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 110,
      "type": "FIXME",
      "content": "// XXX FIXME - fix this so it can also choose a single value",
      "context": "///           AtomZ\n///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n",
      "description": "- fix this so it can also choose a single value"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 143,
      "type": "TODO",
      "content": "// XXX TODO if execute() above returns FloatValue, use that!",
      "context": "\t\t\tif (hw->is_executable())\n\t\t\t\thw = HandleCast(hw->execute(as, silent));\n\n\t\t\t// XXX TODO if execute() above returns FloatValue, use that!\n\t\t\tNumberNodePtr nn(NumberNodeCast(hw));\n\t\t\tif (nullptr == nn) // goto uniform;\n\t\t\t\tthrow SyntaxException(TRACE_INFO,\n",
      "description": "if execute() above returns FloatValue, use that!"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 179,
      "type": "FIXME",
      "content": "// XXX FIXME, also allow a FloatValue!!",
      "context": "\t\tstd::vector<double> weights;\n\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n",
      "description": ", also allow a FloatValue!!"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
      "line": 296,
      "type": "TODO",
      "content": "// TODO: the following has no unit test!!! Yet it introduces a",
      "context": "\t// Base case\n\tif (h->is_node())\n\t{\n\t\t// TODO: the following has no unit test!!! Yet it introduces a\n\t\t// bug covered by RewriteLinkUTest::test_consume_quotations_4(),\n\t\t// thus this code is disabled till a unit test it created for it\n\t\t// and we understand what it fixes and how it fixes.\n",
      "description": "the following has no unit test!!! Yet it introduces a"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
      "line": 340,
      "type": "TODO",
      "content": "// TODO: generalize with when Unquote and Quote are apart",
      "context": "\t\t\t// A succession of (Unquote (Quote ..)) is an involution\n\t\t\t// and thus can be remove.\n\t\t\t//\n\t\t\t// TODO: generalize with when Unquote and Quote are apart\n\t\t\tif (child->get_type() == QUOTE_LINK)\n\t\t\t{\n\t\t\t\tquotation.update(child->get_type());\n",
      "description": "generalize with when Unquote and Quote are apart"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.h",
      "line": 224,
      "type": "TODO",
      "content": "// TODO: we probably want to",
      "context": "\t */\n\tHandle consume_quotations() const;\n\tstatic Handle consume_quotations(const Variables& variables, const Handle& h,\n\t                                 // TODO: we probably want to\n\t                                 // move quotation,\n\t                                 // needless_quotation,\n\t                                 // clause_root and more in\n",
      "description": "we probably want to"
    },
    {
      "file": "atomspace/opencog/atoms/core/TypeNode.h",
      "line": 90,
      "type": "TODO",
      "content": "// XXX TODO ... Some types are defined. In this case,",
      "context": "\tstatic void validate(const std::string& str)\n\t{\n\t\tType t = nameserver().getType(str);\n\t\t// XXX TODO ... Some types are defined. In this case,\n\t\t// verify that the string occurs as a name inside\n\t\t// some DefineLink... if it does, then it's valid.\n\t\t// If it does not, then it's invalid.\n",
      "description": "... Some types are defined. In this case,"
    },
    {
      "file": "atomspace/opencog/atoms/core/TypedVariableLink.cc",
      "line": 56,
      "type": "FIXME",
      "content": "VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug",
      "context": "\t    DEFINED_TYPE_NODE != dtype and\n\t    TYPE_CHOICE != dtype and\n\t    TYPE_INTERSECTION_LINK != dtype and\n\t    VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug\n\t    SIGNATURE_LINK != dtype and\n\t    INTERVAL_LINK != dtype and\n\t    ARROW_LINK != dtype)\n",
      "description": "this is wrong; URE-bug"
    },
    {
      "file": "atomspace/opencog/atoms/core/Variables.cc",
      "line": 109,
      "type": "FIXME",
      "content": "// XXX FIXME URE calls us with broken handle!!",
      "context": " */\nvoid Variables::validate_vardecl(const Handle& hdecls)\n{\n\t// XXX FIXME URE calls us with broken handle!!\n\tif (nullptr == hdecls) return;\n\n\t// Expecting the declaration list to be either a single\n",
      "description": "URE calls us with broken handle!!"
    },
    {
      "file": "atomspace/opencog/atoms/core/Variables.cc",
      "line": 437,
      "type": "TODO",
      "content": "// XXX TODO type-checking could be lazy; if the function is not",
      "context": "\t\t\t\"Incorrect number of arguments specified, expecting %lu got %lu\",\n\t\t\tvarseq.size(), args.size());\n\n\t// XXX TODO type-checking could be lazy; if the function is not\n\t// actually using one of the args, it's type should not be checked.\n\t// Viz., one of the arguments might be undefined, and that's OK,\n\t// if that argument is never actually used.  Fixing this requires a\n",
      "description": "type-checking could be lazy; if the function is not"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 288,
      "type": "TODO",
      "content": "// TODO: what about globs?",
      "context": "\t\t\treturn expr;\n\n\t\t// If it is a quoted or shadowed variable don't substitute.\n\t\t// TODO: what about globs?\n\t\tif (VARIABLE_NODE == t and not context_cp.is_free_variable(expr))\n\t\t\treturn expr;\n\n",
      "description": "what about globs?"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 598,
      "type": "FIXME",
      "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
      "context": "\t// We do this here, instead of in walk_tree(), because adding\n\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n",
      "description": "Can we defer the addition to the atomspace to an even"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 642,
      "type": "FIXME",
      "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
      "context": "\tif (expr->is_type(NODE) and expr->is_executable())\n\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n",
      "description": ", we need to get rid of this call entirely, and just"
    },
    {
      "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
      "line": 69,
      "type": "TODO",
      "content": "// TODO: Handle executable _outgoing[0] by executing it first.",
      "context": "\n\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n",
      "description": "Handle executable _outgoing[0] by executing it first."
    },
    {
      "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
      "line": 70,
      "type": "TODO",
      "content": "// TODO: Support complex type signatures beyond simple TYPE_NODE.",
      "context": "\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n\t\tthrow InvalidParamException(TRACE_INFO,\n",
      "description": "Support complex type signatures beyond simple TYPE_NODE."
    },
    {
      "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
      "line": 615,
      "type": "TODO",
      "content": "// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,",
      "context": "\t{\n\t\tvex = _outgoing[1]->execute(as, silent);\n\n\t\t// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,\n\t\t// then we should construct another Queue as the return value,\n\t\t// and perform filtering on-demand.\n\t\tif (vex->is_type(LINK_VALUE))\n",
      "description": "FIXME -- if vex is a stream, e.g. a QueueValue,"
    },
    {
      "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
      "line": 41,
      "type": "FIXME",
      "content": "/// XXX FIXME - in the future, some user is going to want to include",
      "context": "/// not typed, and there are *two* bodies, each body returning one\n/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n",
      "description": "- in the future, some user is going to want to include"
    },
    {
      "file": "atomspace/opencog/atoms/flow/ValueOfLink.cc",
      "line": 84,
      "type": "TODO",
      "content": "// XXX TODO FIXME ... if either of these are executable, then",
      "context": "\t// space; we can add the Atom there, and things will\n\t// trickle out properly in the end.\n\t//\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Yes, they do! We\n\t// can currently get away with not doing this for two reasons:\n\t// In all existing code, the first Atom is always an anchor,\n",
      "description": "FIXME ... if either of these are executable, then"
    },
    {
      "file": "atomspace/opencog/atoms/join/JoinLink.cc",
      "line": 549,
      "type": "TODO",
      "content": "/// TODO: it might be faster to use hash tables instead of rb-trees",
      "context": "/// think of any way of combining steps (2) and (3) that would avoid\n/// step (4) ... or even would reduce the work for stpe (4). Oh well.\n///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n",
      "description": "it might be faster to use hash tables instead of rb-trees"
    },
    {
      "file": "atomspace/opencog/atoms/join/JoinLink.cc",
      "line": 721,
      "type": "FIXME",
      "content": "// XXX FIXME this is really dumb, using a queue and then",
      "context": "\n\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n",
      "description": "this is really dumb, using a queue and then"
    },
    {
      "file": "atomspace/opencog/atoms/parallel/ExecuteThreadedLink.cc",
      "line": 59,
      "type": "TODO",
      "content": "/// XXX TODO: We could have a non-blocking version of this atom. We",
      "context": "/// Atoms in the set. If the NumberNode is present, then the number of\n/// threads is the smaller of the NumberNode and the seize of the Set.\n///\n/// XXX TODO: We could have a non-blocking version of this atom. We\n/// could just return the QueueValue immediately; the user could check\n/// to see if the queue is closed, to find out if the threads have\n/// finished.\n",
      "description": "We could have a non-blocking version of this atom. We"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 146,
      "type": "FIXME",
      "content": "// XXX FIXME, more correct would be to loop over",
      "context": "\t{\n\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n",
      "description": ", more correct would be to loop over"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 165,
      "type": "FIXME",
      "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
      "context": "\t\tunbundle_clauses(h);\n\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n",
      "description": ", this handles `absents`, `always` and `grouping`"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1039,
      "type": "FIXME",
      "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
      "context": "/// If the ImplicationLink is suitably simple, it can be added\n/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n",
      "description": "the code here assumes that the situation is indeed"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1255,
      "type": "FIXME",
      "content": "// XXX FIXME -- this is wrong. What we really want is to",
      "context": "\t\t\t_pat.have_evaluatables = true;\n\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n",
      "description": "-- this is wrong. What we really want is to"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1465,
      "type": "FIXME",
      "content": "// XXX FIXME: debug_log() above is more readable than the below.",
      "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n",
      "description": "debug_log() above is more readable than the below."
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
      "line": 80,
      "type": "TODO",
      "content": "// TODO: it would probably be more efficient to swap which of these",
      "context": "\tHandle _handle;\n\tHandle _quote;\n\n\t// TODO: it would probably be more efficient to swap which of these\n\t// two is weak, since I think _outgoing is requested far more often\n\t// than _parent, and having it run faster would be a performance win.\n\tPatternTermPtr _parent;\n",
      "description": "it would probably be more efficient to swap which of these"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternUtils.cc",
      "line": 55,
      "type": "FIXME",
      "content": "// XXX FIXME Are the below needed?",
      "context": "\t\t      or nameserver().isA(clause->getOutgoingAtom(0)->get_type(),\n\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n",
      "description": "Are the below needed?"
    },
    {
      "file": "atomspace/opencog/atoms/reduct/AccumulateLink.cc",
      "line": 71,
      "type": "TODO",
      "content": "// XXX TODO -- we could also handle vectors of strings, by",
      "context": "\t\treturn createFloatValue(acc);\n\t}\n\n\t// XXX TODO -- we could also handle vectors of strings, by\n\t// concatenating them into one long string.  However, for this\n\t// to be generally useful, we'd want to insert whitespace in\n\t// between. But how? One way would be to pass another argument\n",
      "description": "-- we could also handle vectors of strings, by"
    },
    {
      "file": "atomspace/opencog/atoms/reduct/DecimateLink.cc",
      "line": 65,
      "type": "FIXME",
      "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
      "context": "\t\treturn do_execute(vmask, vi);\n\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n",
      "description": "... both the NumberNode and the FloatValue variations"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 138,
      "type": "TODO",
      "content": "// TODO: this should probably be moved to a method on class Atom.",
      "context": "        }\n\n        // Check the values...\n        // TODO: this should probably be moved to a method on class Atom.\n        if (check_values)\n        {\n            HandleSet keys_first = atom_first->getKeys();\n",
      "description": "this should probably be moved to a method on class Atom."
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 272,
      "type": "FIXME",
      "content": "// Fixme maybe later someday, if/when this is needed.",
      "context": "\t// having one AtomSpace be placed as a member into many others,\n\t// except that we don't have any viable mechanisms for such multiple\n\t// membership, and so I don't know how to treat this right now.\n\t// Fixme maybe later someday, if/when this is needed.\n\tif (not (nullptr == _atom_space or as == nullptr))\n\t\tthrow RuntimeException(TRACE_INFO,\n\t\t\t\"At this time, an AtomSpace can only be placed in one other\\n\"\n",
      "description": "maybe later someday, if/when this is needed."
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 283,
      "type": "FIXME",
      "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
      "context": "}\n\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n",
      "description": "-- The recursive design of the depth() routine below makes"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.h",
      "line": 524,
      "type": "FIXME",
      "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
      "context": "\n    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n",
      "description": "Users should call StorageNode::add_nocheck() instead."
    },
    {
      "file": "atomspace/opencog/atomspace/Transient.cc",
      "line": 43,
      "type": "FIXME",
      "content": "/// XXX FIXME. Performance has not been recently measured; there",
      "context": "/// cheaper to just have a cache of empty atomspaces, hanging around,\n/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n",
      "description": ". Performance has not been recently measured; there"
    },
    {
      "file": "atomspace/opencog/cython/PythonEval.cc",
      "line": 1427,
      "type": "FIXME",
      "content": "// XXX FIXME this does a lot of wasteful string copying.",
      "context": "\nvoid PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n",
      "description": "this does a lot of wasteful string copying."
    },
    {
      "file": "atomspace/opencog/guile/SchemeSmobAtom.cc",
      "line": 84,
      "type": "FIXME",
      "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
      "context": "\n/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n",
      "description": ". Work around the despicable, horrible guile UTF8 handling."
    },
    {
      "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
      "line": 73,
      "type": "FIXME",
      "content": "// XXX FIXME: can we fix cython to not do this, already?",
      "context": "// NOTE HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n",
      "description": "can we fix cython to not do this, already?"
    },
    {
      "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
      "line": 126,
      "type": "FIXME",
      "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
      "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n",
      "description": "; we should be using ptm->isVariable() instead !?"
    },
    {
      "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
      "line": 382,
      "type": "TODO",
      "content": "// TODO -- weed out duplicates!",
      "context": "\t}\n\telse\n\t{\n\t\t// TODO -- weed out duplicates!\n\t}\n\treturn true;\n}\n",
      "description": "-- weed out duplicates!"
    },
    {
      "file": "atomspace/opencog/query/NextSearchMixin.cc",
      "line": 167,
      "type": "TODO",
      "content": "// XXX TODO ... Rather than counting the number of variables, we",
      "context": "// can be done in a direct fashion; it resembles the concept of\n// \"unit propagation\" in the DPLL algorithm.\n//\n// XXX TODO ... Rather than counting the number of variables, we\n// should instead look for one with the smallest incoming set.\n// That is because the very next thing that we do will be to\n// iterate over the incoming set of \"pursue\" ... so it could be\n",
      "description": "... Rather than counting the number of variables, we"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 284,
      "type": "FIXME",
      "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
      "context": "/// Compare the contents of a Present term in the pattern to the\n/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n",
      "description": "this is currently a weak stop-gap measure to handle"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1532,
      "type": "FIXME",
      "content": "// XXX FIXME - this is not very elegant. We should probably",
      "context": "\t// If this is some other rando variable that is not part of\n\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n",
      "description": "- this is not very elegant. We should probably"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1982,
      "type": "FIXME",
      "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
      "context": "/// form; see `explore_sparse_branches()`.\n///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n",
      "description": "Issue #3016 - Unification with unordered AndLinks"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2049,
      "type": "FIXME",
      "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
      "context": "/// functional group, and the glob will end up holding the moiety that\n/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n",
      "description": "Right now, this code handles graphs that have only one"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2065,
      "type": "TODO",
      "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
      "context": "{\n\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n",
      "description": "FIXME. The ptm needs to be decomposed into connected"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2223,
      "type": "FIXME",
      "content": "/// XXX FIXME -- do the above.",
      "context": "/// -- build a connectivity map, just like the one for clauses\n/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n",
      "description": "-- do the above."
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2445,
      "type": "TODO",
      "content": "// XXX TODO make sure that all variables in the clause have",
      "context": "\t\t                 << \"Parent has evaluatable but code path was expected to be unreachable. \"\n\t\t                 << \"Clause: \" << clause->getQuote()->to_string();\n\t\t// Continue with the evaluation anyway, but log the issue\n\t\t// XXX TODO make sure that all variables in the clause have\n\t\t// been grounded!  If they're not, something is badly wrong!\n\t\tlogmsg(\"Term inside evaluatable, move up to it's top:\",\n\t\t\t       clause->getQuote());\n",
      "description": "make sure that all variables in the clause have"
    },
    {
      "file": "atomspace/opencog/query/Recognizer.cc",
      "line": 126,
      "type": "TODO",
      "content": "// TODO: Change to something better if possible...",
      "context": "\t// mis-matched types are a dead-end.\n\tif (lpat->get_type() != lsoln->get_type()) return false;\n\n\t// TODO: Change to something better if possible...\n\t// What is happening here is to manually call the\n\t// fuzzy_match callback immediately if and only if\n\t// lsoln has one or more GlobNodes AND lpat and lsoln\n",
      "description": "Change to something better if possible..."
    },
    {
      "file": "atomspace/opencog/query/RewriteMixin.cc",
      "line": 164,
      "type": "FIXME",
      "content": "/// XXX FIXME now I see how it can be done. The groupings should",
      "context": "/// to dribble in. Perhaps the engine search could be modified in some\n/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n",
      "description": "now I see how it can be done. The groupings should"
    },
    {
      "file": "atomspace/opencog/query/SatisfyMixin.cc",
      "line": 583,
      "type": "FIXME",
      "content": "// XXX FIXME terrible hack.",
      "context": "\t\t// pure absent is found.\n\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n",
      "description": "terrible hack."
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 551,
      "type": "TODO",
      "content": "// XXX TODO as discussed on the mailing list, we should perhaps first",
      "context": "\t//       Arg1Atom\n\t//       Arg2Atom\n\t//\n\t// XXX TODO as discussed on the mailing list, we should perhaps first\n\t// see if the following can be found in the atomspace:\n\t//\n\t//   EvaluationLink\n",
      "description": "as discussed on the mailing list, we should perhaps first"
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 710,
      "type": "FIXME",
      "content": "// XXX FIXME: worse: this cannot possibly be right when",
      "context": "\t\t// possibilities?  And if they failed to do so, can we even do\n\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n",
      "description": "worse: this cannot possibly be right when"
    },
    {
      "file": "atomspace/tests/cython/atomspace/test_atomspace.py",
      "line": 362,
      "type": "FIXME",
      "content": "# XXX FIXME is testing the name of the bottom type",
      "context": "    def test_get_type_name(self):\n        self.assertEqual(get_type_name(types.Node), \"Node\")\n        self.assertEqual(get_type_name(2231), \"\")\n        # XXX FIXME is testing the name of the bottom type\n        # a sane thing to do?\n        self.assertEqual(get_type_name(types.NO_TYPE), \"*** Bottom Type! ***\")\n",
      "description": "is testing the name of the bottom type"
    },
    {
      "file": "cogserver/opencog/cogserver/server/CogServer.cc",
      "line": 125,
      "type": "FIXME",
      "content": "// XXX FIXME. terrible terrible hack. What we should be",
      "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n",
      "description": ". terrible terrible hack. What we should be"
    },
    {
      "file": "components/core/atomspace-restful/lib/zmq/zhelpers.hpp",
      "line": 31,
      "type": "TODO",
      "content": "// todo: package updated zmq.hpp",
      "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n",
      "description": "package updated zmq.hpp"
    },
    {
      "file": "components/core/atomspace-restful/opencog/python/web/api/utilities.py",
      "line": 17,
      "type": "FIXME",
      "content": "# FIXME: Should this moved to the atomspace repo and be part",
      "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n",
      "description": "Should this moved to the atomspace repo and be part"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 920,
      "type": "TODO",
      "content": "// XXX TODO - maybe load links depth-order...",
      "context": "{\n\tCHECK_OPEN;\n\t// First, load all the nodes ... then the links.\n\t// XXX TODO - maybe load links depth-order...\n\tloadAtoms(table, \"n@\");\n\tloadAtoms(table, \"l@\");\n}\n",
      "description": "- maybe load links depth-order..."
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 944,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
      "description": ". We would like to call"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksDAG.cc",
      "line": 240,
      "type": "TODO",
      "content": "// XXX TODO: we should probably cache the results, instead of",
      "context": "void RocksStorage::makeOrder(Handle hasp,\n                             std::map<uint64_t, Handle>& order)\n{\n// XXX TODO: we should probably cache the results, instead of\n// recomputing every time!?\n\t// As long as there's a stack of Frames, just loop.\n\twhile (true)\n",
      "description": "we should probably cache the results, instead of"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
      "line": 1283,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n",
      "description": ". We would like to call"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX FIXME -- are open and close actually needed for anything?",
      "context": "    _storage = nullptr;\n}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n",
      "description": "-- are open and close actually needed for anything?"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/Fuzzy.cc",
      "line": 81,
      "type": "TODO",
      "content": "// TODO: Extend to find similar links as well",
      "context": "    {\n        if (h->is_node())\n        {\n            // TODO: Extend to find similar links as well\n            if (lp->get_type() == SIMILARITY_LINK)\n                sl.emplace_back(lp->get_handle());\n\n",
      "description": "Extend to find similar links as well"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatchBasic.cc",
      "line": 106,
      "type": "TODO",
      "content": "// TODO: May use Truth Value instead",
      "context": "\tdouble similarity = common_nodes.size();\n\n\t// Roughly estimate how \"rare\" each node is by using 1 / incoming set size\n\t// TODO: May use Truth Value instead\n\t// for (const Handle& common_node : common_nodes)\n\t// \tsimilarity += 1.0 / common_node->getIncomingSetSize();\n\n",
      "description": "May use Truth Value instead"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
      "line": 41,
      "type": "TODO",
      "content": "// TODO:",
      "context": "TruthValuePtr OpenPsiImplicator::check_satisfiability(const Handle& rule,\n    OpenPsiRules& opr)\n{\n  // TODO:\n  // Solve for multithreaded access. Create a rule class and lock\n  // the rule when updating the cache.\n\n",
      "description": ""
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
      "line": 49,
      "type": "TODO",
      "content": "// TODO: Add cache per atomspace.",
      "context": "  Handle query_body = query->get_pattern().body;\n\n  // Always update cache to clear any previous result.\n  // TODO: Add cache per atomspace.\n  _satisfiability_cache.erase(query_body);\n  _pattern_seen.insert(query_body);\n\n",
      "description": "Add cache per atomspace."
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.h",
      "line": 44,
      "type": "TODO",
      "content": "// TODO Why would one need to reset during psi-loop?",
      "context": "  friend class OpenPsiSatisfier;\n\n  // Needed for resetting private cache.\n  // TODO Why would one need to reset during psi-loop?\n  friend class ::OpenPsiImplicatorUTest;\n\npublic:\n",
      "description": "Why would one need to reset during psi-loop?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 68,
      "type": "TODO",
      "content": "// TODO: Test thoroughly, or develop an alternative. See discussion",
      "context": "      _psi_rules[rule] = std::make_tuple(context, action, goal, query);\n  } else {\n    // This is for backward compatability.\n    // TODO: Test thoroughly, or develop an alternative. See discussion\n    // @ https://github.com/opencog/opencog/pull/2899 for what the\n    // alternative might be.\n\n",
      "description": "Test thoroughly, or develop an alternative. See discussion"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 101,
      "type": "TODO",
      "content": "// TODO But why make the add_category public then?",
      "context": "{\n  _as->add_link(MEMBER_LINK, rule, category);\n  // Add the category just in case it hasn't been declared.\n  // TODO But why make the add_category public then?\n  add_category(category);\n  _category_index[category].insert(rule);\n\n",
      "description": "But why make the add_category public then?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 115,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 124,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 105,
      "type": "TODO",
      "content": "// TODO:add predicate to check for membership of category.",
      "context": "   * @param new_category The node reprsenting the new category.\n   * @return ConceptNode that represents the category.\n   */\n   // TODO:add predicate to check for membership of category.\n  Handle add_category(const Handle& new_category);\n\n  /**\n",
      "description": "add predicate to check for membership of category."
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 126,
      "type": "TODO",
      "content": "// TODO Should these entries be a member of Rules class?",
      "context": "   * where queryis a PatternLink that isn't added to the atomspace, and\n   * is used to check if the rule is satisfiable.\n   */\n  // TODO Should these entries be a member of Rules class?\n  typedef std::tuple<HandleSeq, Handle, Handle, PatternLinkPtr> PsiTuple;\n\n  /**\n",
      "description": "Should these entries be a member of Rules class?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 136,
      "type": "TODO",
      "content": "// TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,",
      "context": "   */\n  std::map<Handle, PsiTuple> _psi_rules;\n\n  // TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,\n  // because it might hinder interoperability with other components that\n  // expect an explicit ontological representation. For historic reasons we\n  // continue using such convention but should be replaced with graph that\n",
      "description": "Using names that are prefixed with \"OpenPsi: \" might be a bad idea,"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
      "line": 91,
      "type": "TODO",
      "content": "// TODO: Should this be a singleton? What could be the issues that need",
      "context": "  const Handle& goal, const TruthValuePtr stv, const Handle& category)\n{\n  AtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"psi-rule\");\n  // TODO: Should this be a singleton? What could be the issues that need\n  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n",
      "description": "Should this be a singleton? What could be the issues that need"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
      "line": 95,
      "type": "TODO",
      "content": "// TODO: Add to multiple categories using scheme rest list.",
      "context": "  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n  // TODO: Add to multiple categories using scheme rest list.\n  openpsi_cache(asp.get()).add_to_category(rule, category);\n  return rule;\n}\n",
      "description": "Add to multiple categories using scheme rest list."
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 42,
      "type": "TODO",
      "content": "// TODO: Saperated component patterns aren't handled by this function",
      "context": "bool OpenPsiSatisfier::grounding(const HandleMap &var_soln,\n                                  const HandleMap &term_soln)\n{\n  // TODO: Saperated component patterns aren't handled by this function\n  // as PMCGroundings is used instead. Update to handle such cases.\n\n  // The psi-rule weight calculations could be done here.\n",
      "description": "Saperated component patterns aren't handled by this function"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 56,
      "type": "TODO",
      "content": "// TODO: If we are here it means the suggested groundings doesn't have",
      "context": "      }\n    }\n\n    // TODO: If we are here it means the suggested groundings doesn't have\n    // VariableNodes, and can be cached. This doesn't account for terms\n    // that are under QuoteLink, or other similar type links. How should\n    // such cases be handled?\n",
      "description": "If we are here it means the suggested groundings doesn't have"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 76,
      "type": "TODO",
      "content": "// TODO: This happens when InitiateSearchCB::no_search has groundings.",
      "context": "    _implicator -> _satisfiability_cache[_pattern_body] = var_soln;\n    return true;\n  } else {\n    // TODO: This happens when InitiateSearchCB::no_search has groundings.\n    // Cases for when this happens hasn't been tested yet. Explore the\n    // behavior and find a better solution. For now, log it and continue\n    // searching.\n",
      "description": "This happens when InitiateSearchCB::no_search has groundings."
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 93,
      "type": "FIXME",
      "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
      "context": "\tif (_in_server) return;\n\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n",
      "description": "This lock is not needed, because in guile-2.2,"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1028,
      "type": "TODO",
      "content": "// TODO: it would be nice to pass exceptions on through, but",
      "context": "\t}\n\texpr = scm_cons(sfunc, expr);\n\n\t// TODO: it would be nice to pass exceptions on through, but\n\t// this currently breaks unit tests.\n\t// if (_in_eval)\n\t//    return scm_eval(expr, scm_interaction_environment());\n",
      "description": "it would be nice to pass exceptions on through, but"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1057,
      "type": "FIXME",
      "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
      "context": "\t\t{\n\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n",
      "description": "-- idealy we should avoid catch-and-rethrow."
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1180,
      "type": "FIXME",
      "content": "// XXX FIXME only a subset is needed.",
      "context": "\nvoid SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n",
      "description": "only a subset is needed."
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
      "line": 239,
      "type": "FIXME",
      "content": "// XXX FIXME this does not smell right; optionals should get",
      "context": "\n    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n",
      "description": "this does not smell right; optionals should get"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
      "line": 268,
      "type": "FIXME",
      "content": "// XXX FIXME ... using an std::map would be more efficient.",
      "context": "    // remove repeated atoms from OR\n    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n",
      "description": "... using an std::map would be more efficient."
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
      "line": 46,
      "type": "FIXME",
      "content": "// FIXME XXX -- Optionals are handled incorrectly here;",
      "context": "\n    std::vector<LGDictExpContainer> subcontainers;\n\n    // FIXME XXX -- Optionals are handled incorrectly here;\n    // they are denoted by a null Exp pointer in an OR_list!\n    // Ignoring all the nulls is just ... wrong.\n#if (LINK_MAJOR_VERSION == 5) &&  (LINK_MINOR_VERSION < 7)\n",
      "description": "XXX -- Optionals are handled incorrectly here;"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
      "line": 103,
      "type": "FIXME",
      "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
      "context": "\n    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n",
      "description": "-- if dn_head is null, then we should check regexes."
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
      "line": 229,
      "type": "FIXME",
      "content": "// XXX FIXME. This should be part of the LgDictNode but since",
      "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n",
      "description": ". This should be part of the LgDictNode but since"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
      "line": 338,
      "type": "FIXME",
      "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
      "context": "\t\t\tparse_options_set_linkage_limit(opts, max_linkages);\n\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n",
      "description": "-- We should fish parse options out of the atomspace."
    },
    {
      "file": "components/learning/moses/examples/example-progs/continmax.cc",
      "line": 67,
      "type": "TODO",
      "content": "// TODO: Expand documentation to match style of onemax/nmax examples.",
      "context": "// -- the number that is -log_2(epsilon) where epsilon is the smallest\n//    distinction between continuous variables what will be drawn.\n//\n// TODO: Expand documentation to match style of onemax/nmax examples.\n// Add parameter descriptions, usage examples, and expected output.\n\nint main(int argc, char** argv)\n",
      "description": "Expand documentation to match style of onemax/nmax examples."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
      "line": 45,
      "type": "TODO",
      "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
      "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n",
      "description": "would be nice to have a more Caml/Haskell style syntax here,"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
      "line": 505,
      "type": "TODO",
      "content": "// TODO",
      "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n",
      "description": ""
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
      "line": 795,
      "type": "TODO",
      "content": "//TODO",
      "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n",
      "description": ""
    },
    {
      "file": "components/learning/moses/moses/comboreduct/interpreter/eval.cc",
      "line": 530,
      "type": "TODO",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return eval_throws_tree(bmap, exp_tr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
      "description": "contin_if should go away."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
      "line": 336,
      "type": "TODO",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
      "description": "contin_if should go away."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/main/action-reductor.cc",
      "line": 93,
      "type": "TODO",
      "content": "// TODO -- replace this by cond",
      "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n",
      "description": "-- replace this by cond"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/main/eval-table.cc",
      "line": 147,
      "type": "FIXME",
      "content": "// XXX FIXME",
      "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n",
      "description": ""
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.cc",
      "line": 963,
      "type": "TODO",
      "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
      "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n",
      "description": "sin(*(-1 x)) -> -sin(x)"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 100,
      "type": "TODO",
      "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
      "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n",
      "description": "I don't understand why this is not damaging contin_if  !??"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.cc",
      "line": 1228,
      "type": "TODO",
      "content": "//check if 0<-(y+pi) -> false //TODO",
      "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n",
      "description": ""
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 409,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 434,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 848,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 692,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 696,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1352,
      "type": "TODO",
      "content": "// XXX TODO, it would be easier if KLD took a sorted list",
      "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n",
      "description": ", it would be easier if KLD took a sorted list"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1366,
      "type": "TODO",
      "content": "// XXX TODO remove this print, for better performance.",
      "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n",
      "description": "remove this print, for better performance."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 955,
      "type": "TODO",
      "content": "// TODO could be simplified, optimized, etc",
      "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n",
      "description": "could be simplified, optimized, etc"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1078,
      "type": "TODO",
      "content": "// TODO: this could definitely be optimized",
      "context": "\n    if (is_sparse) {\n        // fallback on the old loader\n        // TODO: this could definitely be optimized\n        OC_ASSERT(timestamp_feature.empty(), \"Timestamp feature not implemented\");\n        return istreamTable_OLD(in, tab, target_feature, ignore_features);\n    } else {\n",
      "description": "this could definitely be optimized"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.cc",
      "line": 599,
      "type": "TODO",
      "content": "// XXX TODO the code below was modified to allow arg lists of",
      "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n",
      "description": "the code below was modified to allow arg lists of"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
      "line": 235,
      "type": "TODO",
      "content": "// TODO : lambda",
      "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n",
      "description": "lambda"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 441,
      "type": "TODO",
      "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
      "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n",
      "description": "DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 457,
      "type": "TODO",
      "content": "// TODO: re-enable that once best_possible_bscore is fixed",
      "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n",
      "description": "re-enable that once best_possible_bscore is fixed"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
      "description": "this is a bug .. the user may have specified that"
    },
    {
      "file": "components/learning/moses/moses/moses/eda/replacement.h",
      "line": 62,
      "type": "TODO",
      "content": "// TODO: I think it might be a little more efficent to use the",
      "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n",
      "description": "I think it might be a little more efficent to use the"
    },
    {
      "file": "components/learning/moses/moses/moses/main/problem-params.cc",
      "line": 166,
      "type": "TODO",
      "content": "// XXX TODO: make this print correctly, instead of using brackets.",
      "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n",
      "description": "make this print correctly, instead of using brackets."
    },
    {
      "file": "components/learning/moses/moses/moses/main/problem-params.h",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX FIXME TODO The structure below should be split into multiple",
      "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n",
      "description": "TODO The structure below should be split into multiple"
    },
    {
      "file": "components/learning/moses/moses/moses/main/table-problems.cc",
      "line": 138,
      "type": "FIXME",
      "content": "// XXX FIXME -- the multiple tables should be merged into one.",
      "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n",
      "description": "-- the multiple tables should be merged into one."
    },
    {
      "file": "components/learning/moses/moses/moses/main/table-problems.cc",
      "line": 150,
      "type": "FIXME",
      "content": "// XXX FIXME .. check that they all have the same signature.",
      "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n",
      "description": ".. check that they all have the same signature."
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 261,
      "type": "FIXME",
      "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
      "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n",
      "description": "we should use a pointer set for scored_combo_tree_set"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 404,
      "type": "TODO",
      "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
      "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n",
      "description": "Make population cap size-sensitive to exemplar complexity."
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 552,
      "type": "FIXME",
      "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
      "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n",
      "description": "looks to me like it++ can often be collaed twice within this loop!"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
      "line": 222,
      "type": "FIXME",
      "content": "// XXX FIXME should probably not recompute every time ...",
      "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n",
      "description": "should probably not recompute every time ..."
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
      "line": 535,
      "type": "TODO",
      "content": "// TODO: we may want to output the visited status as well",
      "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n",
      "description": "we may want to output the visited status as well"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
      "line": 180,
      "type": "TODO",
      "content": "// TODO use the option of the output",
      "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n",
      "description": "use the option of the output"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 201,
      "type": "TODO",
      "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
      "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n",
      "description": "-- trim the deme down, before sending, by using the worst acceptable score."
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 482,
      "type": "TODO",
      "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
      "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n",
      "description": "Optimize statistics printing frequency to reduce output volume."
    },
    {
      "file": "components/learning/moses/moses/moses/moses/partial.cc",
      "line": 96,
      "type": "TODO",
      "content": "// TODO: Improve generation tracking by getting actual number",
      "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n",
      "description": "Improve generation tracking by getting actual number"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/types.h",
      "line": 210,
      "type": "TODO",
      "content": "// TODO this should be a std::valarray not std::vector but I am too",
      "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n",
      "description": "this should be a std::valarray not std::vector but I am too"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 110,
      "type": "TODO",
      "content": "// XXX TODO make sure this value is appropriately updated.",
      "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n",
      "description": "make sure this value is appropriately updated."
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
      "line": 197,
      "type": "TODO",
      "content": "// TODO: work in a better way to identify convergence.",
      "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n",
      "description": "work in a better way to identify convergence."
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
      "line": 236,
      "type": "TODO",
      "content": "// TODO: Explanation",
      "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n",
      "description": "Explanation"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 154,
      "type": "TODO",
      "content": "// TODO: pso description",
      "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n",
      "description": "pso description"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 315,
      "type": "TODO",
      "content": "// TODO: Wind dispersion, but test without first",
      "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n",
      "description": "Wind dispersion, but test without first"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/star-anneal.cc",
      "line": 42,
      "type": "TODO",
      "content": "// XXX TODO the annealing temperature control code should be ported over",
      "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n",
      "description": "the annealing temperature control code should be ported over"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 316,
      "type": "TODO",
      "content": "/// TODO: measure and compare the resulting performance.",
      "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n",
      "description": "measure and compare the resulting performance."
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 489,
      "type": "TODO",
      "content": "// TODO: should bias the selection of these, so that",
      "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n",
      "description": "should bias the selection of these, so that"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 581,
      "type": "TODO",
      "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
      "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n",
      "description": "Benchmark and clarify optimal breakeven point across different problem sizes."
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 690,
      "type": "TODO",
      "content": "// XXX TODO: Is this really optimal?  The below adds an entire copy",
      "context": "        }\n    }\n\n    // XXX TODO: Is this really optimal?  The below adds an entire copy\n    // of the tree at it, which clearly increases the overall complexity.\n    // But is this really a wise thig to do? It seems gratuitous, and it's\n    // not obvious that knobs from this flipped tree will yeild benefits,\n",
      "description": "Is this really optimal?  The below adds an entire copy"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1181,
      "type": "TODO",
      "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
      "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n",
      "description": "should bias the selection of these (and possibly choose larger subtrees)"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1283,
      "type": "TODO",
      "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
      "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
      "description": "this below is clearly unfinished, broken, etc."
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1342,
      "type": "FIXME",
      "content": "//FIXME: now just attaches to the first output",
      "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n",
      "description": "now just attaches to the first output"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
      "line": 89,
      "type": "FIXME",
      "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
      "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n",
      "description": ", calling score_tree above does not throw the exception; this should be done"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 51,
      "type": "TODO",
      "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
      "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n",
      "description": "One might think that varying the stepsize, i.e. shrinking"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 236,
      "type": "TODO",
      "content": "// XXX TODO need to add support for \"term algebra\" knobs",
      "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n",
      "description": "need to add support for \"term algebra\" knobs"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
      "line": 570,
      "type": "TODO",
      "content": "// TODO",
      "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n",
      "description": ""
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 486,
      "type": "TODO",
      "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n",
      "description": "-- should not return the penalties as part of the bscore,"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
      "line": 108,
      "type": "FIXME",
      "content": "// XXX FIXME complexity_t should be a double not an int ...",
      "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n",
      "description": "complexity_t should be a double not an int ..."
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
      "line": 124,
      "type": "TODO",
      "content": "// XXX TODO should be a std::valarray not a vector.",
      "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n",
      "description": "should be a std::valarray not a vector."
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/time_dispersion.cc",
      "line": 43,
      "type": "TODO",
      "content": "// TODO multipler other than 1 is not supported yet",
      "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n",
      "description": "multipler other than 1 is not supported yet"
    },
    {
      "file": "language-learning/src/grammar_learner/category_learner.py",
      "line": 32,
      "type": "FIXME",
      "content": "log = OrderedDict()  # FIXME: log \u00bb response",
      "context": "    algorithm = kwa('kmeans', 'clustering', **kwargs)\n    verbose = kwa('none', 'verbose', **kwargs)\n\n    log = OrderedDict()  # FIXME: log \u00bb response\n    log.update({'category_learner': 'v.0.7.81231'})\n\n    cdf = pd.DataFrame(columns = ['cluster', 'cluster_words'])\n",
      "description": "log \u00bb response"
    },
    {
      "file": "language-learning/src/grammar_learner/category_learner.py",
      "line": 53,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            dim = vector_space_dim(links, dict_path, tmpath, dim_max, sv_min,\n                                   verbose)\n        except:  # FIXME\n            dim = dim_max\n        log.update({'vector_space_dim': dim})\n\n",
      "description": ""
    },
    {
      "file": "language-learning/src/grammar_learner/clustering.py",
      "line": 361,
      "type": "TODO",
      "content": "# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids",
      "context": "# 80809 update: (30,60,3,[3]) - old range + repeat / (120,30,3) -- search opt\n# 80825 random_clusters\n# 81022 refactoring\n# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids\n# 81231 cleanup\n# 90104 resolve Turtle MST LW crash: 1 cluster\n# 90209 group_links: add min_word_count to 80925 legacy version\n",
      "description": "n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 14,
      "type": "FIXME",
      "content": "nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?",
      "context": "    rights = Counter()  # right words in links\n    links = Counter()   # tuples: (left_word, right_word)\n    lw = Counter()      # linked words\n    nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?\n    nlws = set()        # a set of non-linked words in a sentence in a loop\n    nnlws = 0           # number of non-linked word occasions in all sentences\n    sentence = []       # a list of words (used within loops)\n",
      "description": "not used \u00bb DEL?"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 37,
      "type": "FIXME",
      "content": "nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned",
      "context": "                if len(nlws) > 0:  # indices of non-parsed words in sentence\n                    nnlws += len(nlws)  # number of non-linked words\n                    for j in nlws:\n                        nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned\n                    # nlws = set()\n                # sentence = []\n                # Count only parsed words (excluding ###LEFT-WALL### and .)\n",
      "description": "DEL? nlw not returned"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 112,
      "type": "TODO",
      "content": "# TODO: update - see GitHub issue?",
      "context": "\n# 80802 poc05 restructured: moved here from pparser.py\n# 80829,31 unpws, unlws\n# TODO: update - see GitHub issue?\n# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n",
      "description": "update - see GitHub issue?"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 116,
      "type": "TODO",
      "content": "# TODO: update sentence length count to parsed words?",
      "context": "# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n# TODO: update sentence length count to parsed words?\n",
      "description": "update sentence length count to parsed words?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 71,
      "type": "TODO",
      "content": "# TODO? sort by frequency?",
      "context": "        d = {x: (i + 1) for i, x in\n             enumerate(sorted(set([x for y in cats['disjuncts'] for x in y])))}\n        cats['djs'] = [set([d[x] for x in y]) for y in cats['disjuncts']]\n        # TODO? sort by frequency?\n\n    return cats, sorted(set(similarities), reverse = True)\n\n",
      "description": "? sort by frequency?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 90,
      "type": "TODO",
      "content": "# TODO? define order of children?",
      "context": "            return []\n        else:\n            x = []\n            # TODO? define order of children?\n            for j in children[i]:\n                x.append(j)\n                y = branch(j, children)\n",
      "description": "? define order of children?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 133,
      "type": "TODO",
      "content": "else:  # 81130: prune clusters with empty dj sets  # TODO: update",
      "context": "                    new_dj.append(ordnung.index(abs(index)) * sign(index))\n                new_rule.append(tuple(new_dj))\n            new_cats['disjuncts'][rule] = set(new_rule)\n        else:  # 81130: prune clusters with empty dj sets  # TODO: update\n            print(('rule', rule, '- 0 djs in new_cats[disjuncts][rule]:',\n                   new_cats['disjuncts'][rule]))\n\n",
      "description": "update"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 179,
      "type": "TODO",
      "content": "# TODO: list of merged clusters - to delete",
      "context": "    if aggregation == 'jaccard':\n        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n",
      "description": "list of merged clusters - to delete"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 180,
      "type": "TODO",
      "content": "# TODO: delete merged clusters",
      "context": "        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n        while z > 1 and threshold > aggr_threshold:\n",
      "description": "delete merged clusters"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 206,
      "type": "TODO",
      "content": "# TODO: delete merged clusters?",
      "context": "    cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n    sims = [x for x in similarities]  # if x < threshold]\n    threshold = max(sims) - 0.01\n    # TODO: delete merged clusters?\n\n    z = len(similarities)\n    while z > 1 and threshold > aggr_threshold:\n",
      "description": "delete merged clusters?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 215,
      "type": "TODO",
      "content": "# Renumber connectors in disjuncts # TODO: for all clusters?",
      "context": "        threshold = max(sims) - 0.01\n        z = len(sims)\n\n    # Renumber connectors in disjuncts # TODO: for all clusters?\n    clusters = [i for i, x in enumerate(cats['cluster'])\n                if i > 0 and x is not None]\n\n",
      "description": "for all clusters?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 277,
      "type": "TODO",
      "content": "# TODO: delete merged clusters?",
      "context": "        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        sims = [x for x in similarities]  # if x < threshold]\n        threshold = max(sims) - 0.01\n        # TODO: delete merged clusters?\n        z = len(similarities)\n        while z > 1 and threshold > aggr_threshold:\n            cats, similarities = aggregate(cats, threshold, jaccard, verbose)\n",
      "description": "delete merged clusters?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 342,
      "type": "TODO",
      "content": "# new_cluster_id = len(cats['top'])  # TODO?",
      "context": "    merges = [x for i, x in enumerate(merges) if i not in merged]\n    for mset in merges:\n        new_cluster_id = len(cats['parent'])\n        # new_cluster_id = len(cats['top'])  # TODO?\n        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n",
      "description": "?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 346,
      "type": "TODO",
      "content": "cats['parent'].append(0)  # TODO? append(None) & use top?",
      "context": "        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n        cats['parent'].append(0)  # TODO? append(None) & use top?\n        cats['children'].append(mset)\n        cats['words'].append(set())\n        cats['disjuncts'].append(set())\n",
      "description": "? append(None) & use top?"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 356,
      "type": "TODO",
      "content": "cats['parent'][cluster] = new_cluster_id  # TODO: don't change",
      "context": "\n        for cluster in mset:\n            cats['top'][cluster] = new_cluster_id  # 81123\n            cats['parent'][cluster] = new_cluster_id  # TODO: don't change\n            cats['words'][new_cluster_id].update(cats['words'][cluster])\n            cats['disjuncts'][new_cluster_id].update(cats['disjuncts'][cluster])\n            cats['djs'][new_cluster_id].update(cats['djs'][cluster])\n",
      "description": "don't change"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 414,
      "type": "TODO",
      "content": "# TODO: aggregate_cosine?",
      "context": "# 80725 POC 0.1-0.4 deleted, 0.5 restructured\n# 80802 poc05.py restructured, cats2list moved to category_learner.py,\n# cats2list copied to poc05.py for tmp compatibility\n# TODO: aggregate_cosine?\n# 80802 fix compatibility with dj_counts & max_disjuncts, delete ...05.py?\n# 81121 generalise_rules\n# 81217 FIXME? generalize_categories [F] with new reorder (Turtle tests)\n",
      "description": "aggregate_cosine?"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 27,
      "type": "FIXME",
      "content": "if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!",
      "context": "def calc_pmi(counts, cds):  # Calculates e^PMI; PMI without the log().\n    sum_w = np.array(counts.sum(axis=1))[:, 0]\n    sum_c = np.array(counts.sum(axis=0))[0, :]\n    if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!\n    sum_total = sum_c.sum()\n    sum_w = np.reciprocal(sum_w)\n    sum_c = np.reciprocal(sum_c)\n",
      "description": "cds = 1.0 ?!"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 138,
      "type": "FIXME",
      "content": "print('SVDEmbedding: transpose')    #FIXME:DEL",
      "context": "    # Context embeddings can be created with \"transpose\".\n    def __init__(self, path, normalize=True, eig=0.0, transpose=False):\n        if transpose:\n            print('SVDEmbedding: transpose')    #FIXME:DEL\n            ut = np.load(path + '.vt.npy')\n            self.wi, self.iw = load_vocabulary(path + '.contexts.vocab')\n        else:\n",
      "description": "DEL"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 358,
      "type": "TODO",
      "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
      "context": "    logger.info(f'SVD matrix (3 files .npy) saved: {len(ut[0])} vectors, ut: {len(ut)} s: {len(s)} vt:{len(vt)}')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n",
      "description": "move code here, RAM2RAM"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 439,
      "type": "TODO",
      "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
      "context": "    list2tsv(explicit.ic, svd_path + '.contexts.vocab')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n",
      "description": "move code here, RAM2RAM"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 466,
      "type": "TODO",
      "content": "# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?",
      "context": "# Notes:\n\n# 80329 added vector_space_dim\n# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?\n# 90221 minor updates for Grammar Learner tutorial\n",
      "description": "refactor, control disk writes, ... PPMI \u21d2 +frequency?"
    },
    {
      "file": "language-learning/src/grammar_learner/pqa_table.py",
      "line": 641,
      "type": "FIXME",
      "content": "continue  # FIXME: check case",
      "context": "                     linkage, affinity, gen, ' ---', 'fail',\n                     ' ---', ' ---', ' ---', ' ---', ' ---', ' ---']\n            details.append(dline)\n            continue  # FIXME: check case\n        if kwargs['linkage_limit'] > 0:\n            start = time.time()\n            a, f1, precision, q = pqa_meter(re['grammar_file'],\n",
      "description": "check case"
    },
    {
      "file": "language-learning/src/grammar_learner/preprocessing.py",
      "line": 33,
      "type": "TODO",
      "content": "# TODO: cleanup here or in a separate constructor?",
      "context": "            if us[-1] != '\\n' :  us += '\\n'\n        us += s\n        if us[-1] != '\\n' :  us += '\\n'\n    # TODO: cleanup here or in a separate constructor?\n    re = OrderedDict([('read_files', UTC()),\n                      ('input_path', kwargs['input_path']),\n                      ('read_files_number', len(files)),\n",
      "description": "cleanup here or in a separate constructor?"
    },
    {
      "file": "language-learning/src/grammar_learner/preprocessing.py",
      "line": 141,
      "type": "FIXME",
      "content": "# else:  # FIXME: raise error / assert ?",
      "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n",
      "description": "raise error / assert ?"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 25,
      "type": "TODO",
      "content": "elif clustering == 'group':  # TODO: call ILE clustering?",
      "context": "            clustering = ('kmeans', 'k-means++', 10)\n        elif clustering in ['mean_shift', 'mean shift', 'meanshift']:\n            clustering = ('mean_shift', 2)  # Note: 'auto' bandwidth not yet implemented\n        elif clustering == 'group':  # TODO: call ILE clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n",
      "description": "call ILE clustering?"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 29,
      "type": "TODO",
      "content": "elif clustering == 'random':  # TODO: call random clustering?",
      "context": "            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n        elif clustering == 'random':  # TODO: call random clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'random not supported in skl_clustering'}, []\n",
      "description": "call random clustering?"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 56,
      "type": "TODO",
      "content": "# TODO: int / dict",
      "context": "            if len(clustering) > 3:  # connectivity\n                if type(clustering[3]) is int and clustering[3] > 0:\n                    neighbors = clustering[3]\n                    # TODO: int / dict \n                    connectivity = kneighbors_graph(cd, neighbors,\n                                                    include_self=False)\n            if len(clustering) > 4:  # compute_full_tree\n",
      "description": "int / dict "
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 111,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            metrics['silhouette_index'] = float(\n                silhouette_score(cd, labels, metric=clustering_metric[1]))\n        except:  # FIXME\n            metrics['silhouette_index'] = 0.0\n        try:\n            metrics['variance_ratio'] = float(\n",
      "description": ""
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 116,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            metrics['variance_ratio'] = float(\n                calinski_harabaz_score(cd, labels))\n        except:  # FIXME\n            metrics['variance_ratio'] = 0.0\n        # try:\n        #   metrics['davies_bouldin_score'] = float(\n",
      "description": ""
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 124,
      "type": "FIXME",
      "content": "except:  # else:  # FIXME",
      "context": "        # except: metrics['davies_bouldin_score'] = 0.0\n\n        return labels, metrics, centroids\n    except:  # else:  # FIXME\n        print('except: skl_clustering error')\n        return np.asarray(range(cd.shape[0])), \\\n               {'clustering': 'skl_clustering error'}, []\n",
      "description": ""
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 172,
      "type": "TODO",
      "content": "elif len(crange) == 3:  # TODO: replace with SGD?",
      "context": "                    l, m, c = skl_clustering(cd, crange[0], **kwargs)\n                    if m['silhouette_index'] > metrics['silhouette_index']:\n                        labels, metrics, centroids = l, m, c\n        elif len(crange) == 3:  # TODO: replace with SGD?\n            n_min = min(crange[0], crange[1])\n            n_max = max(crange[0], crange[1])\n            labels, metrics, centroids = \\\n",
      "description": "replace with SGD?"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 208,
      "type": "FIXME",
      "content": "# FIXME: try...except",
      "context": "# 181203 cleanup\n# 190118 cleanup: remove debug printing\n# 190425 fix n_clusters > n_words case\n# FIXME: try...except\n",
      "description": "try...except"
    },
    {
      "file": "language-learning/src/grammar_learner/widgets.py",
      "line": 70,
      "type": "TODO",
      "content": "#  TODO: To be reviewed and changed if necessary",
      "context": "                tree.append(['', m+1, cats[j][2], cats[j][3]])\n        else:\n            print('WTF?', k, v)\n    #  TODO: To be reviewed and changed if necessary\n    if verbose not in ['none', 'min']:\n        display(html_table([['Code', 'Parent', 'Id', 'Words']] + tree))\n\n",
      "description": "To be reviewed and changed if necessary"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 26,
      "type": "FIXME",
      "content": "def setUp(self):    # FIXME: should run before every test, but would not?!",
      "context": "\nclass TestGrammarLearner(unittest.TestCase):\n\n    def setUp(self):    # FIXME: should run before every test, but would not?!\n        input_parses = module_path + '/tests/data/POC-Turtle/MST_fixed_manually/'\n        batch_dir = module_path + '/output/Test_Grammar_Learner_' + str(UTC())[:10] + '/'\n        kwargs = {  # defaults\n",
      "description": "should run before every test, but would not?!"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 65,
      "type": "FIXME",
      "content": "# 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester",
      "context": "        # Additional (optional) parameters for parse_metrics (_abiity & _quality):\n        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n",
      "description": "changed in June 2018 Grammar Tester"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 212,
      "type": "TODO",
      "content": "# TODO: Remove these commented lines in next cleanup cycle.",
      "context": "        }\n        re = learn_grammar(**kwargs)\n        # NOTE: Legacy test code commented out for historical reference.\n        # TODO: Remove these commented lines in next cleanup cycle.\n        # a, q, qa = pqa_meter(re['grammar_file'], outpath, cp, rp, **kwargs)\n        # print('parse-ability, parse-quality:', a, q)\n        # assert a*q > 0.99\n",
      "description": "Remove these commented lines in next cleanup cycle."
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 310,
      "type": "FIXME",
      "content": "# FIXME: check with further test_grammar updates and delete.",
      "context": "            'verbose'       :   'min'\n        }\n        # Sometimes pqa_meter(with test_grammar updated 2018-10-19) returns pa,recall = 0,0\n        # FIXME: check with further test_grammar updates and delete.\n        x = 0.\n        n = 0\n        while x < 0.1 :\n",
      "description": "check with further test_grammar updates and delete."
    },
    {
      "file": "moses/moses/comboreduct/combo/descriptions.cc",
      "line": 45,
      "type": "TODO",
      "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
      "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n",
      "description": "would be nice to have a more Caml/Haskell style syntax here,"
    },
    {
      "file": "moses/moses/comboreduct/combo/vertex.h",
      "line": 505,
      "type": "TODO",
      "content": "// TODO",
      "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n",
      "description": ""
    },
    {
      "file": "moses/moses/comboreduct/combo/vertex.h",
      "line": 795,
      "type": "TODO",
      "content": "//TODO",
      "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n",
      "description": ""
    },
    {
      "file": "moses/moses/comboreduct/interpreter/eval.cc",
      "line": 563,
      "type": "TODO",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return eval_throws_tree(new_bmap, lambda_expr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
      "description": "contin_if should go away."
    },
    {
      "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
      "line": 336,
      "type": "TODO",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n",
      "description": "contin_if should go away."
    },
    {
      "file": "moses/moses/comboreduct/main/action-reductor.cc",
      "line": 93,
      "type": "TODO",
      "content": "// TODO -- replace this by cond",
      "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n",
      "description": "-- replace this by cond"
    },
    {
      "file": "moses/moses/comboreduct/main/eval-table.cc",
      "line": 147,
      "type": "FIXME",
      "content": "// XXX FIXME",
      "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n",
      "description": ""
    },
    {
      "file": "moses/moses/comboreduct/reduct/contin_rules.cc",
      "line": 963,
      "type": "TODO",
      "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
      "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n",
      "description": "sin(*(-1 x)) -> -sin(x)"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 102,
      "type": "TODO",
      "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
      "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n",
      "description": "I don't understand why this is not damaging contin_if  !??"
    },
    {
      "file": "moses/moses/comboreduct/reduct/mixed_rules.cc",
      "line": 1228,
      "type": "TODO",
      "content": "//check if 0<-(y+pi) -> false //TODO",
      "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n",
      "description": ""
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 420,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 445,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 859,
      "type": "TODO",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n",
      "description": "replace this by the util p_norm function."
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 692,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 696,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1352,
      "type": "TODO",
      "content": "// XXX TODO, it would be easier if KLD took a sorted list",
      "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n",
      "description": ", it would be easier if KLD took a sorted list"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1366,
      "type": "TODO",
      "content": "// XXX TODO remove this print, for better performance.",
      "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n",
      "description": "remove this print, for better performance."
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 934,
      "type": "TODO",
      "content": "// TODO could be simplified, optimized, etc",
      "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n",
      "description": "could be simplified, optimized, etc"
    },
    {
      "file": "moses/moses/comboreduct/type_checker/type_tree.cc",
      "line": 627,
      "type": "TODO",
      "content": "// XXX TODO the code below was modified to allow arg lists of",
      "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n",
      "description": "the code below was modified to allow arg lists of"
    },
    {
      "file": "moses/moses/comboreduct/type_checker/type_tree.h",
      "line": 235,
      "type": "TODO",
      "content": "// TODO : lambda",
      "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n",
      "description": "lambda"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 441,
      "type": "TODO",
      "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
      "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n",
      "description": "DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 457,
      "type": "TODO",
      "content": "// TODO: re-enable that once best_possible_bscore is fixed",
      "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n",
      "description": "re-enable that once best_possible_bscore is fixed"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
      "description": "this is a bug .. the user may have specified that"
    },
    {
      "file": "moses/moses/moses/eda/replacement.h",
      "line": 62,
      "type": "TODO",
      "content": "// TODO: I think it might be a little more efficent to use the",
      "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n",
      "description": "I think it might be a little more efficent to use the"
    },
    {
      "file": "moses/moses/moses/main/problem-params.cc",
      "line": 169,
      "type": "TODO",
      "content": "// XXX TODO: make this print correctly, instead of using brackets.",
      "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n",
      "description": "make this print correctly, instead of using brackets."
    },
    {
      "file": "moses/moses/moses/main/problem-params.h",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX FIXME TODO The structure below should be split into multiple",
      "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n",
      "description": "TODO The structure below should be split into multiple"
    },
    {
      "file": "moses/moses/moses/main/table-problems.cc",
      "line": 138,
      "type": "FIXME",
      "content": "// XXX FIXME -- the multiple tables should be merged into one.",
      "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n",
      "description": "-- the multiple tables should be merged into one."
    },
    {
      "file": "moses/moses/moses/main/table-problems.cc",
      "line": 150,
      "type": "FIXME",
      "content": "// XXX FIXME .. check that they all have the same signature.",
      "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n",
      "description": ".. check that they all have the same signature."
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 261,
      "type": "FIXME",
      "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
      "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n",
      "description": "we should use a pointer set for scored_combo_tree_set"
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 404,
      "type": "TODO",
      "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
      "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n",
      "description": "Make population cap size-sensitive to exemplar complexity."
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 552,
      "type": "FIXME",
      "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
      "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n",
      "description": "looks to me like it++ can often be collaed twice within this loop!"
    },
    {
      "file": "moses/moses/moses/metapopulation/metapopulation.cc",
      "line": 222,
      "type": "FIXME",
      "content": "// XXX FIXME should probably not recompute every time ...",
      "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n",
      "description": "should probably not recompute every time ..."
    },
    {
      "file": "moses/moses/moses/metapopulation/metapopulation.h",
      "line": 535,
      "type": "TODO",
      "content": "// TODO: we may want to output the visited status as well",
      "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n",
      "description": "we may want to output the visited status as well"
    },
    {
      "file": "moses/moses/moses/moses/local_moses.cc",
      "line": 180,
      "type": "TODO",
      "content": "// TODO use the option of the output",
      "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n",
      "description": "use the option of the output"
    },
    {
      "file": "moses/moses/moses/moses/moses_main.h",
      "line": 102,
      "type": "TODO",
      "content": "// XXX TODO this should be fixed, someday...",
      "context": "        // messages.  In fact, the mpi workers should not even have\n        // a printer at all, or use a null_printer.  Unfortunately,\n        // the current code structure makes this hard to implement.\n        // XXX TODO this should be fixed, someday...\n        if (is_mpi && metapop.size() == 0)\n            return;\n\n",
      "description": "this should be fixed, someday..."
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 202,
      "type": "TODO",
      "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
      "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n",
      "description": "-- trim the deme down, before sending, by using the worst acceptable score."
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 318,
      "type": "TODO",
      "content": "// XXX TODO should probably fetch max_time from somewhere...",
      "context": "            continue; // Continue to next exemplar\n        }\n\n        // XXX TODO should probably fetch max_time from somewhere...\n        time_t max_time = INT_MAX;\n        dex.optimize_demes(max_evals, max_time);\n\n",
      "description": "should probably fetch max_time from somewhere..."
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 486,
      "type": "TODO",
      "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
      "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n",
      "description": "Optimize statistics printing frequency to reduce output volume."
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 616,
      "type": "TODO",
      "content": "// XXX TODO instead of overwritting the demeID it should be",
      "context": "        scored_combo_tree_set candidates;\n        stats.n_expansions ++;\n\n        // XXX TODO instead of overwritting the demeID it should be\n        // correctly defined by the worker and send back to the\n        // dispatcher. That way we can have the breadth_first\n        // componant of the demeID right.\n",
      "description": "instead of overwritting the demeID it should be"
    },
    {
      "file": "moses/moses/moses/moses/neighborhood_sampling.h",
      "line": 327,
      "type": "TODO",
      "content": "// XXX TODO, unroll the last tail call, just like the single-bit",
      "context": "        else\n        {\n            // Recursive call, moved for one position\n            // XXX TODO, unroll the last tail call, just like the single-bit\n            // knob case, below.\n            out = vary_n_knobs(fs, tmp_inst, dist, starting_index + 1, out, end);\n            // Left<->Right\n",
      "description": ", unroll the last tail call, just like the single-bit"
    },
    {
      "file": "moses/moses/moses/moses/partial.cc",
      "line": 96,
      "type": "TODO",
      "content": "// TODO: Improve generation tracking by getting actual number",
      "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n",
      "description": "Improve generation tracking by getting actual number"
    },
    {
      "file": "moses/moses/moses/moses/types.h",
      "line": 210,
      "type": "TODO",
      "content": "// TODO this should be a std::valarray not std::vector but I am too",
      "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n",
      "description": "this should be a std::valarray not std::vector but I am too"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 110,
      "type": "TODO",
      "content": "// XXX TODO make sure this value is appropriately updated.",
      "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n",
      "description": "make sure this value is appropriately updated."
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.cc",
      "line": 198,
      "type": "TODO",
      "content": "// TODO: work in a better way to identify convergence.",
      "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n",
      "description": "work in a better way to identify convergence."
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.cc",
      "line": 237,
      "type": "TODO",
      "content": "// TODO: Explanation",
      "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n",
      "description": "Explanation"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 347,
      "type": "TODO",
      "content": "// TODO: Wind dispersion, but test without first",
      "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n",
      "description": "Wind dispersion, but test without first"
    },
    {
      "file": "moses/moses/moses/optimization/star-anneal.cc",
      "line": 44,
      "type": "TODO",
      "content": "// XXX TODO the annealing temperature control code should be ported over",
      "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n",
      "description": "the annealing temperature control code should be ported over"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 317,
      "type": "TODO",
      "content": "/// TODO: measure and compare the resulting performance.",
      "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n",
      "description": "measure and compare the resulting performance."
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 490,
      "type": "TODO",
      "content": "// TODO: should bias the selection of these, so that",
      "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n",
      "description": "should bias the selection of these, so that"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 582,
      "type": "TODO",
      "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
      "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n",
      "description": "Benchmark and clarify optimal breakeven point across different problem sizes."
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 691,
      "type": "TODO",
      "content": "// XXX TODO: Is this really optimal?  The below adds an entire copy",
      "context": "        }\n    }\n\n    // XXX TODO: Is this really optimal?  The below adds an entire copy\n    // of the tree at it, which clearly increases the overall complexity.\n    // But is this really a wise thig to do? It seems gratuitous, and it's\n    // not obvious that knobs from this flipped tree will yeild benefits,\n",
      "description": "Is this really optimal?  The below adds an entire copy"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1182,
      "type": "TODO",
      "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
      "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n",
      "description": "should bias the selection of these (and possibly choose larger subtrees)"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1284,
      "type": "TODO",
      "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
      "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
      "description": "this below is clearly unfinished, broken, etc."
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1343,
      "type": "FIXME",
      "content": "//FIXME: now just attaches to the first output",
      "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n",
      "description": "now just attaches to the first output"
    },
    {
      "file": "moses/moses/moses/representation/instance_scorer.h",
      "line": 89,
      "type": "FIXME",
      "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
      "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n",
      "description": ", calling score_tree above does not throw the exception; this should be done"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 51,
      "type": "TODO",
      "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
      "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n",
      "description": "One might think that varying the stepsize, i.e. shrinking"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 238,
      "type": "TODO",
      "content": "// XXX TODO need to add support for \"term algebra\" knobs",
      "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n",
      "description": "need to add support for \"term algebra\" knobs"
    },
    {
      "file": "moses/moses/moses/scoring/bscores.cc",
      "line": 570,
      "type": "TODO",
      "content": "// TODO",
      "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n",
      "description": ""
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 512,
      "type": "TODO",
      "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n",
      "description": "-- should not return the penalties as part of the bscore,"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 646,
      "type": "TODO",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the break-even-point for this ctable row.\nscore_t bep_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt * _true_total);\n    double best_possible_recall = 1.0 / _true_total;\n    return (best_possible_precision + best_possible_recall) / 2;\n",
      "description": "FIXME is this really correct?"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 655,
      "type": "TODO",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the difference for this ctable row.\nscore_t bep_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt);\n    double best_possible_recall = (0.0 < pos) ? 1.0 : 0.0;\n    return fabs(best_possible_precision - best_possible_recall);\n",
      "description": "FIXME is this really correct?"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 707,
      "type": "TODO",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "// generation of best-possible score.\nscore_t f_one_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    return 1.0;\n}\n\n",
      "description": "FIXME is this really correct?"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 714,
      "type": "TODO",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the f_one for this ctable row.\nscore_t f_one_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / cnt;\n    double best_possible_recall = 1.0;\n    double f_one = 2 * best_possible_precision * best_possible_recall\n",
      "description": "FIXME is this really correct?"
    },
    {
      "file": "moses/moses/moses/scoring/scoring_base.cc",
      "line": 152,
      "type": "FIXME",
      "content": "// XXX FIXME complexity_t should be a double not an int ...",
      "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n",
      "description": "complexity_t should be a double not an int ..."
    },
    {
      "file": "moses/moses/moses/scoring/scoring_base.h",
      "line": 124,
      "type": "TODO",
      "content": "// XXX TODO should be a std::valarray not a vector.",
      "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n",
      "description": "should be a std::valarray not a vector."
    },
    {
      "file": "moses/moses/moses/scoring/time_dispersion.cc",
      "line": 43,
      "type": "TODO",
      "content": "// TODO multipler other than 1 is not supported yet",
      "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n",
      "description": "multipler other than 1 is not supported yet"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 48,
      "type": "TODO",
      "content": "// TODO: the notion of equality between 2 CHandles might one where",
      "context": "public:\n\t// Contextual Handle\n\t//\n\t// TODO: the notion of equality between 2 CHandles might one where\n\t// the Context isn't necessarily equal but where the 2 handles\n\t// (besides being equal) have the same quotation and same\n\t// (free inter shadow) variables.\n",
      "description": "the notion of equality between 2 CHandles might one where"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 159,
      "type": "TODO",
      "content": "// TODO: the type of a typed block is currently a handle of the",
      "context": "\t// the simplest satisfiable solution set.\n\tstatic const Partitions empty_partition_singleton;\n\n\t// TODO: the type of a typed block is currently a handle of the\n\t// variable or ground it is exists, instead of an actual type.\n\tstruct SolutionSet : Partitions\n\t{\n",
      "description": "the type of a typed block is currently a handle of the"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 188,
      "type": "TODO",
      "content": "// TODO: maybe we could simplify a great deal of code by replacing",
      "context": "\t// Subtitution values and their corresponding variable declaration\n\t// after substitution (cause some values may be variables).\n\t//\n\t// TODO: maybe we could simplify a great deal of code by replacing\n\t// Handle by Variables.\n\ttypedef std::map<HandleCHandleMap, Handle> TypedSubstitutions;\n\ttypedef std::pair<HandleCHandleMap, Handle> TypedSubstitution;\n",
      "description": "maybe we could simplify a great deal of code by replacing"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 521,
      "type": "TODO",
      "content": "public:                         // TODO: being friend with UnifyUTest",
      "context": "\t// Memoization cache for unification results\n\tmutable std::map<std::pair<CHandle, CHandle>, SolutionSet> _unify_cache;\n\npublic:                         // TODO: being friend with UnifyUTest\n\t/**\n\t * Set Unify::_variables given the variable declarations of the\n\t * two terms to unify.\n",
      "description": "being friend with UnifyUTest"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 601,
      "type": "TODO",
      "content": "public:                         // TODO: being friend with UnifyUTest",
      "context": "\t */\n\tSolutionSet mkvarsol(CHandle lhs, CHandle rhs) const;\n\npublic:                         // TODO: being friend with UnifyUTest\n                                // somehow doesn't work\n\t/**\n\t * Join 2 solution sets. Generate the product of all consistent\n",
      "description": "being friend with UnifyUTest"
    },
    {
      "file": "unify/opencog/unify/atoms/UnifierLink.cc",
      "line": 141,
      "type": "FIXME",
      "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
      "context": "\t// I don't really understand what a solution set is.\n\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n",
      "description": ", Maybe. This seems to handle all of the cases I've"
    },
    {
      "file": "ure/opencog/ure/Rule.cc",
      "line": 58,
      "type": "TODO",
      "content": "// TODO: could certainly be optimized by not systematically",
      "context": "\nvoid RuleSet::expand_meta_rules(AtomSpace& as)\n{\n\t// TODO: could certainly be optimized by not systematically\n\t// recollecting and re-instantiating meta-rules.\n\tRuleSet meta_rules;\n\tfor (RulePtr rule : *this) {\n",
      "description": "could certainly be optimized by not systematically"
    },
    {
      "file": "ure/opencog/ure/Rule.h",
      "line": 373,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\t// True if the rule has already been applied.\n\tbool _exhausted;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n\n\t// Return a copy of the rule with the variables alpha-converted\n",
      "description": "subdivide in smaller and shared mutexes"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.cc",
      "line": 121,
      "type": "TODO",
      "content": "set_leaf2bitnode();         // TODO: might differ till needed to optimize",
      "context": "AndBIT::AndBIT(const Handle& f, double cpx, const AtomSpace* qas)\n\t: fcs(f), complexity(cpx), exhausted(false), queried_as(qas)\n{\n\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n",
      "description": "might differ till needed to optimize"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.cc",
      "line": 374,
      "type": "TODO",
      "content": "// TODO: is this merging necessary?",
      "context": "\tHandle nrewrite = expand_fcs_rewrite(nfcs_rewrite, rule.first);\n\n\t// Generate new vardecl\n\t// TODO: is this merging necessary?\n\tHandle merged_vardecl = merge_vardecl(nfcs_vardecl, rule_vardecl);\n\tHandle nvardecl = filter_vardecl(merged_vardecl, {npattern, nrewrite});\n\n",
      "description": "is this merging necessary?"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.h",
      "line": 72,
      "type": "TODO",
      "content": "// TODO: Maybe this should be moved to BackwardChainer",
      "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n",
      "description": "Maybe this should be moved to BackwardChainer"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
      "line": 288,
      "type": "TODO",
      "content": "// TODO: Maybe we could take advantage of the new read-only",
      "context": "\t// of concerns instead of the atoms themselves, and only modify\n\t// the atoms if there are existing results to copy back to _as.\n\t//\n\t// TODO: Maybe we could take advantage of the new read-only\n\t// capabilities of the AtomSpace.\n\tHandle hresult = HandleCast(fcs->execute(tmp_as.get()));\n\tHandleSeq results;\n",
      "description": "Maybe we could take advantage of the new read-only"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BackwardChainer.h",
      "line": 232,
      "type": "TODO",
      "content": "// TODO: perhaps move that under BIT",
      "context": "\t// Structure holding the Back Inference Tree\n\tBIT _bit;\n\n\t// TODO: perhaps move that under BIT\n\tAndBITFitness _andbit_fitness;\n\n\t// In charge of recording the inference traces\n",
      "description": "perhaps move that under BIT"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/ControlPolicy.h",
      "line": 45,
      "type": "TODO",
      "content": "// TODO: maybe wrap that in a class, and use it in foward chainer",
      "context": "// selected rule fulfills the objective, which must be passed\n// to the BIT to calculate the and-BIT complexity.\n//\n// TODO: maybe wrap that in a class, and use it in foward chainer\ntypedef std::pair<RuleTypedSubstitutionPair, double> RuleSelection;\n\nclass ControlPolicy\n",
      "description": "maybe wrap that in a class, and use it in foward chainer"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/Fitness.h",
      "line": 75,
      "type": "TODO",
      "content": "// TODO: we may want to move the arguments in its own class if it",
      "context": "\t\tTrace\n\t};\n\n\t// TODO: we may want to move the arguments in its own class if it\n\t// grows bigger.\n\tAndBITFitness(FitnessType ft=Uniform,\n\t              const std::set<ContentHash>& tr=std::set<ContentHash>());\n",
      "description": "we may want to move the arguments in its own class if it"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/Fitness.h",
      "line": 92,
      "type": "TODO",
      "content": "// TODO: replace by class dedicated to hold the parameters",
      "context": "\tdouble operator()(const AndBIT& andbit) const;\n\nprivate:\n\t// TODO: replace by class dedicated to hold the parameters\n\tstd::set<ContentHash> _trace;\n};\n\n",
      "description": "replace by class dedicated to hold the parameters"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
      "line": 94,
      "type": "TODO",
      "content": "// TODO: the TV on the evaluation link should be more carefully",
      "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n",
      "description": "the TV on the evaluation link should be more carefully"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/FCStat.h",
      "line": 76,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\tstd::vector<InferenceRecord> _inf_rec;\n\tAtomSpace* _trace_as;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n};\n\n",
      "description": "subdivide in smaller and shared mutexes"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 101,
      "type": "TODO",
      "content": "// TODO: For now the FC follows the old standard. We may move to",
      "context": "\n\t// Set rules.\n\t_rules = _config.get_rules();\n\t// TODO: For now the FC follows the old standard. We may move to\n\t// the new standard when all rules have been ported to the new one.\n\tfor (RulePtr rule : _rules)\n\t\trule->premises_as_clauses = true;\n",
      "description": "For now the FC follows the old standard. We may move to"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 165,
      "type": "TODO",
      "content": "// TODO: if creating/destroying threads is too expensive, use a thread",
      "context": "\twhile (not termination()) do_step(_iteration++);\n}\n\n// TODO: if creating/destroying threads is too expensive, use a thread\n// pool (see boost::asio::thread_pool).\nvoid ForwardChainer::do_steps_multithread()\n{\n",
      "description": "if creating/destroying threads is too expensive, use a thread"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 289,
      "type": "TODO",
      "content": "// TODO: This can be simplified but is let here until do_step is",
      "context": "\t\t// before being passed to the new source constructor, as this\n\t\t// one will take it into account.\n\t\t//\n\t\t// TODO: This can be simplified but is let here until do_step is\n\t\t// replaced by do_step_srpi.\n\t\tdouble weight = std::min(1.0, slc_sr.source->weight);\n\t\tdouble prob = success_plty / weight;\n",
      "description": "This can be simplified but is let here until do_step is"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 372,
      "type": "TODO",
      "content": "// TODO: refine mutex",
      "context": "\nSourcePtr ForwardChainer::select_source(const std::string& msgprfx)\n{\n\t// TODO: refine mutex\n\tstd::unique_lock<std::mutex> lock(_part_mutex);\n\n\tstd::vector<double> weights = _sources.get_weights();\n",
      "description": "refine mutex"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 409,
      "type": "TODO",
      "content": "// TODO: This has the effect of deallocating the rules, which",
      "context": "\t\tif (_config.get_retry_exhausted_sources()) {\n\t\t\ture_logger().debug() << msgprfx\n\t\t\t                     << \"Reset all exhausted flags to retry them\";\n\t\t\t// TODO: This has the effect of deallocating the rules, which\n\t\t\t// might cause a memory corruption if another thread is\n\t\t\t// attempting to apply that rule at the same time.\n\t\t\t_sources.reset_exhausted();\n",
      "description": "This has the effect of deallocating the rules, which"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 523,
      "type": "TODO",
      "content": "std::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine",
      "context": "\nRuleSet ForwardChainer::get_valid_rules(const Source& source)\n{\n\tstd::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine\n\n\t// Generate all valid rules\n\tRuleSet valid_rules;\n",
      "description": "refine"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
      "line": 237,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\n\tbool _search_focus_set;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n",
      "description": "subdivide in smaller and shared mutexes"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
      "line": 241,
      "type": "TODO",
      "content": "// TODO: use shared mutexes",
      "context": "\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n\t// TODO: use shared mutexes\n\tmutable std::mutex _rules_mutex;\n\n\t// Keep track of the number of threads to make sure\n",
      "description": "use shared mutexes"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.cc",
      "line": 48,
      "type": "TODO",
      "content": "// TODO:",
      "context": "\t// The minimum value is 1e-16 to not ignore completely the source\n\t// when the it is a default TV.\n\t//\n\t// TODO:\n\t// 1. Support more fitness functions\n\t// 2. Explicitely turn the fitness into a probability of success\n\tTruthValuePtr tv = bdy->getTruthValue();\n",
      "description": ""
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 54,
      "type": "TODO",
      "content": "// TODO: this class has thing in common with AndBIT, maybe their",
      "context": " *\n * 4. a flag call indicating if the source expansions have been exhausted.\n */\n// TODO: this class has thing in common with AndBIT, maybe their\n// common things could be placed in a parent class.\nclass Source : public boost::totally_ordered<Source>\n{\n",
      "description": "this class has thing in common with AndBIT, maybe their"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 151,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\tRuleSet rules;\n\nprivate:\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n",
      "description": "subdivide in smaller and shared mutexes"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 165,
      "type": "TODO",
      "content": "// TODO: this class has things in common with BIT, maybe their common",
      "context": "/**\n * Population of sources to forwardly expand. Primary owner.\n */\n// TODO: this class has things in common with BIT, maybe their common\n// things could be placed in a parent class.\nclass SourceSet\n{\n",
      "description": "this class has things in common with BIT, maybe their common"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 223,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "private:\n\tconst UREConfig& _config;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n",
      "description": "subdivide in smaller and shared mutexes"
    }
  ]
}