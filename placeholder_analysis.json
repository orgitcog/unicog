{
  "total_placeholders": 864,
  "by_type": {
    "FIXME": 570,
    "TODO": 268,
    "NotImplementedError": 10,
    "stub": 16
  },
  "by_file_count": 372,
  "detailed_placeholders": [
    {
      "file": "atomspace/opencog/scm/opencog/base/file-utils.scm",
      "line": 122,
      "type": "FIXME",
      "content": "; XXX this duplicates (load-from-path) which is a built-in in guile...",
      "context": ")\n\n; ---------------------------------------------------------------------\n; XXX this duplicates (load-from-path) which is a built-in in guile...\n(define-public (load-scm-from-file filename)\n\"\n load-scm-from-file filename   Run scheme code taken from file\n"
    },
    {
      "file": "atomspace/opencog/scm/opencog/base/utilities.scm",
      "line": 749,
      "type": "FIXME",
      "content": "; XXX This should probably be made obsolete.",
      "context": "\n; -----------------------------------------------------------------------\n;\n; XXX This should probably be made obsolete.\n(define-public (cog-get-reference refptr)\n\"\n  Given a reference structure, return the referenced list entries.\n"
    },
    {
      "file": "atomspace/tests/atoms/execution/defined-schema.scm",
      "line": 239,
      "type": "FIXME",
      "content": "; XXX FIXME, this does not quite work as one might naively expect,",
      "context": "\n; Define a recursive tree-walker. Unlike the above, this does\n; not reverse the order of the edges.\n; XXX FIXME, this does not quite work as one might naively expect,\n; because the search results are expanded combinatorially, instead\n; of being kept in branching-tree form.\n(DefineLink\n"
    },
    {
      "file": "atomspace/tests/query/seq-absence.scm",
      "line": 86,
      "type": "FIXME",
      "content": ";; XXX FIXME ... this and the above need to get done right.",
      "context": ";; AbsentLinks in a fundamentally different way. But we test this\n;; anyway, for now.  Like the above, its currently broken. Its too\n;; weird right now for me to want to fix it, so I am punting on this.\n;; XXX FIXME ... this and the above need to get done right.\n\n(define or-not-absent\n\t(SatisfactionLink\n"
    },
    {
      "file": "atomspace/tests/query/sudoku-puzzle.scm",
      "line": 9,
      "type": "FIXME",
      "content": "; XXX As of 18 October 2014, the pattern matcher fails to find a",
      "context": "; Hand-typed-in version of\n; http://www.theguardian.com/lifeandstyle/2014/oct/17/sudoku-2944-hard\n;\n; XXX As of 18 October 2014, the pattern matcher fails to find a\n; solution.  This is probably due to a bug in the pattern matcher,\n; although it might be due to a bug in the coding below ...\n; XXXXXXXXXXXXXXXXX\n"
    },
    {
      "file": "atomspace/tests/scm/typedefs.scm",
      "line": 3,
      "type": "FIXME",
      "content": "; XXX THIS FILE IS TO BE USED IN ASSOCIATION WITH THIS TEST CASE ONLY",
      "context": "; This file contains basic scheme wrappers for atom creation.\n; \n; XXX THIS FILE IS TO BE USED IN ASSOCIATION WITH THIS TEST CASE ONLY\n; DO NOT USE THIS FILE FOR ORDINARY CODE DEVELOPMENT; YOUR CODE WILL\n; BE BROKEN IF YOU DO!  XXXX\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/behavior-rules.scm",
      "line": 35,
      "type": "TODO",
      "content": "; TODO: This one only works currently with single word matches to the globs",
      "context": "            (ConceptNode \"GORGEOUS\")))\n    (DefinedPredicateNode \"be happy\"))\n\n; TODO: This one only works currently with single word matches to the globs\n; due to https://github.com/opencog/atomspace/issues/724\n(BindLink\n        (ListLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 16,
      "type": "TODO",
      "content": "; TODO: probably can take out eva-behavior module when express.scm is moved out",
      "context": ";\n; Requires installation of opencog/ros-behavior-scripting\n\n; TODO: probably can take out eva-behavior module when express.scm is moved out\n;       of that module.\n(use-modules (opencog) (opencog query) (opencog exec) (opencog eva-model)\n    (opencog eva-behavior))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 30,
      "type": "TODO",
      "content": "; TODO: multiple globnode values are not matching (Github issue created #724)",
      "context": "(load \"behavior-defs.scm\")\n(load \"behavior-rules.scm\")\n\n; TODO: multiple globnode values are not matching (Github issue created #724)\n\n;-----------------------------------------------------------------\n; The main training rule template for natural language training\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 35,
      "type": "TODO",
      "content": "; Todo: Or / Choice links not working in antecedant for recongition, so doing a",
      "context": ";-----------------------------------------------------------------\n; The main training rule template for natural language training\n\n; Todo: Or / Choice links not working in antecedant for recongition, so doing a\n; couple different rules for now as a workaround. Potential solution: also\n; search for OR at top level with cog-recognize\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 138,
      "type": "TODO",
      "content": "; TODO: For now just using a single result, but we should handle multiple",
      "context": "; Retrieve atomspace behavior rule with antecedent that contains atomese\n; representation of the input string.\n(define (get-tree-with-antecedent listified-string)\n    ; TODO: For now just using a single result, but we should handle multiple\n    ;       returned results.\n\t; TODO: Match on multiple conditions (ie using OR)\n\t;create temp child atomspace for temporarily needed atoms\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 140,
      "type": "TODO",
      "content": "; TODO: Match on multiple conditions (ie using OR)",
      "context": "(define (get-tree-with-antecedent listified-string)\n    ; TODO: For now just using a single result, but we should handle multiple\n    ;       returned results.\n\t; TODO: Match on multiple conditions (ie using OR)\n\t;create temp child atomspace for temporarily needed atoms\n\t(cog-push-atomspace)\n    (let* ((query-pattern (PatternLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 195,
      "type": "TODO",
      "content": "; TODO: Create feedback response that something was learned",
      "context": ";-----------------------------------------------------------------\n; Creates new behavior rule in atomese based on a given simulus and response\n(define (create-behavior-rule stimulus response)\n; TODO: Create feedback response that something was learned\n    ; create new behavior rule with text input stimulus and behavior response\n    (define new-rule)\n    (define atomese-string)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 202,
      "type": "TODO",
      "content": "; TODO: we should check first make sure the response is a pre-defined behavior",
      "context": "    (display \"\\n(create-behavior-rule) \\n    stimulus: \")(display stimulus)\n        (display \"    response: \")(display response)(newline)\n\n    ; TODO: we should check first make sure the response is a pre-defined behavior\n\t(set! new-rule\n    \t(BindLink\n    \t\tstimulus\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 216,
      "type": "TODO",
      "content": "; TODO: move to util file",
      "context": "\n;-----------------------------------------------------------------\n; Utils\n; TODO: move to util file\n\n; shortcuts\n(define (incoming atom) (cog-incoming-set atom))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 230,
      "type": "TODO",
      "content": "; TODO: ask linas about these",
      "context": "\n\n\n; TODO: ask linas about these\n; Approach to pull the training rule from the atomspace dynamically rather than\n; relying on the scheme var.\n; maybe the DefinedType atom is being replaced in the cog-satisfy\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      "line": 234,
      "type": "TODO",
      "content": "; TODO: let's try cog-get-partner instead",
      "context": "; Approach to pull the training rule from the atomspace dynamically rather than\n; relying on the scheme var.\n; maybe the DefinedType atom is being replaced in the cog-satisfy\n; TODO: let's try cog-get-partner instead\n; Check if an atom is the training rule\n(define (training-rule? atom)\n    (cog-satisfy\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 19,
      "type": "TODO",
      "content": "; TODO:",
      "context": "; Pause the main loop:\n;    (halt)\n;\n; TODO:\n; -----\n; The current OpenPsi framework allows much more general and flexible\n; rules than what are presented below; this geneality should be made\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 147,
      "type": "FIXME",
      "content": ";; XXX Needs to be replaced by OpenPsi emotional state modelling.",
      "context": "\n\n;; Interact with the current face target.\n;; XXX Needs to be replaced by OpenPsi emotional state modelling.\n(DefineLink\n\t(DefinedPredicate \"Interact with face\")\n\t(SequentialAnd\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 179,
      "type": "FIXME",
      "content": "; XXX FIXME this should be a part of \"Show random expression\"",
      "context": "\t(SequentialAnd\n\t\t(DefinedPredicate \"was room empty?\")\n\t\t; Record a new emotional state (for self-awareness)\n\t\t; XXX FIXME this should be a part of \"Show random expression\"\n\t\t; below ...\n\t\t(Put (DefinedPredicate \"Request Set Face Expression\")\n\t\t\t(ListLink bhv-source (Concept \"new-arrival\")))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 228,
      "type": "FIXME",
      "content": "(RandomChoice (Put; FIXME Replace by multiple face tracking.",
      "context": "\t(SequentialAnd\n\t\t(True (Put ; Setting interaction target for \"look at person\"\n\t\t\t(DefinedPredicate \"Set interaction target\")\n\t\t\t(RandomChoice (Put; FIXME Replace by multiple face tracking.\n\t\t\t\t(DefinedSchemaNode \"Get recognized face's face id\")\n\t\t\t\t(DefinedSchema \"Get recognized faces\")))))\n\t\t(DefinedPredicate \"look at person\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 232,
      "type": "TODO",
      "content": ";TODO: Separate out room-state into separate demands that occur before",
      "context": "\t\t\t\t(DefinedSchemaNode \"Get recognized face's face id\")\n\t\t\t\t(DefinedSchema \"Get recognized faces\")))))\n\t\t(DefinedPredicate \"look at person\")\n\t\t;TODO: Separate out room-state into separate demands that occur before\n\t\t; or after other demands are handled. How should order of execution\n\t\t; be represented?\n\t\t(DefinedPredicate \"Update status\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 242,
      "type": "FIXME",
      "content": ";; XXX TODO -- if interacting for a while",
      "context": "\n;; Respond to a new face becoming visible.\n;\n;; XXX TODO -- if interacting for a while\n;; this alters probability of glance...\n(DefineLink\n\t(DefinedPredicate \"Respond to new arrival\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 378,
      "type": "FIXME",
      "content": "; XXX incomplete!  need the face study saccade stuff...",
      "context": "\t\t\t\t(SequentialOr\n\t\t\t\t\t(SequentialAnd\n\t\t\t\t\t\t(DefinedPredicateNode \"dice-roll: face study\")\n; XXX incomplete!  need the face study saccade stuff...\n; I am confused ... has this been superceeded by the ROS-saccades,\n; or is this still means to be used?\n\t\t\t\t\t\t(False)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 428,
      "type": "FIXME",
      "content": ";; XXX question: This is turning the whole head; perhaps we",
      "context": "\n\t\t;; Search for attention -- change gaze every so often.\n\t\t;; Coordinate system: x forward; y side-to-side, z up.\n\t\t;; XXX question: This is turning the whole head; perhaps we\n\t\t;; should be moving eyes only?\n\t\t(SequentialOr\n\t\t\t(Not (DefinedPredicate \"Time to change gaze\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 719,
      "type": "FIXME",
      "content": ";; XXX FIXME -- this should not be hard-coded here!",
      "context": "\t))\n\n;; Actions for loud sound\n;; XXX FIXME -- this should not be hard-coded here!\n(DefineLink\n\t(DefinedPredicate \"Say whoa!\")\n\t\t(Put (DefinedPredicate \"Say\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      "line": 763,
      "type": "FIXME",
      "content": "; XXX FIXME ... this means that this rule is c alled too often!",
      "context": "\t(DefinedPredicate \"Salient:Curious\")\n\t(SequentialAnd\n\t\t; Disable printing, because it prints at 100x/second.\n\t\t; XXX FIXME ... this means that this rule is c alled too often!\n\t\t; Tracking should be autonomous, not piped through the behaviors.\n\t\t; (True (Evaluation (GroundedPredicate \"scm: print-msg\")\n\t\t;\t(ListLink (Node \"--- Saliency Tracking\"))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/cfg-eva.scm",
      "line": 244,
      "type": "FIXME",
      "content": ";; XXX Right now, search for attention turns the whole head;",
      "context": "(State (Schema \"time_search_glance_max\") (Number 2.0))\n\n;; During search-for-attention, how far to look to left or right.\n;; XXX Right now, search for attention turns the whole head;\n;; perhaps only the eyes should move?\n(DefineLink (DefinedSchema \"gaze left max\") (Number 0.35))\n(DefineLink (DefinedSchema \"gaze right max\") (Number -0.4))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/cfg-sophia.scm",
      "line": 365,
      "type": "FIXME",
      "content": ";; XXX Right now, search for attention turns the whole head;",
      "context": "(State (Schema \"time_search_glance_min\") (Number 0.5))\n(State (Schema \"time_search_glance_max\") (Number 2.0))\n;; During search-for-attention, how far to look to left or right.\n;; XXX Right now, search for attention turns the whole head;\n;; perhaps only the eyes should move?\n(DefineLink (DefinedSchema \"gaze left max\") (Number 0.35))\n(DefineLink (DefinedSchema \"gaze right max\") (Number -0.4))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 6,
      "type": "TODO",
      "content": "; TODO: Make the set, get, & delete of properites into a utility template",
      "context": "(use-modules (opencog eva-model) (opencog eva-behavior))\n\n; -----------------------------------------------------------------------------\n; TODO: Make the set, get, & delete of properites into a utility template\n; similar ot change-template and timestamp-template, as similar patterns\n; will be used for modeling the world. It should also make moving to\n; protoatoms[now renamed values] simplier when they are ready.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 74,
      "type": "FIXME",
      "content": "; FIXME: There should never be an empty set. The value should be set",
      "context": "                            (DefinedSchema \"Get face priority\")\n                            (Number face-id))))\n    (if (equal? (Set) result)\n        ; FIXME: There should never be an empty set. The value should be set\n        ; during acknowledgment.\n        (begin\n            (set-priority! face-id ordinary-face-priority)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 124,
      "type": "TODO",
      "content": "; TODO: Move to config file",
      "context": "; Parameters are not published by cmt_tracker and have to be pre-set, so see\n; /HEAD/src/vision/cmt_tracker/src/cmt_tracker_node.cpp#L486\n; /HEAD/src/vision/pi_vision/pi_face_tracker/nodes/face_tracker.py#L271\n; TODO: Move to config file\n(define fov 1.42)\n(define camera-width 640)\n(define camera-height 480)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 131,
      "type": "FIXME",
      "content": "; FIXME But why have this plane instead of calculating the distance between",
      "context": "\n; `distance` is distance from the camera. The assumption is that at the given\n; distance from the camera is the plane where all the faces are at.\n; FIXME But why have this plane instead of calculating the distance between\n; faces, will it affect the priority?\n(define distance 1.0)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 192,
      "type": "FIXME",
      "content": ";; XXX refactor all of this -- this si supposed to be a service provided",
      "context": ")\n\n;;\n;; XXX refactor all of this -- this si supposed to be a service provided\n;; byt the spoace-time server, instead of being in scheme spaghetti\n;; code.\n(define (distance-in-plane-yz face-id-1 face-id-2)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
      "line": 224,
      "type": "FIXME",
      "content": "; FIXME: Sometimes d is larger than the width-of-yz-plane",
      "context": "        ; This check is for (inf). If d is not (inf) and is greater than\n        ; the width-of-yz-plane, then something fishy is going on.\n        (if (> d  width-of-yz-plane)\n            ; FIXME: Sometimes d is larger than the width-of-yz-plane\n            ; and returning 0 is causing a problem in 'choose-next-face'\n            ; Recalculate the width-of-yz-plane?\n            0.0001\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/movement-api.scm",
      "line": 27,
      "type": "FIXME",
      "content": "; XXX FIXME -- someday, should probably create a distinct API for",
      "context": "   (stv 1 1))\n\n; Must print to stdout, so that IRC chatbots can see what happened.\n; XXX FIXME -- someday, should probably create a distinct API for\n; the IRC text strings.\n(define-public (prt-face-expr PRED NAME TIME TENS)\n\t(format #t \"Robot displays facial expression \\\"~a\\\" at strength ~a for ~a seconds\\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/movement-api.scm",
      "line": 73,
      "type": "FIXME",
      "content": "; XXX FIXME: these record the animation that was chosen, and a",
      "context": "\t\t\t(ListLink PRED))))\n\n;\n; XXX FIXME: these record the animation that was chosen, and a\n; timestamp in some StateLinks. These need to be replaced by the\n; TimeServer, instead.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
      "line": 48,
      "type": "FIXME",
      "content": "; XXX FIXME: this records the animation that was chosen, and a",
      "context": "; If we wanted to rate-limit this, then make a copy of \"change-template\"\n; and edit it to provide a minimum elapsed time predicate.\n;\n; XXX FIXME: this records the animation that was chosen, and a\n; timestamp in some StateLinks. These need to be replaced by the\n; TimeServer, instead.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
      "line": 137,
      "type": "FIXME",
      "content": "; XXX FIXME, this is still broken during search for attention.",
      "context": "; As above, but (momentarily) break eye contact, first.\n; Otherwise, the behavior tree forces eye contact to be continually\n; running, and the turn-look command is promptly over-ridden.\n; XXX FIXME, this is still broken during search for attention.\n\n(DefineLink\n\t(DefinedPredicate \"Look command\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
      "line": 222,
      "type": "FIXME",
      "content": "; XXX Currently, this does nothing at all. Some future version may",
      "context": "; Currently, this always honors all requests.\n; Currently, the requestor is ignored.\n;\n; XXX Currently, this does nothing at all. Some future version may\n; deny change requests, depending on the request source or on other\n; factors.  XXX This is incompletely thought out and maybe should be\n; removed.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
      "line": 20,
      "type": "TODO",
      "content": "; TODO: make generic for orchestration.",
      "context": "(define speech-demand-satisfied (True))\n\n; Demand for tracking faces\n; TODO: make generic for orchestration.\n(define track-demand (psi-demand \"track demand\"))\n(define track-demand-satisfied (True))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
      "line": 68,
      "type": "TODO",
      "content": "; TODO Remove after thoroughly testing behavior on robot.",
      "context": "\tface-demand-satisfied (stv 1 1) face-demand)\n\n; This rule is the old multiple-face tracking rule\n; TODO Remove after thoroughly testing behavior on robot.\n(psi-rule (list (SequentialAnd\n\t\t(NotLink (DefinedPredicate \"Skip Interaction?\"))\n\t\t(DefinedPredicate \"Someone visible?\")))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
      "line": 75,
      "type": "TODO",
      "content": "; TODO: How should rules that could run concurrently be represented, when",
      "context": "\t(DefinedPredicate \"Interact with people\")\n\tface-demand-satisfied (stv 1 1) face-demand)\n\n; TODO: How should rules that could run concurrently be represented, when\n; we have action compostion(aka Planning/Orchestration)?\n(psi-rule (list (DefinedPredicate \"Someone visible?\"))\n\t(DefinedPredicate \"Interact with face\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
      "line": 82,
      "type": "TODO",
      "content": "; TODO: test the behabior when talking.",
      "context": "\ttrack-demand-satisfied (stv .5 .5) track-demand)\n\n(psi-rule (list (SequentialAnd\n\t\t; TODO: test the behabior when talking.\n\t\t; (Not (DefinedPredicate \"chatbot is talking?\"))\n\t\t(DefinedPredicate \"Someone visible?\")\n\t\t(DefinedPredicate \"Time to change interaction\")))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
      "line": 12,
      "type": "FIXME",
      "content": ";; XXX FIXME this is a cut-n-paste job from process-query",
      "context": "\n;--------------------------------------------------------------------\n\n;; XXX FIXME this is a cut-n-paste job from process-query\n\n(define-public (grounded-talk USER QUERY)\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
      "line": 28,
      "type": "FIXME",
      "content": ";; XXX FIXME -- remove the IRC debug response below.",
      "context": "    ; nlp-parse returns (SentenceNode \"sentence@45c470a6-29...\")\n    (define sent-node (car (nlp-parse QUERY)))\n\n    ;; XXX FIXME -- remove the IRC debug response below.\n    (display \"Hello \")\n    (display USER)\n    (display \", you said: \\\"\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
      "line": 40,
      "type": "FIXME",
      "content": "; XXX Currently, this dispatch is done via scheme code below. The",
      "context": "    ; of the utterance.  The response processing will be based on the\n    ; type of the speech act.\n    ;\n    ; XXX Currently, this dispatch is done via scheme code below. The\n    ; correct design would use an ImplicationLink to match up the\n    ; speech-act type to the processing that would be performed.  This\n    ; would allow a single sentence to be interpreted as possibly several\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-alt.scm",
      "line": 64,
      "type": "FIXME",
      "content": "; XXX fixme -- we should not need to load either relex2logic or",
      "context": "\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n; the rules right here, since the code in this module does not depend\n; directly on thes.\n(use-modules (opencog nlp relex2logic))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-alt.scm",
      "line": 121,
      "type": "FIXME",
      "content": "; XXX These are not being used right now; these are meant to be",
      "context": ";--------------------------------------------------------------------\n;\n; These are English-language sentences that I (Eva) understand.\n; XXX These are not being used right now; these are meant to be\n; fuzzy-matched, in a newer/different design,.... which is\n; maybe abandoned right now???\n(define known-directives\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-rules.scm",
      "line": 45,
      "type": "FIXME",
      "content": "; XXX needs to be public, so that cog-execute! can find this...",
      "context": "; ---------\n(define (print-msg node) (display (cog-name node)) (newline) (stv 1 1))\n\n; XXX needs to be public, so that cog-execute! can find this...\n(define-public (show-arg node) (display node) node)\n\n; ---------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-rules.scm",
      "line": 224,
      "type": "FIXME",
      "content": "; XXX TODO Design notes:",
      "context": "\t\t)\n\t))\n\n; XXX TODO Design notes:\n; Rather than hand-crafting a bunch of rules like the above, we should\n; do three things:\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative.scm",
      "line": 142,
      "type": "FIXME",
      "content": "; XXX FIXME we need a better way of marking actions as having",
      "context": "\t\t; At this time, a ListLink is used to anchor suggested\n\t\t; actions to the current-action anchor. Wipe these out.\n\t\t; (because we have already performed the actions).\n\t\t; XXX FIXME we need a better way of marking actions as having\n\t\t; been performed, already.\n\t\t(for-each (lambda (x)\n\t\t\t(cog-extract-recursive! (ListLink current-action x)))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative.scm",
      "line": 148,
      "type": "FIXME",
      "content": "; XXX replace the dont-know reply by ChatScript or something.",
      "context": "\t\t\t(cog-extract-recursive! (ListLink current-action x)))\n\t\t\t\taction-list)\n\n\t\t; XXX replace the dont-know reply by ChatScript or something.\n\t\t(if (null? action-list)\n\t\t\t(begin\n\t\t\t\t(State (Anchor \"Chatbot: ChatbotEvaAction\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 73,
      "type": "FIXME",
      "content": "; XXX This is incorrect, just right now; its too simple, and interacts",
      "context": "; of the system is behind the eyes, middle of head.  \"forward\" is the\n; object the chest is facing.\n;\n; XXX This is incorrect, just right now; its too simple, and interacts\n; badly with the face tracker.  The directions need to be general\n; 2D areas.  For imperative commands, we need to pick some random point\n; out of the 2D area. To answer questions, we need to compare the 2D\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 180,
      "type": "FIXME",
      "content": "; XXX Remove this -- It should go into the self-model file.",
      "context": "; in various irritating ways, so we duplicate the above using\n; ConceptNode, instead.\n;\n; XXX Remove this -- It should go into the self-model file.\n\n; Knowledge about spatial directions. Pair up words and physical\n; directions.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 258,
      "type": "FIXME",
      "content": "; XXX FIXME -- Implement-me, actually -- need to do the above, but for",
      "context": "\t\t(ConceptNode \"look-at-cmd\")\n\t\t(ConceptNode \"schema-thing\")))\n\n; XXX FIXME -- Implement-me, actually -- need to do the above, but for\n; the self-model, rather than the direct robot action.  The self-model\n; is not being updated by these imperatives.\n;--------------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 358,
      "type": "FIXME",
      "content": "; XXX a bunch of verb synonyms -- handled manually. These should be",
      "context": "; Grounding of words for facial expressions by animations in the Eva\n; blender model: happy, sad, confused, etc. See below for full list.\n\n; XXX a bunch of verb synonyms -- handled manually. These should be\n; automated via synonymous phrase support. Total hack, needs fixing.\n; Each verb here must also be handled by a corresponding rule in the\n; `imperative-rules.scm` file.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 399,
      "type": "FIXME",
      "content": "; XXX FIXME ... the list below is duplicated twice, once as adjectives",
      "context": "(ReferenceLink (WordNode \"recoil\") (DefinedSchema \"recoil\"))\n(ReferenceLink (WordNode \"worry\")  (DefinedSchema \"worry\"))\n\n; XXX FIXME ... the list below is duplicated twice, once as adjectives\n; and once as nouns.  This is partly because relex normalization is\n; not being correctly used, and/or R2L in its current form is not\n; quite usable for this (it's too fragile, among other things).\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 404,
      "type": "FIXME",
      "content": "; XXX FIXME -- this list contains lots of synonyms; needs to be replaced",
      "context": "; not being correctly used, and/or R2L in its current form is not\n; quite usable for this (it's too fragile, among other things).\n;\n; XXX FIXME -- this list contains lots of synonyms; needs to be replaced\n; by proper synonym support.\n;\n; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 407,
      "type": "FIXME",
      "content": "; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"",
      "context": "; XXX FIXME -- this list contains lots of synonyms; needs to be replaced\n; by proper synonym support.\n;\n; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"\n; could map to either \"worry\" or to \"sad\" expressions.  So, need to deal\n; with that. Also: emotions are graded: some call for much milder\n; expressions than others -- right now, the expressions pick a random\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      "line": 591,
      "type": "FIXME",
      "content": "; XXX Remove this -- this si supposed to ba a part of the action",
      "context": "; Duplicate of the above, except that this is for use in controlling\n; the self-model, rather than the physical motors.\n;\n; XXX Remove this -- this si supposed to ba a part of the action\n; orchestrateor, i.e. the self model is about what the orchestrator\n; actually did, not what it was told to do.\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
      "line": 51,
      "type": "FIXME",
      "content": "; XXX FIXME This is wrong; this has been replaced by the eva-model",
      "context": "\t\t\t(dependency \"_subj\" \"$verb-inst\" \"$subj-inst\")\n\t\t\t(LemmaLink (VariableNode \"$subj-inst\") (WordNode \"you\"))\n\n; XXX FIXME This is wrong; this has been replaced by the eva-model\n; code Unfortunately, it does not offer any easy way of querying.\n\t\t\t; (State (Anchor \"*-gaze-direction-*\") (Variable \"$direction\"))\n\t\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
      "line": 95,
      "type": "FIXME",
      "content": "; XXX hack",
      "context": "(define (prt-curr-sent) (cog-execute! prt-sent))\n\n;--------------------------------------------------------------------\n; XXX hack\n(define face-expression-state (AnchorNode \"Facial Expression State\"))\n\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
      "line": 156,
      "type": "FIXME",
      "content": "; XXX this should be moved to cog-utils. Also needs to be fixed",
      "context": "\n;--------------------------------------------------------------------\n;\n; XXX this should be moved to cog-utils. Also needs to be fixed\n; to not detect bound variables. We already have C++ code that\n; does  the right thing, here, so we should use that.\n(define (cog-grounded? EXPR)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
      "line": 178,
      "type": "FIXME",
      "content": "; XXX This is broken.",
      "context": ")\n\n;--------------------------------------------------------------------\n; XXX This is broken.\n;\n; This is where I wish I had lexical functions rather than just sureal.\n; The problem here is that sureal, all by itself, is unable to convert\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
      "line": 19,
      "type": "FIXME",
      "content": "; XXX remove the below when we get a chance.",
      "context": "\n(start-cogserver \"../../lib/opencog-chatbot.conf\")\n\n; XXX remove the below when we get a chance.\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
      "line": 22,
      "type": "FIXME",
      "content": "; XXX fixme -- we should not need to load either relex2logic or",
      "context": "; XXX remove the below when we get a chance.\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n; the rules right here, since the code in this module does not depend\n; directly on these.\n(use-modules (opencog nlp relex2logic))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
      "line": 29,
      "type": "FIXME",
      "content": "; XXX temp hack to run in module context, for debugging",
      "context": "; (load-r2l-rulebase)\n;\n\n; XXX temp hack to run in module context, for debugging\n; (add-to-load-path \".\")\n; (add-to-load-path \"..\")\n; (load \"chatbot-eva.scm\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/faces.scm",
      "line": 5,
      "type": "FIXME",
      "content": "; XXX most of face-tracking is now in self-model.scm",
      "context": "; faces.scm\n;\n; Assorted utilities for supporting face tracking\n; XXX most of face-tracking is now in self-model.scm\n; Perhaps this file is not needed any more? XXX FIXME\n;\n(use-modules (opencog))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/faces.scm",
      "line": 11,
      "type": "FIXME",
      "content": ";; XXX FIXME: This file defines a \"Room State\", which currently can",
      "context": "(use-modules (opencog))\n(use-modules (opencog exec))\n\n;; XXX FIXME: This file defines a \"Room State\", which currently can\n;; be \"empty\" or \"non-empty\", depending on whether faces are visible\n;; or not.  But this is kind-of pointless: its probably easier to just\n;; check if the number of visible faces is greater than zero, or not.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 43,
      "type": "FIXME",
      "content": "; XXX FIXME There are a bunch of define-publics in here, they probably",
      "context": "\n; ------------------------------------------------------\n; State variables\n; XXX FIXME There are a bunch of define-publics in here, they probably\n; should not be; they're needed only by the behavior module.\n\n; Face tracking state indicates if we respond to face tracking events.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 95,
      "type": "FIXME",
      "content": "; XXX FIXME -- this should return neutral, if the timestamp is more",
      "context": "(StateLink face-expression-state expression-neutral)\n\n; Get the current facial expression.\n; XXX FIXME -- this should return neutral, if the timestamp is more\n; than 8 seconds in the past. Well, actually, it should probably\n; reset the face expression state after 8 seconds or so --\n; or maybe use the timeserver....\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 143,
      "type": "TODO",
      "content": ";; TODO Remove this when the time-server is ready.",
      "context": "(StateLink interaction-state no-interaction)\n\n;; Record with whome she was previously intracting with.\n;; TODO Remove this when the time-server is ready.\n(define-public prev-interaction-state (AnchorNode \"Previous Interaction State\"))\n(StateLink prev-interaction-state no-interaction)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 173,
      "type": "FIXME",
      "content": "; XXX quick hack",
      "context": "\t(DefinedSchema \"current-speaker\")\n   (Get (State last-speaker (Variable \"$x\"))))\n\n; XXX quick hack\n(DefineLink\n\t(DefinedSchema \"other-speaker\")\n   (Get (State last-speaker (Variable \"$x\"))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 254,
      "type": "FIXME",
      "content": "; XXX FIXME: Note also: we currently fail to distinguish the affect",
      "context": "; Chat affect. Is the robot happy about what its saying?\n; Right now, there are only two affects: happy and not happy.\n; NB the python ROS sensor code uses these defines!\n; XXX FIXME: Note also: we currently fail to distinguish the affect\n; that was perceived, from our own state. There is a ROS message that\n; informs us about what the perceived affect was: it sets this state.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 374,
      "type": "FIXME",
      "content": ";; XXX FIXME -- the psi subsystem should be performing this action,",
      "context": ";; If there are no visible faces, and something \"salient\" is seen, with\n;; a degree greater than 13, then it's considered as salient. The robot\n;; should then look at the salient position and show curious expression.\n;; XXX FIXME -- the psi subsystem should be performing this action,\n;; instead of hard-coding it here.\n\n;; Coordinates for the salient location\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
      "line": 931,
      "type": "FIXME",
      "content": "; XXX Double-check that the \"New arrivals\" list is non-empty;",
      "context": ";; (DefinedSchema \"look at person\") to make it look.\n(DefineLink\n\t(DefinedPredicate \"interact with new person\")\n\t; XXX Double-check that the \"New arrivals\" list is non-empty;\n\t; some OpenPsi bug sometimes sends us here, and the RandomChoice\n\t; crashes if the list is empty.\n\t(SequentialAnd\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
      "line": 9,
      "type": "FIXME",
      "content": "; XXX FIXME -- some of the below should be handled as psi-rules,",
      "context": "; direction the sound is coming from, as compared to the position\n; of the face.\n;\n; XXX FIXME -- some of the below should be handled as psi-rules,\n; instead of being hard-coded, here.  That is, we are interested\n; in the locations of sound events in general, not just for determing\n; who is speaking.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
      "line": 38,
      "type": "FIXME",
      "content": "; XXX FIXME Is it wise to start this, just because the guile module got",
      "context": "\n; Run the map in a new thread. This will automatically create a new\n; time-slice every 66 milliseconds.\n; XXX FIXME Is it wise to start this, just because the guile module got\n; loaded? or should we have a distinct \"start running it now\" function?\n(cog-pointmem-auto-step-time-on facemap)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
      "line": 161,
      "type": "FIXME",
      "content": ";; XXX FIXME -- this kind of crazy angle computation should be",
      "context": ";assuming sound was saved with co-oridinate transform applied for camera\n;angle in radians\n;\n;; XXX FIXME -- this kind of crazy angle computation should be\n;; happenening in the space-time server, and not here.\n;;\n(define (angle_face_id_snd FACE-ID xx yy zz)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
      "line": 196,
      "type": "FIXME",
      "content": ";; XXX FIXME -- this kind of tulity needs to be in the space-time",
      "context": ";; A face is near if the sound direction is within 15 degrees of\n;; the face.  Returns the atom for the face, or the emtpy list.\n;;\n;; XXX FIXME -- this kind of tulity needs to be in the space-time\n;; server, and not here.\n(define (face-nearest-sound xx yy zz)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
      "line": 237,
      "type": "FIXME",
      "content": ";; XXX TODO -- this should eventually be a psi-rule, so that we can",
      "context": "\n;; This needs to be define-public, so that ros-bridge can send this\n;; to the cogserver.\n;; XXX TODO -- this should eventually be a psi-rule, so that we can\n;; associate spoken sounds with speakers, but also know the locations\n;; of loud sounds.  That is, the time-server needs to get sound\n;; direction, no matter what.\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/btree.scm",
      "line": 4,
      "type": "FIXME",
      "content": "; XXX FIXME ... I think this blob of code is obsolete ... I think",
      "context": ";\n; btree.scm\n;\n; XXX FIXME ... I think this blob of code is obsolete ... I think\n; that the current interfaces are in `btree-psi.scm`.  So remove this\n; file once we are clear on this.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/btree.scm",
      "line": 88,
      "type": "FIXME",
      "content": "; XXX Need to ... auuh load the chatbot...",
      "context": "\t\t; since the text processing results in python calls.\n\t\t; (lambda () (process-query \"luser\" (cog-name TXT-ATOM)))\n\t\t; (lambda () (grounded-talk \"luser\" (cog-name TXT-ATOM)))\n\t\t; XXX Need to ... auuh load the chatbot...\n;\t\t(lambda () (chat TXT-ATOM))\n;\t)\n\t(stv 1 1)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/old-tree.scm",
      "line": 50,
      "type": "FIXME",
      "content": ";; XXX FIXME chatbot is disengaged from everything else.",
      "context": "\t\t\t\t(DefinedPredicate \"Nothing is happening\")\n\t\t\t\t(True))\n\n\t\t\t;; XXX FIXME chatbot is disengaged from everything else.\n\t\t\t;; The room can be empty, the head is bored or even asleep,\n\t\t\t;; but the chatbot is still smiling and yabbering.\n\t\t\t;; If interaction is turned-off need keep alive gestures\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
      "line": 68,
      "type": "FIXME",
      "content": "; XXX FIXME -- this is hacky -- and has multiple design flaws.",
      "context": "; ------------------------------------------------------------------\n; Functions to initiate random positive and negative expressions\n\n; XXX FIXME -- this is hacky -- and has multiple design flaws.\n; These are:\n;\n; * This should not use cog-evaluate! to force execution. Instead,\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
      "line": 188,
      "type": "TODO",
      "content": "; TODO Replace with openpsi-dynamics logger when it is available.",
      "context": "\t\t\t(begin\n\t\t\t\t(psi-set-event-occurrence! room-got-bright-event)\n\t\t\t\t(set! room-was-bright #t)\n\t\t\t\t; TODO Replace with openpsi-dynamics logger when it is available.\n\t\t\t\t;(if verbose (display \"**** Room got bright *****\\n\"))\n\t\t\t)\n\t\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
      "line": 203,
      "type": "TODO",
      "content": "; TODO Replace with openpsi-dynamics logger when it is available.",
      "context": "\t\t\t(begin\n\t\t\t\t(psi-set-event-occurrence! room-got-dark-event)\n\t\t\t\t(set! room-was-dark #t)\n\t\t\t\t; TODO Replace with openpsi-dynamics logger when it is available.\n\t\t\t\t;(if verbose (display \"**** Room got dark *****\\n\"))\n\t\t\t)\n\t\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
      "line": 75,
      "type": "FIXME",
      "content": "; FIXME: This is not really newline.",
      "context": "    ; The token value for 'CR is empty-string so as to handle multiline\n    ; rules.\n    ((has-match? \"\\r\" str) (result:suffix 'CR location \"\"))\n    ; FIXME: This is not really newline.\n    ((string=? \"\" str) (cons (make-lexical-token 'NEWLINE location #f) \"\"))\n    ((has-match? \"urge:\" str) (result:suffix 'URGE location #f))\n    ((has-match? \"ordered-goal:\" str) (result:suffix 'ORD-GOAL location #f))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
      "line": 90,
      "type": "TODO",
      "content": "; TODO Add tester function for this",
      "context": "    ((has-match? \"global-default-rule:\" str)\n      (result:suffix 'GLOBAL-DEFAULT-RULE location #f))\n    ((has-match? \"#!\" str) ; This should be checked always before #\n      ; TODO Add tester function for this\n      (cons (make-lexical-token 'SAMPLE_INPUT location #f) \"\"))\n    ((has-match? \"*#\" str)\n      (cons (make-lexical-token 'COMMENT location #f) \"\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
      "line": 139,
      "type": "TODO",
      "content": "; TODO Maybe replace with dictionary keyword sets then process it on action?",
      "context": "    ((has-match? \"[a-zA-Z]+~[a-zA-Z1-9]+\" str)\n      (result:suffix 'DICTKEY location (command-pair)))\n    ; Range-restricted Wildcards.\n    ; TODO Maybe replace with dictionary keyword sets then process it on action?\n    ((has-match? \"\\\\*~[0-9]+\" str)\n      (result:suffix '*~n location\n        (substring (string-trim-both (match:substring current-match)) 2)))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
      "line": 298,
      "type": "TODO",
      "content": "(SAMPLE_INPUT) : #f ; TODO replace with a tester function",
      "context": "      (rejoinder) : $1\n      (enter) : $1\n      (COMMENT) : #f\n      (SAMPLE_INPUT) : #f ; TODO replace with a tester function\n    )\n\n    (enter\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
      "line": 710,
      "type": "TODO",
      "content": "; TODO: This has a restart_matching effect. See chatscript documentation",
      "context": "      (phrase) : $1\n    )\n\n    ; TODO: This has a restart_matching effect. See chatscript documentation\n    (unordered-matching\n      (<< unordered-terms >>) :\n        (format #f \"(cons 'unordered-matching (list ~a))\" $2)\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/matcher.scm",
      "line": 176,
      "type": "TODO",
      "content": "; TODO: Return the actual action instead of a rule",
      "context": "\n  ; If there is only one action in the list, return that\n  ; Otherwise, pick one based on their weights\n  ; TODO: Return the actual action instead of a rule\n  (if (= (length rules-satisfied) 1)\n    (car rules-satisfied)\n    ; Here there are special handling for rejoinders:\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/stimulation.scm",
      "line": 32,
      "type": "TODO",
      "content": "; TODO: Find some better representation for that",
      "context": "; 'ghost-word-seq' is shared among the rules with word-related pattern\n; This is mainly to make sure the rules with only a wildcard in the pattern\n; will also get some non-zero STI.\n; TODO: Find some better representation for that\n(add-hook! (perceive-word-hook)\n  (lambda () (cog-stimulate (ghost-word-seq-pred) (/ default-stimulus 2))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/terms.scm",
      "line": 238,
      "type": "TODO",
      "content": "; TODO: Should be handled in OpenCog internally?",
      "context": "  of it before sending the whole thing out.\n  The TTS server will handle the rest afterwards.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"|\" (string-join (map cog-name (flatten-list ARGS)) \",\") \"|\")))\n\n; ----------\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/terms.scm",
      "line": 255,
      "type": "TODO",
      "content": "; TODO: Should be handled in OpenCog internally?",
      "context": "  Support things like {% set delay=2 %} in the action of a rule, which\n  set how long STT should wait before sending the input to GHOST.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"{% set delay=\" (cog-name SECOND) \" %}\"))\n)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/terms.scm",
      "line": 291,
      "type": "TODO",
      "content": "; TODO: Check to make sure the function has been defined",
      "context": "  The Scheme or Python function named NAME should have already been defined.\n  The Python name has 'py_' prefix and Scheme name has 'scm_' or no prefix.\n\"\n  ; TODO: Check to make sure the function has been defined\n  (Evaluation (GroundedPredicate (parse-method-name NAME))\n              (List (map (lambda (a) (if (equal? 'GlobNode (cog-type a))\n                                         (List a) a))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/terms.scm",
      "line": 304,
      "type": "TODO",
      "content": "; TODO: Check to make sure the function has been defined",
      "context": "  The Scheme or Python function named NAME should have already been defined.\n  The Python name has 'py_' prefix and Scheme name has 'scm_' or no prefix.\n\"\n  ; TODO: Check to make sure the function has been defined\n  (ExecutionOutput (GroundedSchema (parse-method-name NAME))\n                   (List (map (lambda (a) (if (equal? 'GlobNode (cog-type a))\n                                              (List a) a))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/test.scm",
      "line": 18,
      "type": "TODO",
      "content": "; TODO: Remove once experimentation is over",
      "context": "  (cog-logger-set-level! ghost-logger \"info\"))\n\n; ----------\n; TODO: Remove once experimentation is over\n(define expt-var '())\n(define-public (test-ghost TXT)\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/translator.scm",
      "line": 189,
      "type": "TODO",
      "content": "; TODO: The specificity of ordered vs unordered should be",
      "context": "    (for-each (lambda (t)\n      (cond ((equal? 'unordered-matching (car t))\n             (update-lists (process (cdr t)))\n             ; TODO: The specificity of ordered vs unordered should be\n             ; considered as well\n             (set! is-unordered? #t))\n            ((equal? 'word (car t))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/translator.scm",
      "line": 547,
      "type": "TODO",
      "content": "; TODO: Handle variables as well",
      "context": "  ; from the rule being reused and append it to\n  ; rule that uses the reuse function, as well as\n  ; the additional ones that are in the same TrueLink\n  ; TODO: Handle variables as well\n  (define (get-reused-action atomese)\n    (append-map\n      (lambda (x)\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/translator.scm",
      "line": 856,
      "type": "TODO",
      "content": "; TODO: Remove the geometric series as it is no longer needed?",
      "context": "        ; PsiImplicator, so psi-action-executed? will return\n        ; false for the reused rule even if its action has been\n        ; executed already, which is not the behavior we want here\n        ; TODO: Remove the geometric series as it is no longer needed?\n        (if (> (length rule-hierarchy) 0)\n          (let ((var (Variable (gen-var \"GHOST-executed-rule\" #f))))\n            (set! vars (append vars (list\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
      "line": 40,
      "type": "TODO",
      "content": "; TODO: Replace by microplanner.",
      "context": ";;       (Concept \"people\")\n;;       (Concept P-name)))))\n(define (implication-to-evaluation-s2l P Q)\n; TODO: Replace by microplanner.\n    (let ((P-name (cog-name P)))\n       (Set\n          (Evaluation\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
      "line": 62,
      "type": "TODO",
      "content": "; TODO:  Remove this check once other inference-trails are",
      "context": "    (define semantics (select-highest-tv-semantics semantics-list))\n\n    (define logic\n        ; TODO:  Remove this check once other inference-trails are\n        ; handled by different response handlers.\n        (if (equal? 'ImplicationLink (cog-type semantics))\n            (implication-to-evaluation-s2l\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
      "line": 69,
      "type": "TODO",
      "content": "; TODO: Remove the check  once other inference-trails are handled",
      "context": "                (gar semantics) (gdr semantics))\n            '()))\n\n    ; TODO: Remove the check  once other inference-trails are handled\n    ; diffferently.\n    (define sureal-result (if (nil? logic) '() (sureal logic)))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
      "line": 140,
      "type": "FIXME",
      "content": "; FIXME Why doesn't the first call of (update-inferences) work?",
      "context": "    (cog-logger-info \"[PLN-Action] Started (do-pln-qa)\")\n\n    (State pln-qa process-started)\n    ; FIXME Why doesn't the first call of (update-inferences) work?\n    (update-inferences rb-trail-1 3 time)\n    (update-inferences rb-trail-1 3 time)\n    (let ((inferences (get-inferred-atoms rb-trail-1)))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
      "line": 78,
      "type": "TODO",
      "content": "; TODO: Move this to an (opencog pln) module, when there is one.",
      "context": "   a-list:\n  - This is a list of atoms, for example a list of r2l outputs\n\"\n; TODO: Move this to an (opencog pln) module, when there is one.\n    (define filter-in-pattern\n        (ScopeLink\n            (TypedVariable\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
      "line": 191,
      "type": "TODO",
      "content": "; TODO: Add measure to choose between candidates based on query or some",
      "context": "      '()\n      (cog-outgoing-set (filter-for-sureal pln-outputs))))\n\n  ; TODO: Add measure to choose between candidates based on query or some\n  ; other method.\n  (if (nil? candidates)\n    \"\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
      "line": 195,
      "type": "FIXME",
      "content": "; FIXME: This only works for trail-3",
      "context": "  ; other method.\n  (if (nil? candidates)\n    \"\"\n    ; FIXME: This only works for trail-3\n    (let ((sureal-results (get-sureal-results candidates)))\n      (if (nil? sureal-results)\n        \"\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-1.scm",
      "line": 7,
      "type": "FIXME",
      "content": "; FIXME: Doesn't return anything when confidence is low, don't use for now",
      "context": "(use-modules (opencog nlp))\n(use-modules (opencog pln))\n(use-modules (opencog ure))\n; FIXME: Doesn't return anything when confidence is low, don't use for now\n;(load-from-path \"opencog/pln/rules/implication-direct-evaluation.scm\")\n\n;;;;;;;;;;;;;;;;;;;;;\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-1.scm",
      "line": 344,
      "type": "TODO",
      "content": "; TODO: use pln-load-rules when move to new PLN API, see",
      "context": "(define (configure-pln-rbs-1)\n    (define rb (ConceptNode \"r2l-pln-1\"))\n\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    (load-from-path (pln-rule-type->filename \"term/deduction\"))\n    (load-from-path (pln-rule-type->filename \"wip/abduction\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-2.scm",
      "line": 46,
      "type": "TODO",
      "content": "; TODO: Record the acutal inference trails that have been learned and apply",
      "context": "        (Variable \"$A-subset\")\n        (Variable \"$B\")))))\n\n; TODO: Record the acutal inference trails that have been learned and apply\n; them instead of trying to randomly try different permutations.\n(define (configure-pln-rbs-2)\n    (define rb (ConceptNode \"r2l-pln-2\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-2.scm",
      "line": 51,
      "type": "TODO",
      "content": "; TODO: use pln-load-rules when move to new PLN API, see",
      "context": "(define (configure-pln-rbs-2)\n    (define rb (ConceptNode \"r2l-pln-2\"))\n\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    (load-from-path (pln-rule-type->filename \"term/deduction\"))\n    (load-from-path (pln-rule-type->filename \"wip/abduction\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-3.scm",
      "line": 115,
      "type": "TODO",
      "content": "; TODO: use pln-load-rules when move to new PLN API, see",
      "context": "    ; The deduction rule doesn't work when the truth-value are extremely\n    ; low. (load-gtwc) wasn't helpful\n    ;\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    ;\n    ;(load-from-path (pln-rule-type->filename \"term/deduction\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/predicates.scm",
      "line": 249,
      "type": "TODO",
      "content": ";TODO: The assumption is that this is used by an ordered goal. Make it",
      "context": "  is not passed then it will check if any of the sources have an answer, and\n  cache a random source from the list.\n\"\n  ;TODO: The assumption is that this is used by an ordered goal. Make it\n  ; handle unordered goal.\n  (define src-list (get-sources))\n  (define sent\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/predicates.scm",
      "line": 311,
      "type": "TODO",
      "content": "; TODO: Replace the ConceptNode with a PredicateNode",
      "context": "; Create the GroundedPredicateNode, and link it to a generic \"timer-predicate\"\n; so that we can stimulate the generic one and the STI will diffuse to\n; the specific predicates connecting to it\n; TODO: Replace the ConceptNode with a PredicateNode\n(Implication (GroundedPredicate \"scm: is_after_min\") timer-predicate)\n(Implication (GroundedPredicate \"scm: emotion\") (Predicate \"emotion\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
      "line": 387,
      "type": "TODO",
      "content": ";TODO: How to represent word said by face-id without having an",
      "context": "\n  Returns (WordNode WORD) after increasing its sti.\n\"\n  ;TODO: How to represent word said by face-id without having an\n  ; explosion of atoms.\n  (define wn (Word word))\n  (define cn (Concept word))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
      "line": 468,
      "type": "TODO",
      "content": "; TODO Move the time related helpers to the time-server. Some of this",
      "context": "  )\n)\n\n; TODO Move the time related helpers to the time-server. Some of this\n; utilities should have been provided by it.\n(define (set-event-times! model old-value new-value time)\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
      "line": 1007,
      "type": "TODO",
      "content": "; TODO: move genric steps to the pln module",
      "context": "(load \"procedures/predicates.scm\")\n(load \"procedures/schemas.scm\")\n(load \"procedures/sq-bind.scm\")\n; TODO: move genric steps to the pln module\n;(load \"procedures/pln-reasoner.scm\")\n;(load \"procedures/pln-trail-3.scm\")\n;(load \"procedures/pln-utils.scm\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
      "line": 9,
      "type": "TODO",
      "content": "; TODO: List out the DefinedPredicates that are used as API, so as to",
      "context": "; NOTE: For testing use (opencog eva-behavior) module. For\n; running use (opencog movement) module. This is because the\n; APIs are atomese DefinedPredicates.\n; TODO: List out the DefinedPredicates that are used as API, so as to\n; use delete-definition. Also adapt the scheme function naming convention\n; to make remembering easier.\n; --------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
      "line": 322,
      "type": "TODO",
      "content": "; TODO: Replace by an actual sentence splitter",
      "context": "  (define query (source-query sent))\n  ; A very crude and limited way to get the first sentence\n  ; from the respond, but is OK in this context\n  ; TODO: Replace by an actual sentence splitter\n  (define (get-first-sentence str)\n    (define default-length 50)\n    (if (< (string-length str) default-length)\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
      "line": 405,
      "type": "TODO",
      "content": "; TODO: use query for filtering results, by using similarity measures b/n",
      "context": "(define pln-src (def-source \"pln\" \"ask-pln\"))\n\n(define* (ask-pln sent #:optional (steps 24))\n  ; TODO: use query for filtering results, by using similarity measures b/n\n  ; the query and the inferred outputs. There may be multiple layers of\n  ; filters.\n  (define query (source-query sent))\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
      "line": 409,
      "type": "TODO",
      "content": "; TODO: How to choose an appropriate trail or set of trails?",
      "context": "  ; the query and the inferred outputs. There may be multiple layers of\n  ; filters.\n  (define query (source-query sent))\n  ; TODO: How to choose an appropriate trail or set of trails?\n  (update-inferences rb-trail-3 steps (pln-get-recorded-time))\n  (source-set-result! sent pln-src (pln->sureal rb-trail-3))\n)\n"
    },
    {
      "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
      "line": 808,
      "type": "TODO",
      "content": "; TODO: When there is an api to get information about the range of volume",
      "context": "; The *voice* schemas follow from ssml were 'speed' == 'rate'\n; See https://www.w3.org/TR/speech-synthesis/#edef_prosody\n;\n; TODO: When there is an api to get information about the range of volume\n; and speeds that is possible to use.\n(define (increase_voice_speed percent)\n  (set-parameter (Concept \"speech\") (Concept \"rate\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 180,
      "type": "FIXME",
      "content": "; XXX FIXME. This is yucky, something prettier is needed.",
      "context": "; followed by the action.  Given a rule, (gar r) is the AndLink.\n; Either gaar or gadr is the context; the other is the action.\n; We identify the action by using the `psi-action?` utility.\n; XXX FIXME. This is yucky, something prettier is needed.\n(define (get-ctxt-act r)\n\t(define andy (gar r))\n\t(define pa (gar andy))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 214,
      "type": "FIXME",
      "content": ";; XXX TODO -- filter out the exact rules that have non-trivial",
      "context": "\t\t\t\t(if (null? pred) #f\n\t\t\t\t\t(equal? (gdr pred) SENT)))))\n\n\t;; XXX TODO -- filter out the exact rules that have non-trivial\n\t;; THAT and TOPIC contexts.\n\n\t; Get all the exact rules that apply to the SENT\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 247,
      "type": "TODO",
      "content": "; TODO: Maybe it is better to get these rules using GetLink + SignatureLink,",
      "context": "\n\t(define (get-rules)\n\t\t; For getting those \"wildcard\" rules\n\t\t; TODO: Maybe it is better to get these rules using GetLink + SignatureLink,\n\t\t; but at the moment it does not support unordered link, and doing it this\n\t\t; way is fast...\n\t\t(define wildcard-rule-context\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 265,
      "type": "FIXME",
      "content": "; XXX Need to handle that, topic rules as appropriate.",
      "context": "\n; Given a pattern-based rule, run it. Given that it has variables\n; in it, accomplish this by creating and running a MapLink.\n; XXX Need to handle that, topic rules as appropriate.\n(define (run-pattern-rule RULE SENT)\n\t(define maplk (MapLink\n\t\t(ImplicationLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 284,
      "type": "FIXME",
      "content": "; XXX FIXME -- handle topic stars also ....",
      "context": "\n; Return #t if the topic in the RULE context is actually equal\n; to the current AIML topic state.\n; XXX FIXME -- handle topic stars also ....\n(define (is-topical-rule? RULE)\n\t(define pred (get-pred RULE \"*-AIML-topic-*\"))\n\t(if (null? pred) #t\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 361,
      "type": "FIXME",
      "content": ";; XXX FIXME crazy hacky weight-adjusting formula. This makes",
      "context": "  aiml-select-rule RULE-LIST - Given a list of AIML rules,\n  select one to run.\n\"\n\t;; XXX FIXME crazy hacky weight-adjusting formula. This makes\n\t;; no sense at all, but is a hacky hack designed to pick more\n\t;; desirable rules more often.  Someone should figure out\n\t;; some weighting formula that makes more sense tahn this.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 484,
      "type": "FIXME",
      "content": "; XXX FIXME .. Maybe check a much longer list??",
      "context": "\t; response being given twice in a row. Avoid repeating, by\n\t; checking to see if the suggested response is the same as the\n\t; previous response. Right now, we just check one level deep.\n\t; XXX FIXME .. Maybe check a much longer list??\n\t(define (same-as-before? SENT)\n\t\t(define that (do-aiml-get (Concept \"that\")))\n\t\t(define that-len\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      "line": 528,
      "type": "FIXME",
      "content": "; XXX TODO: Would be better to log and retrieve the chat",
      "context": "\n\t\t; The robots response is the current \"that\".\n\t\t; Store up to two previous inputs and outputs\n\t\t; XXX TODO: Would be better to log and retrieve the chat\n\t\t;           history using AtTimeLink and the time server\n\t\t(if (valid-response? response)\n\t\t\t(let ((that (do-aiml-get (Concept \"that\"))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/chatbot/chat-interface.scm",
      "line": 126,
      "type": "FIXME",
      "content": ";     XXX except that above isn't done any more -- WordNodes are",
      "context": ";\n; Anyway, three different kinds of things can be found:\n; WordNodes, almost always \"yes\", in answer to a yes/no question.\n;     XXX except that above isn't done any more -- WordNodes are\n;     never attached, it seems. XXX\n; WordInstanceNodes, in answer to SVO pattern matching.\n; SemeNodes, in answer to triples matching.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/chatbot/chat-interface.scm",
      "line": 143,
      "type": "FIXME",
      "content": "; XXX should we defer this loading till later ??",
      "context": "\t\t\t\t((eq? tipo 'SemeNode) \n\t\t\t\t\t; The lemma-link for a seme might still be sitting on disk!\n\t\t\t\t\t; We will need the lemma when printing, etc.\n\t\t\t\t\t; XXX should we defer this loading till later ?? \n\t\t\t\t\t(load-referers answ)\n\t\t\t\t\tansw\n\t\t\t\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
      "line": 601,
      "type": "FIXME",
      "content": "; XXX we should fetch from SQL ... XXXX",
      "context": "\t\t\t\t(object->string seme-cnt)))\n\t\t\t)\n\n\t\t\t; XXX we should fetch from SQL ... XXXX\n\t\t\t; (fetch-related-semes trip-seme-list)\n\t\t\t;\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
      "line": 628,
      "type": "FIXME",
      "content": "; XXX but it leaves a DocumentNode with nothing pointing to it.",
      "context": "\n\t\t; Delete upwards ... this deletes the link to the document,\n\t\t; and also the link to the new-parsed-sentences anchor.\n\t\t; XXX but it leaves a DocumentNode with nothing pointing to it.\n\t\t(cog-extract-recursive! sent)\n\t)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
      "line": 645,
      "type": "FIXME",
      "content": "(define (do-implication x) #t)  ; XXX use cog-bind instead ...",
      "context": "; This may generate a list of atoms. Take that list, and manually\n; store it in the database.\n;\n(define (do-implication x) #t)  ; XXX use cog-bind instead ... \n(define (xxxprocess-rule rule)\n\t(define triple-list (cog-outgoing-set (do-implication rule)))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
      "line": 37,
      "type": "FIXME",
      "content": "; XXX Support for OrLink in the pattern matcher would simplify this ...",
      "context": "\t)\n)\n\n; XXX Support for OrLink in the pattern matcher would simplify this ...\n(define wh-question-id-rule-0 (wh-question-pattern \"who\"))\n(define wh-question-id-rule-1 (wh-question-pattern \"what\"))\n(define wh-question-id-rule-2 (wh-question-pattern \"when\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
      "line": 76,
      "type": "FIXME",
      "content": "; XXX we should also make sure that adverbs, if any, that",
      "context": "\n\t\t\t(core \"$ans\" \"$clause\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
      "line": 176,
      "type": "FIXME",
      "content": "; XXX we should also make sure that adverbs, if any, that",
      "context": "\t\t\t(r-rlx \"$prep\" \"$seme-ovar\" \"$seme-pvar\")\n\t\t\t(r-rlx \"_subj\" \"$ans-verb\" \"$ans\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
      "line": 230,
      "type": "FIXME",
      "content": ";; XXX someday, this needs to be an or-list of WH- words.",
      "context": "\t\t\twh-clause  ; the prep-phrase we are matching!\n\t\t\t(r-decl-vartype \"PrepositionalRelationshipNode\" \"$tripl\")\n\n\t\t\t;; XXX someday, this needs to be an or-list of WH- words.\n\t\t\t(r-rlx-flag wh-word \"$qvar\")\n\t\t\t(r-decl-lemma  \"$word-inst\" \"$word\")\n\t\t\t(r-decl-lemma  \"$join-inst\" \"$word\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
      "line": 327,
      "type": "FIXME",
      "content": "; XXX we should also make sure that adverbs, if any, that",
      "context": "\t\t\t(r-rlx \"_subj\" \"$ans-verb\" \"$ans-svar\")\n\t\t\t(r-rlx \"_obj\"  \"$ans-verb\" \"$ans-ovar\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
      "line": 211,
      "type": "FIXME",
      "content": "; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.",
      "context": "\t\t)\n\n\t\t; Return the variables and clauses in an association list\n\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
      "line": 212,
      "type": "FIXME",
      "content": "; XXX However, to fix this, we will need to modify the varscope code to",
      "context": "\n\t\t; Return the variables and clauses in an association list\n\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
      "line": 214,
      "type": "FIXME",
      "content": "; XXX err, well, no, since b can sometimes be a",
      "context": "\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n\t\t; XXX SemeNodes can appear here as well.\n\t\t(r-new-expr vartypes clauses (r-fv rel a b))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
      "line": 216,
      "type": "FIXME",
      "content": "; XXX SemeNodes can appear here as well.",
      "context": "\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n\t\t; XXX SemeNodes can appear here as well.\n\t\t(r-new-expr vartypes clauses (r-fv rel a b))\n\t)\n)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
      "line": 617,
      "type": "FIXME",
      "content": "; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX",
      "context": ";\n; Assumes that both \"prep\" and \"prep-word\" are vairables, \n; and declares \"prep\" to be of type DefinedLinguisticRelationshipNode\n; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX\n;\n; Returns an r-expression.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
      "line": 353,
      "type": "FIXME",
      "content": "; XXX This rejects sentences with prep phrases, but it should also probably",
      "context": "; var1=mortal var2=man\n; Must reject prepositions, so that e.g. \"the color (of the sky) is blue.\" \n; which contains _predadj as well as a prep \"of\", is rejected.\n; XXX This rejects sentences with prep phrases, but it should also probably\n; reject anything with _subj, _obj, etc. XXX\n;\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
      "line": 394,
      "type": "FIXME",
      "content": "; XXX FIXME (this is same, similar problem to the other XXX above.)",
      "context": "; var1=Berlin var2=Germany $prep=in\n; However, this can't work if defined as simply as this: there are\n; too many bogus matches for 'prep'.\n; XXX FIXME (this is same, similar problem to the other XXX above.)\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n;      ^ %WordInstanceLink($var1,$sent)  ; $var1 and $var2 must be\n;      ^ %WordInstanceLink($var2,$sent)  ; in the same sentence\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
      "line": 404,
      "type": "FIXME",
      "content": "; XXX for some reason, this isn't working, not sure why ...",
      "context": "; \n; Question: What are bats made of?\n; var0=bat $vrb=make $prep=of $qvar=what\n; XXX for some reason, this isn't working, not sure why ... \n; this needs debugging.\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n;       ^ %WordInstanceLink($var0,$sent)  ; $var0 and $vrb must be\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
      "line": 469,
      "type": "FIXME",
      "content": "; XXX FIXME, rule below is just rule above, but without the prep check.",
      "context": ";\n; or more generally \"X verbed Y prep Z\". \n;\n; XXX FIXME, rule below is just rule above, but without the prep check.\n; This means this rule might break one of the triple-style rules above...\n\n(define truth-assertion-rule-1\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/varscope.scm",
      "line": 7,
      "type": "FIXME",
      "content": "; XXX This is not used any more, because the perl script is not used any",
      "context": "; Wrapper to create proper BindLinks from the naked\n; ImplicationLinks that the perl files generate.\n;\n; XXX This is not used any more, because the perl script is not used any\n; more.  This is currently kept here because it might still come in \n; handy during the conversion of the RelEx frame rules into pure\n; opencog.  Delete this file when frames have been removed from RelEx\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
      "line": 14,
      "type": "TODO",
      "content": "(let* (; TODO: Should be bias according to the score",
      "context": "(define (pick-and-generate list-of-results)\n    (if (equal? (length list-of-results) 0)\n        '()\n        (let* (; TODO: Should be bias according to the score\n               (picked (list-ref list-of-results (random (length list-of-results))))\n               ; TODO: Should use gen-sentences when new microplanner is ready\n               (generated (sureal (gar picked))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
      "line": 16,
      "type": "TODO",
      "content": "; TODO: Should use gen-sentences when new microplanner is ready",
      "context": "        '()\n        (let* (; TODO: Should be bias according to the score\n               (picked (list-ref list-of-results (random (length list-of-results))))\n               ; TODO: Should use gen-sentences when new microplanner is ready\n               (generated (sureal (gar picked))))\n            (if (nil? generated)\n                ; Do it again if the chosen one can't be used to generate a sentence\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
      "line": 156,
      "type": "TODO",
      "content": "; TODO: Should actually clean up the WordNodes instead",
      "context": "    ; indicates that a grammatical interpretation of the sentence is\n    ; found by deleting this word in the sentence using null links)\n    ; The backslash is sometimes generated by AIML rules\n    ; TODO: Should actually clean up the WordNodes instead\n    (set! utterance (string-trim (string-filter\n        (lambda (c) (not (or (char=? #\\[ c) (char=? #\\] c) (char=? #\\\\ c)))) utterance)))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/chatscript.scm",
      "line": 40,
      "type": "TODO",
      "content": "; TODO: Parse the reply?",
      "context": "        ; Ignore the first part of it\n        (set! reply (regexp-substitute/global #f regex reply 'pre \"\" 'post))\n\n        ; TODO: Parse the reply?\n        (State chatscript-reply (List (map Word (string-split reply #\\ ))))\n        (State chatscript process-finished)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/contexts.scm",
      "line": 241,
      "type": "TODO",
      "content": "; TODO: May want to check more than time elapsed",
      "context": "\n(Define\n    (DefinedPredicate \"no-other-fast-reply?\")\n    ; TODO: May want to check more than time elapsed\n    (Evaluation (GroundedPredicate \"scm: long-time-elapsed\") (List))\n)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/external-sources.scm",
      "line": 29,
      "type": "TODO",
      "content": "; TODO: Do something better for getting the first sentence of a paragraph, though",
      "context": "    (State duckduckgo process-started)\n\n    (begin-thread\n        ; TODO: Do something better for getting the first sentence of a paragraph, though\n        ; it isn't that critical here\n        (define (get-first-sentence str)\n            (define default-length 50)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/pln-contexts.scm",
      "line": 16,
      "type": "TODO",
      "content": "; TODO: Replace with what has been assked to be inferred upon.",
      "context": "(define (is-pln-inferred-related?)\n  ;; (cog-logger-info \"[PLN-Context] is-pln-inferred-related?\")\n\n  ; TODO: Replace with what has been assked to be inferred upon.\n  (let ((sentence-names (get-input-utterance-names)))\n    (if (lset<= equal? must-have-names sentence-names)\n        (stv 1 1)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-psi/random-sentence-generator.scm",
      "line": 1,
      "type": "FIXME",
      "content": "; XXX Temp quick hacks for the upcoming demos",
      "context": "; XXX Temp quick hacks for the upcoming demos\n; The design is horrible to call the generator like this\n\n; Example usage of the generator directly from the command line\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
      "line": 41,
      "type": "FIXME",
      "content": ";; XXX FIXME -- remove the IRC debug response below.",
      "context": "            ; nlp-parse returns (SentenceNode \"sentence@45c470a6-29...\")\n            (define sent-node (car (nlp-parse query)))\n\n            ;; XXX FIXME -- remove the IRC debug response below.\n            (display \"Hello \")\n            (display user)\n            (display \", you said: \\\"\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
      "line": 66,
      "type": "FIXME",
      "content": "; XXX Use AIML here to say something snarky.",
      "context": "                    )\n                    ((equal? utr (DefinedLinguisticConceptNode \"DeclarativeSpeechAct\"))\n                        (display \"You made a Declarative SpeechAct\\n\")\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                    ((equal? utr (DefinedLinguisticConceptNode \"ImperativeSpeechAct\"))\n                        (display \"You made a Imperative SpeechAct\\n\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
      "line": 72,
      "type": "FIXME",
      "content": "; XXX Use AIML here to say something snarky.",
      "context": "                        (display \"You made a Imperative SpeechAct\\n\")\n                        ; Make the robot do whatever ...\n\t\t                    ; (imperative_process sent-node)\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                    (else\n                        (display \"Sorry, I can't identify the speech act type\\n\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
      "line": 76,
      "type": "FIXME",
      "content": "; XXX Use AIML here to say something snarky.",
      "context": "                    )\n                    (else\n                        (display \"Sorry, I can't identify the speech act type\\n\")\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                )\n            )\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
      "line": 108,
      "type": "FIXME",
      "content": "; XXX FIXME This also definitely requires change after the backward",
      "context": ";-------------------------------------------------------------------\n; Used by 'truth_query_process' to find the input for the backward\n; chaining.\n; XXX FIXME This also definitely requires change after the backward\n; chaining is completed.\n;-------------------------------------------------------------------\n(define (fAtom querySentence)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
      "line": 25,
      "type": "TODO",
      "content": "; TODO: Replace these time related utilities with one from TimeMap, when it is",
      "context": "             (opencog nlp relex2logic))\n\n; -----------------------------------------------------------------------\n; TODO: Replace these time related utilities with one from TimeMap, when it is\n; ready.\n(define time-domain (DialogNode \"Dialogue-System\"))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
      "line": 34,
      "type": "FIXME",
      "content": "; FIXME: maybe opencog's internal time octime should",
      "context": "  Associate time to the last sentence\n\"\n\t(AtTimeLink\n\t\t; FIXME: maybe opencog's internal time octime should\n\t\t; be used. Will do for now, assuming a single instance\n\t\t; deals with a single conversation.\n\t\tsent\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
      "line": 96,
      "type": "TODO",
      "content": "; TODO use the timeserver when it is ready.",
      "context": "  - The time in seconds since 1970-01-01 00:00:00 UTC. (current-time) gives\n    such time.\n\"\n; TODO use the timeserver when it is ready.\n    (define query\n        (Get\n            (VariableList\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
      "line": 222,
      "type": "FIXME",
      "content": "; XXX FIXME -- sentiment analysis should not be done here.",
      "context": "\t\t(if nlp-stimulate-parses\n\t\t\t(nlp-stimulate sent-node nlp-stimulation-value))\n\n\t\t; XXX FIXME -- sentiment analysis should not be done here.\n\t\t; (perform-sentiment-analysis sent-node)\n\n\t\t; Track some counts needed by R2L.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/fuzzy.scm",
      "line": 54,
      "type": "FIXME",
      "content": "; XXX FIXME the Microplanner should use the same speech-act types as",
      "context": "\"\n\n    ; Find the speech act from the SetLink and use it for Microplanning\n    ; XXX FIXME the Microplanner should use the same speech-act types as\n    ; everyone else, so that we don't have to do this horrific string\n    ; manginling.\n    (define (get-speech-act setlink)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/fuzzy.scm",
      "line": 157,
      "type": "TODO",
      "content": "; TODO: Subject to change, currently it returns the top ones that",
      "context": "    ; Post processing for the results found by the fuzzy-matchers. May\n    ; be generally useful, if we have multiple results and we want to\n    ; merge or ignore some of them.\n    ; TODO: Subject to change, currently it returns the top ones that\n    ; have the same similarity score.\n    (define (post-process fset)\n        (let ( (max-score 0)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
      "line": 55,
      "type": "TODO",
      "content": "; TODO recognition of \"our group\" -> \"we\" and \"our cars\" -> \"they\"",
      "context": "\t\t\t)\n\t\t)\n\n\t\t; TODO recognition of \"our group\" -> \"we\" and \"our cars\" -> \"they\"\n\n\t\t(cond ; if already a pronoun, change it to the base form\n\t\t      (is-pronoun\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
      "line": 89,
      "type": "FIXME",
      "content": "; XXX how to handle \"mine\", \"hers\", \"theirs\", etc?  Seems these will mostly",
      "context": ";\n; The modified form will be based on the noun's usage (subject/object).\n;\n; XXX how to handle \"mine\", \"hers\", \"theirs\", etc?  Seems these will mostly\n; appear within some be-inheritance? (eg.  \"That car is her car\" becoming\n; \"That car is hers\")  Can also appear in \"That car of hers is yellow.\"\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
      "line": 178,
      "type": "FIXME",
      "content": "; XXX might on some special occassion want the supersets?",
      "context": "; meaning of the original sentence stays true.  Randomly return one with\n; some weights.\n;\n; XXX might on some special occassion want the supersets?\n;\n(define-method (get-lexical-node (ni <noun-item>))\n\t(define (determine-lexical)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
      "line": 183,
      "type": "FIXME",
      "content": "; XXX also accept links that inherit the abstracted version? currently not doing that",
      "context": "(define-method (get-lexical-node (ni <noun-item>))\n\t(define (determine-lexical)\n\t\t(define the-noun-node (get-noun-node ni))\n\t\t; XXX also accept links that inherit the abstracted version? currently not doing that\n\t\t; since the anchor is also a ConceptNode, cog-get-link will return each link twice, so need to delete duplicates\n\t\t(define all-inheritances (delete-duplicates (cog-get-link 'InheritanceLink 'ConceptNode the-noun-node)))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-nouns-list.scm",
      "line": 243,
      "type": "TODO",
      "content": "; TODO sometimes it is OK depends on the main subject (current and previous sentence)",
      "context": "\t   0\n\t)\n\n\t; TODO sometimes it is OK depends on the main subject (current and previous sentence)\n\t; (eg.  John helped Sam to prepare his project.)\n\t; (eg.  John helped Sam to feed himself.)\n)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora.scm",
      "line": 23,
      "type": "TODO",
      "content": "; TODO also insert anaphora for missing subjects/objects",
      "context": "; Accepts a <chunks-set>.  Returns new <chunks-set> with anaphora inserted\n; (as new atoms).\n;\n; TODO also insert anaphora for missing subjects/objects\n;\n(define (insert-anaphora inputs-set)\n\t(define results-set (clone-set inputs-set))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora.scm",
      "line": 46,
      "type": "FIXME",
      "content": "; XXX possibly better algorithm for choosing between pronoun vs lexical noun phrase?",
      "context": "\t\t\t\t\t\t(cog-new-node (cog-type old-noun-node) (get-modified-pronomial ni forms) (cog-tv old-noun-node))\n\t\t\t\t\t)\n\t\t\t\t\t; otherwise, try getting a node with the lexical noun\n\t\t\t\t\t; XXX possibly better algorithm for choosing between pronoun vs lexical noun phrase?\n\t\t\t\t\t(if (is-lexical-safe? ni)\n\t\t\t\t\t \t(if (get-association n-lst ni)\n\t\t\t \t\t\t\t(get-lexical-node (get-association n-lst ni))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/helpers.scm",
      "line": 253,
      "type": "FIXME",
      "content": "; XXX optimization possible? This makes the whole function O(mn) rather than O(n)",
      "context": ";\n(define (distance-transform main-list anchor-list)\n\t; initialize where the anchors are\n\t; XXX optimization possible? This makes the whole function O(mn) rather than O(n)\n\t(define len (length main-list))\n\t(define result-list (map (lambda (i) (if (member i anchor-list) 0 1)) main-list))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
      "line": 53,
      "type": "TODO",
      "content": "; TODO: Describe what these variables are for.",
      "context": "; Some constants\n; =======================================================================\n\n; TODO: Describe what these variables are for.\n(define *microplanning_not_sayable* 0)\n(define *microplanning_sayable* 1)\n(define *microplanning_too_long* 2)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
      "line": 83,
      "type": "FIXME",
      "content": "; XXX FIXME utterance-type should be an atom, not a string!",
      "context": "  OPTION is a <chunks-option> object\n  ANAPHORA can be #t or #f.\n\"\n\t; XXX FIXME utterance-type should be an atom, not a string!\n\t; viz (DefinedLinguisticConceptNode \"DeclarativeSpeechAct\") etc.\n\t; this would avoid a lot of string-matching/downcasing/appending\n\t; tomfoolery i.e. simplify the code.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
      "line": 164,
      "type": "TODO",
      "content": "; TODO Keep some of the atoms (those that do not",
      "context": "\t\t\t\t; make-sentence made a new chunk; make more chunks\n\t\t\t\t; with the remaining atoms.\n\t\t\t\t((not (nil? new-atomW-chunk))\n\t\t\t\t\t; TODO Keep some of the atoms (those that do not\n\t\t\t\t\t; satisfy sentence forms) for later use?\n\t\t\t\t\t(recursive-helper\n\t\t\t\t\t\t(lset-difference equal? atomW-unused new-atomW-chunk)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
      "line": 351,
      "type": "FIXME",
      "content": "; XXX could possibly allow choosing different",
      "context": "\t\t\t\t\t\t\t(else\n\t\t\t\t\t\t\t\t; Find the first link in atomW-not-tried that\n\t\t\t\t\t\t\t\t; contains one of the solo words.\n\t\t\t\t\t\t\t\t; XXX could possibly allow choosing different\n\t\t\t\t\t\t\t\t; link to generate multiple chunking result.\n\t\t\t\t\t\t\t\t(set! temp-var1\n\t\t\t\t\t\t\t\t\t(find (lambda (a)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 26,
      "type": "FIXME",
      "content": "; XXX FIXME this method is really bad because for each new type of",
      "context": "; corresponding ConceptNode or PredicateNode or NumberNode or\n; DefinedLinguisticPredicateNode created by R2L helper.\n;\n; XXX FIXME this method is really bad because for each new type of\n; node that R2L uses, it needs to be added here.  There needs some\n; different way for linking R2L nodes to WordInstanceNodes other\n; than node name! e.g. maybe an R2LLink ?\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 53,
      "type": "FIXME",
      "content": "; XXX FIXME except that we can have (EvaluationLink \"not\" \"run@1234\") which",
      "context": "; Given a link, check if it only contains one instanced node.  Used to\n; ignore links that do not need to be post-processed.\n;\n; XXX FIXME except that we can have (EvaluationLink \"not\" \"run@1234\") which\n;     appears unary but should be post-processed.  A more long term\n;     solution is needed.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 140,
      "type": "FIXME",
      "content": "; XXX FIXME should be changed to just use sha-256 -- that would make it",
      "context": "; random-UUID -- Generate a new UUID version 4\n;\n; Returns UUID version 4 (ie, mostly just random hex with some fixed values)\n; XXX FIXME should be changed to just use sha-256 -- that would make it\n; faster, better.\n;\n(define (random-UUID)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 361,
      "type": "FIXME",
      "content": ";XXX FIXME using the hacky word-get-r2l-node, bad idea!",
      "context": "  update:\n  - #t or #f to signal the update of etv in the abstracted r2l outputs returned\n\"\n;XXX FIXME using the hacky word-get-r2l-node, bad idea!\n\t; get all the nodes linked by this link\n\t(define old-oset (cog-outgoing-set ilink))\n\t(define (replace-old old-atom)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 371,
      "type": "FIXME",
      "content": "; XXX what would an abstracted VariableNode be like?",
      "context": "\t\t      ; if node needed to be abstracted\n\t\t      ((member? old-atom lone-nodes)\n\t\t\t\t\t(if (equal? 'VariableNode (cog-type old-atom))\n\t\t\t\t\t\t; XXX what would an abstracted VariableNode be like?\n\t\t\t\t\t\told-atom\n\t\t\t\t\t\t; fail-safe for when R2L rule is incomplete and\n\t\t\t\t\t\t; never created the abstract node\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 386,
      "type": "FIXME",
      "content": ";  ; FIXME: Why create a node with new-instance name? Is this for",
      "context": "\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t      )\n\t\t\t;  ; FIXME: Why create a node with new-instance name? Is this for\n\t\t\t; anaphora-resolution?\n\t\t    ;  ; If node needed to be cloned with new instance name\n\t\t    ;  (a-pair\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      "line": 480,
      "type": "FIXME",
      "content": ";FIXME: Why occurence of a node in more than one relation",
      "context": "\t\t\t(lambda (n)\n\t\t\t\t(and\n\t\t\t\t\t(is-r2l-inst? n)\n\t\t\t\t\t;FIXME: Why occurence of a node in more than one relation\n\t\t\t\t\t; matter? One reason is if the instance-node is renamed\n\t\t\t\t\t; then one wouldn't want to rename the same instance to\n\t\t\t\t\t; different nodes, but then again why create new\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/relex2logic.scm",
      "line": 39,
      "type": "FIXME",
      "content": "; XXX maybe this should be part of the ure module??",
      "context": "        ; from the FC, then delete it and return a list of\n        ; its contents, else return a list holding A-LINK.\n        ;\n        ; XXX maybe this should be part of the ure module??\n        (if (or (equal? 'ListLink (cog-type A-LINK)) IS-FROM-FC)\n            (let ((returned-list (cog-outgoing-set A-LINK)))\n                    (cog-extract! A-LINK)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/relex2logic.scm",
      "line": 63,
      "type": "FIXME",
      "content": "; FIXME: Presently, only a single interpretation is created for",
      "context": "    )\n\n    (define (interpret PARSE-NODE)\n        ; FIXME: Presently, only a single interpretation is created for\n        ; each parse. Multiple interpreation should be handled, when\n        ; word-sense-disambiguation, anaphora-resolution and other\n        ; post-processing are added to the pipeline.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 50,
      "type": "TODO",
      "content": "; TODO: do the same for non-instanced node",
      "context": ")\n; -----------------------------------------------------------------------\n; Connect WordInstanceNode With ConceptNode\n; TODO: do the same for non-instanced node\n(define (r2l-wordinst-concept inst-name)\n\t(ReferenceLink\n\t\t(ConceptNode inst-name)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 59,
      "type": "TODO",
      "content": "; TODO: do the same for non-instanced node",
      "context": ")\n; -----------------------------------------------------------------------\n; Connect WordInstanceNode With PredicateNode\n; TODO: do the same for non-instanced node\n(define (r2l-wordinst-predicate inst-name)\n\t(ReferenceLink\n\t\t(PredicateNode inst-name)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 510,
      "type": "FIXME",
      "content": "; XXX this rule is not used anywhere!",
      "context": "; -----------------------------------------------------------------------\n; unary rules\n; -----------------------------------------------------------------------\n; XXX this rule is not used anywhere!\n(define-public (entity-rule word word_instance)\n\t(ListLink\n\t\t(InheritanceLink (SpecificEntityNode word_instance) (ConceptNode word)))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 516,
      "type": "FIXME",
      "content": "; FIXME: this is bad because in SV, SVO type rules the same word is",
      "context": "\t\t(InheritanceLink (SpecificEntityNode word_instance) (ConceptNode word)))\n)\n\n; FIXME: this is bad because in SV, SVO type rules the same word is\n; ConceptNode instead\n(define-public (gender-rule lemma word_inst gender)\n\t(define word (cog-name lemma))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 634,
      "type": "FIXME",
      "content": ";; XXX FIXME: right now, this says ImplicationScopeLink",
      "context": "\t(cond\n\t\t((or (string=? determiner \"those\") (string=? determiner \"these\"))\n\t\t\t(ListLink\n\t\t\t\t;; XXX FIXME: right now, this says ImplicationScopeLink\n\t\t\t\t;; But I think the intended meaning is a for-all link:\n\t\t\t\t;; (ForAllLink (VariableNode var_name) (ImplicationLink ...))\n\t\t\t\t;; Right?\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 649,
      "type": "FIXME",
      "content": "; XXX Just to avoid getting the `#<Invalid handle>` error",
      "context": "\t\t\t\t(InheritanceLink (VariableNode var_name) (ConceptNode concept)))\n\t\t)\n\n\t\t; XXX Just to avoid getting the `#<Invalid handle>` error\n\t\t; TODO Need to add more to the list (e.g. \"the\") to cover all cases\n\t\t; or update the below to generate something reasonable\n\t\t(else (ListLink))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 650,
      "type": "TODO",
      "content": "; TODO Need to add more to the list (e.g. \"the\") to cover all cases",
      "context": "\t\t)\n\n\t\t; XXX Just to avoid getting the `#<Invalid handle>` error\n\t\t; TODO Need to add more to the list (e.g. \"the\") to cover all cases\n\t\t; or update the below to generate something reasonable\n\t\t(else (ListLink))\n\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 696,
      "type": "FIXME",
      "content": "; XXX this rule is not used anywhere!",
      "context": "; -----------------------------------------------------------------------\n; misc rules\n; -----------------------------------------------------------------------\n; XXX this rule is not used anywhere!\n(define-public (number-rule noun noun_instance num num_instance)\n\t(define noun_ins_concept (ConceptNode noun_instance))\n\t(ListLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 706,
      "type": "FIXME",
      "content": "; XXX this rule is not used anywhere!",
      "context": "\t)\n)\n\n; XXX this rule is not used anywhere!\n(define-public (about-rule verb verb_instance  noun noun_instance)\n\t(ListLink\n\t\t(ImplicationLink (PredicateNode verb_instance) (PredicateNode verb))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 725,
      "type": "FIXME",
      "content": "; XXX FIXME these two are not returned ???",
      "context": "\t(define n1_instance (cog-name n1-inst ))\n\t(define n2 (cog-name n2-lemma))\n\t(define n2_instance (cog-name n2-inst ))\n; XXX FIXME these two are not returned ???\n\t(r2l-wordinst-concept n1_instance)\n\t(r2l-wordinst-concept n2_instance)\n\t(ListLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1274,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define verb_instance (cog-name verb_inst))\n\t(define obj_concept (cog-name obj_lemma))\n\t(define obj_instance (cog-name obj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjSVIOQ-rule\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1287,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define obj_instance (cog-name obj_inst))\n\t(define iobj_concept (cog-name iobj_lemma))\n\t(define iobj_instance (cog-name iobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichobjSVIOQ-rule\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1300,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define obj_instance (cog-name obj_inst))\n\t(define iobj_concept (cog-name iobj_lemma))\n\t(define iobj_instance (cog-name iobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichpobjQ-rule\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1311,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define prep_instance (cog-name prep_inst))\n\t(define pobj_concept (cog-name pobj_lemma))\n\t(define pobj_instance (cog-name pobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjpobjQ-rule\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1322,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define prep_instance (cog-name prep_inst))\n\t(define pobj_concept (cog-name pobj_lemma))\n\t(define pobj_instance (cog-name pobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjSVQ-rule\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1331,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented)",
      "context": "\t(define subj_instance (cog-name subj_inst))\n\t(define verb (cog-name verb_lemma))\n\t(define verb_instance (cog-name verb_inst))\n\t(throw 'not-implemented)\n)\n\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1345,
      "type": "FIXME",
      "content": "; XXX all-rule is not used anywhere ...",
      "context": "; \"All Canadians write.\"                 -> (all-rule \"Canadians@333\")\n; \"All right-handed Canadians write.\"    -> (all-rule \"Canadians@333\")\n;\n; XXX all-rule is not used anywhere ...\n(define-public (all-rule noun_instance)\n\t(ListLink\n\t\t(r2l-wordinst-concept noun_instance)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1363,
      "type": "FIXME",
      "content": "; XXX this rule is not used anywhere ...",
      "context": "; passive verb rules\n; -----------------------------------------------------------------------\n; Example: \"The books were written by Charles Dickens.\"\n; XXX this rule is not used anywhere ...\n(define-public (passive-rule1 verb verb_instance obj obj_instance passive_obj passive_obj_instance)\n    (ListLink\n\t (ImplicationLink (PredicateNode verb_instance) (PredicateNode verb))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1593,
      "type": "FIXME",
      "content": "; XXX that-rule is not used anywhere!",
      "context": "; \"He ran so quickly that he flew.\"\n; A that-rule for \"object clause\", \"content clause\", \"complement clause\",\n; etc, but not \"adjective clause\"\n; XXX that-rule is not used anywhere!\n;(define (that-rule main main_instance sub sub_instance)\n;\t(ListLink\n;\t\t(ImplicationLink (PredicateNode main_instance) (PredicateNode main))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1619,
      "type": "FIXME",
      "content": "; XXX before-after-rule is not used anywhere!",
      "context": "; https://github.com/opencog/opencog/pull/993\n; Examples: \"She went home before I left\", \"I went after him\", \"He sleeps\n; before he is tired\"\n; XXX before-after-rule is not used anywhere!\n;(define (before-after-rule $x_instance $y_instance $y_pos $before_or_after)\n;    (define y-node\n;        (if (or (string=? $y_pos \"verb\") (string=? $y_pos \"adj\"))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1637,
      "type": "FIXME",
      "content": "; XXX time-rule is not used anywhere!",
      "context": ";\n; -----------------------------------------------------------------------\n; Examples: \"I had dinner at 6 pm\", \"I went to sleep at 1 am\"\n; XXX time-rule is not used anywhere!\n;(define (time-rule $hour $period $v_instance)\n;    (define time-node\n;        (if (string=? $period \"am\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1652,
      "type": "FIXME",
      "content": "; XXX FIXME: there is no such thing as a \"TruthValueGreaterThanLink\",",
      "context": "; -----------------------------------------------------------------------\n; functions without R2L rule, not working, unneeded, etc\n; -----------------------------------------------------------------------\n; XXX FIXME: there is no such thing as a \"TruthValueGreaterThanLink\",\n; so this rule is borken.\n;(define (comparative-rule w1 w1_instance w2 w2_instance adj adj_instance)\n;\t(ListLink\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      "line": 1669,
      "type": "FIXME",
      "content": "; XXX on-rule is not used anywhere!",
      "context": ";)\n;\n;---------------------------------------------------------------\n; XXX on-rule is not used anywhere!\n;(define (on-rule w1 w1_instance w2 w2_instance)\n;\t(ListLink\n;\t(InheritanceLink (ConceptNode w1_instance) (ConceptNode w1))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-utils.scm",
      "line": 7,
      "type": "FIXME",
      "content": "; XXX why is this public?",
      "context": "; Some generic rule utilities, not limited to r2l.\n;\n;--------------------------------------------------------------------\n; XXX why is this public?\n(define-public r2l-rules (ConceptNode \"R2L-en-RuleBase\"))\n\n;--------------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/tv-utilities.scm",
      "line": 11,
      "type": "TODO",
      "content": "; TODO: move this to (opencog data) module when it is created.",
      "context": "  Populate the atomspace with ConceptNodes drived from Google's Trillion Word\n  Corpus.\n\"\n; TODO: move this to (opencog data) module when it is created.\n    (let ((path \"/var/opencog/data/gtwc-en-333333-words.scm\"))\n        (if (file-exists? path)\n            (primitive-load path)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/relex2logic/rules/passive.scm",
      "line": 2,
      "type": "FIXME",
      "content": "; XXX Fix relex so that we don't have to make such string searches!",
      "context": "; check the tense if it is passive\n; XXX Fix relex so that we don't have to make such string searches!\n(define-public (check-tense tense)\n\t(if (string-contains (cog-name tense) \"passive\") (stv 1 1) (stv 0 1))\n)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/oc.scm",
      "line": 20,
      "type": "FIXME",
      "content": "; XXX What? nothing else anywhere needs this! FIXME, somethings broke.",
      "context": "(include-from-path \"opencog/nlp/oc/processing-utils.scm\")\n\n; Weird ... MUST say `(export)` or no define-publics are visible!\n; XXX What? nothing else anywhere needs this! FIXME, somethings broke.\n(export)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/parse-rank.scm",
      "line": 174,
      "type": "FIXME",
      "content": "; XXX Umm, actually, this routine was intended for a",
      "context": "\n\t; Iterate over a list graph edges, and return the edge with the\n\t; highest weight.\n\t; XXX Umm, actually, this routine was intended for a\n\t; maximum-spanning-tree algorithm, but we don't actually need that\n\t; algo to properly rank parse scores. So this is actually some dead\n\t; code that we're not using just right now ...\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
      "line": 8,
      "type": "FIXME",
      "content": "; XXX This is currently not used anywhere, but if it was fixed up,",
      "context": "; RelEx types. These are \"anti-syntactic sugar\", and avoid the need\n; for new atom types, such as \"GenderNode\" or \"TenseNode\", etc.\n;\n; XXX This is currently not used anywhere, but if it was fixed up,\n; it could be, I guess ...\n;\n; Copyright (c) 2008 Linas Vepstas\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
      "line": 13,
      "type": "FIXME",
      "content": "; XXX This list is *probably* incomplete, and needs to be reviewed! XXX",
      "context": ";\n; Copyright (c) 2008 Linas Vepstas\n;\n; XXX This list is *probably* incomplete, and needs to be reviewed! XXX\n; In particular, the tense list is incomplete. The part-of-speech list\n; might be incomplete.\n; The list of entities (person, locatin, date, money) is incomplete.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
      "line": 21,
      "type": "FIXME",
      "content": "; XXX This list could be auto-generated by using",
      "context": "; documenting these things. See\n; http://opencog.org/wiki/RelEx_Semantic_Relationship_Extractor\n;\n; XXX This list could be auto-generated by using\n; (module-define! (current-module) ,var ,val))\n;\n; Better solution:\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
      "line": 128,
      "type": "FIXME",
      "content": "; XXX this list is highly incomplete",
      "context": "\n;; -------------------------------------------------------------------\n; tense in RelEx\n; XXX this list is highly incomplete\n;\n(InheritanceLink\n\t(DefinedLinguisticConceptNode \"past\")\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/scm/oc/relex-utils.scm",
      "line": 176,
      "type": "FIXME",
      "content": "; FIXME: this is a dumb way to get other type",
      "context": "\"\n\t(let ((wlist (cog-chase-link 'LemmaLink 'WordNode word-inst)))\n\t\t(if (nil? wlist)\n\t\t\t; FIXME: this is a dumb way to get other type\n\t\t\t(let ((nlist (cog-chase-link 'LemmaLink 'NumberNode word-inst)))\n\t\t\t\t(if (nil? nlist)\n\t\t\t\t\t'()\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/sureal/sureal.scm",
      "line": 3,
      "type": "FIXME",
      "content": "; XXX Huh ???",
      "context": "; Links relex-to-logic output with relex-opencog-output\n; It is temporary until the r2l rules are moved into the URE\n; XXX Huh ???\n\n; Test sentence : \"This is a sentence.\"\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/sureal/surface-realization.scm",
      "line": 163,
      "type": "TODO",
      "content": "; TODO: There could be too many... skip if seen before?",
      "context": "                            (if (equal? (cog-type n) 'PredicateNode)\n                                (map\n                                    (lambda (p)\n                                        ; TODO: There could be too many... skip if seen before?\n                                        (lg-dict-entry (word-inst-get-word p))\n                                    )\n                                    (cog-chase-link 'LemmaLink 'WordInstanceNode (r2l-get-word n))\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/sureal/surface-realization.scm",
      "line": 291,
      "type": "FIXME",
      "content": "; FIXME: This results in 'result' being 'Invalid handle' sometimes.",
      "context": "    (define result (cog-execute! (MapLink filter-in-pattern filter-from)))\n\n    ; Delete the filter-from SetLink and its encompasing MapLink.\n    ; FIXME: This results in 'result' being 'Invalid handle' sometimes.\n    ;(cog-extract-recursive! filter-from)\n\n    result\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/wsd-post/cluster.scm",
      "line": 67,
      "type": "FIXME",
      "content": ";; XXX not tail recursive; get performance boost if it was.",
      "context": "\n;; --------------------------------------------------------------------\n;; create a list of disjuncts by merging those from two coord lists\n;; XXX not tail recursive; get performance boost if it was.\n\n(define (make-dj-list coords-a coords-b)\n\t; Add dj to list, but only if not in list\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/wsd-post/collect-stats/disjunct-list.scm",
      "line": 12,
      "type": "FIXME",
      "content": "; XXX This code is deprecated and/or obsolete. Why?",
      "context": "; is a link-grammar link relations, with an appended + or - indicating\n; whether the connection is to the right or left.\n;\n; XXX This code is deprecated and/or obsolete. Why?\n; 1) Because disjuncts can now be obtained directly from relex and LG.\n;    They use the ConnectorNode, LgAndLink and LgDisjunct to specifiy\n;    them. Grep the viterbi code for details; see also the sureal code.\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/wsd-post/collect-stats/stats-collection.scm",
      "line": 359,
      "type": "FIXME",
      "content": "; XXX The method used here, of tagging documents with \"finished\"",
      "context": "; Return all of the documents for which WSD has been completed,\n; but disjunct processing has not been.\n;\n; XXX The method used here, of tagging documents with \"finished\"\n; tags, is rather ad-hoc, and is meant to be a stop-gap until\n; opencog offers some way of defining a processing pipeline.\n;\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/action-selector.scm",
      "line": 81,
      "type": "TODO",
      "content": "; TODO Why have a cutoff? That is why return a list of rules",
      "context": "\n  ; Recursively move through the list of rules, until the\n  ; sum of the weights of the rules exceeds the cutoff.\n  ; TODO Why have a cutoff? That is why return a list of rules\n  ; instead of just picking the one with the highest weight.\n  (define (pick-rule wcut rule-list)\n    ; Subtract weight of the first rule.\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 89,
      "type": "FIXME",
      "content": "; FIXME -- can we have a shorter/better name for this method?",
      "context": ")\n\n; --------------------------------------------------------------\n; FIXME -- can we have a shorter/better name for this method?\n;\n(define (psi-rule-set-atomese-weight psi-rule weight)\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 104,
      "type": "FIXME",
      "content": "; FIXME - the long-term design calls for the use of an AtTimeLink",
      "context": "  if multiple rules have the same name, then all of thise rules will\n  also have the same weight.\n\"\n    ; FIXME - the long-term design calls for the use of an AtTimeLink\n    ; instead of a StateLink, here.\n    ;\n    ; FIXME -- if there are multiple names for a rule, this will\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 107,
      "type": "FIXME",
      "content": "; FIXME -- if there are multiple names for a rule, this will",
      "context": "    ; FIXME - the long-term design calls for the use of an AtTimeLink\n    ; instead of a StateLink, here.\n    ;\n    ; FIXME -- if there are multiple names for a rule, this will\n    ; use all of those names in the StateLink.  If a rule is given\n    ; a second or third name later on, this will cause dead StateLinks\n    ; to linger in the atomspace. FIXME -- make sure that a rule can\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 169,
      "type": "FIXME",
      "content": "(StateLink ; FIXME should use AtTimeLink",
      "context": "                    (VariableNode \"psi-rule-alias\")\n                    (TypeNode \"ConceptNode\")))\n            (AndLink\n                (StateLink ; FIXME should use AtTimeLink\n                    (ListLink\n                        (VariableNode \"psi-rule-alias\")\n                        (ConceptNode (string-append psi-prefix-str \"weight\")))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 218,
      "type": "TODO",
      "content": "; TODO: Use categories instead of aliases for categorization",
      "context": "  - a list with psi-rules.\n\"\n    (receive (filtered other)\n        ; TODO: Use categories instead of aliases for categorization\n        (psi-partition-rule-with-alias rule-alias psi-rule-list)\n        (map\n            (lambda (psi-rule) (psi-rule-set-atomese-weight psi-rule 0.0))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 239,
      "type": "TODO",
      "content": "; TODO: Use categories instead of aliases for categorization",
      "context": "  - a list with psi-rules.\n\"\n    (receive (filtered other)\n      ; TODO: Use categories instead of aliases for categorization\n        (psi-partition-rule-with-alias rule-alias psi-rule-list)\n        (map\n            (lambda (psi-rule) (psi-rule-set-atomese-weight psi-rule 0.9))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/control.scm",
      "line": 272,
      "type": "FIXME",
      "content": "(StateLink ; FIXME should use AtTimeLink",
      "context": "            (MemberLink\n                (Variable \"controlled-rule\")\n                psi-controller-demand)\n            (StateLink ; FIXME should use AtTimeLink\n                (ListLink\n                    (VariableNode \"psi-rule-alias\")\n                    (ConceptNode (string-append psi-prefix-str \"weight\")))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/main.scm",
      "line": 35,
      "type": "TODO",
      "content": "; TODO: Adding  a component to a category makes no sense",
      "context": "; but there activities are defined using openpsi-rules and action-selectors\n; associated with it.\n(define psi-component-node (ConceptNode \"component\"))\n; TODO: Adding  a component to a category makes no sense\n(psi-add-category psi-component-node)\n\n; --------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/main.scm",
      "line": 94,
      "type": "FIXME",
      "content": "; XXX FIXME -- right now, this assumes that a single thread, running",
      "context": "\n; --------------------------------------------------------------\n;\n; XXX FIXME -- right now, this assumes that a single thread, running\n; at no more than 100 steps per second, is sufficient to run all of the\n; psi rules.  For now, this is OK, but at some point, this will become\n; a bottleneck, as we will need to evaluate more rules more often.\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 128,
      "type": "TODO",
      "content": "; TODO: Add utilities for declaring custom urge formula.",
      "context": "  where GOAL_VALUE is the present value of the goal, and DGV is the\n  desired-goal-value for the GOAL.\n\"\n  ; TODO: Add utilities for declaring custom urge formula.\n  (- (psi-dgv goal) (psi-goal-value goal))\n)\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 142,
      "type": "TODO",
      "content": "; TODO: Add utilities for declaring custom decrease-urge formula.",
      "context": "  goal-value, thus VALUE should be a positive number. This assumes\n  the desired-goal-value to be 1.\n\"\n  ; TODO: Add utilities for declaring custom decrease-urge formula.\n  (let* ((u (psi-urge goal))\n    (gv (- 1 (- u (abs value)))))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 161,
      "type": "TODO",
      "content": "; TODO: Add utilities for declaring custom increase-urge formula.",
      "context": "  Return GOAL after increasing the magnitude of the urge by VALUE. VALUE\n  should be a positive number. This assumes the desired-goal-value to be 1.\n\"\n  ; TODO: Add utilities for declaring custom increase-urge formula.\n  (let* ((u (psi-urge goal))\n    (gv (- 1 (+ u (abs value)))))\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 197,
      "type": "TODO",
      "content": "; TODO Uncomment after testing with ghost",
      "context": "      rule\n      (ConceptNode name)))\n\n  ; TODO Uncomment after testing with ghost\n  ;(cog-set-value!\n  ;  rule\n  ;  psi-rule-name-predicate-node\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 223,
      "type": "TODO",
      "content": "; TODO Uncomment after testing with ghost",
      "context": "          (QuoteLink rule)  ;; ?? why is a Quote needed here?\n          (VariableNode \"rule-alias\"))))))\n\n  ; TODO Uncomment after testing with ghost\n  ;(let ((alias-value (cog-value rule psi-rule-name-predicate-node)))\n  ;  (if (nil? alias-value)\n  ;    '()\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 240,
      "type": "FIXME",
      "content": ";; XXX this is not an efficient way of searching for goals.  If",
      "context": "    A goal is associated with an action whenever the goal appears in\n    a psi-rule with that action in it.\n\"\n  ;; XXX this is not an efficient way of searching for goals.  If\n  ;; this method is used a lot, we should search for the goals directly\n  ;; See https://github.com/opencog/opencog/pull/2899.\n  (let* (\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 294,
      "type": "FIXME",
      "content": "; XXX FIXME How about actually using a SequentialAndLink?",
      "context": "  ; map-in-order is used to simulate AndLink assuming\n  ; psi-get-context maintains, which is unlikely. What other options\n  ; are there?\n  ; XXX FIXME How about actually using a SequentialAndLink?\n  ; then the code will be faster, and there won't be this problem.\n  ; TODO: This calculation can be done in OpenPsiImplicator::grounding or\n  ; when the rule is being added. Since it unlikely to change except\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/rule.scm",
      "line": 296,
      "type": "TODO",
      "content": "; TODO: This calculation can be done in OpenPsiImplicator::grounding or",
      "context": "  ; are there?\n  ; XXX FIXME How about actually using a SequentialAndLink?\n  ; then the code will be faster, and there won't be this problem.\n  ; TODO: This calculation can be done in OpenPsiImplicator::grounding or\n  ; when the rule is being added. Since it unlikely to change except\n  ; during learning it can be saved in the AndLink.\n  (context-stv (map-in-order cog-evaluate! (psi-get-context rule)))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/utilities.scm",
      "line": 14,
      "type": "FIXME",
      "content": "; XXX TODO: does this really need to be public? change into atom.",
      "context": "(use-modules (opencog) (opencog exec))\n\n; --------------------------------------------------------------\n; XXX TODO: does this really need to be public? change into atom.\n(define psi-prefix-str \"OpenPsi: \")\n\n; --------------------------------------------------------------\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/utilities.scm",
      "line": 18,
      "type": "FIXME",
      "content": "; XXX TODO: does this really need to be public?",
      "context": "(define psi-prefix-str \"OpenPsi: \")\n\n; --------------------------------------------------------------\n; XXX TODO: does this really need to be public?\n(define (psi-suffix-str a-string)\n\"\n  psi-suffix-str STRING\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/modulator.scm",
      "line": 48,
      "type": "TODO",
      "content": "; todo: cog-chase-link bug? - it is returning the anchor node in the results",
      "context": ")\n\n(define (psi-get-modulators)\n\t; todo: cog-chase-link bug? - it is returning the anchor node in the results\n\t;(cog-chase-link 'InheritanceLink 'ConceptNode psi-modulator-node))\n\t(cog-outgoing-set (cog-execute!\n\t\t(Get (Inheritance (Variable \"$mod\") psi-modulator-node)))))\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/sec.scm",
      "line": 67,
      "type": "TODO",
      "content": "; Todo: add variable names (?) and add getters for agent-state secs",
      "context": "(define (psi-is-sec? atom)\n\t(member atom (psi-get-secs)))\n\n; Todo: add variable names (?) and add getters for agent-state secs\n\n; =============================================================================\n; CREATE SECs\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 38,
      "type": "TODO",
      "content": "; TODO Replace verbose & logger variable in openpsi/dyanmics/updater.scm with",
      "context": "(load \"interaction-rule.scm\")\n(load \"event.scm\")\n\n; TODO Replace verbose & logger variable in openpsi/dyanmics/updater.scm with\n; cog-logger-component for this module.\n(define logging #t)\n(define verbose #f)\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 47,
      "type": "TODO",
      "content": "; Todo: Move these to a config file",
      "context": "\n; --------------------------------------------------------------\n; Config Parameters\n; Todo: Move these to a config file\n\n; Multiplier that can be tweaked to increase or decrease the sensitivity of\n; interactactions between openpsi entities. Default is 1.\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 69,
      "type": "TODO",
      "content": "; Todo: implement these tables in the atomspace",
      "context": "\n; --------------------------------------------------------------\n\n; Todo: implement these tables in the atomspace\n(define prev-value-table (make-hash-table 40))\n(define prev-most-recent-ts-table (make-hash-table 40))\n(define psi-event-detection-callbacks '())\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 112,
      "type": "TODO",
      "content": "; Todo: Add a general callback function that is called once each loop",
      "context": "\t\t(append psi-event-detection-callbacks (list callback)))\n)\n\n; Todo: Add a general callback function that is called once each loop\n\n(define (psi-updater-init)\n\"\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 375,
      "type": "TODO",
      "content": "; todo: Could optimize by only calling rules containing the changed params",
      "context": "\t\t\t\t(close-output-port output-port))))\n\n\t; Grab and evaluate the interaction rules\n\t; todo: Could optimize by only calling rules containing the changed params\n\t(let ((rules (psi-get-interaction-rules)))\n\t\t(map psi-evaluate-interaction-rule rules)\n\t)\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 532,
      "type": "TODO",
      "content": "; TODO: handle current value = #f (or not number in general)",
      "context": "\t\t; Increasing slope increases the degree change at all levels\n\t\t(set! slope 10000)\n\t\t;(format #t \"current value: ~a\\n\" current-value)\n\t\t; TODO: handle current value = #f (or not number in general)\n\t\t; finagle the extreme cases because the curve is not exactly how we want\n\t\t(if (> alpha 0)\n\t\t\t(if (>= alpha .5)\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      "line": 748,
      "type": "TODO",
      "content": "; Todo: Perhaps will want to integrate this into the main OpenPsi loop, but OTOH",
      "context": "; --------------------------------------------------------------\n; Updater Loop Control\n; --------------------------------------------------------------\n; Todo: Perhaps will want to integrate this into the main OpenPsi loop, but OTOH\n; we may want them running at different frequencies.\n\n(define psi-updater-is-running #f)\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/utilities.scm",
      "line": 39,
      "type": "TODO",
      "content": "; Todo: Could potential optimize? here by using",
      "context": "\"\n\t;(define result #f)\n\n\t; Todo: Could potential optimize? here by using\n\t; psi-value-representation-type fucntion\n\n\t; First check for StateLink value\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/dynamics/utilities.scm",
      "line": 114,
      "type": "TODO",
      "content": "; Todo: this will probably need to be changed to handle",
      "context": "\t\t\t        ; If PredicateNode, then set node TV\n\t\t\t        (cog-set-tv! entity (stv value 1))\n\t\t\t        ; else wrap it in an EvaluationLink\n\t\t\t        ; Todo: this will probably need to be changed to handle\n\t\t\t        ; arguments.\n\t\t\t\t    (Evaluation entity (List) (stv value 1))))\n\t\t\t((equal? value-rep-type executable)\n"
    },
    {
      "file": "components/integration/opencog/tests/openpsi/psi-implicator.scm",
      "line": 39,
      "type": "FIXME",
      "content": "; FIXME: Using psi-goal results in the failure of OpenPsiRulesUTest",
      "context": "\n(define (component-1) (psi-component \"component-1\"))\n\n; FIXME: Using psi-goal results in the failure of OpenPsiRulesUTest\n; and OpenPsiImplicatorUTest\n;(define goal-1 (psi-goal \"goal-1\" 1))\n(define goal-1 (Concept \"goal-1\"))\n"
    },
    {
      "file": "components/language/learn/attic/repair/word-merge.scm",
      "line": 197,
      "type": "FIXME",
      "content": "; XXX technically, this is wrong, we should be renaming these...",
      "context": "\t)\n\n\t; Discard alternates\n\t; XXX technically, this is wrong, we should be renaming these...\n\t(define (bug-cleanup laid)\n\t\t(if (< 0 laid)\n;\t\t\t(let* ((aud (get-eval-uuid laid)))\n"
    },
    {
      "file": "components/language/learn/attic/run-poc/fetch-word-pairs.scm",
      "line": 25,
      "type": "TODO",
      "content": "(set! star-obj (add-pair-stars pair-obj)) ;TODO: Can it be left out??",
      "context": "         (equal? cnt-mode \"clique-dist\"))\n      (set! pair-obj (make-clique-pair-api))))\n\n  (set! star-obj (add-pair-stars pair-obj)) ;TODO: Can it be left out??\n  (pair-obj 'fetch-pairs)\n\n  ; Print the sql stats\n"
    },
    {
      "file": "components/language/learn/attic/run-v3/run-common/export-dictionary.scm",
      "line": 26,
      "type": "FIXME",
      "content": "; XXX this and above steps should move to `marginals-dict.scm` !?",
      "context": "(asc 'create-hi-count-singles 1)\n\n; Compute MI. This is needed for LG costs.\n; XXX this and above steps should move to `marginals-dict.scm` !?\n(display \"Computing Link Grammar costs\\n\")\n(define gcs (add-pair-stars gca))\n(define gcf (add-wordclass-filter gcs))\n"
    },
    {
      "file": "components/language/learn/attic/run-v3/run-common/export-dictionary.scm",
      "line": 40,
      "type": "FIXME",
      "content": "; XXX put INCLUDE-UNKNOWN into the environment.",
      "context": "\n; Perform the actual export. The dictionary name and locale\n; are taken from environment variables.\n; XXX put INCLUDE-UNKNOWN into the environment.\n(display \"Exporting Dictionary\\n\")\n(use-modules (opencog nlp lg-export))\n(export-csets gcf\n"
    },
    {
      "file": "components/language/learn/attic/run-v3/run-common/marginals-mst-shape.scm",
      "line": 34,
      "type": "FIXME",
      "content": "; XXX The current merge code tracks stats that requires the MI",
      "context": "\n(print-matrix-summary-report csc)\n\n; XXX The current merge code tracks stats that requires the MI\n; for word-disjunct pairs to be computed. These stats are not\n; required, but are interesting to observe. To get these, the\n; MI needs to be computed, as below:\n"
    },
    {
      "file": "components/language/learn/attic/run-v3/run-common/trim-pair.scm",
      "line": 22,
      "type": "FIXME",
      "content": "; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry",
      "context": "(barrier storage-node)\n\n; Trim the dataset.\n; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry\n; for why these are chosen, instead of something else. Basically,\n; trimming this much raises the average MI of the dataset to its\n; highest value. It also cuts the number of word pairs about half.\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/disjunct-cross.scm",
      "line": 32,
      "type": "FIXME",
      "content": "; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.",
      "context": "\n(define pca (make-pseudo-cset-api))\n(define psa (add-pair-stars pca))\n; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.\n(define psc (add-pair-count-api psa))\n(define psf (add-pair-freq-api psa))\n(define psu (add-support-api psa))\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/disjunct-stats.scm",
      "line": 39,
      "type": "FIXME",
      "content": "; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.",
      "context": "\n(define pca (make-pseudo-cset-api))\n(define psa (add-pair-stars pca))\n; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.\n(define psc (add-pair-count-api psa))\n(define psf (add-pair-freq-api psa))\n(define psu (add-support-api psa))\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/ortho-compute.scm",
      "line": 21,
      "type": "TODO",
      "content": "; TODO filter the top lists",
      "context": "(smi 'fetch-pairs) ;;; same as (load-atoms-of-type 'Similarity)\n\n; -------------------------------------\n; TODO filter the top lists\n; (define (filter the top list...\n\n; Wrap similarity, to create a new base object.\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/ortho-compute.scm",
      "line": 57,
      "type": "FIXME",
      "content": "; XXX todo store mean-rms on any-node.",
      "context": "(goe 'mean-rms)\n(gor 'mean-rms)\n\n; XXX todo store mean-rms on any-node.\n\n(define gos (add-similarity-api ami #f \"goe\"))\n\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/orthogonal-ensemble.scm",
      "line": 52,
      "type": "TODO",
      "content": "; TODO filter the top lists",
      "context": "\t(close csv))\n\n; -------------------------------------\n; TODO filter the top lists\n; (define (filter the top list...\n\n; Wrap similarity, to create a new base object.\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/utils/word-cosines.scm",
      "line": 31,
      "type": "FIXME",
      "content": "; XXX FIXME add-pair-count-api is osolete; use add-support-api instead.",
      "context": "\n(define pseudo-cset-api (make-pseudo-cset-api))\n\n; XXX FIXME add-pair-count-api is osolete; use add-support-api instead.\n(define pseudo-cset-count-api (add-pair-count-api pseudo-cset-api))\n(define pseudo-cset-freq-api (add-pair-freq-api pseudo-cset-api))\n(define pseudo-cset-support-api (add-support-api pseudo-cset-api))\n"
    },
    {
      "file": "components/language/learn/learn-lang-diary/word-classes/word-classes.scm",
      "line": 9,
      "type": "FIXME",
      "content": "; XXX Don't use this; use ((make-gram-class-api) 'fetch-pairs) instead.",
      "context": "(use-modules (srfi srfi-1))\n;\n; Load all grammatical classes from storage\n; XXX Don't use this; use ((make-gram-class-api) 'fetch-pairs) instead.\n(define (fetch-all-gram-classes)\n\t(load-atoms-of-type 'WordClassNode)\n\t(for-each\n"
    },
    {
      "file": "components/language/learn/run-common/cogserver.scm",
      "line": 97,
      "type": "FIXME",
      "content": "; XXX Is this needed? Didn't cogserver already get the top?",
      "context": "\t#:prompt (getenv \"OCPROMPT\")\n\t#:logfile (getenv \"LOGFILE\"))\n\n; XXX Is this needed? Didn't cogserver already get the top?\n(when (< 0 (length frame-tops))\n\t(set-cogserver-atomspace! (cog-atomspace)))\n\n"
    },
    {
      "file": "components/language/learn/run-common/marginals-mst-shape.scm",
      "line": 35,
      "type": "FIXME",
      "content": "; XXX The current merge code tracks stats that requires the MI",
      "context": "\n(print-matrix-summary-report csc)\n\n; XXX The current merge code tracks stats that requires the MI\n; for word-disjunct pairs to be computed. These stats are not\n; required, but are interesting to observe. To get these, the\n; MI needs to be computed, as below:\n"
    },
    {
      "file": "components/language/learn/run-common/trim-pair.scm",
      "line": 23,
      "type": "FIXME",
      "content": "; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry",
      "context": "(barrier storage-node)\n\n; Trim the dataset.\n; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry\n; for why these are chosen, instead of something else. Basically,\n; trimming this much raises the average MI of the dataset to its\n; highest value. It also cuts the number of word pairs about half.\n"
    },
    {
      "file": "components/language/learn/run-common/attic/export-dictionary.scm",
      "line": 26,
      "type": "FIXME",
      "content": "; XXX this and above steps should move to `marginals-dict.scm` !?",
      "context": "(asc 'create-hi-count-singles 1)\n\n; Compute MI. This is needed for LG costs.\n; XXX this and above steps should move to `marginals-dict.scm` !?\n(display \"Computing Link Grammar costs\\n\")\n(define gcs (add-pair-stars gca))\n(define gcf (add-wordclass-filter gcs))\n"
    },
    {
      "file": "components/language/learn/run-common/attic/export-dictionary.scm",
      "line": 40,
      "type": "FIXME",
      "content": "; XXX put INCLUDE-UNKNOWN into the environment.",
      "context": "\n; Perform the actual export. The dictionary name and locale\n; are taken from environment variables.\n; XXX put INCLUDE-UNKNOWN into the environment.\n(display \"Exporting Dictionary\\n\")\n(use-modules (opencog nlp lg-export))\n(export-csets gcf\n"
    },
    {
      "file": "components/language/learn/scm/common.scm",
      "line": 14,
      "type": "FIXME",
      "content": "; XXX TODO FIXME All users of the three functions below need to be",
      "context": "(use-modules (srfi srfi-1))\n(use-modules (opencog) (opencog persist))\n\n; XXX TODO FIXME All users of the three functions below need to be\n; converted into users of the add-count-api, add-storage-count and\n; add-marginal-count API's. The three functions below are\n; deprecated/obsolete.\n"
    },
    {
      "file": "components/language/learn/scm/learn.scm",
      "line": 15,
      "type": "FIXME",
      "content": "(include-from-path \"opencog/learn/pipe-count.scm\") ; XXX experimental",
      "context": "(include-from-path \"opencog/learn/waiter.scm\")\n\n; Pipe stuff\n(include-from-path \"opencog/learn/pipe-count.scm\") ; XXX experimental\n\n; Pair stuff.\n(include-from-path \"opencog/learn/pair-api.scm\")\n"
    },
    {
      "file": "components/language/learn/scm/lg-compare.scm",
      "line": 365,
      "type": "FIXME",
      "content": "; XXX Temp hack. Currently, the test dicts are missing",
      "context": "\t\t\t(define right-wall (WordNode \"###RIGHT-WALL###\"))\n\n\t\t\t; Get the list of words in the standard dict.\n\t\t\t; XXX Temp hack. Currently, the test dicts are missing\n\t\t\t; RIGHT-WALL and so we filter it out manually. This\n\t\t\t; should be made more elegant. Argh. And the gold dict\n\t\t\t; is missing them too ...\n"
    },
    {
      "file": "components/language/learn/scm/attic/singletons.scm",
      "line": 5,
      "type": "FIXME",
      "content": "; XXX This is not currently used, and should maybe be deleted.",
      "context": "; singletons.scm\n;\n; Stuff for working with singltons.\n; XXX This is not currently used, and should maybe be deleted.\n; It probably does not even work right.\n;\n; Copyright (c) 2017 Linas Vepstas\n"
    },
    {
      "file": "components/language/learn/scm/attic/summary.scm",
      "line": 5,
      "type": "FIXME",
      "content": "; XXX This is stale and semi-abandoned and needs to be modernized.",
      "context": "; summary.scm\n;\n; Print a summary report for a dataset.\n; XXX This is stale and semi-abandoned and needs to be modernized.\n;\n; Copyright (c) 2017 Linas Vepstas\n;\n"
    },
    {
      "file": "components/language/learn/scm/attic/summary.scm",
      "line": 51,
      "type": "FIXME",
      "content": "; XXX FIXME work on the singletons API so that we don't",
      "context": "\t; Fetch them, if needed.\n\t(if (eqv? 0.0 nww)\n\t\t(begin\n\t\t\t; XXX FIXME work on the singletons API so that we don't\n\t\t\t; need to fetch the words.\n\t\t\t(display \"Start loading words ...\\n\")\n\t\t\t(call-only-once fetch-all-words)\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 381,
      "type": "FIXME",
      "content": "; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,",
      "context": ";     else they might fit. Viz, many words have both noun and verb\n;     forms, and thus need to go into multiple classes.\n;\n; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,\n; words in the DONE-LIST have a good chance of being completely\n; neutered, with almost nothing left in them. They should get dropped.\n;\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 385,
      "type": "FIXME",
      "content": "; XXX Maybe-FIXME: There's some amount of pointless recomputation of",
      "context": "; words in the DONE-LIST have a good chance of being completely\n; neutered, with almost nothing left in them. They should get dropped.\n;\n; XXX Maybe-FIXME: There's some amount of pointless recomputation of\n; cosines between the word-list, and the existing grammatical classes.\n; During the construction of the classes, a greedy search was formed\n; part-way down the word-list. Thus, when resuming the search, its\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 567,
      "type": "FIXME",
      "content": "; XXX There is a user-adjustable parameter used below, `diag-block-size`,",
      "context": "; measured, confirmed, tested, yet. It seems to be the case, but\n; actual measurements have not been made.\n;\n; XXX There is a user-adjustable parameter used below, `diag-block-size`,\n; to specify the initial block size.  This could be exposed in the API,\n; maybe.  On the other hand, it could stay hard-coded forever, for all\n; practical purposes.\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 586,
      "type": "FIXME",
      "content": "; XXX the block sizes are by powers of 2...",
      "context": "\t\t\t\t\t; perform clustering\n\t\t\t\t\t(new-clist (block-assign-to-classes MERGER chunk clist)))\n\t\t\t\t; Recurse and do the next block.\n\t\t\t\t; XXX the block sizes are by powers of 2...\n\t\t\t\t; perhaps they should be something else?\n\t\t\t\t(diag-blocks rest (* 2 size) new-clist)\n\t\t\t)\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 667,
      "type": "FIXME",
      "content": "; XXX FIXME ... at the conclusion of this, we have a done list,",
      "context": "\n\t(print-concluding-report)\n\n\t; XXX FIXME ... at the conclusion of this, we have a done list,\n\t; which, because of repeated merging, might possibly have been\n\t; reduced to single senses, which can now be classified.\n)\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
      "line": 680,
      "type": "FIXME",
      "content": "; XXX FIXME, should probably use",
      "context": ";\n(define (load-stuff)\n\t(define start-time (get-internal-real-time))\n\t; XXX FIXME, should probably use\n\t; ((make-gram-class-api) 'fetch-pairs) instead.\n\t(display \"Start loading words and word-classes\\n\")\n\t(load-atoms-of-type 'WordNode)\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/agglo-pairwise.scm",
      "line": 51,
      "type": "FIXME",
      "content": "; XXX The below needs routines defined in `agglo-rank.scm`",
      "context": "(use-modules (opencog) (opencog matrix) (opencog persist))\n\n; ---------------------------------------------------------------\n; XXX The below needs routines defined in `agglo-rank.scm`\n\n(define-public (pair-wise-cluster LLOBJ NRANK LOOP-CNT)\n\"\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/cset-class.scm",
      "line": 148,
      "type": "TODO",
      "content": "; TODO: Evaluate if this function provides meaningful functionality.",
      "context": "; a disjunct with a connector that belongs to an existing WordClass.\n; The goal is to trim the list of sections to something smaller.\n;\n; TODO: Evaluate if this function provides meaningful functionality.\n; Consider refactoring or removing if performance impact is minimal.\n(define (get-all-sections-in-classes WCL)\n\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/cset-merge.scm",
      "line": 90,
      "type": "FIXME",
      "content": "; XXX Incomplete, in development.",
      "context": "(use-modules (opencog) (opencog sheaf) (opencog persist))\n\n; ---------------------------------------------------------------\n; XXX Incomplete, in development.\n\n(define (matching-sequences CON-A CON-B)\n\"\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/cset-merge.scm",
      "line": 149,
      "type": "FIXME",
      "content": "; XXX this is maybe-dead code, its only used by `fetch-mergable-sections`",
      "context": "; In most cases, this is not strictly necessary, as the usual case is\n; that all words and word-classes are already in RAM.\n;\n; XXX this is maybe-dead code, its only used by `fetch-mergable-sections`\n; below, which is not used anywhere...\n;\n(define (fetch-class-words CLS-LST)\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
      "line": 188,
      "type": "TODO",
      "content": "; TODO",
      "context": "; of the two is already a word-class, then the counts are simply moved\n; from the word to the class.\n;\n; TODO\n; ----\n; It might be useful to move the management of the MemberLink's to\n; the `add-gram-class-api` object.\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
      "line": 313,
      "type": "FIXME",
      "content": "; XXX TODO this should not be exported, not really.",
      "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (start-cluster LLOBJ CLS WA WB FRAC-FN NOISE MRG-CON)\n\"\n  start-cluster LLOBJ CLS WA WB FRAC-FN NOISE MRG-CON --\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
      "line": 409,
      "type": "FIXME",
      "content": "; XXX TODO this should not be exported, not really.",
      "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (merge-into-cluster LLOBJ CLS WA FRAC-FN NOISE MRG-CON)\n\"\n  merge-into-cluster LLOBJ CLS WA FRAC-FN MRG-CON --\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
      "line": 494,
      "type": "FIXME",
      "content": "; XXX TODO this should not be exported, not really.",
      "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (merge-clusters LLOBJ CLA CLB MRG-CON)\n\"\n  merge-clusters LLOBJ CLA CLB FRAC-FN MRG-CON --\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
      "line": 592,
      "type": "FIXME",
      "content": "; XXX TODO once make-merge-majority is done, this can be reimplemented",
      "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO once make-merge-majority is done, this can be reimplemented\n; as a special case of that. That means that the above three functions\n; can be discarded. It also means that `gram-class-api` 'make-cluster\n; method can be discarded or refactored.\n"
    },
    {
      "file": "components/language/learn/scm/attic/cluster/shape-project.scm",
      "line": 266,
      "type": "TODO",
      "content": "; todo",
      "context": "\t; updated CrossSection.\n\t(define (revise-xsect XST)\n; xxxxx\n; todo\n\t\t#f\n\t)\n\n"
    },
    {
      "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
      "line": 19,
      "type": "FIXME",
      "content": ";; XXX hack alert:",
      "context": ";\n; Needs the guile-dbi interfaces, in order to write the SQL files.\n;;\n;; XXX hack alert:\n;; TODO WordClassNode support might be .. funky.\n;; In particular, if a WordNode appears in a connector, it is replaced\n;; by all WordClasses that it might be a part of. This is an\n"
    },
    {
      "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
      "line": 20,
      "type": "TODO",
      "content": ";; TODO WordClassNode support might be .. funky.",
      "context": "; Needs the guile-dbi interfaces, in order to write the SQL files.\n;;\n;; XXX hack alert:\n;; TODO WordClassNode support might be .. funky.\n;; In particular, if a WordNode appears in a connector, it is replaced\n;; by all WordClasses that it might be a part of. This is an\n;; over-generalization, but needed for just right now.\n"
    },
    {
      "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
      "line": 94,
      "type": "FIXME",
      "content": "; XXX It would be nicer if we could avoid creating the ListLink",
      "context": "\t\t; cache is what is able to detect and re-emit a previously\n\t\t; issued link name.\n\t\t;\n\t\t; XXX It would be nicer if we could avoid creating the ListLink\n\t\t; below... use a pair-caching function of some kind ...\n\t\t(lambda (left-word right-word)\n\t\t\t(cache (ListLink left-word right-word)))\n"
    },
    {
      "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
      "line": 343,
      "type": "FIXME",
      "content": "; XXX This is a temp hack, because the classification code",
      "context": "\t\t\t(mk-cls-str germ-str) dj-str COST))\n\n\t\t; Might fail with \"UNIQUE constraint failed:\" so just warn.\n\t\t; XXX This is a temp hack, because the classification code\n\t\t; is not yet written.\n\t\t(let ((err-code (car (dbi-get_status db-obj)))\n\t\t\t\t(err-msg (cdr (dbi-get_status db-obj))))\n"
    },
    {
      "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
      "line": 72,
      "type": "FIXME",
      "content": "; XXX FIXME Both of these are global and stateful in LG and",
      "context": "  Parses are counted by updating the count on `(ParseNode \\\"MST\\\")`.\n  XXX TODO Make above configurable.\n\"\n\t; XXX FIXME Both of these are global and stateful in LG and\n\t; should be a property of the dict. They must not change,\n\t; once set.\n\t(define stol (if STORAGE (list STORAGE) '()))\n"
    },
    {
      "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
      "line": 132,
      "type": "FIXME",
      "content": "(count-one-atom mst-start)   ;; XXX tmp hack",
      "context": "\t\t\t(cog-extract-recursive! phrali)\n\t\t)\n\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n"
    },
    {
      "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
      "line": 133,
      "type": "FIXME",
      "content": "(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack",
      "context": "\t\t)\n\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n\t\t(monitor-parse-rate #f)\n"
    },
    {
      "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
      "line": 134,
      "type": "FIXME",
      "content": "(if timeo (count-one-atom mst-timeo)) ; XXX temp hack",
      "context": "\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n\t\t(monitor-parse-rate #f)\n\t)\n"
    },
    {
      "file": "components/language/learn/scm/attic/pair-count-new/word-pair-count.scm",
      "line": 121,
      "type": "FIXME",
      "content": "; XXX TODO: this should probably be converted to an 1xN matrix",
      "context": "\n\t; update-word-counts -- update the count of the individual words\n\t; in a parse.\n\t; XXX TODO: this should probably be converted to an 1xN matrix\n\t; and handled with a matrix API. The sentence count and parse\n\t; count should be marginals on this thing.\n\t(define (update-word-counts WRD-LIST)\n"
    },
    {
      "file": "components/language/learn/scm/attic/pair-count/clique-pair-count.scm",
      "line": 22,
      "type": "FIXME",
      "content": "; XXX FIXME we should probably not store this way. We should probably",
      "context": "; of N, a given word-pair might be observed with every possible\n; distance between them, i.e. up to N times.\n;\n; XXX FIXME we should probably not store this way. We should probably\n; have just one word-pair, and hold the counts in different values,\n; instead. This needs a code redesign. XXX\n;\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/agglo-mi-rank.scm",
      "line": 45,
      "type": "TODO",
      "content": "; TODO:",
      "context": "; Main entry point:\n; * Call `in-group-mi-cluster`, below.\n;\n; TODO:\n; * Before each merge step, a new AtomSpace frame should be created, so\n;   that the pre-merge data remains available.  This is not being done.\n;   It's really easy to add, but ... nothing needs this yet.\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/agglo-mi-rank.scm",
      "line": 205,
      "type": "FIXME",
      "content": "; XXX Is this really needed? Detailed balance means that neither",
      "context": "\t; count by the total count, and nothing more. The 'cache-left-entropy\n\t; just takes some logs, and nothing more.\n\t;\n\t; XXX Is this really needed? Detailed balance means that neither\n\t; the marginal counts on the DJ's, nor the marginal frrequency or\n\t; entropy should change. Validating that nothing changed could be\n\t; a reasonable data-integrity check.\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
      "line": 22,
      "type": "TODO",
      "content": "; TODO filter the top lists",
      "context": "  LLOBJ\n\n\"\n\t; TODO filter the top lists\n\t; (define (filter the top list...\n\n\t; TODO check if LLOBJ is a similrity object\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
      "line": 25,
      "type": "TODO",
      "content": "; TODO check if LLOBJ is a similrity object",
      "context": "\t; TODO filter the top lists\n\t; (define (filter the top list...\n\n\t; TODO check if LLOBJ is a similrity object\n\n\t; Wrap similarity, to create a new base object.\n\t(define sob (add-pair-stars LLOBJ))\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
      "line": 57,
      "type": "FIXME",
      "content": "; XXX todo store mean-rms on any-node.",
      "context": "\t(define goe (add-gaussian-ortho-api ami))\n\t(goe 'mean-rms)\n\n; XXX todo store mean-rms on any-node.\n\n\t(define gos (add-similarity-api ami #f \"goe\"))\n\t(define goec (add-similarity-compute goe))\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/gram-class-api.scm",
      "line": 65,
      "type": "FIXME",
      "content": "; XXX FIXME: this won't work for some classes, which store",
      "context": "\t(define (get-left-wildcard DJ) (ListLink any-left DJ))\n\n\t; Recycle the right wildcard from the parent class.\n\t; XXX FIXME: this won't work for some classes, which store\n\t; marginals in a different format than pairs. That is, the\n\t; 'right-element method will work correctly on pairs only,\n\t; not on marginals. For example, direct-sum is like that.\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/gram-class-api.scm",
      "line": 133,
      "type": "FIXME",
      "content": "; XXX FIXME the semantics of this thing is ugly, and should be",
      "context": "\t; return the existing class. If this is called a second time\n\t; with the same arguments, then a new, unique name is generated!\n\t; Therefore, this should never be called than once!\n\t; XXX FIXME the semantics of this thing is ugly, and should be\n\t; moved to the caller. We shouldn't have to second-guess the\n\t; callers dsired behavior!\n\t(define (make-cluster A-ATOM B-ATOM)\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/gram-majority.scm",
      "line": 205,
      "type": "FIXME",
      "content": "; XXX TODO this should be either",
      "context": "\t\t\t(<= vote-thresh\n\t\t\t\t(fold\n\t\t\t\t\t(lambda (WRD CNT)\n\t\t\t\t\t\t; XXX TODO this should be either\n\t\t\t\t\t\t; (if (< 0 (LLOBJ 'pair-count WRD DJ)) ...)\n\t\t\t\t\t\t; or it should be\n\t\t\t\t\t\t; (if (< NOISE (LLOBJ 'pair-count WRD DJ)) ...)\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/gram-majority.scm",
      "line": 465,
      "type": "FIXME",
      "content": "; XXX It would be nice to preserve history somehow, but how?",
      "context": "\t\t\t\tsublist)\n\n\t\t\t; Get rid of the class-membership.  This erases the history.\n\t\t\t; XXX It would be nice to preserve history somehow, but how?\n\t\t\t(cog-delete! dmemb))\n\n\t\t(for-each (lambda (WRD)\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/shape-project.scm",
      "line": 307,
      "type": "FIXME",
      "content": "; XXX TODO -- generic deletion should be moved to a method",
      "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO -- generic deletion should be moved to a method\n; on the base object -- probably to add-pair-stars. The extra\n; stuff like deleting crosses belongs in the shape-vec API.\n(define (remove-empty-sections LLOBJ ROW RMX)\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/shape-project.scm",
      "line": 369,
      "type": "FIXME",
      "content": "; FIXME but how?",
      "context": "\t; After doing the above, we may find that ROW has no more users,\n\t; anywhere, except in the marginals. We should clean those up\n\t; too, except we don't know what the marginals are. Alas!\n\t; FIXME but how?\n\n\t; (format #t \"Deleted ~A secs, ~A crosses for ~A\" ns nx ROW)\n)\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/shape-vec.scm",
      "line": 109,
      "type": "TODO",
      "content": "; TODO: with appropriate cleanup, this probably should be moved",
      "context": ";       (WordNode \"level\")\n;       (Shape ... the above shape))\n;\n; TODO: with appropriate cleanup, this probably should be moved\n; to a generic \"section\" or \"sheaf\" module.  That is because it\n; generically explodes a section into all of it's constituent\n; connector-shape pairs, which is presumably something everyone\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/shape-vec.scm",
      "line": 583,
      "type": "FIXME",
      "content": "; XXX FIXME: we should give the star-wild a unique name,",
      "context": "\t\t\t; (for-each extract-cross (LLOBJ 'get-all-elts))\n\n\t\t\t; Extracting the star-wild will clobber all CrossSections.\n\t\t\t; XXX FIXME: we should give the star-wild a unique name,\n\t\t\t; so we don't accidentally clobber CrossSections in other\n\t\t\t; objects.\n\t\t\t(for-each cog-extract-recursive! (cog-incoming-set star-wild))\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/singletons.scm",
      "line": 58,
      "type": "FIXME",
      "content": "; XXX this is broken",
      "context": "\t\t(throw 'missing-method 'add-singleton-classes\n\t\t\t\"The 'flatten method is needed to create singletons\\nUse `add-covering-sections` to get it.\"))\n\n\t; XXX this is broken\n\t(define (delete-singles)\n\t\t; delete each word-class node..\n\t\t(throw 'not-implemented 'add-singleton-classes\n"
    },
    {
      "file": "components/language/learn/scm/gram-class/singletons.scm",
      "line": 61,
      "type": "NotImplementedError",
      "content": "(throw 'not-implemented 'add-singleton-classes",
      "context": "\t; XXX this is broken\n\t(define (delete-singles)\n\t\t; delete each word-class node..\n\t\t(throw 'not-implemented 'add-singleton-classes\n\t\t\t\"This method is borken and don't work right!\")\n\t\t(for-each cog-delete-recursive!\n\t\t\t; make a list of word-classes containing only one word...\n"
    },
    {
      "file": "components/language/learn/scm/pair-count/word-pair-pipe.scm",
      "line": 24,
      "type": "TODO",
      "content": "; TODO:",
      "context": "; and\n;    run-common/cogserver-pair.scm:(define (observe-block-pairs TXT)\n;\n; TODO:\n; * Need ((add-count-api LLOBJ) 'count-key) to replace hard-coded count\n;   But this is not urgent, because the count-api itself is hard coded.\n\n"
    },
    {
      "file": "components/language/learn/scm/parse/lg-pipe-parser.scm",
      "line": 17,
      "type": "FIXME",
      "content": "; XXX FIXME. The next 30 lines of code are a cut-n-paste of the",
      "context": "(use-modules (opencog nlp) (opencog nlp lg-parse))\n(use-modules (opencog matrix))\n\n; XXX FIXME. The next 30 lines of code are a cut-n-paste of the\n; pair parsing pipeline code. It is needed because the batch processor\n; force-feeds use text, instead of allowing us to read on our own.\n; It just wires up a pipeline to feed text.\n"
    },
    {
      "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
      "line": 39,
      "type": "TODO",
      "content": "; TODO:",
      "context": ";   of the individual Edges in that Section. (The edges are effectively\n;   word-pairs, although this depends on the dictionary.)\n;\n; TODO:\n; * Need ((add-count-api LLOBJ) 'count-key) to replace hard-coded count\n;   But this is not urgent, because the count-api itself is hard coded.\n\n"
    },
    {
      "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
      "line": 195,
      "type": "FIXME",
      "content": "; XXX Hack to fetch sentence count from storage. XXX we should not",
      "context": "\t(define DICT (LgDict \"any\"))\n\t(define any-parse (ParseNode \"ANY\"))\n\n\t; XXX Hack to fetch sentence count from storage. XXX we should not\n\t; do it this way, and use a cleaner design but I'm in a hurry so....\n\t; XXX Need to fetch any-parse, too.\n\t; (define any-sent (SentenceNode \"ANY\"))\n"
    },
    {
      "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
      "line": 197,
      "type": "FIXME",
      "content": "; XXX Need to fetch any-parse, too.",
      "context": "\n\t; XXX Hack to fetch sentence count from storage. XXX we should not\n\t; do it this way, and use a cleaner design but I'm in a hurry so....\n\t; XXX Need to fetch any-parse, too.\n\t; (define any-sent (SentenceNode \"ANY\"))\n\t; (cog-execute! (FetchValueOf any-sent COUNT-PRED STORAGE\n\t;    (FloatValueOf COUNT-ZERO)))\n"
    },
    {
      "file": "components/language/learn/scm/utils/utilities.scm",
      "line": 377,
      "type": "FIXME",
      "content": "; FIXME: use a thread-safe test-n-set instead.",
      "context": "\t\t(define old (if v (cog-value->list v) '()))\n\t\t(define new (append old (list val)))\n\n\t\t; FIXME: use a thread-safe test-n-set instead.\n\t\t(cog-set-value! ATOM KEY (cog-new-value typ new)))\n)\n\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/lg-dict.scm",
      "line": 51,
      "type": "FIXME",
      "content": "; XXX Argh. This function gets called in par-map in sureal,",
      "context": "\t(define djset (cog-incoming-by-type WORD 'LgDisjunct))\n\t(if (nil? djset)\n\t\t(let ((dentry (LgDictEntry WORD (LgDictNode \"en\"))))\n\t\t\t; XXX Argh. This function gets called in par-map in sureal,\n\t\t\t; and because it races, the dentry could already be deleted\n\t\t\t; by now, in another thread. If so, the the cog-extract! throws.\n\t\t\t; Yuck.\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/scm/attic/nlp-utils.scm",
      "line": 134,
      "type": "TODO",
      "content": "; TODO: Consider refactoring this pattern to use GetLink syntax.",
      "context": "  one of DeclarativeSpeechAct, InterrogativeSpeechAct,\n  TruthQuerySpeechAct, etc...\n\"\n\t; TODO: Consider refactoring this pattern to use GetLink syntax.\n\t; A more concise GetLink syntax would improve readability and\n\t; allow writing link chases as sequences rather than nested calls.\n\n"
    },
    {
      "file": "ure/opencog/scm/opencog/ure/ure-utils.scm",
      "line": 1261,
      "type": "TODO",
      "content": "; TODO: Move logic to ForwardChainer.",
      "context": "\"\n; NOTE: It is simple b/c it doesn't try to restrict inference over a\n; certain source atoms.\n; TODO: Move logic to ForwardChainer.\n    (let* ((result (cog-fc RB-NODE (Set) #:focus-set (Set FOCUS-SET)))\n           (result-list (cog-outgoing-set result)))\n        ; Cleanup\n"
    },
    {
      "file": "ure/tests/ure/backwardchainer/scm/green-balls-targets.scm",
      "line": 105,
      "type": "TODO",
      "content": ";; TODO: the type of G should be further specified, such the number of",
      "context": "      ;; Evidence\n      (Set G))))\n\n;; TODO: the type of G should be further specified, such the number of\n;; elements, or possible range, as well as possible the type of each\n;; element, e.g. List, once the backward chainer supports deep types.\n"
    },
    {
      "file": "ure/tests/ure/rules/conditional-direct-evaluation.scm",
      "line": 11,
      "type": "TODO",
      "content": ";; TODO: we should make the evidence as premises. One way to do that",
      "context": ";; like an ImplicationLink, ImplicationScopeLink, InheritanceLink,\n;; etc.\n;;\n;; TODO: we should make the evidence as premises. One way to do that\n;; would be to calculate incrementally, keeping track of all evidence\n;; that have been used to calculate its TV and choose one that hasn't\n;; so been used so far. This would allow to evaluate evidence if\n"
    },
    {
      "file": "ure/tests/ure/rules/conditional-direct-evaluation.scm",
      "line": 22,
      "type": "TODO",
      "content": ";; TODO: turn that into a generator",
      "context": "(use-modules (opencog exec))\n(use-modules (opencog logger))\n\n;; TODO: turn that into a generator\n;; Implemented as a generator pattern for evidence calculation\n\n(define (evidence-generator antecedent-terms consequent-terms)\n"
    },
    {
      "file": "ure/tests/ure/rules/evidence-based-conditional-direct-evaluation.scm",
      "line": 31,
      "type": "TODO",
      "content": ";; TODO: resume once GlobNode is supported",
      "context": ";; evidence of the implication scope in the premise, and E is the new\n;; term of evidence.\n\n;; TODO: resume once GlobNode is supported\n\n(define evidence-based-conditional-direct-evaluation-implication-scope-rule\n  ;; (let* ((X (Variable \"$X\"))\n"
    },
    {
      "file": "ure/tests/ure/rules/implication-and-lambda-factorization-rule.scm",
      "line": 4,
      "type": "TODO",
      "content": ";; TODO: Replace this by higher order fact",
      "context": ";; =======================================================================\n;; ImplicationLink AndLink Lambda Factorization Rule\n;;\n;; TODO: Replace this by higher order fact\n;;\n;; AndLink\n;;    LambdaLink\n"
    },
    {
      "file": "ure/tests/ure/rules/implication-instantiation-rule.scm",
      "line": 141,
      "type": "TODO",
      "content": ";; TODO: To make this function better a form of partial pattern",
      "context": ";; 3. calculates its TV (just the TV on the implication link for now,\n;; in principle there might better ways)\n;;\n;; TODO: To make this function better a form of partial pattern\n;; matching should be supported. Probably enabling self grounding in\n;; the pattern matcher would do the trick (see\n;; PatternMatchEngine::self_compare)\n"
    },
    {
      "file": "ure/tests/ure/rules/implication-scope-to-implication-rule.scm",
      "line": 27,
      "type": "TODO",
      "content": ";; TODO: support VariableSet",
      "context": "        (VariableNode \"$TyVs\")\n        (TypeChoice\n           (TypeNode \"TypedVariableLink\")\n           ;; TODO: support VariableSet\n           (TypeNode \"VariableList\")))\n     (VariableNode \"$P\")\n     (VariableNode \"$Q\")))\n"
    },
    {
      "file": "ure/tests/ure/rules/intensional-inheritance-direct-introduction.scm",
      "line": 50,
      "type": "TODO",
      "content": ";; TODO: in order to add the Attraction links in the premises maybe an",
      "context": ";; relevant attraction links to be present in the atomspace in order\n;; to correctly calculate the TV.\n\n;; TODO: in order to add the Attraction links in the premises maybe an\n;; idea would be to introduce a has-closure predicate, such as\n;;\n;; Evaluation (stv 1 1)\n"
    },
    {
      "file": "ure/tests/ure/rules/pln-implication-and-lambda-factorization-rule.scm",
      "line": 4,
      "type": "TODO",
      "content": ";; TODO: Replace this by higher order fact",
      "context": ";; =======================================================================\n;; ImplicationLink AndLink Lambda Factorization Rule\n;;\n;; TODO: Replace this by higher order fact\n;;\n;; AndLink\n;;    LambdaLink\n"
    },
    {
      "file": "atomspace-restful/lib/zmq/zhelpers.hpp",
      "line": 31,
      "type": "TODO",
      "content": "// todo: package updated zmq.hpp",
      "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n"
    },
    {
      "file": "components/core/atomspace-restful/lib/zmq/zhelpers.hpp",
      "line": 31,
      "type": "TODO",
      "content": "// todo: package updated zmq.hpp",
      "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/csv/table_read.h",
      "line": 38,
      "type": "TODO",
      "content": "// TODO: Should this be a StringValue?",
      "context": "\nnamespace opencog {\n\n// TODO: Should this be a StringValue?\ntypedef std::vector<std::string> string_seq;\n\n/**\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.h",
      "line": 224,
      "type": "TODO",
      "content": "// TODO: we probably want to",
      "context": "\t */\n\tHandle consume_quotations() const;\n\tstatic Handle consume_quotations(const Variables& variables, const Handle& h,\n\t                                 // TODO: we probably want to\n\t                                 // move quotation,\n\t                                 // needless_quotation,\n\t                                 // clause_root and more in\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/TypeNode.h",
      "line": 90,
      "type": "FIXME",
      "content": "// XXX TODO ... Some types are defined. In this case,",
      "context": "\tstatic void validate(const std::string& str)\n\t{\n\t\tType t = nameserver().getType(str);\n\t\t// XXX TODO ... Some types are defined. In this case,\n\t\t// verify that the string occurs as a name inside\n\t\t// some DefineLink... if it does, then it's valid.\n\t\t// If it does not, then it's invalid.\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
      "line": 80,
      "type": "TODO",
      "content": "// TODO: it would probably be more efficient to swap which of these",
      "context": "\tHandle _handle;\n\tHandle _quote;\n\n\t// TODO: it would probably be more efficient to swap which of these\n\t// two is weak, since I think _outgoing is requested far more often\n\t// than _parent, and having it run faster would be a performance win.\n\tPatternTermPtr _parent;\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
      "line": 267,
      "type": "FIXME",
      "content": "if (itm->_handle == _handle) return true; // XXX maybe quote?",
      "context": "\n\tbool contained_in(const std::vector<PatternTermPtr>& vect) {\n\t\tfor (const PatternTermPtr& itm : vect)\n\t\t\tif (itm->_handle == _handle) return true; // XXX maybe quote?\n\t\treturn false;\n\t}\n\n"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.h",
      "line": 524,
      "type": "FIXME",
      "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
      "context": "\n    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n"
    },
    {
      "file": "atomspace/opencog/cython/PyIncludeWrapper.h",
      "line": 4,
      "type": "FIXME",
      "content": "// XXX Cython currently conflicts with standard C library definitions.",
      "context": "\n#ifdef HAVE_CYTHON\n\n// XXX Cython currently conflicts with standard C library definitions.\n// The push/pop below should hush it, for now. (needed for cython\n// 0.15.1 and maybe other versions)  FIXME someday...\n#ifdef _GNU_SOURCE\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX Extended to support optional arguments as list of handles",
      "context": "\t\t// These wrappers abstract the atomspace away.\n\t\tHandle (*_func_h_ah)(AtomSpace*, const Handle&);\n\t\tHandle (*_func_h_ahz)(AtomSpace*, const Handle&, size_t);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tHandle (*_func_h_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tHandle as_wrapper_h_h(Handle);\n\t\tHandle as_wrapper_h_hz(Handle, size_t);\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 55,
      "type": "FIXME",
      "content": "// XXX Extended to support optional arguments as list of handles",
      "context": "\t\t// These wrappers return a TruthValuePtr and abstract the\n\t\t// atomspace away.\n\t\tTruthValuePtr (*_pred_ah)(AtomSpace*, const Handle&);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tTruthValuePtr (*_pred_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tTruthValuePtr as_wrapper_p_h(Handle);\n\t\tTruthValuePtr as_wrapper_p_h_seq(Handle, const HandleSeq&);\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 61,
      "type": "FIXME",
      "content": "// XXX Extended to support optional arguments as list of handles",
      "context": "\t\tTruthValuePtr as_wrapper_p_h_seq(Handle, const HandleSeq&);\n\n\t\tValuePtr (*_proto_ah)(AtomSpace*, const Handle&);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tValuePtr (*_proto_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tValuePtr as_wrapper_v_h(Handle);\n\t\tValuePtr as_wrapper_v_h_seq(Handle, const HandleSeq&);\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 72,
      "type": "FIXME",
      "content": "// XXX Added support for optional arguments as list of handles",
      "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(Handle (*)(AtomSpace*, const Handle&, size_t),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(Handle (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&),\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 77,
      "type": "FIXME",
      "content": "// XXX Added support for optional arguments as list of handles",
      "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&),\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX Added support for optional arguments as list of handles",
      "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n};\n"
    },
    {
      "file": "cogutil/opencog/util/sigslot.h",
      "line": 74,
      "type": "FIXME",
      "content": "// XXX Something like this should work, but I can't get it to go.",
      "context": "\n#if BORKEN_FOR_SOME_REASON\n\t\t// Connect member of a given object.\n\t\t// XXX Something like this should work, but I can't get it to go.\n\t\t//\n\t\t// class Bar { public:\n\t\t//     void baz(int x, std::vector<int> y) {\n"
    },
    {
      "file": "cogutil/opencog/util/tree.h",
      "line": 2846,
      "type": "FIXME",
      "content": "// FIXME: add the other members of fixed_depth_iterator.",
      "context": "    return *this;\n}\n\n        // FIXME: add the other members of fixed_depth_iterator.\n\n\n// Sibling iterator\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.h",
      "line": 44,
      "type": "TODO",
      "content": "// TODO Why would one need to reset during psi-loop?",
      "context": "  friend class OpenPsiSatisfier;\n\n  // Needed for resetting private cache.\n  // TODO Why would one need to reset during psi-loop?\n  friend class ::OpenPsiImplicatorUTest;\n\npublic:\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 105,
      "type": "TODO",
      "content": "// TODO:add predicate to check for membership of category.",
      "context": "   * @param new_category The node reprsenting the new category.\n   * @return ConceptNode that represents the category.\n   */\n   // TODO:add predicate to check for membership of category.\n  Handle add_category(const Handle& new_category);\n\n  /**\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 126,
      "type": "TODO",
      "content": "// TODO Should these entries be a member of Rules class?",
      "context": "   * where queryis a PatternLink that isn't added to the atomspace, and\n   * is used to check if the rule is satisfiable.\n   */\n  // TODO Should these entries be a member of Rules class?\n  typedef std::tuple<HandleSeq, Handle, Handle, PatternLinkPtr> PsiTuple;\n\n  /**\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
      "line": 136,
      "type": "TODO",
      "content": "// TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,",
      "context": "   */\n  std::map<Handle, PsiTuple> _psi_rules;\n\n  // TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,\n  // because it might hinder interoperability with other components that\n  // expect an explicit ontological representation. For historic reasons we\n  // continue using such convention but should be replaced with graph that\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
      "line": 101,
      "type": "FIXME",
      "content": "// XXX This should be obsoleted by cond, at some point.",
      "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
      "line": 505,
      "type": "TODO",
      "content": "// TODO",
      "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
      "line": 795,
      "type": "TODO",
      "content": "//TODO",
      "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 98,
      "type": "FIXME",
      "content": "// XXX FIXME TODO: change the implementation, per the above note.",
      "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1089,
      "type": "FIXME",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1287,
      "type": "FIXME",
      "content": "// XXX TODO, it would be easier if KLD took a sorted list",
      "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1296,
      "type": "FIXME",
      "content": "// XXX review this, is this really correct?  At any rate,",
      "context": "        }\n\n        // KLD is negative; we want the IC to be postive.\n        // XXX review this, is this really correct?  At any rate,\n        // feature selection utterly fails with negative IC.\n        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1301,
      "type": "FIXME",
      "content": "// XXX TODO remove this print, for better performance.",
      "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.h",
      "line": 137,
      "type": "TODO",
      "content": "// TODO: reimplement loadITable with the same model of loadTable and",
      "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
      "line": 235,
      "type": "TODO",
      "content": "// TODO : lambda",
      "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
    },
    {
      "file": "components/learning/moses/moses/feature-selection/algo/simple.h",
      "line": 150,
      "type": "FIXME",
      "content": "//  XXX or use partial_sort, as mentioned above...",
      "context": "        }\n    } else {\n        // stair-step distribution: keep the top num_desired only.\n        //  XXX or use partial_sort, as mentioned above...\n        for (auto pr = sorted_flist.begin(); pr != sorted_flist.end(); pr++) {\n            final.insert(*pr->second.begin());\n            num_desired --;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/eda/local_structure.h",
      "line": 268,
      "type": "FIXME",
      "content": "// XXX ??? Huh? More details, please...",
      "context": "\n    // Now that we have created all of the dtrees, construct a\n    // feasible order that respects the initial dependencies\n    // XXX ??? Huh? More details, please... \n    randomized_topological_sort(_initial_deps, _ordering.begin());\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/eda/local_structure.h",
      "line": 285,
      "type": "TODO",
      "content": "// TODO: Clarify what statistics are being accumulated and where they are stored.",
      "context": "// each variable in the field set (and more, for contins & terms).  So,\n// iterate over the dtrees, and accumulate statistics.\n//\n// TODO: Clarify what statistics are being accumulated and where they are stored.\n// This function processes decision trees and updates the destination model.\ntemplate<typename It>\nvoid local_structure_probs_learning::operator()(const field_set& fs,\n"
    },
    {
      "file": "components/learning/moses/moses/moses/eda/replacement.h",
      "line": 62,
      "type": "TODO",
      "content": "// TODO: I think it might be a little more efficent to use the",
      "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
    },
    {
      "file": "components/learning/moses/moses/moses/main/problem-params.h",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX FIXME TODO The structure below should be split into multiple",
      "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
      "line": 535,
      "type": "TODO",
      "content": "// TODO: we may want to output the visited status as well",
      "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/types.h",
      "line": 189,
      "type": "FIXME",
      "content": "// XXX wouldn't it be better to store ints here ??",
      "context": "/// by a single call of the deme expander. The initial metapopulation\n/// comes from demeID \"0\".\n//\n// XXX wouldn't it be better to store ints here ??\nstruct demeID_t : public std::string\n{\n    demeID_t(unsigned expansion = 0 /* default initial deme */);\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/types.h",
      "line": 210,
      "type": "TODO",
      "content": "// TODO this should be a std::valarray not std::vector but I am too",
      "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX This parameter should probably be automatically adjusted with",
      "context": "    // RAM in the instance_set, and its not currently obvious that a full\n    // scan is that much better than a random sampling.  XXX Or is it?\n    //\n    // XXX This parameter should probably be automatically adjusted with\n    // free RAM availability!?  Or something like that !?\n    //\n    // Nil: If it is adjusted with free RAM it should be able to be\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 97,
      "type": "FIXME",
      "content": "// XXX I don't understand what the below is saying.",
      "context": "    // by not doing an exhaustive search, the run-time can be significantly\n    // improved.\n    //\n    // XXX I don't understand what the below is saying.\n    // One should probably try first to tweak pop_size_ratio to\n    // control the allocation of resources. However in some cases (for\n    // instance when hill_climbing is used for feature-selection),\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 103,
      "type": "FIXME",
      "content": "// XXX pop_size_ratio disabled in hill-climbing, since its definition",
      "context": "    // instance when hill_climbing is used for feature-selection),\n    // there is only one deme to explore and tweaking that parameter\n    // can make a difference (breadth vs depth)\n    // XXX pop_size_ratio disabled in hill-climbing, since its definition\n    // was insane/non-sensical.  I can't figure out how it was supposed\n    // to work.\n    double fraction_of_nn;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 110,
      "type": "FIXME",
      "content": "// XXX TODO make sure this value is appropriately updated.",
      "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
      "line": 281,
      "type": "FIXME",
      "content": "// XXX In fact, all of the current code uses this entry point, no one",
      "context": "                    time_t max_time);\n\n    // Like above but assumes that init_inst is null (backward compatibility)\n    // XXX In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/optimization.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
      "context": "                     score_t _min_score_improv = 0.5);\n\n    // N = p.popsize_ratio * n^1.05\n    // XXX Why n^1.05 ??? This is going to have a significant effect\n    // (as compared to n^1.00) only when n is many thousands or bigger...\n    unsigned pop_size(const field_set& fs) const;\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 45,
      "type": "FIXME",
      "content": "// XXX PSO parameters hardcoded just for now.",
      "context": "// Applied Soft Computing 21 (2014): 554-567.\n\n// Particle Swarm parameters\n// XXX PSO parameters hardcoded just for now.\nstruct ps_parameters\n{\n    // There isn't need to set all this parameters, for most\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX I have to find the best values for bit and disc.",
      "context": "    unsigned max_parts;\n\n    // For continuous problems, 0.7 and 1.43 are good values.\n    // XXX I have to find the best values for bit and disc.\n    // Information from: M. Clerc, L\u2019optimisation par essaim particulaire: versions\n    // param\u00e9triques et adaptatives, Hermes Science Publications, Lavoisier, Paris, 2005.\n    double bit_c1, disc_c1, cont_c1; // c1 = Individual learning rate.\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 133,
      "type": "FIXME",
      "content": "// XXX If i have time, i'll put some variation here to get a better global search.",
      "context": "    // sional data sets, in: Proceedings of 22th International IEEE Conference on Tools\n    // with Artificial Intelligence IEEE-ICTAI, vol. 1, Arras, France, 27\u201329 October 2010,\n    // 2010, pp. 87\u201393.\n    // XXX If i have time, i'll put some variation here to get a better global search.\n    double bit_min_value, bit_max_value, // [0,1] <- XXX these two aren't used yet.\n           disc_min_value, disc_max_value, // [0,1] in rounding off\n           cont_min_value, cont_max_value; // [min contin_t, max contin_t]\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 154,
      "type": "TODO",
      "content": "// TODO: pso description",
      "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 253,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        check_bit_vel(vel);\n    }\n\n    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 256,
      "type": "FIXME",
      "content": "(1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)",
      "context": "    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n    }\n\n    void update_bit_particle(instance& temp, const instance& personal,\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 281,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        return (disc_t) std::round(cvalue * (max_dvalue - 1)); // Return dvalue\n    }\n\n    // XXX Explanation\n    disc_t new_disc_value(double& cvalue,\n            const double& vel, const unsigned max_dvalue){\n        cvalue += vel;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 303,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        check_cont_vel(vel);\n    }\n\n    // XXX Explanation\n    contin_t new_cont_value(const contin_t& value, const double& vel){\n        // Wind dispersion enter here.\n        contin_t res = value + vel;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 315,
      "type": "TODO",
      "content": "// TODO: Wind dispersion, but test without first",
      "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      "line": 340,
      "type": "FIXME",
      "content": "// XXX This could help PSO if we maintain the best particle.",
      "context": "    // Like above but assumes that init_inst is null (backward compatibility)\n    // In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    // XXX This could help PSO if we maintain the best particle.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n                    unsigned max_evals,\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/field_set.h",
      "line": 213,
      "type": "FIXME",
      "content": "// XXX should be enum ...",
      "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
      "line": 89,
      "type": "FIXME",
      "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
      "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/knobs.h",
      "line": 225,
      "type": "FIXME",
      "content": "// XXX This uses reduct::logical_reduction rules; it is not clear if those",
      "context": "// A unary function knob: this knob negates (or not) a boolean-valued\n// tree underneath it.\n//\n// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/knobs.h",
      "line": 228,
      "type": "FIXME",
      "content": "// XXX what is the difference between \"present\" and \"absent\" ??? A",
      "context": "// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n// knob that is \"absent\" from a logical \"or\" is the same as \"present\n// and false\".  while one that is absent from a logical \"and\" is the\n// same as \"present and true\" So I think this is a bit confusing ...\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/knobs.h",
      "line": 237,
      "type": "FIXME",
      "content": "// XXX Also -- I think I want to rename this to \"logical unary knob\",",
      "context": "// overall, this is confusing without some sort of additional\n// justification.\n//\n// XXX Also -- I think I want to rename this to \"logical unary knob\",\n// or something like that, as it is a unary logical function ... err...\n// well, I guess all combo opers are unary, due to Currying.\n//\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/knobs.h",
      "line": 283,
      "type": "TODO",
      "content": "// TODO: Clarify the canonization behavior for parent-child relationships.",
      "context": "#define MAX_PERM_ACTIONS 128\n\n// Note - children aren't canonized when parents are called.\n// TODO: Clarify the canonization behavior for parent-child relationships.\nstruct action_subtree_knob : public discrete_knob<MAX_PERM_ACTIONS>\n{\n    typedef combo_tree::pre_order_iterator pre_it;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
      "line": 124,
      "type": "FIXME",
      "content": "// XXX TODO should be a std::valarray not a vector.",
      "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
    },
    {
      "file": "ggml-tensor-kernel/include/atomspace_stub.h",
      "line": 550,
      "type": "stub",
      "content": "// Stub: just log the evaluation",
      "context": "    }\n    \n    void eval(const std::string& expression) {\n        // Stub: just log the evaluation\n        logger().debug(\"SchemeEval: %s\", expression.c_str());\n    }\n    \n"
    },
    {
      "file": "ggml-tensor-kernel/include/atomspace_stub.h",
      "line": 555,
      "type": "stub",
      "content": "// Stub: return undefined handle",
      "context": "    }\n    \n    Handle eval_h(const std::string& expression) {\n        // Stub: return undefined handle\n        logger().debug(\"SchemeEval eval_h: %s\", expression.c_str());\n        return Handle::UNDEFINED;\n    }\n"
    },
    {
      "file": "ggml-tensor-kernel/include/atomspace_stub.h",
      "line": 561,
      "type": "stub",
      "content": "// Stub: return empty string",
      "context": "    }\n    \n    std::string eval_str(const std::string& expression) {\n        // Stub: return empty string\n        logger().debug(\"SchemeEval eval_str: %s\", expression.c_str());\n        return \"\";\n    }\n"
    },
    {
      "file": "ggml-tensor-kernel/include/ggml-cpu.h",
      "line": 16,
      "type": "stub",
      "content": "// Stub implementation",
      "context": "\n// CPU backend initialization (stub - does nothing)\nstatic inline void ggml_cpu_init(void) {\n    // Stub implementation\n}\n\n#ifdef __cplusplus\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/vertex.h",
      "line": 101,
      "type": "FIXME",
      "content": "// XXX This should be obsoleted by cond, at some point.",
      "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/vertex.h",
      "line": 505,
      "type": "TODO",
      "content": "// TODO",
      "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/vertex.h",
      "line": 795,
      "type": "TODO",
      "content": "//TODO",
      "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 99,
      "type": "FIXME",
      "content": "// XXX FIXME TODO: change the implementation, per the above note.",
      "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 684,
      "type": "FIXME",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 688,
      "type": "FIXME",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1126,
      "type": "FIXME",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1344,
      "type": "FIXME",
      "content": "// XXX TODO, it would be easier if KLD took a sorted list",
      "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1353,
      "type": "FIXME",
      "content": "// XXX review this, is this really correct?  At any rate,",
      "context": "        }\n\n        // KLD is negative; we want the IC to be postive.\n        // XXX review this, is this really correct?  At any rate,\n        // feature selection utterly fails with negative IC.\n        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1358,
      "type": "FIXME",
      "content": "// XXX TODO remove this print, for better performance.",
      "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.h",
      "line": 137,
      "type": "TODO",
      "content": "// TODO: reimplement loadITable with the same model of loadTable and",
      "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
    },
    {
      "file": "moses/moses/comboreduct/type_checker/type_tree.h",
      "line": 235,
      "type": "TODO",
      "content": "// TODO : lambda",
      "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
    },
    {
      "file": "moses/moses/feature-selection/algo/simple.h",
      "line": 150,
      "type": "FIXME",
      "content": "//  XXX or use partial_sort, as mentioned above...",
      "context": "        }\n    } else {\n        // stair-step distribution: keep the top num_desired only.\n        //  XXX or use partial_sort, as mentioned above...\n        for (auto pr = sorted_flist.begin(); pr != sorted_flist.end(); pr++) {\n            final.insert(*pr->second.begin());\n            num_desired --;\n"
    },
    {
      "file": "moses/moses/moses/eda/local_structure.h",
      "line": 268,
      "type": "FIXME",
      "content": "// XXX ??? Huh? More details, please...",
      "context": "\n    // Now that we have created all of the dtrees, construct a\n    // feasible order that respects the initial dependencies\n    // XXX ??? Huh? More details, please... \n    randomized_topological_sort(_initial_deps, _ordering.begin());\n}\n\n"
    },
    {
      "file": "moses/moses/moses/eda/local_structure.h",
      "line": 285,
      "type": "TODO",
      "content": "// TODO: Clarify what statistics are being accumulated and where they are stored.",
      "context": "// each variable in the field set (and more, for contins & terms).  So,\n// iterate over the dtrees, and accumulate statistics.\n//\n// TODO: Clarify what statistics are being accumulated and where they are stored.\n// This function processes decision trees and updates the destination model.\ntemplate<typename It>\nvoid local_structure_probs_learning::operator()(const field_set& fs,\n"
    },
    {
      "file": "moses/moses/moses/eda/replacement.h",
      "line": 62,
      "type": "TODO",
      "content": "// TODO: I think it might be a little more efficent to use the",
      "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
    },
    {
      "file": "moses/moses/moses/main/problem-params.h",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX FIXME TODO The structure below should be split into multiple",
      "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/metapopulation.h",
      "line": 535,
      "type": "TODO",
      "content": "// TODO: we may want to output the visited status as well",
      "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
    },
    {
      "file": "moses/moses/moses/moses/moses_main.h",
      "line": 102,
      "type": "FIXME",
      "content": "// XXX TODO this should be fixed, someday...",
      "context": "        // messages.  In fact, the mpi workers should not even have\n        // a printer at all, or use a null_printer.  Unfortunately,\n        // the current code structure makes this hard to implement.\n        // XXX TODO this should be fixed, someday...\n        if (is_mpi && metapop.size() == 0)\n            return;\n\n"
    },
    {
      "file": "moses/moses/moses/moses/neighborhood_sampling.h",
      "line": 327,
      "type": "FIXME",
      "content": "// XXX TODO, unroll the last tail call, just like the single-bit",
      "context": "        else\n        {\n            // Recursive call, moved for one position\n            // XXX TODO, unroll the last tail call, just like the single-bit\n            // knob case, below.\n            out = vary_n_knobs(fs, tmp_inst, dist, starting_index + 1, out, end);\n            // Left<->Right\n"
    },
    {
      "file": "moses/moses/moses/moses/types.h",
      "line": 189,
      "type": "FIXME",
      "content": "// XXX wouldn't it be better to store ints here ??",
      "context": "/// by a single call of the deme expander. The initial metapopulation\n/// comes from demeID \"0\".\n//\n// XXX wouldn't it be better to store ints here ??\nstruct demeID_t : public std::string\n{\n    demeID_t(unsigned expansion = 0 /* default initial deme */);\n"
    },
    {
      "file": "moses/moses/moses/moses/types.h",
      "line": 210,
      "type": "TODO",
      "content": "// TODO this should be a std::valarray not std::vector but I am too",
      "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX This parameter should probably be automatically adjusted with",
      "context": "    // RAM in the instance_set, and its not currently obvious that a full\n    // scan is that much better than a random sampling.  XXX Or is it?\n    //\n    // XXX This parameter should probably be automatically adjusted with\n    // free RAM availability!?  Or something like that !?\n    //\n    // Nil: If it is adjusted with free RAM it should be able to be\n"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 97,
      "type": "FIXME",
      "content": "// XXX I don't understand what the below is saying.",
      "context": "    // by not doing an exhaustive search, the run-time can be significantly\n    // improved.\n    //\n    // XXX I don't understand what the below is saying.\n    // One should probably try first to tweak pop_size_ratio to\n    // control the allocation of resources. However in some cases (for\n    // instance when hill_climbing is used for feature-selection),\n"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 103,
      "type": "FIXME",
      "content": "// XXX pop_size_ratio disabled in hill-climbing, since its definition",
      "context": "    // instance when hill_climbing is used for feature-selection),\n    // there is only one deme to explore and tweaking that parameter\n    // can make a difference (breadth vs depth)\n    // XXX pop_size_ratio disabled in hill-climbing, since its definition\n    // was insane/non-sensical.  I can't figure out how it was supposed\n    // to work.\n    double fraction_of_nn;\n"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 110,
      "type": "FIXME",
      "content": "// XXX TODO make sure this value is appropriately updated.",
      "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n"
    },
    {
      "file": "moses/moses/moses/optimization/hill-climbing.h",
      "line": 281,
      "type": "FIXME",
      "content": "// XXX In fact, all of the current code uses this entry point, no one",
      "context": "                    time_t max_time);\n\n    // Like above but assumes that init_inst is null (backward compatibility)\n    // XXX In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
    },
    {
      "file": "moses/moses/moses/optimization/optimization.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
      "context": "                     score_t _min_score_improv = 0.5);\n\n    // N = p.popsize_ratio * n^1.05\n    // XXX Why n^1.05 ??? This is going to have a significant effect\n    // (as compared to n^1.00) only when n is many thousands or bigger...\n    unsigned pop_size(const field_set& fs) const;\n\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 45,
      "type": "FIXME",
      "content": "// XXX PSO parameters hardcoded just for now.",
      "context": "// Applied Soft Computing 21 (2014): 554-567.\n\n// Particle Swarm parameters\n// XXX PSO parameters hardcoded just for now.\nstruct ps_parameters\n{\n    // There isn't need to set all this parameters, for most\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX I have to find the best values for bit and disc.",
      "context": "    unsigned max_parts;\n\n    // For continuous problems, 0.7 and 1.43 are good values.\n    // XXX I have to find the best values for bit and disc.\n    // Information from: M. Clerc, L\u2019optimisation par essaim particulaire: versions\n    // param\u00e9triques et adaptatives, Hermes Science Publications, Lavoisier, Paris, 2005.\n    double bit_c1, disc_c1, cont_c1; // c1 = Individual learning rate.\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 133,
      "type": "FIXME",
      "content": "// XXX If i have time, i'll put some variation here to get a better global search.",
      "context": "    // sional data sets, in: Proceedings of 22th International IEEE Conference on Tools\n    // with Artificial Intelligence IEEE-ICTAI, vol. 1, Arras, France, 27\u201329 October 2010,\n    // 2010, pp. 87\u201393.\n    // XXX If i have time, i'll put some variation here to get a better global search.\n    double bit_min_value, bit_max_value, // [0,1] <- XXX these two aren't used yet.\n           disc_min_value, disc_max_value, // [0,1] in rounding off\n           cont_min_value, cont_max_value; // [min contin_t, max contin_t]\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 154,
      "type": "TODO",
      "content": "// TODO: pso description",
      "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 253,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        check_bit_vel(vel);\n    }\n\n    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 256,
      "type": "FIXME",
      "content": "(1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)",
      "context": "    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n    }\n\n    void update_bit_particle(instance& temp, const instance& personal,\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 281,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        return (disc_t) std::round(cvalue * (max_dvalue - 1)); // Return dvalue\n    }\n\n    // XXX Explanation\n    disc_t new_disc_value(double& cvalue,\n            const double& vel, const unsigned max_dvalue){\n        cvalue += vel;\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 303,
      "type": "FIXME",
      "content": "// XXX Explanation",
      "context": "        check_cont_vel(vel);\n    }\n\n    // XXX Explanation\n    contin_t new_cont_value(const contin_t& value, const double& vel){\n        // Wind dispersion enter here.\n        contin_t res = value + vel;\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 315,
      "type": "TODO",
      "content": "// TODO: Wind dispersion, but test without first",
      "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.h",
      "line": 340,
      "type": "FIXME",
      "content": "// XXX This could help PSO if we maintain the best particle.",
      "context": "    // Like above but assumes that init_inst is null (backward compatibility)\n    // In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    // XXX This could help PSO if we maintain the best particle.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n                    unsigned max_evals,\n"
    },
    {
      "file": "moses/moses/moses/representation/field_set.h",
      "line": 213,
      "type": "FIXME",
      "content": "// XXX should be enum ...",
      "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
    },
    {
      "file": "moses/moses/moses/representation/instance_scorer.h",
      "line": 89,
      "type": "FIXME",
      "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
      "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
    },
    {
      "file": "moses/moses/moses/representation/knobs.h",
      "line": 200,
      "type": "FIXME",
      "content": "// XXX Huh?? what does this do?? Why does shifting matter,",
      "context": "    int _default;\n    int _current;   // The current knob setting.\n\n    // XXX Huh?? what does this do?? Why does shifting matter,\n    // if the only thing done is to count the number of bits set ??\n    // WTF ??  I think the shift is n the  wrong direction, yeah?\n    // If the goal is to skip over index values that are disallowed, then\n"
    },
    {
      "file": "moses/moses/moses/representation/knobs.h",
      "line": 218,
      "type": "FIXME",
      "content": "// XXX This uses reduct::logical_reduction rules; it is not clear if those",
      "context": "// A unary function knob: this knob negates (or not) a boolean-valued\n// tree underneath it.\n//\n// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n"
    },
    {
      "file": "moses/moses/moses/representation/knobs.h",
      "line": 221,
      "type": "FIXME",
      "content": "// XXX what is the difference between \"present\" and \"absent\" ??? A",
      "context": "// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n// knob that is \"absent\" from a logical \"or\" is the same as \"present\n// and false\".  while one that is absent from a logical \"and\" is the\n// same as \"present and true\" So I think this is a bit confusing ...\n"
    },
    {
      "file": "moses/moses/moses/representation/knobs.h",
      "line": 230,
      "type": "FIXME",
      "content": "// XXX Also -- I think I want to rename this to \"logical unary knob\",",
      "context": "// overall, this is confusing without some sort of additional\n// justification.\n//\n// XXX Also -- I think I want to rename this to \"logical unary knob\",\n// or something like that, as it is a unary logical function ... err...\n// well, I guess all combo opers are unary, due to Currying.\n//\n"
    },
    {
      "file": "moses/moses/moses/representation/knobs.h",
      "line": 276,
      "type": "TODO",
      "content": "// TODO: Clarify the canonization behavior for parent-child relationships.",
      "context": "#define MAX_PERM_ACTIONS 128\n\n// Note - children aren't canonized when parents are called.\n// TODO: Clarify the canonization behavior for parent-child relationships.\nstruct action_subtree_knob : public discrete_knob<MAX_PERM_ACTIONS>\n{\n    typedef combo_tree::pre_order_iterator pre_it;\n"
    },
    {
      "file": "moses/moses/moses/scoring/scoring_base.h",
      "line": 124,
      "type": "FIXME",
      "content": "// XXX TODO should be a std::valarray not a vector.",
      "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 136,
      "type": "stub",
      "content": "// Stub types when Link Grammar is not available",
      "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 138,
      "type": "stub",
      "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
      "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 139,
      "type": "stub",
      "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
      "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 48,
      "type": "TODO",
      "content": "// TODO: the notion of equality between 2 CHandles might one where",
      "context": "public:\n\t// Contextual Handle\n\t//\n\t// TODO: the notion of equality between 2 CHandles might one where\n\t// the Context isn't necessarily equal but where the 2 handles\n\t// (besides being equal) have the same quotation and same\n\t// (free inter shadow) variables.\n"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 159,
      "type": "TODO",
      "content": "// TODO: the type of a typed block is currently a handle of the",
      "context": "\t// the simplest satisfiable solution set.\n\tstatic const Partitions empty_partition_singleton;\n\n\t// TODO: the type of a typed block is currently a handle of the\n\t// variable or ground it is exists, instead of an actual type.\n\tstruct SolutionSet : Partitions\n\t{\n"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 188,
      "type": "TODO",
      "content": "// TODO: maybe we could simplify a great deal of code by replacing",
      "context": "\t// Subtitution values and their corresponding variable declaration\n\t// after substitution (cause some values may be variables).\n\t//\n\t// TODO: maybe we could simplify a great deal of code by replacing\n\t// Handle by Variables.\n\ttypedef std::map<HandleCHandleMap, Handle> TypedSubstitutions;\n\ttypedef std::pair<HandleCHandleMap, Handle> TypedSubstitution;\n"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 521,
      "type": "TODO",
      "content": "public:                         // TODO: being friend with UnifyUTest",
      "context": "\t// Memoization cache for unification results\n\tmutable std::map<std::pair<CHandle, CHandle>, SolutionSet> _unify_cache;\n\npublic:                         // TODO: being friend with UnifyUTest\n\t/**\n\t * Set Unify::_variables given the variable declarations of the\n\t * two terms to unify.\n"
    },
    {
      "file": "unify/opencog/unify/Unify.h",
      "line": 601,
      "type": "TODO",
      "content": "public:                         // TODO: being friend with UnifyUTest",
      "context": "\t */\n\tSolutionSet mkvarsol(CHandle lhs, CHandle rhs) const;\n\npublic:                         // TODO: being friend with UnifyUTest\n                                // somehow doesn't work\n\t/**\n\t * Join 2 solution sets. Generate the product of all consistent\n"
    },
    {
      "file": "ure/opencog/ure/Rule.h",
      "line": 373,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\t// True if the rule has already been applied.\n\tbool _exhausted;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n\n\t// Return a copy of the rule with the variables alpha-converted\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.h",
      "line": 72,
      "type": "TODO",
      "content": "// TODO: Maybe this should be moved to BackwardChainer",
      "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BackwardChainer.h",
      "line": 232,
      "type": "TODO",
      "content": "// TODO: perhaps move that under BIT",
      "context": "\t// Structure holding the Back Inference Tree\n\tBIT _bit;\n\n\t// TODO: perhaps move that under BIT\n\tAndBITFitness _andbit_fitness;\n\n\t// In charge of recording the inference traces\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/ControlPolicy.h",
      "line": 45,
      "type": "TODO",
      "content": "// TODO: maybe wrap that in a class, and use it in foward chainer",
      "context": "// selected rule fulfills the objective, which must be passed\n// to the BIT to calculate the and-BIT complexity.\n//\n// TODO: maybe wrap that in a class, and use it in foward chainer\ntypedef std::pair<RuleTypedSubstitutionPair, double> RuleSelection;\n\nclass ControlPolicy\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/Fitness.h",
      "line": 75,
      "type": "TODO",
      "content": "// TODO: we may want to move the arguments in its own class if it",
      "context": "\t\tTrace\n\t};\n\n\t// TODO: we may want to move the arguments in its own class if it\n\t// grows bigger.\n\tAndBITFitness(FitnessType ft=Uniform,\n\t              const std::set<ContentHash>& tr=std::set<ContentHash>());\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/Fitness.h",
      "line": 92,
      "type": "TODO",
      "content": "// TODO: replace by class dedicated to hold the parameters",
      "context": "\tdouble operator()(const AndBIT& andbit) const;\n\nprivate:\n\t// TODO: replace by class dedicated to hold the parameters\n\tstd::set<ContentHash> _trace;\n};\n\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
      "line": 94,
      "type": "TODO",
      "content": "// TODO: the TV on the evaluation link should be more carefully",
      "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/FCStat.h",
      "line": 76,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\tstd::vector<InferenceRecord> _inf_rec;\n\tAtomSpace* _trace_as;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n};\n\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
      "line": 237,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\n\tbool _search_focus_set;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
      "line": 241,
      "type": "TODO",
      "content": "// TODO: use shared mutexes",
      "context": "\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n\t// TODO: use shared mutexes\n\tmutable std::mutex _rules_mutex;\n\n\t// Keep track of the number of threads to make sure\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceRuleSet.h",
      "line": 102,
      "type": "TODO",
      "content": "// TODO: implement tournament selection as well, as a cheaper",
      "context": "\t */\n\tstd::pair<SourceRule, TruthValuePtr> thompson_select();\n\n\t// TODO: implement tournament selection as well, as a cheaper\n\t// alternative to Thompson sampling.\n\n\t/**\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 54,
      "type": "TODO",
      "content": "// TODO: this class has thing in common with AndBIT, maybe their",
      "context": " *\n * 4. a flag call indicating if the source expansions have been exhausted.\n */\n// TODO: this class has thing in common with AndBIT, maybe their\n// common things could be placed in a parent class.\nclass Source : public boost::totally_ordered<Source>\n{\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 151,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "\tRuleSet rules;\n\nprivate:\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 165,
      "type": "TODO",
      "content": "// TODO: this class has things in common with BIT, maybe their common",
      "context": "/**\n * Population of sources to forwardly expand. Primary owner.\n */\n// TODO: this class has things in common with BIT, maybe their common\n// things could be placed in a parent class.\nclass SourceSet\n{\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
      "line": 223,
      "type": "TODO",
      "content": "// TODO: subdivide in smaller and shared mutexes",
      "context": "private:\n\tconst UREConfig& _config;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
    },
    {
      "file": "cogutil/opencog/util/getopt_long.c",
      "line": 110,
      "type": "FIXME",
      "content": "/* XXX: GNU ignores PC if *options == '-' */",
      "context": "                      || (IGNORE_FIRST && options[1] != ':')))\n#define IS_POSIXLY_CORRECT (getenv(\"POSIXLY_CORRECT\") != NULL)\n#define PERMUTE         (!IS_POSIXLY_CORRECT && !IGNORE_FIRST)\n/* XXX: GNU ignores PC if *options == '-' */\n#define IN_ORDER        (!IS_POSIXLY_CORRECT && *options == '-')\n\n/* return values */\n"
    },
    {
      "file": "cogutil/opencog/util/getopt_long.c",
      "line": 127,
      "type": "FIXME",
      "content": "/* XXX: set optreset to 1 rather than these two */",
      "context": "\nstatic char *place = EMSG; /* option letter processing */\n\n/* XXX: set optreset to 1 rather than these two */\nstatic int nonopt_start = -1; /* first non option argument (for permute) */\nstatic int nonopt_end = -1;   /* first option after non options (for permute) */\n\n"
    },
    {
      "file": "cogutil/opencog/util/getopt_long.c",
      "line": 306,
      "type": "FIXME",
      "content": "/* XXX: what if no long options provided (called by getopt)? */",
      "context": "        return BADCH;\n    }\n    if (optchar == 'W' && oli[1] == ';') {      /* -W long-option */\n        /* XXX: what if no long options provided (called by getopt)? */\n        if (*place) \n            return -2;\n\n"
    },
    {
      "file": "cogutil/opencog/util/getopt_long.c",
      "line": 335,
      "type": "FIXME",
      "content": "/* XXX: disable test for :: if PC? (GNU doesn't) */",
      "context": "        optarg = NULL;\n        if (*place)         /* no white space */\n            optarg = place;\n        /* XXX: disable test for :: if PC? (GNU doesn't) */\n        else if (oli[1] != ':') {   /* arg not optional */\n            if (++optind >= nargc) {    /* no arg */\n                place = EMSG;\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/wordnet-import/wni.c",
      "line": 340,
      "type": "FIXME",
      "content": "// XXX ?? is there some reason these are not \"DefinedLinguisticConceptNode\" ??",
      "context": "\texit(0);\n#endif\n\n\t// XXX ?? is there some reason these are not \"DefinedLinguisticConceptNode\" ??\n\t// I'd think they should be, right ... ? Is this a bug ??\n\tprintf(\"scm\\n\");\n\tprintf(\"(define noun (ConceptNode \\\"noun\\\"))\\n\");\n"
    },
    {
      "file": "ggml-tensor-kernel/src/ggml_stub.c",
      "line": 136,
      "type": "stub",
      "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
      "context": "\n// Math operations (simplified stubs)\nstruct ggml_tensor* ggml_add(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_mul(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n"
    },
    {
      "file": "ggml-tensor-kernel/src/ggml_stub.c",
      "line": 140,
      "type": "stub",
      "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
      "context": "}\n\nstruct ggml_tensor* ggml_mul(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_mul_mat(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n"
    },
    {
      "file": "ggml-tensor-kernel/src/ggml_stub.c",
      "line": 144,
      "type": "stub",
      "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
      "context": "}\n\nstruct ggml_tensor* ggml_mul_mat(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_soft_max(struct ggml_context* ctx, struct ggml_tensor* a) {\n"
    },
    {
      "file": "ggml-tensor-kernel/src/ggml_stub.c",
      "line": 148,
      "type": "stub",
      "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
      "context": "}\n\nstruct ggml_tensor* ggml_soft_max(struct ggml_context* ctx, struct ggml_tensor* a) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_relu(struct ggml_context* ctx, struct ggml_tensor* a) {\n"
    },
    {
      "file": "ggml-tensor-kernel/src/ggml_stub.c",
      "line": 152,
      "type": "stub",
      "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
      "context": "}\n\nstruct ggml_tensor* ggml_relu(struct ggml_context* ctx, struct ggml_tensor* a) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_new_f32(struct ggml_context* ctx, float value) {\n"
    },
    {
      "file": "atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 1004,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
    },
    {
      "file": "atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
      "line": 1371,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
      "line": 31,
      "type": "FIXME",
      "content": "// XXX FIXME: except for the error messages, most of this code is",
      "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/flow/FetchValueOfLink.cc",
      "line": 63,
      "type": "FIXME",
      "content": "// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]",
      "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]\n\t// are executable, then they need to be executed, first, right?\n\t// Yes, they do. But, for just right now, we don't, to stay\n\t// compatible with ValueOfLink. See comments in that code.\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/flow/StoreValueOfLink.cc",
      "line": 61,
      "type": "FIXME",
      "content": "// XXX TODO FIXME ... if either of these are executable, then",
      "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Because that's the\n\t// usual intent. Else they'd be wrapped in a DontExecLink, right?\n\t// I'm confused.\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/CachingProxy.cc",
      "line": 48,
      "type": "FIXME",
      "content": "// XXX TODO Add support for expiration times, limited AtomSpace",
      "context": "}\n\n// Get our configuration from the ProxyParameterLink we live in.\n// XXX TODO Add support for expiration times, limited AtomSpace\n// size and whatever other whizzy caching ideas we might want.\nvoid CachingProxy::open(void)\n{\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.cc",
      "line": 77,
      "type": "FIXME",
      "content": "// XXX TODO ... create this in some temp atomspace...",
      "context": "\t}\n\n\t// Ah! Its a procedure! Make it executable!\n// XXX TODO ... create this in some temp atomspace...\n\tHandle exo = _atom_space->add_link(EXECUTION_OUTPUT_LINK,\n\t\tHandleCast(rawvp),\n\t\tcreateLink(LIST_LINK, atom));\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
      "line": 141,
      "type": "FIXME",
      "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
      "context": "// Get our configuration from the DefineLink we live in.\n// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
      "line": 195,
      "type": "FIXME",
      "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
      "context": "void WriteBufferProxy::updateValue(const Handle& atom, const Handle& key,\n                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 164,
      "type": "FIXME",
      "content": "// XXX this should be nuked, and replaced by appropriate kind of proxy.",
      "context": "// -----------------------------------------------\n// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 165,
      "type": "FIXME",
      "content": "// FIXME read above comment.",
      "context": "// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n\tsize_t pos = 0;\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 181,
      "type": "FIXME",
      "content": "// XXX Hacky .. store time in float value...",
      "context": "\t\tHandle meta = Sexpr::decode_atom(cmd, pos, _space_map);\n\t\tmeta = _base_space->add_atom(meta);\n\n\t\t// XXX Hacky .. store time in float value...\n\t\t_base_space->set_value(query, meta, createFloatValue((double)time(0)));\n\t\tif (std::string::npos != cmd.find(\"#t\", pos))\n\t\t\tforce = true;\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 200,
      "type": "FIXME",
      "content": "// XXX is this correct???",
      "context": "\n\t_base_space->set_value(query, key, rslt);\n\n\t// XXX is this correct???\n\t// _proxy->store_value(query, key);\n\n\treturn Sexpr::encode_value(rslt);\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 257,
      "type": "FIXME",
      "content": "h = as->add_atom(h); // XXX shouldn't this be get_atom!????",
      "context": "\tType t = Sexpr::decode_type(cmd, pos);\n\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\th = as->add_atom(h); // XXX shouldn't this be get_atom!????\n\n\tif (_proxy and _proxy->have_fetchIncomingByType)\n\t{\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 302,
      "type": "FIXME",
      "content": "h = as->add_atom(h); // XXX shouldn't this be get_atom!????",
      "context": "\tsize_t pos = 0;\n\tHandle h = Sexpr::decode_atom(cmd, pos, _space_map);\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\th = as->add_atom(h); // XXX shouldn't this be get_atom!????\n\n\tif (_proxy and _proxy->have_getAtom)\n\t{\n"
    },
    {
      "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      "line": 395,
      "type": "FIXME",
      "content": "atom = as->add_atom(atom); // XXX shouldn't this be get_atom!????",
      "context": "\tHandle key = Sexpr::decode_atom(cmd, ++pos, _space_map);\n\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\tatom = as->add_atom(atom); // XXX shouldn't this be get_atom!????\n\tkey = as->add_atom(key);\n\n\tif (_proxy and _proxy->have_loadValue)\n"
    },
    {
      "file": "atomspace/opencog/atoms/base/Valuation.cc",
      "line": 50,
      "type": "FIXME",
      "content": "// XXX TODO -- C++ smart pointers are not atomic; we really",
      "context": "\nvoid Valuation::setValue(const ValuePtr& v)\n{\n\t// XXX TODO -- C++ smart pointers are not atomic; we really\n\t// need to use a lock here, to avoid thread-races.\n\t_value = v;\n}\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
      "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 79,
      "type": "FIXME",
      "content": "// XXX FIXME, this is to be removed, because UnionLink,",
      "context": "\t\t// well, in that case these are interpreted as intersection,\n\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 93,
      "type": "FIXME",
      "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
      "context": "\t\t// want to forbid it in the future by maybe introducing a\n\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 110,
      "type": "FIXME",
      "content": "// XXX FIXME - fix this so it can also choose a single value",
      "context": "///           AtomZ\n///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 143,
      "type": "FIXME",
      "content": "// XXX TODO if execute() above returns FloatValue, use that!",
      "context": "\t\t\tif (hw->is_executable())\n\t\t\t\thw = HandleCast(hw->execute(as, silent));\n\n\t\t\t// XXX TODO if execute() above returns FloatValue, use that!\n\t\t\tNumberNodePtr nn(NumberNodeCast(hw));\n\t\t\tif (nullptr == nn) // goto uniform;\n\t\t\t\tthrow SyntaxException(TRACE_INFO,\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
      "line": 179,
      "type": "FIXME",
      "content": "// XXX FIXME, also allow a FloatValue!!",
      "context": "\t\tstd::vector<double> weights;\n\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
      "line": 296,
      "type": "TODO",
      "content": "// TODO: the following has no unit test!!! Yet it introduces a",
      "context": "\t// Base case\n\tif (h->is_node())\n\t{\n\t\t// TODO: the following has no unit test!!! Yet it introduces a\n\t\t// bug covered by RewriteLinkUTest::test_consume_quotations_4(),\n\t\t// thus this code is disabled till a unit test it created for it\n\t\t// and we understand what it fixes and how it fixes.\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
      "line": 340,
      "type": "TODO",
      "content": "// TODO: generalize with when Unquote and Quote are apart",
      "context": "\t\t\t// A succession of (Unquote (Quote ..)) is an involution\n\t\t\t// and thus can be remove.\n\t\t\t//\n\t\t\t// TODO: generalize with when Unquote and Quote are apart\n\t\t\tif (child->get_type() == QUOTE_LINK)\n\t\t\t{\n\t\t\t\tquotation.update(child->get_type());\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/TypedVariableLink.cc",
      "line": 56,
      "type": "FIXME",
      "content": "VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug",
      "context": "\t    DEFINED_TYPE_NODE != dtype and\n\t    TYPE_CHOICE != dtype and\n\t    TYPE_INTERSECTION_LINK != dtype and\n\t    VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug\n\t    SIGNATURE_LINK != dtype and\n\t    INTERVAL_LINK != dtype and\n\t    ARROW_LINK != dtype)\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/Variables.cc",
      "line": 109,
      "type": "FIXME",
      "content": "// XXX FIXME URE calls us with broken handle!!",
      "context": " */\nvoid Variables::validate_vardecl(const Handle& hdecls)\n{\n\t// XXX FIXME URE calls us with broken handle!!\n\tif (nullptr == hdecls) return;\n\n\t// Expecting the declaration list to be either a single\n"
    },
    {
      "file": "atomspace/opencog/atoms/core/Variables.cc",
      "line": 437,
      "type": "FIXME",
      "content": "// XXX TODO type-checking could be lazy; if the function is not",
      "context": "\t\t\t\"Incorrect number of arguments specified, expecting %lu got %lu\",\n\t\t\tvarseq.size(), args.size());\n\n\t// XXX TODO type-checking could be lazy; if the function is not\n\t// actually using one of the args, it's type should not be checked.\n\t// Viz., one of the arguments might be undefined, and that's OK,\n\t// if that argument is never actually used.  Fixing this requires a\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/EvaluationLink.cc",
      "line": 824,
      "type": "FIXME",
      "content": "// XXX Is there a more efficient way to do this copy?",
      "context": "\t\telse\n\t\t{\n\t\t\t// Copy all but the first.\n\t\t\t// XXX Is there a more efficient way to do this copy?\n\t\t\tsize_t sz = sna.size();\n\t\t\tfor (size_t i=1; i<sz; i++) args.push_back(sna[i]);\n\t\t}\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/ExecutionOutputLink.cc",
      "line": 155,
      "type": "FIXME",
      "content": "// XXX should be be unwrapping SetLinks here?",
      "context": "\t{\n\t\tif (not h->is_executable())\n\t\t{\n\t\t\t// XXX should be be unwrapping SetLinks here?\n\t\t\texargs.push_back(h);\n\t\t\tcontinue;\n\t\t}\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 288,
      "type": "TODO",
      "content": "// TODO: what about globs?",
      "context": "\t\t\treturn expr;\n\n\t\t// If it is a quoted or shadowed variable don't substitute.\n\t\t// TODO: what about globs?\n\t\tif (VARIABLE_NODE == t and not context_cp.is_free_variable(expr))\n\t\t\treturn expr;\n\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 542,
      "type": "FIXME",
      "content": "// XXX Don't we need to plug in the vars, first!?",
      "context": "\t// ExecutionOutputLinks\n\tif (nameserver().isA(t, EXECUTION_OUTPUT_LINK))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Maybe this is just not tested?\n\t\tHandle eolh = reduce_exout(expr, ist);\n\t\tif (not eolh->is_executable()) return eolh;\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 553,
      "type": "FIXME",
      "content": "// XXX Don't we need to plug in the vars, first!?",
      "context": "\t// The thread-links are ambiguously executable/evaluatable.\n\tif (nameserver().isA(t, PARALLEL_LINK))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Yes, we do, but this is just not tested, right now.\n\t\treturn ValueCast(EvaluationLink::do_evaluate(_as, expr, silent));\n\t}\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 561,
      "type": "FIXME",
      "content": "// XXX Don't we need to plug in the vars, first!?",
      "context": "\t// Execute any DefinedPredicateNodes\n\tif (nameserver().isA(t, DEFINED_PREDICATE_NODE))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Maybe this is just not tested?\n\t\treturn ValueCast(EvaluationLink::do_evaluate(_as, expr, silent));\n\t}\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 598,
      "type": "FIXME",
      "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
      "context": "\t// We do this here, instead of in walk_tree(), because adding\n\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n"
    },
    {
      "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
      "line": 642,
      "type": "FIXME",
      "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
      "context": "\tif (expr->is_type(NODE) and expr->is_executable())\n\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
      "line": 69,
      "type": "TODO",
      "content": "// TODO: Handle executable _outgoing[0] by executing it first.",
      "context": "\n\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
      "line": 70,
      "type": "TODO",
      "content": "// TODO: Support complex type signatures beyond simple TYPE_NODE.",
      "context": "\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n\t\tthrow InvalidParamException(TRACE_INFO,\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
      "line": 278,
      "type": "FIXME",
      "content": "/// XXX Is executing the ground a good design choice? I dunno. It's the",
      "context": "/// variable).\n///\n/// Any executable terms in `ground` are executed prior to comparison.\n/// XXX Is executing the ground a good design choice? I dunno. It's the\n/// historical choice. So it goes.\n///\n/// If false is returned, the contents of valmap are invalid. If true\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
      "line": 615,
      "type": "FIXME",
      "content": "// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,",
      "context": "\t{\n\t\tvex = _outgoing[1]->execute(as, silent);\n\n\t\t// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,\n\t\t// then we should construct another Queue as the return value,\n\t\t// and perform filtering on-demand.\n\t\tif (vex->is_type(LINK_VALUE))\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
      "line": 41,
      "type": "FIXME",
      "content": "/// XXX FIXME - in the future, some user is going to want to include",
      "context": "/// not typed, and there are *two* bodies, each body returning one\n/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
      "line": 72,
      "type": "FIXME",
      "content": "// XXX This is buggy. If the formula contains a VariableList,",
      "context": "/// This returns a SimpleTruthValue, if there are two arguments,\n/// and a CountTruthVaue, if there are three.\n//\n// XXX This is buggy. If the formula contains a VariableList,\n// and any of the two sub-parts of it use only some of the variables,\n// but not all of them, then the reduction will go wrong. The solution\n// is probably to inherit from Lambda instead, and also have multi-body\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/TruthValueOfLink.cc",
      "line": 30,
      "type": "FIXME",
      "content": "// XXX why isn't this centralized somewhere?",
      "context": "\nusing namespace opencog;\n\n// XXX why isn't this centralized somewhere?\n// Why am I writing this again, from scratch?\nstatic TruthValuePtr get_the_tv(AtomSpace* as, const Handle& h, bool silent)\n{\n"
    },
    {
      "file": "atomspace/opencog/atoms/flow/ValueOfLink.cc",
      "line": 84,
      "type": "FIXME",
      "content": "// XXX TODO FIXME ... if either of these are executable, then",
      "context": "\t// space; we can add the Atom there, and things will\n\t// trickle out properly in the end.\n\t//\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Yes, they do! We\n\t// can currently get away with not doing this for two reasons:\n\t// In all existing code, the first Atom is always an anchor,\n"
    },
    {
      "file": "atomspace/opencog/atoms/join/JoinLink.cc",
      "line": 549,
      "type": "TODO",
      "content": "/// TODO: it might be faster to use hash tables instead of rb-trees",
      "context": "/// think of any way of combining steps (2) and (3) that would avoid\n/// step (4) ... or even would reduce the work for stpe (4). Oh well.\n///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n"
    },
    {
      "file": "atomspace/opencog/atoms/join/JoinLink.cc",
      "line": 721,
      "type": "FIXME",
      "content": "// XXX FIXME this is really dumb, using a queue and then",
      "context": "\n\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n"
    },
    {
      "file": "atomspace/opencog/atoms/parallel/ExecuteThreadedLink.cc",
      "line": 59,
      "type": "FIXME",
      "content": "/// XXX TODO: We could have a non-blocking version of this atom. We",
      "context": "/// Atoms in the set. If the NumberNode is present, then the number of\n/// threads is the smaller of the NumberNode and the seize of the Set.\n///\n/// XXX TODO: We could have a non-blocking version of this atom. We\n/// could just return the QueueValue immediately; the user could check\n/// to see if the queue is closed, to find out if the threads have\n/// finished.\n"
    },
    {
      "file": "atomspace/opencog/atoms/parallel/PureExecLink.cc",
      "line": 64,
      "type": "FIXME",
      "content": "// XXX Note that this leaks, if the execute throws.",
      "context": "\t}\n\n\t// No AtomSpace provided. Use a temporary.\n\t// XXX Note that this leaks, if the execute throws.\n\t// The transient code will catch the leak, and complain.\n\t// (There's no actual memleak; just a complaint about counting.)\n\tAtomSpace* tas = grab_transient_atomspace(as);\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 146,
      "type": "FIXME",
      "content": "// XXX FIXME, more correct would be to loop over",
      "context": "\t{\n\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 165,
      "type": "FIXME",
      "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
      "context": "\t\tunbundle_clauses(h);\n\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 407,
      "type": "FIXME",
      "content": "/// XXX No one, except unit tests, use these deprecated API's. These",
      "context": "/// a list of clauses to solve.  This is currently kind-of crippled,\n/// since no variable type restricions are possible, and no optionals,\n/// either.  This is used only for backwards-compatibility API's.\n/// XXX No one, except unit tests, use these deprecated API's. These\n/// old unit tests should be removed.\nPatternLink::PatternLink(const HandleSet& vars,\n                         const HandleSeq& clauses)\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 980,
      "type": "FIXME",
      "content": "// XXX Shouldn't we be adding this to _fixed, too?",
      "context": "\t\t\tif (not ptm->contained_in(_pat.pmandatory))\n\t\t\t\t_pat.pmandatory.push_back(ptm);\n\n\t\t\t// XXX Shouldn't we be adding this to _fixed, too?\n\t\t\treturn true;\n\t\t}\n\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1003,
      "type": "FIXME",
      "content": "// XXX Shouldn't we be adding this to _fixed, too?",
      "context": "\t\tif (not ptm->contained_in(_pat.pmandatory))\n\t\t\t_pat.pmandatory.push_back(ptm);\n\n\t\t// XXX Shouldn't we be adding this to _fixed, too?\n\t\treturn true;\n\t}\n\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1039,
      "type": "FIXME",
      "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
      "context": "/// If the ImplicationLink is suitably simple, it can be added\n/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1044,
      "type": "FIXME",
      "content": "/// XXX The situation here is also very dangerous: without any",
      "context": "/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n///\n/// XXX The situation here is also very dangerous: without any\n/// type constraints, we risk searching atoms created in the scratch\n/// atomspace, resulting in infinite recursion and a blown stack.\n/// Not clear how to avoid that...\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1255,
      "type": "FIXME",
      "content": "// XXX FIXME -- this is wrong. What we really want is to",
      "context": "\t\t\t_pat.have_evaluatables = true;\n\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1465,
      "type": "FIXME",
      "content": "// XXX FIXME: debug_log() above is more readable than the below.",
      "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternUtils.cc",
      "line": 55,
      "type": "FIXME",
      "content": "// XXX FIXME Are the below needed?",
      "context": "\t\t      or nameserver().isA(clause->getOutgoingAtom(0)->get_type(),\n\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n"
    },
    {
      "file": "atomspace/opencog/atoms/reduct/AccumulateLink.cc",
      "line": 71,
      "type": "FIXME",
      "content": "// XXX TODO -- we could also handle vectors of strings, by",
      "context": "\t\treturn createFloatValue(acc);\n\t}\n\n\t// XXX TODO -- we could also handle vectors of strings, by\n\t// concatenating them into one long string.  However, for this\n\t// to be generally useful, we'd want to insert whitespace in\n\t// between. But how? One way would be to pass another argument\n"
    },
    {
      "file": "atomspace/opencog/atoms/reduct/DecimateLink.cc",
      "line": 65,
      "type": "FIXME",
      "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
      "context": "\t\treturn do_execute(vmask, vi);\n\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n"
    },
    {
      "file": "atomspace/opencog/atoms/truthvalue/CountTruthValue.cc",
      "line": 168,
      "type": "FIXME",
      "content": "// XXX This is not the correct way to handle confidence ...",
      "context": "    strength_t meeny = (get_mean() * get_count() +\n                   oc->get_mean() * oc->get_count()) / cnt;\n\n    // XXX This is not the correct way to handle confidence ...\n    // The confidence will typically hold the log probability,\n    // where the probability is the normalized count.  Thus\n    // the right thing to do is probably to add the probabilities!?\n"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 138,
      "type": "TODO",
      "content": "// TODO: this should probably be moved to a method on class Atom.",
      "context": "        }\n\n        // Check the values...\n        // TODO: this should probably be moved to a method on class Atom.\n        if (check_values)\n        {\n            HandleSet keys_first = atom_first->getKeys();\n"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 272,
      "type": "FIXME",
      "content": "// Fixme maybe later someday, if/when this is needed.",
      "context": "\t// having one AtomSpace be placed as a member into many others,\n\t// except that we don't have any viable mechanisms for such multiple\n\t// membership, and so I don't know how to treat this right now.\n\t// Fixme maybe later someday, if/when this is needed.\n\tif (not (nullptr == _atom_space or as == nullptr))\n\t\tthrow RuntimeException(TRACE_INFO,\n\t\t\t\"At this time, an AtomSpace can only be placed in one other\\n\"\n"
    },
    {
      "file": "atomspace/opencog/atomspace/AtomSpace.cc",
      "line": 283,
      "type": "FIXME",
      "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
      "context": "}\n\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n"
    },
    {
      "file": "atomspace/opencog/atomspace/Transient.cc",
      "line": 43,
      "type": "FIXME",
      "content": "/// XXX FIXME. Performance has not been recently measured; there",
      "context": "/// cheaper to just have a cache of empty atomspaces, hanging around,\n/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n"
    },
    {
      "file": "atomspace/opencog/cython/PythonEval.cc",
      "line": 1427,
      "type": "FIXME",
      "content": "// XXX FIXME this does a lot of wasteful string copying.",
      "context": "\nvoid PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n"
    },
    {
      "file": "atomspace/opencog/cython/opencog/load-file.cc",
      "line": 86,
      "type": "FIXME",
      "content": "// XXX This is fairly tacky/broken, and needs a better fix.",
      "context": "    if (search_paths.empty()) {\n        // Sometimes paths are given without the \"opencog\" part.\n        // Also check the build directory for autogen'ed files.\n        // XXX This is fairly tacky/broken, and needs a better fix.\n        for (auto p : default_paths) {\n            search_paths.push_back(p);\n            search_paths.push_back(p + \"/opencog\");\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.cc",
      "line": 70,
      "type": "FIXME",
      "content": "//XXX New constructors supporting optional arguments as list of handles",
      "context": "\tdefine_scheme_primitive(_name, &FunctionWrap::as_wrapper_v_h, this, modname);\n}\n\n//XXX New constructors supporting optional arguments as list of handles\nFunctionWrap::FunctionWrap(Handle (f)(AtomSpace*, const Handle&, const HandleSeq&),\n                           const char* funcname, const char* modname)\n\t: _func_h_ah(nullptr), _func_h_ahz(nullptr), _func_h_ah_seq(f),\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeModule.cc",
      "line": 133,
      "type": "FIXME",
      "content": "// XXX New wrapper methods supporting optional arguments as list of handles",
      "context": "\treturn _proto_ah(as, h);\n}\n\n// XXX New wrapper methods supporting optional arguments as list of handles\nHandle FunctionWrap::as_wrapper_h_h_seq(Handle h, const HandleSeq& opt_args)\n{\n\tconst AtomSpacePtr& asp = SchemeSmob::ss_get_env_as(_name);\n"
    },
    {
      "file": "atomspace/opencog/guile/SchemeSmobAtom.cc",
      "line": 84,
      "type": "FIXME",
      "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
      "context": "\n/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n"
    },
    {
      "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
      "line": 70,
      "type": "FIXME",
      "content": "// XXX HACK ALERT This needs to be static, in order for python to",
      "context": "\n// ========================================================\n\n// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n"
    },
    {
      "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
      "line": 73,
      "type": "FIXME",
      "content": "// XXX FIXME: can we fix cython to not do this, already?",
      "context": "// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n"
    },
    {
      "file": "atomspace/opencog/guile/modules/TypeUtilsSCM.cc",
      "line": 58,
      "type": "FIXME",
      "content": "// XXX HACK ALERT This needs to be static, in order for python to",
      "context": "\n// ========================================================\n\n// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// Oh well. I guess that's OK, since the definition is meant to be\n"
    },
    {
      "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
      "line": 126,
      "type": "FIXME",
      "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
      "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n"
    },
    {
      "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
      "line": 370,
      "type": "FIXME",
      "content": "// XXX ?? Why incoming set ???",
      "context": "\t\t// This feels wonky. Is this correct?\n\t\tif (_starter_term->getHandle()->is_link())\n\t\t{\n\t\t\t// XXX ?? Why incoming set ???\n\t\t\tch.search_set = get_incoming_set(best_start,\n\t\t\t                              _starter_term->getHandle()->get_type());\n\t\t}\n"
    },
    {
      "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
      "line": 382,
      "type": "TODO",
      "content": "// TODO -- weed out duplicates!",
      "context": "\t}\n\telse\n\t{\n\t\t// TODO -- weed out duplicates!\n\t}\n\treturn true;\n}\n"
    },
    {
      "file": "atomspace/opencog/query/NextSearchMixin.cc",
      "line": 167,
      "type": "FIXME",
      "content": "// XXX TODO ... Rather than counting the number of variables, we",
      "context": "// can be done in a direct fashion; it resembles the concept of\n// \"unit propagation\" in the DPLL algorithm.\n//\n// XXX TODO ... Rather than counting the number of variables, we\n// should instead look for one with the smallest incoming set.\n// That is because the very next thing that we do will be to\n// iterate over the incoming set of \"pursue\" ... so it could be\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 284,
      "type": "FIXME",
      "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
      "context": "/// Compare the contents of a Present term in the pattern to the\n/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 335,
      "type": "FIXME",
      "content": "// XXX This is almost surely wrong... if there are two",
      "context": "\t              << \" of \" << iend << \" of term=\" << ptm->to_string()\n\t              << \", choose_next=\" << _choose_next;})\n\n\t// XXX This is almost surely wrong... if there are two\n\t// nested choice links, then this will hog the steps,\n\t// and the deeper choice will fail.\n\tif (_choose_next)\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 805,
      "type": "FIXME",
      "content": "// XXX should we be clearing ... or popping this flag?",
      "context": "\tPOPSTK(_perm_more_stack, _perm_have_more);\n\tPOPSTK(_perm_breakout_stack, _perm_breakout);\n\n\t// XXX should we be clearing ... or popping this flag?\n\t_perm_go_around = false;\n\n\tPOPSTK(_perm_odo_stack, _perm_odo_state);\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 956,
      "type": "FIXME",
      "content": "// XXX why are we not doing any checks to see if the",
      "context": "\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// XXX why are we not doing any checks to see if the\n\t\t\t\t// grounding meets the variable constraints?\n\t\t\t\tglob_pos_stack.push({glob, {ip, jg}});\n\t\t\t\t_glob_state[osp] = {glob_grd, glob_pos_stack};\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1005,
      "type": "FIXME",
      "content": "// XXX Huh ???",
      "context": "\t\t\t\t}\n\n\t\t\t\t// Just in case, if the upper bound is zero...\n\t\t\t\t// XXX Huh ???\n\t\t\t\tif (not _variables->is_upper_bound(ohp, 1))\n\t\t\t\t{\n\t\t\t\t\trecord_match(glob, glob_seq);\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1116,
      "type": "FIXME",
      "content": "// XXX The current implementation is a brute-force search, and is highly",
      "context": "/// care about the rest, the moiety (which can be very large; thus\n/// \"sparse\".)\n//\n// XXX The current implementation is a brute-force search, and is highly\n// inefficient for truly sparse searches. A (vastly) superior search\n// woudld be to obtain the connected components in the search set, and\n// try to ground those.  This avoids the pointless odometer spinning.\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1159,
      "type": "FIXME",
      "content": "// XXX TODO The logic here should be updated to resemble that",
      "context": "\tDO_LOG({LAZY_LOG_FINE << \"tree_comp NEW SETUP sparse term=\"\n\t                      << ptm->to_string();})\n\n\t// XXX TODO The logic here should be updated to resemble that\n\t// in curr_perm(), which deals correctly with nested permutations\n\t// of unordered patterns. For just right now, we are not\n\t// implementing nested sparse links, mostly because I'm too lazy\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1533,
      "type": "FIXME",
      "content": "// XXX FIXME - this is not very elegant. We should probably",
      "context": "\t// If this is some other rando variable that is not part of\n\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1631,
      "type": "FIXME",
      "content": "// XXX I'm not convinced this is right, if there are mixtures",
      "context": "\t\treturn explore_upspar_branches(ptm, hg, clause);\n\n\t// Check if the pattern has globs in it.\n\t// XXX I'm not convinced this is right, if there are mixtures\n\t// of unordered and globby links in different places...\n\tif (parent->hasAnyGlobbyVar())\n\t\treturn explore_upglob_branches(ptm, hg, clause);\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 1983,
      "type": "FIXME",
      "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
      "context": "/// form; see `explore_sparse_branches()`.\n///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2050,
      "type": "FIXME",
      "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
      "context": "/// functional group, and the glob will end up holding the moiety that\n/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2066,
      "type": "FIXME",
      "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
      "context": "{\n\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2176,
      "type": "FIXME",
      "content": "// XXX This `need_choice_push` thing is probably wrong; it probably",
      "context": "\n\tlogmsg(\"Begin choice branchpoint iteration loop\");\n\tdo {\n\t\t// XXX This `need_choice_push` thing is probably wrong; it probably\n\t\t// should resemble the perm_push() used for unordered links.\n\t\t// However, currently, no test case trips this up. so .. OK.\n\t\t// Whatever. This still probably needs fixing.\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2224,
      "type": "FIXME",
      "content": "/// XXX FIXME -- do the above.",
      "context": "/// -- build a connectivity map, just like the one for clauses\n/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n"
    },
    {
      "file": "atomspace/opencog/query/PatternMatchEngine.cc",
      "line": 2446,
      "type": "FIXME",
      "content": "// XXX TODO make sure that all variables in the clause have",
      "context": "\t\t                 << \"Parent has evaluatable but code path was expected to be unreachable. \"\n\t\t                 << \"Clause: \" << clause->getQuote()->to_string();\n\t\t// Continue with the evaluation anyway, but log the issue\n\t\t// XXX TODO make sure that all variables in the clause have\n\t\t// been grounded!  If they're not, something is badly wrong!\n\t\tlogmsg(\"Term inside evaluatable, move up to it's top:\",\n\t\t\t       clause->getQuote());\n"
    },
    {
      "file": "atomspace/opencog/query/Recognizer.cc",
      "line": 126,
      "type": "TODO",
      "content": "// TODO: Change to something better if possible...",
      "context": "\t// mis-matched types are a dead-end.\n\tif (lpat->get_type() != lsoln->get_type()) return false;\n\n\t// TODO: Change to something better if possible...\n\t// What is happening here is to manually call the\n\t// fuzzy_match callback immediately if and only if\n\t// lsoln has one or more GlobNodes AND lpat and lsoln\n"
    },
    {
      "file": "atomspace/opencog/query/RewriteMixin.cc",
      "line": 164,
      "type": "FIXME",
      "content": "/// XXX FIXME now I see how it can be done. The groupings should",
      "context": "/// to dribble in. Perhaps the engine search could be modified in some\n/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n"
    },
    {
      "file": "atomspace/opencog/query/SatisfyMixin.cc",
      "line": 583,
      "type": "FIXME",
      "content": "// XXX FIXME terrible hack.",
      "context": "\t\t// pure absent is found.\n\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n"
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 197,
      "type": "FIXME",
      "content": "// XXX The assert below -- if we hit this, then we have nested",
      "context": "\t\t// Unless it is quoted.\n\t\tif (ptm->isQuoted()) return true;\n\n\t\t// XXX The assert below -- if we hit this, then we have nested\n\t\t// scoped links. The correct fix would be to push these onto a\n\t\t// stack, and then alter scope_match() to walk the stack,\n\t\t// verifying alpha-convertability.\n"
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 551,
      "type": "FIXME",
      "content": "// XXX TODO as discussed on the mailing list, we should perhaps first",
      "context": "\t//       Arg1Atom\n\t//       Arg2Atom\n\t//\n\t// XXX TODO as discussed on the mailing list, we should perhaps first\n\t// see if the following can be found in the atomspace:\n\t//\n\t//   EvaluationLink\n"
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 702,
      "type": "FIXME",
      "content": "// XXX ... This might be buggy; I'm confused. Deep in the bowels",
      "context": "\t\t// OrLink for term-presence.  The other behavior \"all clauses\n\t\t// must be present\" is implemented by PresentLink.\n\t\t//\n\t\t// XXX ... This might be buggy; I'm confused. Deep in the bowels\n\t\t// of the pattern matcher, we make an explicit promise to explore\n\t\t// all possible choices.  Here, we are making no such promise;\n\t\t// instead, we're just responding to what higher layers have\n"
    },
    {
      "file": "atomspace/opencog/query/TermMatchMixin.cc",
      "line": 710,
      "type": "FIXME",
      "content": "// XXX FIXME: worse: this cannot possibly be right when",
      "context": "\t\t// possibilities?  And if they failed to do so, can we even do\n\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n"
    },
    {
      "file": "cogserver/opencog/cogserver/server/CogServer.cc",
      "line": 125,
      "type": "FIXME",
      "content": "// XXX FIXME. terrible terrible hack. What we should be",
      "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n"
    },
    {
      "file": "cogserver/opencog/cogserver/server/ServerConsole.cc",
      "line": 261,
      "type": "FIXME",
      "content": "/// XXX escaped quotes are not handled correctly. FIXME.",
      "context": "\n\n/// Parse command line. Quotes are stripped.\n/// XXX escaped quotes are not handled correctly. FIXME.\n/// This passes over quotes embeded in the middle strings.\n/// And that OK, because what the heck did you want to happen?\nstatic std::list<std::string> simple_tokenize(const std::string& line)\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 920,
      "type": "FIXME",
      "content": "// XXX TODO - maybe load links depth-order...",
      "context": "{\n\tCHECK_OPEN;\n\t// First, load all the nodes ... then the links.\n\t// XXX TODO - maybe load links depth-order...\n\tloadAtoms(table, \"n@\");\n\tloadAtoms(table, \"l@\");\n}\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
      "line": 944,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksDAG.cc",
      "line": 240,
      "type": "FIXME",
      "content": "// XXX TODO: we should probably cache the results, instead of",
      "context": "void RocksStorage::makeOrder(Handle hasp,\n                             std::map<uint64_t, Handle>& order)\n{\n// XXX TODO: we should probably cache the results, instead of\n// recomputing every time!?\n\t// As long as there's a stack of Frames, just loop.\n\twhile (true)\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
      "line": 522,
      "type": "FIXME",
      "content": "// XXX this is adding to wrong atomspace!?",
      "context": "\t\tfid = \":\" + writeFrame(as);\n\n\tValuePtr vp = getValue(\"k@\" + sid + fid + \":\" + kid);\n// XXX this is adding to wrong atomspace!?\n\tif (as and vp) vp = as->add_atoms(vp);\n\th->setValue(key, vp);\n}\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
      "line": 1283,
      "type": "FIXME",
      "content": "// XXX FIXME. We would like to call",
      "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
      "line": 82,
      "type": "FIXME",
      "content": "// XXX FIXME -- are open and close actually needed for anything?",
      "context": "    _storage = nullptr;\n}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
      "line": 285,
      "type": "FIXME",
      "content": "(WORD_NODE == soltype) || // XXX get rid of WordNode here, someday.",
      "context": "\n\t// Word instances match only if they have the same word lemma.\n\tif ((WORD_INSTANCE_NODE == soltype) ||\n\t    (WORD_NODE == soltype) || // XXX get rid of WordNode here, someday.\n\t    (SEME_NODE == soltype))\n\t{\n\t\tbool match = word_instance_match(npat, nsoln);\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
      "line": 293,
      "type": "FIXME",
      "content": "// XXX This code is never reached !!!???",
      "context": "\t\treturn match;\n\t}\n\n\t// XXX This code is never reached !!!??? \n\t// This is a bit of dead code, which may need to be revived for more\n\t// proper relex matching ... or maybe not ... \n\tif (DEFINED_LINGUISTIC_CONCEPT_NODE == soltype)\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
      "line": 361,
      "type": "FIXME",
      "content": "// XXX this needs to be replaced in the end, for now its just a cheesy",
      "context": "\tPatternMatchEngine::print_solution(var_grounding, pred_grounding);\n\n\t// And now for a cheesy hack to report the solution\n\t// XXX this needs to be replaced in the end, for now its just a cheesy\n\t// hack to pass data back to scheme.\n\tHandle hq = atom_space->addNode(ANCHOR_NODE, \"# QUERY SOLUTION\");\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/Fuzzy.cc",
      "line": 81,
      "type": "TODO",
      "content": "// TODO: Extend to find similar links as well",
      "context": "    {\n        if (h->is_node())\n        {\n            // TODO: Extend to find similar links as well\n            if (lp->get_type() == SIMILARITY_LINK)\n                sl.emplace_back(lp->get_handle());\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatchBasic.cc",
      "line": 106,
      "type": "TODO",
      "content": "// TODO: May use Truth Value instead",
      "context": "\tdouble similarity = common_nodes.size();\n\n\t// Roughly estimate how \"rare\" each node is by using 1 / incoming set size\n\t// TODO: May use Truth Value instead\n\t// for (const Handle& common_node : common_nodes)\n\t// \tsimilarity += 1.0 / common_node->getIncomingSetSize();\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/sureal/SuRealSCM.cc",
      "line": 171,
      "type": "FIXME",
      "content": "// XXX perhaps it's better to write a eval_q in SchemeEval to convert",
      "context": "    const HandleSeq& qClauses = h->getOutgoingSet();\n\n    // get all the nodes to be treated as variable in the Pattern Matcher\n    // XXX perhaps it's better to write a eval_q in SchemeEval to convert\n    //     a scm list to HandleSeq, so can just use the scheme utilities?\n    UnorderedHandleSet allNodes;\n    get_all_unique_nodes(h, allNodes);\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/wsd/SenseSimilaritySQL.cc",
      "line": 151,
      "type": "FIXME",
      "content": "// XXX however, what we should really do is to not that we have no",
      "context": "\trp.rs->release();\n\n\t// If no data, return similarity of zero!\n\t// XXX however, what we should really do is to not that we have no\n\t// data, and maybe try to gather some.\n\tif (!rp.have_data)\n\t{\n"
    },
    {
      "file": "components/integration/opencog/opencog/nlp/wsd/WordSenseProcessor.cc",
      "line": 120,
      "type": "FIXME",
      "content": "// XXX we are being called too often. this needs to be fixed.",
      "context": "{\n\trun_no_delay();\n\n\t// XXX we are being called too often. this needs to be fixed.\n\t// in truth, should only poll on new input.\n\tusleep(50*1000);\n}\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
      "line": 41,
      "type": "TODO",
      "content": "// TODO:",
      "context": "TruthValuePtr OpenPsiImplicator::check_satisfiability(const Handle& rule,\n    OpenPsiRules& opr)\n{\n  // TODO:\n  // Solve for multithreaded access. Create a rule class and lock\n  // the rule when updating the cache.\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
      "line": 49,
      "type": "TODO",
      "content": "// TODO: Add cache per atomspace.",
      "context": "  Handle query_body = query->get_pattern().body;\n\n  // Always update cache to clear any previous result.\n  // TODO: Add cache per atomspace.\n  _satisfiability_cache.erase(query_body);\n  _pattern_seen.insert(query_body);\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 68,
      "type": "TODO",
      "content": "// TODO: Test thoroughly, or develop an alternative. See discussion",
      "context": "      _psi_rules[rule] = std::make_tuple(context, action, goal, query);\n  } else {\n    // This is for backward compatability.\n    // TODO: Test thoroughly, or develop an alternative. See discussion\n    // @ https://github.com/opencog/opencog/pull/2899 for what the\n    // alternative might be.\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 101,
      "type": "TODO",
      "content": "// TODO But why make the add_category public then?",
      "context": "{\n  _as->add_link(MEMBER_LINK, rule, category);\n  // Add the category just in case it hasn't been declared.\n  // TODO But why make the add_category public then?\n  add_category(category);\n  _category_index[category].insert(rule);\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 115,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 124,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
      "line": 91,
      "type": "TODO",
      "content": "// TODO: Should this be a singleton? What could be the issues that need",
      "context": "  const Handle& goal, const TruthValuePtr stv, const Handle& category)\n{\n  AtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"psi-rule\");\n  // TODO: Should this be a singleton? What could be the issues that need\n  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
      "line": 95,
      "type": "TODO",
      "content": "// TODO: Add to multiple categories using scheme rest list.",
      "context": "  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n  // TODO: Add to multiple categories using scheme rest list.\n  openpsi_cache(asp.get()).add_to_category(rule, category);\n  return rule;\n}\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 42,
      "type": "TODO",
      "content": "// TODO: Saperated component patterns aren't handled by this function",
      "context": "bool OpenPsiSatisfier::grounding(const HandleMap &var_soln,\n                                  const HandleMap &term_soln)\n{\n  // TODO: Saperated component patterns aren't handled by this function\n  // as PMCGroundings is used instead. Update to handle such cases.\n\n  // The psi-rule weight calculations could be done here.\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 56,
      "type": "TODO",
      "content": "// TODO: If we are here it means the suggested groundings doesn't have",
      "context": "      }\n    }\n\n    // TODO: If we are here it means the suggested groundings doesn't have\n    // VariableNodes, and can be cached. This doesn't account for terms\n    // that are under QuoteLink, or other similar type links. How should\n    // such cases be handled?\n"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
      "line": 76,
      "type": "TODO",
      "content": "// TODO: This happens when InitiateSearchCB::no_search has groundings.",
      "context": "    _implicator -> _satisfiability_cache[_pattern_body] = var_soln;\n    return true;\n  } else {\n    // TODO: This happens when InitiateSearchCB::no_search has groundings.\n    // Cases for when this happens hasn't been tested yet. Explore the\n    // behavior and find a better solution. For now, log it and continue\n    // searching.\n"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 93,
      "type": "FIXME",
      "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
      "context": "\tif (_in_server) return;\n\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1028,
      "type": "TODO",
      "content": "// TODO: it would be nice to pass exceptions on through, but",
      "context": "\t}\n\texpr = scm_cons(sfunc, expr);\n\n\t// TODO: it would be nice to pass exceptions on through, but\n\t// this currently breaks unit tests.\n\t// if (_in_eval)\n\t//    return scm_eval(expr, scm_interaction_environment());\n"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1057,
      "type": "FIXME",
      "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
      "context": "\t\t{\n\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n"
    },
    {
      "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
      "line": 1180,
      "type": "FIXME",
      "content": "// XXX FIXME only a subset is needed.",
      "context": "\nvoid SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
      "line": 239,
      "type": "FIXME",
      "content": "// XXX FIXME this does not smell right; optionals should get",
      "context": "\n    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
      "line": 268,
      "type": "FIXME",
      "content": "// XXX FIXME ... using an std::map would be more efficient.",
      "context": "    // remove repeated atoms from OR\n    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
      "line": 46,
      "type": "FIXME",
      "content": "// FIXME XXX -- Optionals are handled incorrectly here;",
      "context": "\n    std::vector<LGDictExpContainer> subcontainers;\n\n    // FIXME XXX -- Optionals are handled incorrectly here;\n    // they are denoted by a null Exp pointer in an OR_list!\n    // Ignoring all the nulls is just ... wrong.\n#if (LINK_MAJOR_VERSION == 5) &&  (LINK_MINOR_VERSION < 7)\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
      "line": 103,
      "type": "FIXME",
      "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
      "context": "\n    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
      "line": 229,
      "type": "FIXME",
      "content": "// XXX FIXME. This should be part of the LgDictNode but since",
      "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
      "line": 338,
      "type": "FIXME",
      "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
      "context": "\t\t\tparse_options_set_linkage_limit(opts, max_linkages);\n\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/continmax.cc",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX Currently, this doesn't really work well, or maybe at all, in",
      "context": "// evolutionary algorithms typically do not track derivatives (which\n// is how the problem becomes easy when applying calculus).\n//\n// XXX Currently, this doesn't really work well, or maybe at all, in\n// part because the contin implementation in the field set is incomplete\n// or broken or maybe both; there is a confusion between depth and arity\n// in that code. (i.e. confusion between depth and breadth, between arity\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/continmax.cc",
      "line": 67,
      "type": "TODO",
      "content": "// TODO: Expand documentation to match style of onemax/nmax examples.",
      "context": "// -- the number that is -log_2(epsilon) where epsilon is the smallest\n//    distinction between continuous variables what will be drawn.\n//\n// TODO: Expand documentation to match style of onemax/nmax examples.\n// Add parameter descriptions, usage examples, and expected output.\n\nint main(int argc, char** argv)\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/nmax.cc",
      "line": 38,
      "type": "FIXME",
      "content": "// XXX setting n=2 currently fails due to a bug, see",
      "context": "// namely, a set of variables, the value of each of which is at maximum.\n// This is a generalization of the \"onemax\" problem, which is nmax with n=2.\n//\n// XXX setting n=2 currently fails due to a bug, see\n// https://bugs.launchpad.net/moses/+bug/908230\n//\n// NOTE: This is NOT a demonstration of program learning, which is what\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/ontomax.cc",
      "line": 36,
      "type": "FIXME",
      "content": "// XXX Someday, fix all of this!",
      "context": "// contin support, but for general terms arranged in an n-ary tree, \n// instead of a 2-ary tree for contin.\n//\n// XXX Someday, fix all of this!\n\nvoid recbuild(term_tree& tr, term_tree::iterator it,\n\t      int b, int maxd, int d, int s)\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
      "line": 26,
      "type": "FIXME",
      "content": "// XXX under construction XXX",
      "context": "\nusing boost::lexical_cast;\n\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
      "line": 28,
      "type": "FIXME",
      "content": "// XXX this example is broken, and will remain so until \"multivariate\"",
      "context": "\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
      "line": 31,
      "type": "FIXME",
      "content": "// XXX some of the documentation below may be misleading.",
      "context": "// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n//\n// Demonstration program for the \"bit-trap\" optimization problem.\n// This is a standard optimization demonstraton problem: a \n"
    },
    {
      "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX which is why we need to put structure leanring back in the code XXX",
      "context": "// scoring functions make different bits depend on one-another.  Thus,\n// the optimal solution cannot be found without structure learning; the\n// MOSES univariate() learner is a no-op, and so cannot solve this problem.\n// XXX which is why we need to put structure leanring back in the code XXX\n//\n// The correlation between variables is accomplished by using a\n// vee-shaped scoring function. The vee-shape is meant to be \"deceptive\",\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
      "line": 45,
      "type": "TODO",
      "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
      "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
      "line": 85,
      "type": "FIXME",
      "content": "// XXX Should probably be \"union\", yeah?",
      "context": "    //     if (p1) v1; else if (p2) v2; else if ... else y\n    //\n    // The 'value' is marked unknown, as it can be of any type.\n    // XXX Should probably be \"union\", yeah?\n    { id::cond,               \"->(arg_list(boolean unknown) unknown unknown)\" },\n\n    // Someday, contin_if will be obsolted/equivalent to above cond ...\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/combo/iostream_combo.cc",
      "line": 440,
      "type": "FIXME",
      "content": "// XXX ?? Ahem, won't calling out<<(*m) just lead to infinite",
      "context": "    if (const enum_t* m = get<enum_t>(&v))\n        return out << m->getContent();\n\n    // XXX ?? Ahem, won't calling out<<(*m) just lead to infinite\n    // recursion ?? \n    if (const ann_type* z = get<ann_type>(&v))\n        return out << (*z);\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/interpreter/eval.cc",
      "line": 530,
      "type": "FIXME",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return eval_throws_tree(bmap, exp_tr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
      "line": 336,
      "type": "FIXME",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/main/action-reductor.cc",
      "line": 93,
      "type": "TODO",
      "content": "// TODO -- replace this by cond",
      "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/main/eval-table.cc",
      "line": 147,
      "type": "FIXME",
      "content": "// XXX FIXME",
      "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.cc",
      "line": 963,
      "type": "TODO",
      "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
      "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 100,
      "type": "FIXME",
      "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
      "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 667,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.cc",
      "line": 1228,
      "type": "TODO",
      "content": "//check if 0<-(y+pi) -> false //TODO",
      "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 409,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 434,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 667,
      "type": "FIXME",
      "content": "// XXX this cannot possibly be correct, the total count is in general",
      "context": "    for (auto row_it = begin();\n         row_it != end() and idx_it != idxs.end();) {\n        auto& outputs = row_it->second;\n// XXX this cannot possibly be correct, the total count is in general\n// a fraction, not an integer; it is merely the sum of the weights\n// of the rows. It is NOT equal to the toal number of rows!\n// I cannot figure out what this algo is trying to do, so I can't\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.cc",
      "line": 848,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 955,
      "type": "TODO",
      "content": "// TODO could be simplified, optimized, etc",
      "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1078,
      "type": "TODO",
      "content": "// TODO: this could definitely be optimized",
      "context": "\n    if (is_sparse) {\n        // fallback on the old loader\n        // TODO: this could definitely be optimized\n        OC_ASSERT(timestamp_feature.empty(), \"Timestamp feature not implemented\");\n        return istreamTable_OLD(in, tab, target_feature, ignore_features);\n    } else {\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1256,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.cc",
      "line": 599,
      "type": "FIXME",
      "content": "// XXX TODO the code below was modified to allow arg lists of",
      "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n"
    },
    {
      "file": "components/learning/moses/moses/feature-selection/algo/simple.cc",
      "line": 43,
      "type": "FIXME",
      "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
      "context": "    if (0 == fs_params.target_size) {\n        // Nothing happened, return all features by default\n        \n        // XXX: fsc(all_features) is skipped because that algorithm is\n        // used in combination with contin MI in\n        // feature_selectionUTest.cxxtest and contin MI does not\n        // support feature sets with more than 1 feature.\n"
    },
    {
      "file": "components/learning/moses/moses/feature-selection/algo/simple.cc",
      "line": 55,
      "type": "FIXME",
      "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
      "context": "                                      fs_params.target_size,\n                                      fs_params.exp_distrib,\n                                      fs_params.threshold);\n    // XXX: fsc(all_features) is skipped because that algorithm is\n    // used in combination with contin MI in\n    // feature_selectionUTest.cxxtest and contin MI does not support\n    // feature sets with more than 1 feature.\n"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 441,
      "type": "TODO",
      "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
      "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 457,
      "type": "TODO",
      "content": "// TODO: re-enable that once best_possible_bscore is fixed",
      "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
    },
    {
      "file": "components/learning/moses/moses/moses/main/problem-params.cc",
      "line": 166,
      "type": "FIXME",
      "content": "// XXX TODO: make this print correctly, instead of using brackets.",
      "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n"
    },
    {
      "file": "components/learning/moses/moses/moses/main/table-problems.cc",
      "line": 138,
      "type": "FIXME",
      "content": "// XXX FIXME -- the multiple tables should be merged into one.",
      "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/main/table-problems.cc",
      "line": 150,
      "type": "FIXME",
      "content": "// XXX FIXME .. check that they all have the same signature.",
      "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
    },
    {
      "file": "components/learning/moses/moses/moses/main/table-problems.cc",
      "line": 487,
      "type": "FIXME",
      "content": "// XXX Eh ??? for precision/recall scorers,",
      "context": "\n        // For enum targets, like boolean targets, the score\n        // can never exceed zero (perfect score).\n        // XXX Eh ??? for precision/recall scorers,\n        // the score range is 0.0 to 1.0 so this is wrong...\n        if (0.0 < pms.moses_params.max_score) {\n            pms.moses_params.max_score = 0.0;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/ensemble.cc",
      "line": 259,
      "type": "FIXME",
      "content": "// XXX the logic below is probably wrong.",
      "context": "\t\t\tconst behavioral_score& bs = sct.get_bscore();\n\t\t\tsize_t bslen = _bscorer.size();\n\n\t\t\t// XXX the logic below is probably wrong.\n\t\t\tOC_ASSERT(false, \"this doesn't work right now.\");\n\t\t\t// Now, look to see where this scorer was wrong, and bump the\n\t\t\t// bias for that.  Here, we make the defacto assumption that\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 261,
      "type": "FIXME",
      "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
      "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 404,
      "type": "TODO",
      "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
      "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 552,
      "type": "FIXME",
      "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
      "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
      "line": 577,
      "type": "FIXME",
      "content": "// XXX this lock probably doesn't have to be the same one",
      "context": "        return;\n\n    // Make this routine thread-safe.\n    // XXX this lock probably doesn't have to be the same one\n    // that merge uses.  I think.\n    std::lock_guard<std::mutex> lock(_merge_mutex);\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
      "line": 222,
      "type": "FIXME",
      "content": "// XXX FIXME should probably not recompute every time ...",
      "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/complexity.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX What is the complexity of contin expressions?",
      "context": "// fewer operators than either CNF or DNF, so counting operators\n// doesn't seem wrong to me ...)\n//\n// XXX What is the complexity of contin expressions?\n// Expressions containining greater_than_zero, impulse, cond?  I'm\n// somwhat confused about how thigs are being measured.   Note that\n// when we calculate the complexity of a field_set, then contins\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
      "line": 56,
      "type": "FIXME",
      "content": "// XXX When would one never expand?  Wouldn't that be a bug?",
      "context": "\n    // Attempt to create a non-empty representation, by looping\n    // over exemplars until we find one that expands.\n    // XXX When would one never expand?  Wouldn't that be a bug?\n    while (1) {\n        scored_combo_tree_ptr_set_cit exemplar = mp.select_exemplar();\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
      "line": 180,
      "type": "TODO",
      "content": "// TODO use the option of the output",
      "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 201,
      "type": "FIXME",
      "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
      "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 304,
      "type": "TODO",
      "content": "if (!dex.create_demes(exemplar, 0 /* TODO replace with the",
      "context": "        mompi.recv_exemplar(exemplar);\n        logger().info() << \"Allowed \" << max_evals \n                        << \" evals for recvd exemplar \" << exemplar;\n        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // XXX replace this with appropriate message back to root!\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 307,
      "type": "FIXME",
      "content": "// XXX replace this with appropriate message back to root!",
      "context": "        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // XXX replace this with appropriate message back to root!\n            OC_ASSERT(false, \"Exemplar failed to expand!\\n\");\n        }\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 420,
      "type": "FIXME",
      "content": "// XXX is mp.best_score thread safe !???? since another thread might be updating this as we",
      "context": "\n    // If we are here, then we are the root node.  The root will act\n    // as a dispatcher to all of the worker nodes.\n// XXX is mp.best_score thread safe !???? since another thread might be updating this as we\n// come around ...\n\n    size_t tot_workers = mompi.num_workers();\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 482,
      "type": "TODO",
      "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
      "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
      "line": 566,
      "type": "FIXME",
      "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
      "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/partial.cc",
      "line": 96,
      "type": "TODO",
      "content": "// TODO: Improve generation tracking by getting actual number",
      "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/partial.cc",
      "line": 264,
      "type": "FIXME",
      "content": "// XXX is this correct? I think we need to ask the cscorer for the total ...",
      "context": "    // Are we done yet?\n    behavioral_score bs = _bscore->operator()(cand);\n\n    // XXX is this correct? I think we need to ask the cscorer for the total ...\n    score_t total_score = 0.0;\n    for (const score_t& sc : bs)\n        total_score += sc;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/moses/partial.cc",
      "line": 304,
      "type": "FIXME",
      "content": "// XXX Ineffective predicates may be due to enums that have been",
      "context": "        good_count = 0;\n        effective(predicate, good_count, fail_count);\n\n        // XXX Ineffective predicates may be due to enums that have been\n        // completely accounted for ... not sure what to do about that...\n        if ((0 < good_count) || (0 < fail_count))\n            break;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/optimization.cc",
      "line": 79,
      "type": "FIXME",
      "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
      "context": "}\n\n// N = p.popsize_ratio * n^1.05\n// XXX Why n^1.05 ??? This is going to have a significant effect\n// (as compared to n^1.00) only when n is many thousands or bigger...\nunsigned optim_parameters::pop_size(const field_set& fs) const\n{\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
      "line": 122,
      "type": "FIXME",
      "content": "// XXX What score do i use?",
      "context": "                            boost::bind(boost::cref(iscorer), _1));\n        current_number_of_evals += swarm_size;\n\n        // XXX What score do i use?\n        // I'll use best_score for now.\n        bool has_improved = false;\n        for (unsigned i = 0; i < swarm_size; ++i) {\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
      "line": 197,
      "type": "TODO",
      "content": "// TODO: work in a better way to identify convergence.",
      "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
      "line": 236,
      "type": "TODO",
      "content": "// TODO: Explanation",
      "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
    },
    {
      "file": "components/learning/moses/moses/moses/optimization/star-anneal.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX TODO the annealing temperature control code should be ported over",
      "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 51,
      "type": "FIXME",
      "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
      "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 236,
      "type": "FIXME",
      "content": "// XXX TODO need to add support for \"term algebra\" knobs",
      "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 391,
      "type": "FIXME",
      "content": "// XXX This is dead code, no one uses it, and looking at the below, it",
      "context": "}\n\n#ifdef EXEMPLAR_INST_IS_UNDEAD\n// XXX This is dead code, no one uses it, and looking at the below, it\n// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 395,
      "type": "FIXME",
      "content": "// XXX why are we clearing this, instead of setting it back to the",
      "context": "// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 398,
      "type": "FIXME",
      "content": "// XXX Note that the clear_exemplar() methods on the knobs are probably",
      "context": "// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n//  not needed either!?\nvoid representation::clear_exemplar()\n{\n"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/representation.cc",
      "line": 409,
      "type": "FIXME",
      "content": "// XXX that, and contin seems to be handled inconsistently with disc...",
      "context": "}\n\n// What is this doing ? seems to be clearing things out, why do we need this?\n// XXX that, and contin seems to be handled inconsistently with disc...\n// I mean, shouldn't we be setting the exemplar_inst fields so that\n// they match the exmplar?  Do we even need the exemplar_inst for anything?\nvoid representation::set_exemplar_inst()\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
      "line": 570,
      "type": "TODO",
      "content": "// TODO",
      "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
      "line": 930,
      "type": "FIXME",
      "content": "/// XXX this should probably be removed! TODO FIXME",
      "context": "/// even output all the data that is required to use the resulting\n/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 213,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "      _hardness(hardness),\n      _full_bscore(true)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n\n    logger().info(\"Discriminating scorer, hardness = %f, \"\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 417,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_precision, max_precision, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 486,
      "type": "FIXME",
      "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 586,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "                       float hardness)\n    : discriminating_bscore(ct, min_diff, max_diff, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 663,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "f_one_bscore::f_one_bscore(const CTable& ct)\n    : discriminating_bscore(ct, 0.0, 1.0, 1.0e-20)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 1;\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
      "line": 108,
      "type": "FIXME",
      "content": "// XXX FIXME complexity_t should be a double not an int ...",
      "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
    },
    {
      "file": "components/learning/moses/moses/moses/scoring/time_dispersion.cc",
      "line": 43,
      "type": "TODO",
      "content": "// TODO multipler other than 1 is not supported yet",
      "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
    },
    {
      "file": "moses/examples/example-progs/continmax.cc",
      "line": 46,
      "type": "FIXME",
      "content": "// XXX Currently, this doesn't really work well, or maybe at all, in",
      "context": "// evolutionary algorithms typically do not track derivatives (which\n// is how the problem becomes easy when applying calculus).\n//\n// XXX Currently, this doesn't really work well, or maybe at all, in\n// part because the contin implementation in the field set is incomplete\n// or broken or maybe both; there is a confusion between depth and arity\n// in that code. (i.e. confusion between depth and breadth, between arity\n"
    },
    {
      "file": "moses/examples/example-progs/nmax.cc",
      "line": 38,
      "type": "FIXME",
      "content": "// XXX setting n=2 currently fails due to a bug, see",
      "context": "// namely, a set of variables, the value of each of which is at maximum.\n// This is a generalization of the \"onemax\" problem, which is nmax with n=2.\n//\n// XXX setting n=2 currently fails due to a bug, see\n// https://bugs.launchpad.net/moses/+bug/908230\n//\n// NOTE: This is NOT a demonstration of program learning, which is what\n"
    },
    {
      "file": "moses/examples/example-progs/ontomax.cc",
      "line": 36,
      "type": "FIXME",
      "content": "// XXX Someday, fix all of this!",
      "context": "// contin support, but for general terms arranged in an n-ary tree, \n// instead of a 2-ary tree for contin.\n//\n// XXX Someday, fix all of this!\n\nvoid recbuild(term_tree& tr, term_tree::iterator it,\n\t      int b, int maxd, int d, int s)\n"
    },
    {
      "file": "moses/examples/example-progs/trap-bit.cc",
      "line": 26,
      "type": "FIXME",
      "content": "// XXX under construction XXX",
      "context": "\nusing boost::lexical_cast;\n\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n"
    },
    {
      "file": "moses/examples/example-progs/trap-bit.cc",
      "line": 28,
      "type": "FIXME",
      "content": "// XXX this example is broken, and will remain so until \"multivariate\"",
      "context": "\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n"
    },
    {
      "file": "moses/examples/example-progs/trap-bit.cc",
      "line": 31,
      "type": "FIXME",
      "content": "// XXX some of the documentation below may be misleading.",
      "context": "// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n//\n// Demonstration program for the \"bit-trap\" optimization problem.\n// This is a standard optimization demonstraton problem: a \n"
    },
    {
      "file": "moses/examples/example-progs/trap-bit.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX which is why we need to put structure leanring back in the code XXX",
      "context": "// scoring functions make different bits depend on one-another.  Thus,\n// the optimal solution cannot be found without structure learning; the\n// MOSES univariate() learner is a no-op, and so cannot solve this problem.\n// XXX which is why we need to put structure leanring back in the code XXX\n//\n// The correlation between variables is accomplished by using a\n// vee-shaped scoring function. The vee-shape is meant to be \"deceptive\",\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/descriptions.cc",
      "line": 45,
      "type": "TODO",
      "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
      "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/descriptions.cc",
      "line": 85,
      "type": "FIXME",
      "content": "// XXX Should probably be \"union\", yeah?",
      "context": "    //     if (p1) v1; else if (p2) v2; else if ... else y\n    //\n    // The 'value' is marked unknown, as it can be of any type.\n    // XXX Should probably be \"union\", yeah?\n    { id::cond,               \"->(arg_list(boolean unknown) unknown unknown)\" },\n\n    // Someday, contin_if will be obsolted/equivalent to above cond ...\n"
    },
    {
      "file": "moses/moses/comboreduct/combo/iostream_combo.cc",
      "line": 440,
      "type": "FIXME",
      "content": "// XXX ?? Ahem, won't calling out<<(*m) just lead to infinite",
      "context": "    if (const enum_t* m = get<enum_t>(&v))\n        return out << m->getContent();\n\n    // XXX ?? Ahem, won't calling out<<(*m) just lead to infinite\n    // recursion ?? \n    if (const ann_type* z = get<ann_type>(&v))\n        return out << (*z);\n"
    },
    {
      "file": "moses/moses/comboreduct/interpreter/eval.cc",
      "line": 563,
      "type": "FIXME",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return eval_throws_tree(new_bmap, lambda_expr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
    },
    {
      "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
      "line": 336,
      "type": "FIXME",
      "content": "// XXX TODO: contin_if should go away.",
      "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
    },
    {
      "file": "moses/moses/comboreduct/main/action-reductor.cc",
      "line": 93,
      "type": "TODO",
      "content": "// TODO -- replace this by cond",
      "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
    },
    {
      "file": "moses/moses/comboreduct/main/eval-table.cc",
      "line": 147,
      "type": "FIXME",
      "content": "// XXX FIXME",
      "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
    },
    {
      "file": "moses/moses/comboreduct/reduct/contin_rules.cc",
      "line": 963,
      "type": "TODO",
      "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
      "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 100,
      "type": "FIXME",
      "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
      "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 667,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
    },
    {
      "file": "moses/moses/comboreduct/reduct/mixed_rules.cc",
      "line": 1228,
      "type": "TODO",
      "content": "//check if 0<-(y+pi) -> false //TODO",
      "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 420,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 445,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 678,
      "type": "FIXME",
      "content": "// XXX this cannot possibly be correct, the total count is in general",
      "context": "    for (auto row_it = begin();\n         row_it != end() and idx_it != idxs.end();) {\n        auto& outputs = row_it->second;\n// XXX this cannot possibly be correct, the total count is in general\n// a fraction, not an integer; it is merely the sum of the weights\n// of the rows. It is NOT equal to the toal number of rows!\n// I cannot figure out what this algo is trying to do, so I can't\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table.cc",
      "line": 859,
      "type": "FIXME",
      "content": "// XXX TODO replace this by the util p_norm function.",
      "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 99,
      "type": "TODO",
      "content": "// TODO: This routine should be extended so that comments that start",
      "context": "/// This ignores lines that start with a 'standard comment char'\n///\n//\n// TODO: This routine should be extended so that comments that start\n// somewhere other than column 0 are also ignored.\n//\n// The signature of this routine is the same as std:getline()\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 930,
      "type": "TODO",
      "content": "// TODO could be simplified, optimized, etc",
      "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 1241,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
    },
    {
      "file": "moses/moses/comboreduct/type_checker/type_tree.cc",
      "line": 622,
      "type": "FIXME",
      "content": "// XXX TODO the code below was modified to allow arg lists of",
      "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n"
    },
    {
      "file": "moses/moses/feature-selection/algo/simple.cc",
      "line": 43,
      "type": "FIXME",
      "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
      "context": "    if (0 == fs_params.target_size) {\n        // Nothing happened, return all features by default\n        \n        // XXX: fsc(all_features) is skipped because that algorithm is\n        // used in combination with contin MI in\n        // feature_selectionUTest.cxxtest and contin MI does not\n        // support feature sets with more than 1 feature.\n"
    },
    {
      "file": "moses/moses/feature-selection/algo/simple.cc",
      "line": 55,
      "type": "FIXME",
      "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
      "context": "                                      fs_params.target_size,\n                                      fs_params.exp_distrib,\n                                      fs_params.threshold);\n    // XXX: fsc(all_features) is skipped because that algorithm is\n    // used in combination with contin MI in\n    // feature_selectionUTest.cxxtest and contin MI does not support\n    // feature sets with more than 1 feature.\n"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 441,
      "type": "TODO",
      "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
      "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 457,
      "type": "TODO",
      "content": "// TODO: re-enable that once best_possible_bscore is fixed",
      "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
    },
    {
      "file": "moses/moses/moses/main/problem-params.cc",
      "line": 166,
      "type": "FIXME",
      "content": "// XXX TODO: make this print correctly, instead of using brackets.",
      "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n"
    },
    {
      "file": "moses/moses/moses/main/table-problems.cc",
      "line": 138,
      "type": "FIXME",
      "content": "// XXX FIXME -- the multiple tables should be merged into one.",
      "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
    },
    {
      "file": "moses/moses/moses/main/table-problems.cc",
      "line": 150,
      "type": "FIXME",
      "content": "// XXX FIXME .. check that they all have the same signature.",
      "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
    },
    {
      "file": "moses/moses/moses/main/table-problems.cc",
      "line": 487,
      "type": "FIXME",
      "content": "// XXX Eh ??? for precision/recall scorers,",
      "context": "\n        // For enum targets, like boolean targets, the score\n        // can never exceed zero (perfect score).\n        // XXX Eh ??? for precision/recall scorers,\n        // the score range is 0.0 to 1.0 so this is wrong...\n        if (0.0 < pms.moses_params.max_score) {\n            pms.moses_params.max_score = 0.0;\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 261,
      "type": "FIXME",
      "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
      "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 404,
      "type": "TODO",
      "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
      "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 552,
      "type": "FIXME",
      "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
      "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/merging.cc",
      "line": 577,
      "type": "FIXME",
      "content": "// XXX this lock probably doesn't have to be the same one",
      "context": "        return;\n\n    // Make this routine thread-safe.\n    // XXX this lock probably doesn't have to be the same one\n    // that merge uses.  I think.\n    std::lock_guard<std::mutex> lock(_merge_mutex);\n\n"
    },
    {
      "file": "moses/moses/moses/metapopulation/metapopulation.cc",
      "line": 222,
      "type": "FIXME",
      "content": "// XXX FIXME should probably not recompute every time ...",
      "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
    },
    {
      "file": "moses/moses/moses/moses/complexity.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX What is the complexity of contin expressions?",
      "context": "// fewer operators than either CNF or DNF, so counting operators\n// doesn't seem wrong to me ...)\n//\n// XXX What is the complexity of contin expressions?\n// Expressions containining greater_than_zero, impulse, cond?  I'm\n// somwhat confused about how thigs are being measured.   Note that\n// when we calculate the complexity of a field_set, then contins\n"
    },
    {
      "file": "moses/moses/moses/moses/local_moses.cc",
      "line": 56,
      "type": "FIXME",
      "content": "// XXX When would one never expand?  Wouldn't that be a bug?",
      "context": "\n    // Attempt to create a non-empty representation, by looping\n    // over exemplars until we find one that expands.\n    // XXX When would one never expand?  Wouldn't that be a bug?\n    while (1) {\n        scored_combo_tree_ptr_set_cit exemplar = mp.select_exemplar();\n\n"
    },
    {
      "file": "moses/moses/moses/moses/local_moses.cc",
      "line": 180,
      "type": "TODO",
      "content": "// TODO use the option of the output",
      "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 202,
      "type": "FIXME",
      "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
      "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 305,
      "type": "TODO",
      "content": "if (!dex.create_demes(exemplar, 0 /* TODO replace with the",
      "context": "        mompi.recv_exemplar(exemplar);\n        logger().info() << \"Allowed \" << max_evals \n                        << \" evals for recvd exemplar \" << exemplar;\n        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // Notify root of failure and continue processing\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 318,
      "type": "FIXME",
      "content": "// XXX TODO should probably fetch max_time from somewhere...",
      "context": "            continue; // Continue to next exemplar\n        }\n\n        // XXX TODO should probably fetch max_time from somewhere...\n        time_t max_time = INT_MAX;\n        dex.optimize_demes(max_evals, max_time);\n\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 424,
      "type": "FIXME",
      "content": "// XXX is mp.best_score thread safe !???? since another thread might be updating this as we",
      "context": "\n    // If we are here, then we are the root node.  The root will act\n    // as a dispatcher to all of the worker nodes.\n// XXX is mp.best_score thread safe !???? since another thread might be updating this as we\n// come around ...\n\n    size_t tot_workers = mompi.num_workers();\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 486,
      "type": "TODO",
      "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
      "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 570,
      "type": "FIXME",
      "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
      "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
    },
    {
      "file": "moses/moses/moses/moses/mpi_moses.cc",
      "line": 616,
      "type": "FIXME",
      "content": "// XXX TODO instead of overwritting the demeID it should be",
      "context": "        scored_combo_tree_set candidates;\n        stats.n_expansions ++;\n\n        // XXX TODO instead of overwritting the demeID it should be\n        // correctly defined by the worker and send back to the\n        // dispatcher. That way we can have the breadth_first\n        // componant of the demeID right.\n"
    },
    {
      "file": "moses/moses/moses/moses/partial.cc",
      "line": 96,
      "type": "TODO",
      "content": "// TODO: Improve generation tracking by getting actual number",
      "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
    },
    {
      "file": "moses/moses/moses/moses/partial.cc",
      "line": 264,
      "type": "FIXME",
      "content": "// XXX is this correct? I think we need to ask the cscorer for the total ...",
      "context": "    // Are we done yet?\n    behavioral_score bs = _bscore->operator()(cand);\n\n    // XXX is this correct? I think we need to ask the cscorer for the total ...\n    score_t total_score = 0.0;\n    for (const score_t& sc : bs)\n        total_score += sc;\n"
    },
    {
      "file": "moses/moses/moses/moses/partial.cc",
      "line": 304,
      "type": "FIXME",
      "content": "// XXX Ineffective predicates may be due to enums that have been",
      "context": "        good_count = 0;\n        effective(predicate, good_count, fail_count);\n\n        // XXX Ineffective predicates may be due to enums that have been\n        // completely accounted for ... not sure what to do about that...\n        if ((0 < good_count) || (0 < fail_count))\n            break;\n"
    },
    {
      "file": "moses/moses/moses/optimization/optimization.cc",
      "line": 79,
      "type": "FIXME",
      "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
      "context": "}\n\n// N = p.popsize_ratio * n^1.05\n// XXX Why n^1.05 ??? This is going to have a significant effect\n// (as compared to n^1.00) only when n is many thousands or bigger...\nunsigned optim_parameters::pop_size(const field_set& fs) const\n{\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.cc",
      "line": 122,
      "type": "FIXME",
      "content": "// XXX What score do i use?",
      "context": "                            boost::bind(boost::cref(iscorer), _1));\n        current_number_of_evals += swarm_size;\n\n        // XXX What score do i use?\n        // I'll use best_score for now.\n        bool has_improved = false;\n        for (unsigned i = 0; i < swarm_size; ++i) {\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.cc",
      "line": 197,
      "type": "TODO",
      "content": "// TODO: work in a better way to identify convergence.",
      "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
    },
    {
      "file": "moses/moses/moses/optimization/particle-swarm.cc",
      "line": 236,
      "type": "TODO",
      "content": "// TODO: Explanation",
      "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
    },
    {
      "file": "moses/moses/moses/optimization/star-anneal.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX TODO the annealing temperature control code should be ported over",
      "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 51,
      "type": "FIXME",
      "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
      "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 238,
      "type": "FIXME",
      "content": "// XXX TODO need to add support for \"term algebra\" knobs",
      "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 393,
      "type": "FIXME",
      "content": "// XXX This is dead code, no one uses it, and looking at the below, it",
      "context": "}\n\n#ifdef EXEMPLAR_INST_IS_UNDEAD\n// XXX This is dead code, no one uses it, and looking at the below, it\n// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 397,
      "type": "FIXME",
      "content": "// XXX why are we clearing this, instead of setting it back to the",
      "context": "// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 400,
      "type": "FIXME",
      "content": "// XXX Note that the clear_exemplar() methods on the knobs are probably",
      "context": "// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n//  not needed either!?\nvoid representation::clear_exemplar()\n{\n"
    },
    {
      "file": "moses/moses/moses/representation/representation.cc",
      "line": 411,
      "type": "FIXME",
      "content": "// XXX that, and contin seems to be handled inconsistently with disc...",
      "context": "}\n\n// What is this doing ? seems to be clearing things out, why do we need this?\n// XXX that, and contin seems to be handled inconsistently with disc...\n// I mean, shouldn't we be setting the exemplar_inst fields so that\n// they match the exmplar?  Do we even need the exemplar_inst for anything?\nvoid representation::set_exemplar_inst()\n"
    },
    {
      "file": "moses/moses/moses/scoring/bscores.cc",
      "line": 570,
      "type": "TODO",
      "content": "// TODO",
      "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
    },
    {
      "file": "moses/moses/moses/scoring/bscores.cc",
      "line": 930,
      "type": "FIXME",
      "content": "/// XXX this should probably be removed! TODO FIXME",
      "context": "/// even output all the data that is required to use the resulting\n/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 239,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "      _hardness(hardness),\n      _full_bscore(true)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n\n    logger().info(\"Discriminating scorer, hardness = %f, \"\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 443,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_precision, max_precision, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 512,
      "type": "FIXME",
      "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
      "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 612,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "                       float hardness)\n    : discriminating_bscore(ct, min_diff, max_diff, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 646,
      "type": "FIXME",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the break-even-point for this ctable row.\nscore_t bep_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt * _true_total);\n    double best_possible_recall = 1.0 / _true_total;\n    return (best_possible_precision + best_possible_recall) / 2;\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 655,
      "type": "FIXME",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the difference for this ctable row.\nscore_t bep_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt);\n    double best_possible_recall = (0.0 < pos) ? 1.0 : 0.0;\n    return fabs(best_possible_precision - best_possible_recall);\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 674,
      "type": "FIXME",
      "content": "// XXX Currently, this scorer does not return a true behavioral score",
      "context": "f_one_bscore::f_one_bscore(const CTable& ct)\n    : discriminating_bscore(ct, 0.0, 1.0, 1.0e-20)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 1;\n}\n\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 707,
      "type": "FIXME",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "// generation of best-possible score.\nscore_t f_one_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    return 1.0;\n}\n\n"
    },
    {
      "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
      "line": 714,
      "type": "FIXME",
      "content": "// XXX TODO FIXME is this really correct?",
      "context": "/// Return the f_one for this ctable row.\nscore_t f_one_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / cnt;\n    double best_possible_recall = 1.0;\n    double f_one = 2 * best_possible_precision * best_possible_recall\n"
    },
    {
      "file": "moses/moses/moses/scoring/scoring_base.cc",
      "line": 142,
      "type": "FIXME",
      "content": "// XXX FIXME complexity_t should be a double not an int ...",
      "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
    },
    {
      "file": "moses/moses/moses/scoring/time_dispersion.cc",
      "line": 43,
      "type": "TODO",
      "content": "// TODO multipler other than 1 is not supported yet",
      "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 128,
      "type": "stub",
      "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
      "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 129,
      "type": "stub",
      "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
      "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n"
    },
    {
      "file": "unify/opencog/unify/atoms/UnifierLink.cc",
      "line": 141,
      "type": "FIXME",
      "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
      "context": "\t// I don't really understand what a solution set is.\n\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n"
    },
    {
      "file": "ure/opencog/ure/BetaDistribution.cc",
      "line": 33,
      "type": "TODO",
      "content": "// TODO should be replaced by tv->get_mode() once implemented",
      "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n"
    },
    {
      "file": "ure/opencog/ure/Rule.cc",
      "line": 58,
      "type": "TODO",
      "content": "// TODO: could certainly be optimized by not systematically",
      "context": "\nvoid RuleSet::expand_meta_rules(AtomSpace& as)\n{\n\t// TODO: could certainly be optimized by not systematically\n\t// recollecting and re-instantiating meta-rules.\n\tRuleSet meta_rules;\n\tfor (RulePtr rule : *this) {\n"
    },
    {
      "file": "ure/opencog/ure/Rule.cc",
      "line": 397,
      "type": "FIXME",
      "content": "if (not implicand)  // XXX this check is never needed !?",
      "context": "{\n\tHandle implicand = get_implicand();\n\n\tif (not implicand)  // XXX this check is never needed !?\n\t\treturn false;\n\n\tType itype = implicand->get_type();\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.cc",
      "line": 121,
      "type": "TODO",
      "content": "set_leaf2bitnode();         // TODO: might differ till needed to optimize",
      "context": "AndBIT::AndBIT(const Handle& f, double cpx, const AtomSpace* qas)\n\t: fcs(f), complexity(cpx), exhausted(false), queried_as(qas)\n{\n\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BIT.cc",
      "line": 374,
      "type": "TODO",
      "content": "// TODO: is this merging necessary?",
      "context": "\tHandle nrewrite = expand_fcs_rewrite(nfcs_rewrite, rule.first);\n\n\t// Generate new vardecl\n\t// TODO: is this merging necessary?\n\tHandle merged_vardecl = merge_vardecl(nfcs_vardecl, rule_vardecl);\n\tHandle nvardecl = filter_vardecl(merged_vardecl, {npattern, nrewrite});\n\n"
    },
    {
      "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
      "line": 288,
      "type": "TODO",
      "content": "// TODO: Maybe we could take advantage of the new read-only",
      "context": "\t// of concerns instead of the atoms themselves, and only modify\n\t// the atoms if there are existing results to copy back to _as.\n\t//\n\t// TODO: Maybe we could take advantage of the new read-only\n\t// capabilities of the AtomSpace.\n\tHandle hresult = HandleCast(fcs->execute(tmp_as.get()));\n\tHandleSeq results;\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 101,
      "type": "TODO",
      "content": "// TODO: For now the FC follows the old standard. We may move to",
      "context": "\n\t// Set rules.\n\t_rules = _config.get_rules();\n\t// TODO: For now the FC follows the old standard. We may move to\n\t// the new standard when all rules have been ported to the new one.\n\tfor (RulePtr rule : _rules)\n\t\trule->premises_as_clauses = true;\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 165,
      "type": "TODO",
      "content": "// TODO: if creating/destroying threads is too expensive, use a thread",
      "context": "\twhile (not termination()) do_step(_iteration++);\n}\n\n// TODO: if creating/destroying threads is too expensive, use a thread\n// pool (see boost::asio::thread_pool).\nvoid ForwardChainer::do_steps_multithread()\n{\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 289,
      "type": "TODO",
      "content": "// TODO: This can be simplified but is let here until do_step is",
      "context": "\t\t// before being passed to the new source constructor, as this\n\t\t// one will take it into account.\n\t\t//\n\t\t// TODO: This can be simplified but is let here until do_step is\n\t\t// replaced by do_step_srpi.\n\t\tdouble weight = std::min(1.0, slc_sr.source->weight);\n\t\tdouble prob = success_plty / weight;\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 372,
      "type": "TODO",
      "content": "// TODO: refine mutex",
      "context": "\nSourcePtr ForwardChainer::select_source(const std::string& msgprfx)\n{\n\t// TODO: refine mutex\n\tstd::unique_lock<std::mutex> lock(_part_mutex);\n\n\tstd::vector<double> weights = _sources.get_weights();\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 409,
      "type": "TODO",
      "content": "// TODO: This has the effect of deallocating the rules, which",
      "context": "\t\tif (_config.get_retry_exhausted_sources()) {\n\t\t\ture_logger().debug() << msgprfx\n\t\t\t                     << \"Reset all exhausted flags to retry them\";\n\t\t\t// TODO: This has the effect of deallocating the rules, which\n\t\t\t// might cause a memory corruption if another thread is\n\t\t\t// attempting to apply that rule at the same time.\n\t\t\t_sources.reset_exhausted();\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
      "line": 523,
      "type": "TODO",
      "content": "std::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine",
      "context": "\nRuleSet ForwardChainer::get_valid_rules(const Source& source)\n{\n\tstd::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine\n\n\t// Generate all valid rules\n\tRuleSet valid_rules;\n"
    },
    {
      "file": "ure/opencog/ure/forwardchainer/SourceSet.cc",
      "line": 48,
      "type": "TODO",
      "content": "// TODO:",
      "context": "\t// The minimum value is 1e-16 to not ignore completely the source\n\t// when the it is a default TV.\n\t//\n\t// TODO:\n\t// 1. Support more fitness functions\n\t// 2. Explicitely turn the fitness into a probability of success\n\tTruthValuePtr tv = bdy->getTruthValue();\n"
    },
    {
      "file": "analyze_fixme_instances.py",
      "line": 138,
      "type": "FIXME",
      "content": "('xxx' in line_lower and (line_lower.strip().startswith('#') or line_lower.strip().startswith('//'))) or  # XXX comments",
      "context": "            \n        # Look for actual FIXME patterns in comments  \n        return (('fixme' in line_lower) or \n                ('xxx' in line_lower and (line_lower.strip().startswith('#') or line_lower.strip().startswith('//'))) or  # XXX comments\n                ('xxx' in line_lower and ('fix' in line_lower or 'todo' in line_lower)) or\n                ('todo' in line_lower and 'fixme' in line_lower))\n    \n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 13,
      "type": "FIXME",
      "content": "\"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",",
      "context": "    \"\"\"Process the specific FIXME examples from the issue description.\"\"\"\n    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 14,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",",
      "context": "    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 16,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",",
      "context": "        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 17,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",",
      "context": "        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 18,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",",
      "context": "        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 19,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",",
      "context": "        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 23,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",",
      "context": "        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 25,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",",
      "context": "        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 26,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",",
      "context": "        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 28,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",",
      "context": "        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 30,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",",
      "context": "        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 32,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",",
      "context": "        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 33,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",",
      "context": "        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 35,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",",
      "context": "        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 36,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",",
      "context": "        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 38,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",",
      "context": "        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 42,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
      "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 44,
      "type": "FIXME",
      "content": "\"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"",
      "context": "        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n    \n    # Categorize these specific examples\n"
    },
    {
      "file": "analyze_issue_examples.py",
      "line": 106,
      "type": "FIXME",
      "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
      "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n"
    },
    {
      "file": "fixme_resolution_tracker.py",
      "line": 169,
      "type": "FIXME",
      "content": "report.append(\"# FIXME Resolution Progress Report\")",
      "context": "    def generate_next_steps_report(self) -> str:\n        \"\"\"Generate a report implementing the next steps from the catalog.\"\"\"\n        report = []\n        report.append(\"# FIXME Resolution Progress Report\")\n        report.append(f\"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"\")\n        \n"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 83,
      "type": "TODO",
      "content": "echo \"   // TODO: Implement error handling for edge case X\"",
      "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 250,
      "type": "FIXME",
      "content": "# FIXME Resolution Makefile Targets",
      "context": "        \n        makefile = self.repo_root / \"Makefile.fixme\"\n        makefile_content = dedent('''\n            # FIXME Resolution Makefile Targets\n            # Include this in your main Makefile with: include Makefile.fixme\n            \n            .PHONY: fixme-status fixme-easy-wins fixme-report fixme-setup\n"
    },
    {
      "file": "verify_implementations.py",
      "line": 222,
      "type": "NotImplementedError",
      "content": "r'throw.*not\\s+implemented',",
      "context": "    def _check_for_placeholders(self, content: str, item: TodoItem) -> bool:\n        \"\"\"Check for placeholder implementations\"\"\"\n        placeholder_patterns = [\n            r'throw.*not\\s+implemented',\n            r'return.*TODO',\n            r'return.*STUB',\n            r'return.*PLACEHOLDER',\n"
    },
    {
      "file": "find_placeholders.py",
      "line": 21,
      "type": "NotImplementedError",
      "content": "'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
      "context": "        self.patterns = {\n            'TODO': r'(//|#|;|/\\*)\\s*TODO[:\\s]',\n            'FIXME': r'(//|#|;|/\\*)\\s*(FIXME|XXX)[:\\s]',\n            'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',\n            'pass_only': r'def\\s+\\w+\\([^)]*\\):\\s*pass\\s*$',\n            'empty_function': r'def\\s+\\w+\\([^)]*\\):\\s*\\.\\.\\.\\s*$',\n            'stub': r'(//|#|;)\\s*STUB[:\\s]',\n"
    },
    {
      "file": "atomspace-restful/opencog/python/web/api/utilities.py",
      "line": 17,
      "type": "FIXME",
      "content": "# FIXME: Should this moved to the atomspace repo and be part",
      "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
    },
    {
      "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
      "line": 449,
      "type": "FIXME",
      "content": "# XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.",
      "context": "    def test_m_scheme_command(self):\n        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n"
    },
    {
      "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
      "line": 456,
      "type": "TODO",
      "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
      "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
    },
    {
      "file": "atomspace/tests/cython/atomspace/test_atomspace.py",
      "line": 362,
      "type": "FIXME",
      "content": "# XXX FIXME is testing the name of the bottom type",
      "context": "    def test_get_type_name(self):\n        self.assertEqual(get_type_name(types.Node), \"Node\")\n        self.assertEqual(get_type_name(2231), \"\")\n        # XXX FIXME is testing the name of the bottom type\n        # a sane thing to do?\n        self.assertEqual(get_type_name(types.NO_TYPE), \"*** Bottom Type! ***\")\n"
    },
    {
      "file": "components/core/atomspace-restful/opencog/python/web/api/utilities.py",
      "line": 17,
      "type": "FIXME",
      "content": "# FIXME: Should this moved to the atomspace repo and be part",
      "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
    },
    {
      "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
      "line": 449,
      "type": "FIXME",
      "content": "# XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.",
      "context": "    def test_m_scheme_command(self):\n        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n"
    },
    {
      "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
      "line": 456,
      "type": "TODO",
      "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
      "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
    },
    {
      "file": "language-learning/src/grammar_learner/category_learner.py",
      "line": 32,
      "type": "FIXME",
      "content": "log = OrderedDict()  # FIXME: log \u00bb response",
      "context": "    algorithm = kwa('kmeans', 'clustering', **kwargs)\n    verbose = kwa('none', 'verbose', **kwargs)\n\n    log = OrderedDict()  # FIXME: log \u00bb response\n    log.update({'category_learner': 'v.0.7.81231'})\n\n    cdf = pd.DataFrame(columns = ['cluster', 'cluster_words'])\n"
    },
    {
      "file": "language-learning/src/grammar_learner/category_learner.py",
      "line": 53,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            dim = vector_space_dim(links, dict_path, tmpath, dim_max, sv_min,\n                                   verbose)\n        except:  # FIXME\n            dim = dim_max\n        log.update({'vector_space_dim': dim})\n\n"
    },
    {
      "file": "language-learning/src/grammar_learner/clustering.py",
      "line": 361,
      "type": "TODO",
      "content": "# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids",
      "context": "# 80809 update: (30,60,3,[3]) - old range + repeat / (120,30,3) -- search opt\n# 80825 random_clusters\n# 81022 refactoring\n# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids\n# 81231 cleanup\n# 90104 resolve Turtle MST LW crash: 1 cluster\n# 90209 group_links: add min_word_count to 80925 legacy version\n"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 14,
      "type": "FIXME",
      "content": "nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?",
      "context": "    rights = Counter()  # right words in links\n    links = Counter()   # tuples: (left_word, right_word)\n    lw = Counter()      # linked words\n    nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?\n    nlws = set()        # a set of non-linked words in a sentence in a loop\n    nnlws = 0           # number of non-linked word occasions in all sentences\n    sentence = []       # a list of words (used within loops)\n"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 37,
      "type": "FIXME",
      "content": "nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned",
      "context": "                if len(nlws) > 0:  # indices of non-parsed words in sentence\n                    nnlws += len(nlws)  # number of non-linked words\n                    for j in nlws:\n                        nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned\n                    # nlws = set()\n                # sentence = []\n                # Count only parsed words (excluding ###LEFT-WALL### and .)\n"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 112,
      "type": "TODO",
      "content": "# TODO: update - see GitHub issue?",
      "context": "\n# 80802 poc05 restructured: moved here from pparser.py\n# 80829,31 unpws, unlws\n# TODO: update - see GitHub issue?\n# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n"
    },
    {
      "file": "language-learning/src/grammar_learner/corpus_stats.py",
      "line": 116,
      "type": "TODO",
      "content": "# TODO: update sentence length count to parsed words?",
      "context": "# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n# TODO: update sentence length count to parsed words?\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 133,
      "type": "TODO",
      "content": "else:  # 81130: prune clusters with empty dj sets  # TODO: update",
      "context": "                    new_dj.append(ordnung.index(abs(index)) * sign(index))\n                new_rule.append(tuple(new_dj))\n            new_cats['disjuncts'][rule] = set(new_rule)\n        else:  # 81130: prune clusters with empty dj sets  # TODO: update\n            print(('rule', rule, '- 0 djs in new_cats[disjuncts][rule]:',\n                   new_cats['disjuncts'][rule]))\n\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 179,
      "type": "TODO",
      "content": "# TODO: list of merged clusters - to delete",
      "context": "    if aggregation == 'jaccard':\n        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 180,
      "type": "TODO",
      "content": "# TODO: delete merged clusters",
      "context": "        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n        while z > 1 and threshold > aggr_threshold:\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 206,
      "type": "TODO",
      "content": "# TODO: delete merged clusters?",
      "context": "    cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n    sims = [x for x in similarities]  # if x < threshold]\n    threshold = max(sims) - 0.01\n    # TODO: delete merged clusters?\n\n    z = len(similarities)\n    while z > 1 and threshold > aggr_threshold:\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 215,
      "type": "TODO",
      "content": "# Renumber connectors in disjuncts # TODO: for all clusters?",
      "context": "        threshold = max(sims) - 0.01\n        z = len(sims)\n\n    # Renumber connectors in disjuncts # TODO: for all clusters?\n    clusters = [i for i, x in enumerate(cats['cluster'])\n                if i > 0 and x is not None]\n\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 277,
      "type": "TODO",
      "content": "# TODO: delete merged clusters?",
      "context": "        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        sims = [x for x in similarities]  # if x < threshold]\n        threshold = max(sims) - 0.01\n        # TODO: delete merged clusters?\n        z = len(similarities)\n        while z > 1 and threshold > aggr_threshold:\n            cats, similarities = aggregate(cats, threshold, jaccard, verbose)\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 356,
      "type": "TODO",
      "content": "cats['parent'][cluster] = new_cluster_id  # TODO: don't change",
      "context": "\n        for cluster in mset:\n            cats['top'][cluster] = new_cluster_id  # 81123\n            cats['parent'][cluster] = new_cluster_id  # TODO: don't change\n            cats['words'][new_cluster_id].update(cats['words'][cluster])\n            cats['disjuncts'][new_cluster_id].update(cats['disjuncts'][cluster])\n            cats['djs'][new_cluster_id].update(cats['djs'][cluster])\n"
    },
    {
      "file": "language-learning/src/grammar_learner/generalization.py",
      "line": 414,
      "type": "TODO",
      "content": "# TODO: aggregate_cosine?",
      "context": "# 80725 POC 0.1-0.4 deleted, 0.5 restructured\n# 80802 poc05.py restructured, cats2list moved to category_learner.py,\n# cats2list copied to poc05.py for tmp compatibility\n# TODO: aggregate_cosine?\n# 80802 fix compatibility with dj_counts & max_disjuncts, delete ...05.py?\n# 81121 generalise_rules\n# 81217 FIXME? generalize_categories [F] with new reorder (Turtle tests)\n"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 27,
      "type": "FIXME",
      "content": "if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!",
      "context": "def calc_pmi(counts, cds):  # Calculates e^PMI; PMI without the log().\n    sum_w = np.array(counts.sum(axis=1))[:, 0]\n    sum_c = np.array(counts.sum(axis=0))[0, :]\n    if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!\n    sum_total = sum_c.sum()\n    sum_w = np.reciprocal(sum_w)\n    sum_c = np.reciprocal(sum_c)\n"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 138,
      "type": "FIXME",
      "content": "print('SVDEmbedding: transpose')    #FIXME:DEL",
      "context": "    # Context embeddings can be created with \"transpose\".\n    def __init__(self, path, normalize=True, eig=0.0, transpose=False):\n        if transpose:\n            print('SVDEmbedding: transpose')    #FIXME:DEL\n            ut = np.load(path + '.vt.npy')\n            self.wi, self.iw = load_vocabulary(path + '.contexts.vocab')\n        else:\n"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 358,
      "type": "TODO",
      "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
      "context": "    logger.info(f'SVD matrix (3 files .npy) saved: {len(ut[0])} vectors, ut: {len(ut)} s: {len(s)} vt:{len(vt)}')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 439,
      "type": "TODO",
      "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
      "context": "    list2tsv(explicit.ic, svd_path + '.contexts.vocab')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
    },
    {
      "file": "language-learning/src/grammar_learner/hyperwords.py",
      "line": 466,
      "type": "TODO",
      "content": "# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?",
      "context": "# Notes:\n\n# 80329 added vector_space_dim\n# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?\n# 90221 minor updates for Grammar Learner tutorial\n"
    },
    {
      "file": "language-learning/src/grammar_learner/pqa_table.py",
      "line": 641,
      "type": "FIXME",
      "content": "continue  # FIXME: check case",
      "context": "                     linkage, affinity, gen, ' ---', 'fail',\n                     ' ---', ' ---', ' ---', ' ---', ' ---', ' ---']\n            details.append(dline)\n            continue  # FIXME: check case\n        if kwargs['linkage_limit'] > 0:\n            start = time.time()\n            a, f1, precision, q = pqa_meter(re['grammar_file'],\n"
    },
    {
      "file": "language-learning/src/grammar_learner/preprocessing.py",
      "line": 33,
      "type": "TODO",
      "content": "# TODO: cleanup here or in a separate constructor?",
      "context": "            if us[-1] != '\\n' :  us += '\\n'\n        us += s\n        if us[-1] != '\\n' :  us += '\\n'\n    # TODO: cleanup here or in a separate constructor?\n    re = OrderedDict([('read_files', UTC()),\n                      ('input_path', kwargs['input_path']),\n                      ('read_files_number', len(files)),\n"
    },
    {
      "file": "language-learning/src/grammar_learner/preprocessing.py",
      "line": 141,
      "type": "FIXME",
      "content": "# else:  # FIXME: raise error / assert ?",
      "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 25,
      "type": "TODO",
      "content": "elif clustering == 'group':  # TODO: call ILE clustering?",
      "context": "            clustering = ('kmeans', 'k-means++', 10)\n        elif clustering in ['mean_shift', 'mean shift', 'meanshift']:\n            clustering = ('mean_shift', 2)  # Note: 'auto' bandwidth not yet implemented\n        elif clustering == 'group':  # TODO: call ILE clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 29,
      "type": "TODO",
      "content": "elif clustering == 'random':  # TODO: call random clustering?",
      "context": "            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n        elif clustering == 'random':  # TODO: call random clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'random not supported in skl_clustering'}, []\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 56,
      "type": "TODO",
      "content": "# TODO: int / dict",
      "context": "            if len(clustering) > 3:  # connectivity\n                if type(clustering[3]) is int and clustering[3] > 0:\n                    neighbors = clustering[3]\n                    # TODO: int / dict \n                    connectivity = kneighbors_graph(cd, neighbors,\n                                                    include_self=False)\n            if len(clustering) > 4:  # compute_full_tree\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 111,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            metrics['silhouette_index'] = float(\n                silhouette_score(cd, labels, metric=clustering_metric[1]))\n        except:  # FIXME\n            metrics['silhouette_index'] = 0.0\n        try:\n            metrics['variance_ratio'] = float(\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 116,
      "type": "FIXME",
      "content": "except:  # FIXME",
      "context": "        try:\n            metrics['variance_ratio'] = float(\n                calinski_harabaz_score(cd, labels))\n        except:  # FIXME\n            metrics['variance_ratio'] = 0.0\n        # try:\n        #   metrics['davies_bouldin_score'] = float(\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 124,
      "type": "FIXME",
      "content": "except:  # else:  # FIXME",
      "context": "        # except: metrics['davies_bouldin_score'] = 0.0\n\n        return labels, metrics, centroids\n    except:  # else:  # FIXME\n        print('except: skl_clustering error')\n        return np.asarray(range(cd.shape[0])), \\\n               {'clustering': 'skl_clustering error'}, []\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 172,
      "type": "TODO",
      "content": "elif len(crange) == 3:  # TODO: replace with SGD?",
      "context": "                    l, m, c = skl_clustering(cd, crange[0], **kwargs)\n                    if m['silhouette_index'] > metrics['silhouette_index']:\n                        labels, metrics, centroids = l, m, c\n        elif len(crange) == 3:  # TODO: replace with SGD?\n            n_min = min(crange[0], crange[1])\n            n_max = max(crange[0], crange[1])\n            labels, metrics, centroids = \\\n"
    },
    {
      "file": "language-learning/src/grammar_learner/skl_clustering.py",
      "line": 208,
      "type": "FIXME",
      "content": "# FIXME: try...except",
      "context": "# 181203 cleanup\n# 190118 cleanup: remove debug printing\n# 190425 fix n_clusters > n_words case\n# FIXME: try...except\n"
    },
    {
      "file": "language-learning/src/grammar_learner/widgets.py",
      "line": 70,
      "type": "TODO",
      "content": "#  TODO: To be reviewed and changed if necessary",
      "context": "                tree.append(['', m+1, cats[j][2], cats[j][3]])\n        else:\n            print('WTF?', k, v)\n    #  TODO: To be reviewed and changed if necessary\n    if verbose not in ['none', 'min']:\n        display(html_table([['Code', 'Parent', 'Id', 'Words']] + tree))\n\n"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 26,
      "type": "FIXME",
      "content": "def setUp(self):    # FIXME: should run before every test, but would not?!",
      "context": "\nclass TestGrammarLearner(unittest.TestCase):\n\n    def setUp(self):    # FIXME: should run before every test, but would not?!\n        input_parses = module_path + '/tests/data/POC-Turtle/MST_fixed_manually/'\n        batch_dir = module_path + '/output/Test_Grammar_Learner_' + str(UTC())[:10] + '/'\n        kwargs = {  # defaults\n"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 65,
      "type": "FIXME",
      "content": "# 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester",
      "context": "        # Additional (optional) parameters for parse_metrics (_abiity & _quality):\n        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 212,
      "type": "TODO",
      "content": "# TODO: Remove these commented lines in next cleanup cycle.",
      "context": "        }\n        re = learn_grammar(**kwargs)\n        # NOTE: Legacy test code commented out for historical reference.\n        # TODO: Remove these commented lines in next cleanup cycle.\n        # a, q, qa = pqa_meter(re['grammar_file'], outpath, cp, rp, **kwargs)\n        # print('parse-ability, parse-quality:', a, q)\n        # assert a*q > 0.99\n"
    },
    {
      "file": "language-learning/tests/test_grammar_learner.py",
      "line": 310,
      "type": "FIXME",
      "content": "# FIXME: check with further test_grammar updates and delete.",
      "context": "            'verbose'       :   'min'\n        }\n        # Sometimes pqa_meter(with test_grammar updated 2018-10-19) returns pa,recall = 0,0\n        # FIXME: check with further test_grammar updates and delete.\n        x = 0.\n        n = 0\n        while x < 0.1 :\n"
    },
    {
      "file": "scripts/generate_todo_catalog.py",
      "line": 56,
      "type": "NotImplementedError",
      "content": "r'throw.*IOException.*\"Not implemented\"',",
      "context": "            r'NOT IMPLEMENTED',\n            r'STUB\\s*:?\\s*(.*)',\n            r'PLACEHOLDER\\s*:?\\s*(.*)',\n            r'throw.*IOException.*\"Not implemented\"',\n            r'OC_ASSERT\\s*\\(\\s*false\\s*,\\s*\"[^\"]*not implemented[^\"]*\"',\n            r'Ensemble scoring not implemented',\n        ]\n"
    }
  ],
  "summary_by_type": {
    "FIXME": [
      {
        "file": "atomspace/opencog/scm/opencog/base/file-utils.scm",
        "line": 122,
        "type": "FIXME",
        "content": "; XXX this duplicates (load-from-path) which is a built-in in guile...",
        "context": ")\n\n; ---------------------------------------------------------------------\n; XXX this duplicates (load-from-path) which is a built-in in guile...\n(define-public (load-scm-from-file filename)\n\"\n load-scm-from-file filename   Run scheme code taken from file\n"
      },
      {
        "file": "atomspace/opencog/scm/opencog/base/utilities.scm",
        "line": 749,
        "type": "FIXME",
        "content": "; XXX This should probably be made obsolete.",
        "context": "\n; -----------------------------------------------------------------------\n;\n; XXX This should probably be made obsolete.\n(define-public (cog-get-reference refptr)\n\"\n  Given a reference structure, return the referenced list entries.\n"
      },
      {
        "file": "atomspace/tests/atoms/execution/defined-schema.scm",
        "line": 239,
        "type": "FIXME",
        "content": "; XXX FIXME, this does not quite work as one might naively expect,",
        "context": "\n; Define a recursive tree-walker. Unlike the above, this does\n; not reverse the order of the edges.\n; XXX FIXME, this does not quite work as one might naively expect,\n; because the search results are expanded combinatorially, instead\n; of being kept in branching-tree form.\n(DefineLink\n"
      },
      {
        "file": "atomspace/tests/query/seq-absence.scm",
        "line": 86,
        "type": "FIXME",
        "content": ";; XXX FIXME ... this and the above need to get done right.",
        "context": ";; AbsentLinks in a fundamentally different way. But we test this\n;; anyway, for now.  Like the above, its currently broken. Its too\n;; weird right now for me to want to fix it, so I am punting on this.\n;; XXX FIXME ... this and the above need to get done right.\n\n(define or-not-absent\n\t(SatisfactionLink\n"
      },
      {
        "file": "atomspace/tests/query/sudoku-puzzle.scm",
        "line": 9,
        "type": "FIXME",
        "content": "; XXX As of 18 October 2014, the pattern matcher fails to find a",
        "context": "; Hand-typed-in version of\n; http://www.theguardian.com/lifeandstyle/2014/oct/17/sudoku-2944-hard\n;\n; XXX As of 18 October 2014, the pattern matcher fails to find a\n; solution.  This is probably due to a bug in the pattern matcher,\n; although it might be due to a bug in the coding below ...\n; XXXXXXXXXXXXXXXXX\n"
      },
      {
        "file": "atomspace/tests/scm/typedefs.scm",
        "line": 3,
        "type": "FIXME",
        "content": "; XXX THIS FILE IS TO BE USED IN ASSOCIATION WITH THIS TEST CASE ONLY",
        "context": "; This file contains basic scheme wrappers for atom creation.\n; \n; XXX THIS FILE IS TO BE USED IN ASSOCIATION WITH THIS TEST CASE ONLY\n; DO NOT USE THIS FILE FOR ORDINARY CODE DEVELOPMENT; YOUR CODE WILL\n; BE BROKEN IF YOU DO!  XXXX\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 147,
        "type": "FIXME",
        "content": ";; XXX Needs to be replaced by OpenPsi emotional state modelling.",
        "context": "\n\n;; Interact with the current face target.\n;; XXX Needs to be replaced by OpenPsi emotional state modelling.\n(DefineLink\n\t(DefinedPredicate \"Interact with face\")\n\t(SequentialAnd\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 179,
        "type": "FIXME",
        "content": "; XXX FIXME this should be a part of \"Show random expression\"",
        "context": "\t(SequentialAnd\n\t\t(DefinedPredicate \"was room empty?\")\n\t\t; Record a new emotional state (for self-awareness)\n\t\t; XXX FIXME this should be a part of \"Show random expression\"\n\t\t; below ...\n\t\t(Put (DefinedPredicate \"Request Set Face Expression\")\n\t\t\t(ListLink bhv-source (Concept \"new-arrival\")))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 228,
        "type": "FIXME",
        "content": "(RandomChoice (Put; FIXME Replace by multiple face tracking.",
        "context": "\t(SequentialAnd\n\t\t(True (Put ; Setting interaction target for \"look at person\"\n\t\t\t(DefinedPredicate \"Set interaction target\")\n\t\t\t(RandomChoice (Put; FIXME Replace by multiple face tracking.\n\t\t\t\t(DefinedSchemaNode \"Get recognized face's face id\")\n\t\t\t\t(DefinedSchema \"Get recognized faces\")))))\n\t\t(DefinedPredicate \"look at person\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 242,
        "type": "FIXME",
        "content": ";; XXX TODO -- if interacting for a while",
        "context": "\n;; Respond to a new face becoming visible.\n;\n;; XXX TODO -- if interacting for a while\n;; this alters probability of glance...\n(DefineLink\n\t(DefinedPredicate \"Respond to new arrival\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 378,
        "type": "FIXME",
        "content": "; XXX incomplete!  need the face study saccade stuff...",
        "context": "\t\t\t\t(SequentialOr\n\t\t\t\t\t(SequentialAnd\n\t\t\t\t\t\t(DefinedPredicateNode \"dice-roll: face study\")\n; XXX incomplete!  need the face study saccade stuff...\n; I am confused ... has this been superceeded by the ROS-saccades,\n; or is this still means to be used?\n\t\t\t\t\t\t(False)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 428,
        "type": "FIXME",
        "content": ";; XXX question: This is turning the whole head; perhaps we",
        "context": "\n\t\t;; Search for attention -- change gaze every so often.\n\t\t;; Coordinate system: x forward; y side-to-side, z up.\n\t\t;; XXX question: This is turning the whole head; perhaps we\n\t\t;; should be moving eyes only?\n\t\t(SequentialOr\n\t\t\t(Not (DefinedPredicate \"Time to change gaze\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 719,
        "type": "FIXME",
        "content": ";; XXX FIXME -- this should not be hard-coded here!",
        "context": "\t))\n\n;; Actions for loud sound\n;; XXX FIXME -- this should not be hard-coded here!\n(DefineLink\n\t(DefinedPredicate \"Say whoa!\")\n\t\t(Put (DefinedPredicate \"Say\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 763,
        "type": "FIXME",
        "content": "; XXX FIXME ... this means that this rule is c alled too often!",
        "context": "\t(DefinedPredicate \"Salient:Curious\")\n\t(SequentialAnd\n\t\t; Disable printing, because it prints at 100x/second.\n\t\t; XXX FIXME ... this means that this rule is c alled too often!\n\t\t; Tracking should be autonomous, not piped through the behaviors.\n\t\t; (True (Evaluation (GroundedPredicate \"scm: print-msg\")\n\t\t;\t(ListLink (Node \"--- Saliency Tracking\"))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/cfg-eva.scm",
        "line": 244,
        "type": "FIXME",
        "content": ";; XXX Right now, search for attention turns the whole head;",
        "context": "(State (Schema \"time_search_glance_max\") (Number 2.0))\n\n;; During search-for-attention, how far to look to left or right.\n;; XXX Right now, search for attention turns the whole head;\n;; perhaps only the eyes should move?\n(DefineLink (DefinedSchema \"gaze left max\") (Number 0.35))\n(DefineLink (DefinedSchema \"gaze right max\") (Number -0.4))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/cfg-sophia.scm",
        "line": 365,
        "type": "FIXME",
        "content": ";; XXX Right now, search for attention turns the whole head;",
        "context": "(State (Schema \"time_search_glance_min\") (Number 0.5))\n(State (Schema \"time_search_glance_max\") (Number 2.0))\n;; During search-for-attention, how far to look to left or right.\n;; XXX Right now, search for attention turns the whole head;\n;; perhaps only the eyes should move?\n(DefineLink (DefinedSchema \"gaze left max\") (Number 0.35))\n(DefineLink (DefinedSchema \"gaze right max\") (Number -0.4))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 74,
        "type": "FIXME",
        "content": "; FIXME: There should never be an empty set. The value should be set",
        "context": "                            (DefinedSchema \"Get face priority\")\n                            (Number face-id))))\n    (if (equal? (Set) result)\n        ; FIXME: There should never be an empty set. The value should be set\n        ; during acknowledgment.\n        (begin\n            (set-priority! face-id ordinary-face-priority)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 131,
        "type": "FIXME",
        "content": "; FIXME But why have this plane instead of calculating the distance between",
        "context": "\n; `distance` is distance from the camera. The assumption is that at the given\n; distance from the camera is the plane where all the faces are at.\n; FIXME But why have this plane instead of calculating the distance between\n; faces, will it affect the priority?\n(define distance 1.0)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 192,
        "type": "FIXME",
        "content": ";; XXX refactor all of this -- this si supposed to be a service provided",
        "context": ")\n\n;;\n;; XXX refactor all of this -- this si supposed to be a service provided\n;; byt the spoace-time server, instead of being in scheme spaghetti\n;; code.\n(define (distance-in-plane-yz face-id-1 face-id-2)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 224,
        "type": "FIXME",
        "content": "; FIXME: Sometimes d is larger than the width-of-yz-plane",
        "context": "        ; This check is for (inf). If d is not (inf) and is greater than\n        ; the width-of-yz-plane, then something fishy is going on.\n        (if (> d  width-of-yz-plane)\n            ; FIXME: Sometimes d is larger than the width-of-yz-plane\n            ; and returning 0 is causing a problem in 'choose-next-face'\n            ; Recalculate the width-of-yz-plane?\n            0.0001\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/movement-api.scm",
        "line": 27,
        "type": "FIXME",
        "content": "; XXX FIXME -- someday, should probably create a distinct API for",
        "context": "   (stv 1 1))\n\n; Must print to stdout, so that IRC chatbots can see what happened.\n; XXX FIXME -- someday, should probably create a distinct API for\n; the IRC text strings.\n(define-public (prt-face-expr PRED NAME TIME TENS)\n\t(format #t \"Robot displays facial expression \\\"~a\\\" at strength ~a for ~a seconds\\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/movement-api.scm",
        "line": 73,
        "type": "FIXME",
        "content": "; XXX FIXME: these record the animation that was chosen, and a",
        "context": "\t\t\t(ListLink PRED))))\n\n;\n; XXX FIXME: these record the animation that was chosen, and a\n; timestamp in some StateLinks. These need to be replaced by the\n; TimeServer, instead.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
        "line": 48,
        "type": "FIXME",
        "content": "; XXX FIXME: this records the animation that was chosen, and a",
        "context": "; If we wanted to rate-limit this, then make a copy of \"change-template\"\n; and edit it to provide a minimum elapsed time predicate.\n;\n; XXX FIXME: this records the animation that was chosen, and a\n; timestamp in some StateLinks. These need to be replaced by the\n; TimeServer, instead.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
        "line": 137,
        "type": "FIXME",
        "content": "; XXX FIXME, this is still broken during search for attention.",
        "context": "; As above, but (momentarily) break eye contact, first.\n; Otherwise, the behavior tree forces eye contact to be continually\n; running, and the turn-look command is promptly over-ridden.\n; XXX FIXME, this is still broken during search for attention.\n\n(DefineLink\n\t(DefinedPredicate \"Look command\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/orchestrate.scm",
        "line": 222,
        "type": "FIXME",
        "content": "; XXX Currently, this does nothing at all. Some future version may",
        "context": "; Currently, this always honors all requests.\n; Currently, the requestor is ignored.\n;\n; XXX Currently, this does nothing at all. Some future version may\n; deny change requests, depending on the request source or on other\n; factors.  XXX This is incompletely thought out and maybe should be\n; removed.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
        "line": 12,
        "type": "FIXME",
        "content": ";; XXX FIXME this is a cut-n-paste job from process-query",
        "context": "\n;--------------------------------------------------------------------\n\n;; XXX FIXME this is a cut-n-paste job from process-query\n\n(define-public (grounded-talk USER QUERY)\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
        "line": 28,
        "type": "FIXME",
        "content": ";; XXX FIXME -- remove the IRC debug response below.",
        "context": "    ; nlp-parse returns (SentenceNode \"sentence@45c470a6-29...\")\n    (define sent-node (car (nlp-parse QUERY)))\n\n    ;; XXX FIXME -- remove the IRC debug response below.\n    (display \"Hello \")\n    (display USER)\n    (display \", you said: \\\"\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/bot-api.scm",
        "line": 40,
        "type": "FIXME",
        "content": "; XXX Currently, this dispatch is done via scheme code below. The",
        "context": "    ; of the utterance.  The response processing will be based on the\n    ; type of the speech act.\n    ;\n    ; XXX Currently, this dispatch is done via scheme code below. The\n    ; correct design would use an ImplicationLink to match up the\n    ; speech-act type to the processing that would be performed.  This\n    ; would allow a single sentence to be interpreted as possibly several\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-alt.scm",
        "line": 64,
        "type": "FIXME",
        "content": "; XXX fixme -- we should not need to load either relex2logic or",
        "context": "\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n; the rules right here, since the code in this module does not depend\n; directly on thes.\n(use-modules (opencog nlp relex2logic))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-alt.scm",
        "line": 121,
        "type": "FIXME",
        "content": "; XXX These are not being used right now; these are meant to be",
        "context": ";--------------------------------------------------------------------\n;\n; These are English-language sentences that I (Eva) understand.\n; XXX These are not being used right now; these are meant to be\n; fuzzy-matched, in a newer/different design,.... which is\n; maybe abandoned right now???\n(define known-directives\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-rules.scm",
        "line": 45,
        "type": "FIXME",
        "content": "; XXX needs to be public, so that cog-execute! can find this...",
        "context": "; ---------\n(define (print-msg node) (display (cog-name node)) (newline) (stv 1 1))\n\n; XXX needs to be public, so that cog-execute! can find this...\n(define-public (show-arg node) (display node) node)\n\n; ---------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-rules.scm",
        "line": 224,
        "type": "FIXME",
        "content": "; XXX TODO Design notes:",
        "context": "\t\t)\n\t))\n\n; XXX TODO Design notes:\n; Rather than hand-crafting a bunch of rules like the above, we should\n; do three things:\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative.scm",
        "line": 142,
        "type": "FIXME",
        "content": "; XXX FIXME we need a better way of marking actions as having",
        "context": "\t\t; At this time, a ListLink is used to anchor suggested\n\t\t; actions to the current-action anchor. Wipe these out.\n\t\t; (because we have already performed the actions).\n\t\t; XXX FIXME we need a better way of marking actions as having\n\t\t; been performed, already.\n\t\t(for-each (lambda (x)\n\t\t\t(cog-extract-recursive! (ListLink current-action x)))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative.scm",
        "line": 148,
        "type": "FIXME",
        "content": "; XXX replace the dont-know reply by ChatScript or something.",
        "context": "\t\t\t(cog-extract-recursive! (ListLink current-action x)))\n\t\t\t\taction-list)\n\n\t\t; XXX replace the dont-know reply by ChatScript or something.\n\t\t(if (null? action-list)\n\t\t\t(begin\n\t\t\t\t(State (Anchor \"Chatbot: ChatbotEvaAction\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 73,
        "type": "FIXME",
        "content": "; XXX This is incorrect, just right now; its too simple, and interacts",
        "context": "; of the system is behind the eyes, middle of head.  \"forward\" is the\n; object the chest is facing.\n;\n; XXX This is incorrect, just right now; its too simple, and interacts\n; badly with the face tracker.  The directions need to be general\n; 2D areas.  For imperative commands, we need to pick some random point\n; out of the 2D area. To answer questions, we need to compare the 2D\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 180,
        "type": "FIXME",
        "content": "; XXX Remove this -- It should go into the self-model file.",
        "context": "; in various irritating ways, so we duplicate the above using\n; ConceptNode, instead.\n;\n; XXX Remove this -- It should go into the self-model file.\n\n; Knowledge about spatial directions. Pair up words and physical\n; directions.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 258,
        "type": "FIXME",
        "content": "; XXX FIXME -- Implement-me, actually -- need to do the above, but for",
        "context": "\t\t(ConceptNode \"look-at-cmd\")\n\t\t(ConceptNode \"schema-thing\")))\n\n; XXX FIXME -- Implement-me, actually -- need to do the above, but for\n; the self-model, rather than the direct robot action.  The self-model\n; is not being updated by these imperatives.\n;--------------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 358,
        "type": "FIXME",
        "content": "; XXX a bunch of verb synonyms -- handled manually. These should be",
        "context": "; Grounding of words for facial expressions by animations in the Eva\n; blender model: happy, sad, confused, etc. See below for full list.\n\n; XXX a bunch of verb synonyms -- handled manually. These should be\n; automated via synonymous phrase support. Total hack, needs fixing.\n; Each verb here must also be handled by a corresponding rule in the\n; `imperative-rules.scm` file.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 399,
        "type": "FIXME",
        "content": "; XXX FIXME ... the list below is duplicated twice, once as adjectives",
        "context": "(ReferenceLink (WordNode \"recoil\") (DefinedSchema \"recoil\"))\n(ReferenceLink (WordNode \"worry\")  (DefinedSchema \"worry\"))\n\n; XXX FIXME ... the list below is duplicated twice, once as adjectives\n; and once as nouns.  This is partly because relex normalization is\n; not being correctly used, and/or R2L in its current form is not\n; quite usable for this (it's too fragile, among other things).\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 404,
        "type": "FIXME",
        "content": "; XXX FIXME -- this list contains lots of synonyms; needs to be replaced",
        "context": "; not being correctly used, and/or R2L in its current form is not\n; quite usable for this (it's too fragile, among other things).\n;\n; XXX FIXME -- this list contains lots of synonyms; needs to be replaced\n; by proper synonym support.\n;\n; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 407,
        "type": "FIXME",
        "content": "; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"",
        "context": "; XXX FIXME -- this list contains lots of synonyms; needs to be replaced\n; by proper synonym support.\n;\n; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"\n; could map to either \"worry\" or to \"sad\" expressions.  So, need to deal\n; with that. Also: emotions are graded: some call for much milder\n; expressions than others -- right now, the expressions pick a random\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
        "line": 591,
        "type": "FIXME",
        "content": "; XXX Remove this -- this si supposed to ba a part of the action",
        "context": "; Duplicate of the above, except that this is for use in controlling\n; the self-model, rather than the physical motors.\n;\n; XXX Remove this -- this si supposed to ba a part of the action\n; orchestrateor, i.e. the self model is about what the orchestrator\n; actually did, not what it was told to do.\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
        "line": 51,
        "type": "FIXME",
        "content": "; XXX FIXME This is wrong; this has been replaced by the eva-model",
        "context": "\t\t\t(dependency \"_subj\" \"$verb-inst\" \"$subj-inst\")\n\t\t\t(LemmaLink (VariableNode \"$subj-inst\") (WordNode \"you\"))\n\n; XXX FIXME This is wrong; this has been replaced by the eva-model\n; code Unfortunately, it does not offer any easy way of querying.\n\t\t\t; (State (Anchor \"*-gaze-direction-*\") (Variable \"$direction\"))\n\t\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
        "line": 95,
        "type": "FIXME",
        "content": "; XXX hack",
        "context": "(define (prt-curr-sent) (cog-execute! prt-sent))\n\n;--------------------------------------------------------------------\n; XXX hack\n(define face-expression-state (AnchorNode \"Facial Expression State\"))\n\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
        "line": 156,
        "type": "FIXME",
        "content": "; XXX this should be moved to cog-utils. Also needs to be fixed",
        "context": "\n;--------------------------------------------------------------------\n;\n; XXX this should be moved to cog-utils. Also needs to be fixed\n; to not detect bound variables. We already have C++ code that\n; does  the right thing, here, so we should use that.\n(define (cog-grounded? EXPR)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
        "line": 178,
        "type": "FIXME",
        "content": "; XXX This is broken.",
        "context": ")\n\n;--------------------------------------------------------------------\n; XXX This is broken.\n;\n; This is where I wish I had lexical functions rather than just sureal.\n; The problem here is that sureal, all by itself, is unable to convert\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
        "line": 19,
        "type": "FIXME",
        "content": "; XXX remove the below when we get a chance.",
        "context": "\n(start-cogserver \"../../lib/opencog-chatbot.conf\")\n\n; XXX remove the below when we get a chance.\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
        "line": 22,
        "type": "FIXME",
        "content": "; XXX fixme -- we should not need to load either relex2logic or",
        "context": "; XXX remove the below when we get a chance.\n; Must load the rulebase before running eva; see bug\n; https://github.com/opencog/opencog/issues/2021 for details\n; XXX fixme -- we should not need to load either relex2logic or\n; the rules right here, since the code in this module does not depend\n; directly on these.\n(use-modules (opencog nlp relex2logic))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/chatbot-eva/run-chatbot.scm",
        "line": 29,
        "type": "FIXME",
        "content": "; XXX temp hack to run in module context, for debugging",
        "context": "; (load-r2l-rulebase)\n;\n\n; XXX temp hack to run in module context, for debugging\n; (add-to-load-path \".\")\n; (add-to-load-path \"..\")\n; (load \"chatbot-eva.scm\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/faces.scm",
        "line": 5,
        "type": "FIXME",
        "content": "; XXX most of face-tracking is now in self-model.scm",
        "context": "; faces.scm\n;\n; Assorted utilities for supporting face tracking\n; XXX most of face-tracking is now in self-model.scm\n; Perhaps this file is not needed any more? XXX FIXME\n;\n(use-modules (opencog))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/faces.scm",
        "line": 11,
        "type": "FIXME",
        "content": ";; XXX FIXME: This file defines a \"Room State\", which currently can",
        "context": "(use-modules (opencog))\n(use-modules (opencog exec))\n\n;; XXX FIXME: This file defines a \"Room State\", which currently can\n;; be \"empty\" or \"non-empty\", depending on whether faces are visible\n;; or not.  But this is kind-of pointless: its probably easier to just\n;; check if the number of visible faces is greater than zero, or not.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 43,
        "type": "FIXME",
        "content": "; XXX FIXME There are a bunch of define-publics in here, they probably",
        "context": "\n; ------------------------------------------------------\n; State variables\n; XXX FIXME There are a bunch of define-publics in here, they probably\n; should not be; they're needed only by the behavior module.\n\n; Face tracking state indicates if we respond to face tracking events.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 95,
        "type": "FIXME",
        "content": "; XXX FIXME -- this should return neutral, if the timestamp is more",
        "context": "(StateLink face-expression-state expression-neutral)\n\n; Get the current facial expression.\n; XXX FIXME -- this should return neutral, if the timestamp is more\n; than 8 seconds in the past. Well, actually, it should probably\n; reset the face expression state after 8 seconds or so --\n; or maybe use the timeserver....\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 173,
        "type": "FIXME",
        "content": "; XXX quick hack",
        "context": "\t(DefinedSchema \"current-speaker\")\n   (Get (State last-speaker (Variable \"$x\"))))\n\n; XXX quick hack\n(DefineLink\n\t(DefinedSchema \"other-speaker\")\n   (Get (State last-speaker (Variable \"$x\"))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 254,
        "type": "FIXME",
        "content": "; XXX FIXME: Note also: we currently fail to distinguish the affect",
        "context": "; Chat affect. Is the robot happy about what its saying?\n; Right now, there are only two affects: happy and not happy.\n; NB the python ROS sensor code uses these defines!\n; XXX FIXME: Note also: we currently fail to distinguish the affect\n; that was perceived, from our own state. There is a ROS message that\n; informs us about what the perceived affect was: it sets this state.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 374,
        "type": "FIXME",
        "content": ";; XXX FIXME -- the psi subsystem should be performing this action,",
        "context": ";; If there are no visible faces, and something \"salient\" is seen, with\n;; a degree greater than 13, then it's considered as salient. The robot\n;; should then look at the salient position and show curious expression.\n;; XXX FIXME -- the psi subsystem should be performing this action,\n;; instead of hard-coding it here.\n\n;; Coordinates for the salient location\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 931,
        "type": "FIXME",
        "content": "; XXX Double-check that the \"New arrivals\" list is non-empty;",
        "context": ";; (DefinedSchema \"look at person\") to make it look.\n(DefineLink\n\t(DefinedPredicate \"interact with new person\")\n\t; XXX Double-check that the \"New arrivals\" list is non-empty;\n\t; some OpenPsi bug sometimes sends us here, and the RandomChoice\n\t; crashes if the list is empty.\n\t(SequentialAnd\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
        "line": 9,
        "type": "FIXME",
        "content": "; XXX FIXME -- some of the below should be handled as psi-rules,",
        "context": "; direction the sound is coming from, as compared to the position\n; of the face.\n;\n; XXX FIXME -- some of the below should be handled as psi-rules,\n; instead of being hard-coded, here.  That is, we are interested\n; in the locations of sound events in general, not just for determing\n; who is speaking.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
        "line": 38,
        "type": "FIXME",
        "content": "; XXX FIXME Is it wise to start this, just because the guile module got",
        "context": "\n; Run the map in a new thread. This will automatically create a new\n; time-slice every 66 milliseconds.\n; XXX FIXME Is it wise to start this, just because the guile module got\n; loaded? or should we have a distinct \"start running it now\" function?\n(cog-pointmem-auto-step-time-on facemap)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
        "line": 161,
        "type": "FIXME",
        "content": ";; XXX FIXME -- this kind of crazy angle computation should be",
        "context": ";assuming sound was saved with co-oridinate transform applied for camera\n;angle in radians\n;\n;; XXX FIXME -- this kind of crazy angle computation should be\n;; happenening in the space-time server, and not here.\n;;\n(define (angle_face_id_snd FACE-ID xx yy zz)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
        "line": 196,
        "type": "FIXME",
        "content": ";; XXX FIXME -- this kind of tulity needs to be in the space-time",
        "context": ";; A face is near if the sound direction is within 15 degrees of\n;; the face.  Returns the atom for the face, or the emtpy list.\n;;\n;; XXX FIXME -- this kind of tulity needs to be in the space-time\n;; server, and not here.\n(define (face-nearest-sound xx yy zz)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
        "line": 237,
        "type": "FIXME",
        "content": ";; XXX TODO -- this should eventually be a psi-rule, so that we can",
        "context": "\n;; This needs to be define-public, so that ros-bridge can send this\n;; to the cogserver.\n;; XXX TODO -- this should eventually be a psi-rule, so that we can\n;; associate spoken sounds with speakers, but also know the locations\n;; of loud sounds.  That is, the time-server needs to get sound\n;; direction, no matter what.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/btree.scm",
        "line": 4,
        "type": "FIXME",
        "content": "; XXX FIXME ... I think this blob of code is obsolete ... I think",
        "context": ";\n; btree.scm\n;\n; XXX FIXME ... I think this blob of code is obsolete ... I think\n; that the current interfaces are in `btree-psi.scm`.  So remove this\n; file once we are clear on this.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/btree.scm",
        "line": 88,
        "type": "FIXME",
        "content": "; XXX Need to ... auuh load the chatbot...",
        "context": "\t\t; since the text processing results in python calls.\n\t\t; (lambda () (process-query \"luser\" (cog-name TXT-ATOM)))\n\t\t; (lambda () (grounded-talk \"luser\" (cog-name TXT-ATOM)))\n\t\t; XXX Need to ... auuh load the chatbot...\n;\t\t(lambda () (chat TXT-ATOM))\n;\t)\n\t(stv 1 1)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/old-tree.scm",
        "line": 50,
        "type": "FIXME",
        "content": ";; XXX FIXME chatbot is disengaged from everything else.",
        "context": "\t\t\t\t(DefinedPredicate \"Nothing is happening\")\n\t\t\t\t(True))\n\n\t\t\t;; XXX FIXME chatbot is disengaged from everything else.\n\t\t\t;; The room can be empty, the head is bored or even asleep,\n\t\t\t;; but the chatbot is still smiling and yabbering.\n\t\t\t;; If interaction is turned-off need keep alive gestures\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
        "line": 68,
        "type": "FIXME",
        "content": "; XXX FIXME -- this is hacky -- and has multiple design flaws.",
        "context": "; ------------------------------------------------------------------\n; Functions to initiate random positive and negative expressions\n\n; XXX FIXME -- this is hacky -- and has multiple design flaws.\n; These are:\n;\n; * This should not use cog-evaluate! to force execution. Instead,\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 75,
        "type": "FIXME",
        "content": "; FIXME: This is not really newline.",
        "context": "    ; The token value for 'CR is empty-string so as to handle multiline\n    ; rules.\n    ((has-match? \"\\r\" str) (result:suffix 'CR location \"\"))\n    ; FIXME: This is not really newline.\n    ((string=? \"\" str) (cons (make-lexical-token 'NEWLINE location #f) \"\"))\n    ((has-match? \"urge:\" str) (result:suffix 'URGE location #f))\n    ((has-match? \"ordered-goal:\" str) (result:suffix 'ORD-GOAL location #f))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
        "line": 140,
        "type": "FIXME",
        "content": "; FIXME Why doesn't the first call of (update-inferences) work?",
        "context": "    (cog-logger-info \"[PLN-Action] Started (do-pln-qa)\")\n\n    (State pln-qa process-started)\n    ; FIXME Why doesn't the first call of (update-inferences) work?\n    (update-inferences rb-trail-1 3 time)\n    (update-inferences rb-trail-1 3 time)\n    (let ((inferences (get-inferred-atoms rb-trail-1)))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
        "line": 195,
        "type": "FIXME",
        "content": "; FIXME: This only works for trail-3",
        "context": "  ; other method.\n  (if (nil? candidates)\n    \"\"\n    ; FIXME: This only works for trail-3\n    (let ((sureal-results (get-sureal-results candidates)))\n      (if (nil? sureal-results)\n        \"\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-1.scm",
        "line": 7,
        "type": "FIXME",
        "content": "; FIXME: Doesn't return anything when confidence is low, don't use for now",
        "context": "(use-modules (opencog nlp))\n(use-modules (opencog pln))\n(use-modules (opencog ure))\n; FIXME: Doesn't return anything when confidence is low, don't use for now\n;(load-from-path \"opencog/pln/rules/implication-direct-evaluation.scm\")\n\n;;;;;;;;;;;;;;;;;;;;;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 180,
        "type": "FIXME",
        "content": "; XXX FIXME. This is yucky, something prettier is needed.",
        "context": "; followed by the action.  Given a rule, (gar r) is the AndLink.\n; Either gaar or gadr is the context; the other is the action.\n; We identify the action by using the `psi-action?` utility.\n; XXX FIXME. This is yucky, something prettier is needed.\n(define (get-ctxt-act r)\n\t(define andy (gar r))\n\t(define pa (gar andy))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 214,
        "type": "FIXME",
        "content": ";; XXX TODO -- filter out the exact rules that have non-trivial",
        "context": "\t\t\t\t(if (null? pred) #f\n\t\t\t\t\t(equal? (gdr pred) SENT)))))\n\n\t;; XXX TODO -- filter out the exact rules that have non-trivial\n\t;; THAT and TOPIC contexts.\n\n\t; Get all the exact rules that apply to the SENT\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 265,
        "type": "FIXME",
        "content": "; XXX Need to handle that, topic rules as appropriate.",
        "context": "\n; Given a pattern-based rule, run it. Given that it has variables\n; in it, accomplish this by creating and running a MapLink.\n; XXX Need to handle that, topic rules as appropriate.\n(define (run-pattern-rule RULE SENT)\n\t(define maplk (MapLink\n\t\t(ImplicationLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 284,
        "type": "FIXME",
        "content": "; XXX FIXME -- handle topic stars also ....",
        "context": "\n; Return #t if the topic in the RULE context is actually equal\n; to the current AIML topic state.\n; XXX FIXME -- handle topic stars also ....\n(define (is-topical-rule? RULE)\n\t(define pred (get-pred RULE \"*-AIML-topic-*\"))\n\t(if (null? pred) #t\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 361,
        "type": "FIXME",
        "content": ";; XXX FIXME crazy hacky weight-adjusting formula. This makes",
        "context": "  aiml-select-rule RULE-LIST - Given a list of AIML rules,\n  select one to run.\n\"\n\t;; XXX FIXME crazy hacky weight-adjusting formula. This makes\n\t;; no sense at all, but is a hacky hack designed to pick more\n\t;; desirable rules more often.  Someone should figure out\n\t;; some weighting formula that makes more sense tahn this.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 484,
        "type": "FIXME",
        "content": "; XXX FIXME .. Maybe check a much longer list??",
        "context": "\t; response being given twice in a row. Avoid repeating, by\n\t; checking to see if the suggested response is the same as the\n\t; previous response. Right now, we just check one level deep.\n\t; XXX FIXME .. Maybe check a much longer list??\n\t(define (same-as-before? SENT)\n\t\t(define that (do-aiml-get (Concept \"that\")))\n\t\t(define that-len\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 528,
        "type": "FIXME",
        "content": "; XXX TODO: Would be better to log and retrieve the chat",
        "context": "\n\t\t; The robots response is the current \"that\".\n\t\t; Store up to two previous inputs and outputs\n\t\t; XXX TODO: Would be better to log and retrieve the chat\n\t\t;           history using AtTimeLink and the time server\n\t\t(if (valid-response? response)\n\t\t\t(let ((that (do-aiml-get (Concept \"that\"))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/chatbot/chat-interface.scm",
        "line": 126,
        "type": "FIXME",
        "content": ";     XXX except that above isn't done any more -- WordNodes are",
        "context": ";\n; Anyway, three different kinds of things can be found:\n; WordNodes, almost always \"yes\", in answer to a yes/no question.\n;     XXX except that above isn't done any more -- WordNodes are\n;     never attached, it seems. XXX\n; WordInstanceNodes, in answer to SVO pattern matching.\n; SemeNodes, in answer to triples matching.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/chatbot/chat-interface.scm",
        "line": 143,
        "type": "FIXME",
        "content": "; XXX should we defer this loading till later ??",
        "context": "\t\t\t\t((eq? tipo 'SemeNode) \n\t\t\t\t\t; The lemma-link for a seme might still be sitting on disk!\n\t\t\t\t\t; We will need the lemma when printing, etc.\n\t\t\t\t\t; XXX should we defer this loading till later ?? \n\t\t\t\t\t(load-referers answ)\n\t\t\t\t\tansw\n\t\t\t\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
        "line": 601,
        "type": "FIXME",
        "content": "; XXX we should fetch from SQL ... XXXX",
        "context": "\t\t\t\t(object->string seme-cnt)))\n\t\t\t)\n\n\t\t\t; XXX we should fetch from SQL ... XXXX\n\t\t\t; (fetch-related-semes trip-seme-list)\n\t\t\t;\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
        "line": 628,
        "type": "FIXME",
        "content": "; XXX but it leaves a DocumentNode with nothing pointing to it.",
        "context": "\n\t\t; Delete upwards ... this deletes the link to the document,\n\t\t; and also the link to the new-parsed-sentences anchor.\n\t\t; XXX but it leaves a DocumentNode with nothing pointing to it.\n\t\t(cog-extract-recursive! sent)\n\t)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/seme/seme-process.scm",
        "line": 645,
        "type": "FIXME",
        "content": "(define (do-implication x) #t)  ; XXX use cog-bind instead ...",
        "context": "; This may generate a list of atoms. Take that list, and manually\n; store it in the database.\n;\n(define (do-implication x) #t)  ; XXX use cog-bind instead ... \n(define (xxxprocess-rule rule)\n\t(define triple-list (cog-outgoing-set (do-implication rule)))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
        "line": 37,
        "type": "FIXME",
        "content": "; XXX Support for OrLink in the pattern matcher would simplify this ...",
        "context": "\t)\n)\n\n; XXX Support for OrLink in the pattern matcher would simplify this ...\n(define wh-question-id-rule-0 (wh-question-pattern \"who\"))\n(define wh-question-id-rule-1 (wh-question-pattern \"what\"))\n(define wh-question-id-rule-2 (wh-question-pattern \"when\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
        "line": 76,
        "type": "FIXME",
        "content": "; XXX we should also make sure that adverbs, if any, that",
        "context": "\n\t\t\t(core \"$ans\" \"$clause\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
        "line": 176,
        "type": "FIXME",
        "content": "; XXX we should also make sure that adverbs, if any, that",
        "context": "\t\t\t(r-rlx \"$prep\" \"$seme-ovar\" \"$seme-pvar\")\n\t\t\t(r-rlx \"_subj\" \"$ans-verb\" \"$ans\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
        "line": 230,
        "type": "FIXME",
        "content": ";; XXX someday, this needs to be an or-list of WH- words.",
        "context": "\t\t\twh-clause  ; the prep-phrase we are matching!\n\t\t\t(r-decl-vartype \"PrepositionalRelationshipNode\" \"$tripl\")\n\n\t\t\t;; XXX someday, this needs to be an or-list of WH- words.\n\t\t\t(r-rlx-flag wh-word \"$qvar\")\n\t\t\t(r-decl-lemma  \"$word-inst\" \"$word\")\n\t\t\t(r-decl-lemma  \"$join-inst\" \"$word\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
        "line": 327,
        "type": "FIXME",
        "content": "; XXX we should also make sure that adverbs, if any, that",
        "context": "\t\t\t(r-rlx \"_subj\" \"$ans-verb\" \"$ans-svar\")\n\t\t\t(r-rlx \"_obj\"  \"$ans-verb\" \"$ans-ovar\")\n\n\t\t\t; XXX we should also make sure that adverbs, if any, that\n\t\t\t; modify the verb, are also matched up.\n\n\t\t\t; The below make sure that a previous truth query is not\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
        "line": 211,
        "type": "FIXME",
        "content": "; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.",
        "context": "\t\t)\n\n\t\t; Return the variables and clauses in an association list\n\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
        "line": 212,
        "type": "FIXME",
        "content": "; XXX However, to fix this, we will need to modify the varscope code to",
        "context": "\n\t\t; Return the variables and clauses in an association list\n\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
        "line": 214,
        "type": "FIXME",
        "content": "; XXX err, well, no, since b can sometimes be a",
        "context": "\t\t; XXX FIXME: really, if a or b are vars, then they are WordInstanceNodes.\n\t\t; XXX However, to fix this, we will need to modify the varscope code to\n\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n\t\t; XXX SemeNodes can appear here as well.\n\t\t(r-new-expr vartypes clauses (r-fv rel a b))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
        "line": 216,
        "type": "FIXME",
        "content": "; XXX SemeNodes can appear here as well.",
        "context": "\t\t; merge together lits of possibly duplicate var decls!\n\t\t; XXX err, well, no, since b can sometimes be a \n\t\t; DefinedLinguisticRelationshipNode when building a prep-phrase\n\t\t; XXX SemeNodes can appear here as well.\n\t\t(r-new-expr vartypes clauses (r-fv rel a b))\n\t)\n)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
        "line": 617,
        "type": "FIXME",
        "content": "; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX",
        "context": ";\n; Assumes that both \"prep\" and \"prep-word\" are vairables, \n; and declares \"prep\" to be of type DefinedLinguisticRelationshipNode\n; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX\n;\n; Returns an r-expression.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
        "line": 353,
        "type": "FIXME",
        "content": "; XXX This rejects sentences with prep phrases, but it should also probably",
        "context": "; var1=mortal var2=man\n; Must reject prepositions, so that e.g. \"the color (of the sky) is blue.\" \n; which contains _predadj as well as a prep \"of\", is rejected.\n; XXX This rejects sentences with prep phrases, but it should also probably\n; reject anything with _subj, _obj, etc. XXX\n;\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
        "line": 394,
        "type": "FIXME",
        "content": "; XXX FIXME (this is same, similar problem to the other XXX above.)",
        "context": "; var1=Berlin var2=Germany $prep=in\n; However, this can't work if defined as simply as this: there are\n; too many bogus matches for 'prep'.\n; XXX FIXME (this is same, similar problem to the other XXX above.)\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n;      ^ %WordInstanceLink($var1,$sent)  ; $var1 and $var2 must be\n;      ^ %WordInstanceLink($var2,$sent)  ; in the same sentence\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
        "line": 404,
        "type": "FIXME",
        "content": "; XXX for some reason, this isn't working, not sure why ...",
        "context": "; \n; Question: What are bats made of?\n; var0=bat $vrb=make $prep=of $qvar=what\n; XXX for some reason, this isn't working, not sure why ... \n; this needs debugging.\n; # IF %ListLink(\"# APPLY TRIPLE RULES\", $sent)\n;       ^ %WordInstanceLink($var0,$sent)  ; $var0 and $vrb must be\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rules.scm",
        "line": 469,
        "type": "FIXME",
        "content": "; XXX FIXME, rule below is just rule above, but without the prep check.",
        "context": ";\n; or more generally \"X verbed Y prep Z\". \n;\n; XXX FIXME, rule below is just rule above, but without the prep check.\n; This means this rule might break one of the triple-style rules above...\n\n(define truth-assertion-rule-1\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/varscope.scm",
        "line": 7,
        "type": "FIXME",
        "content": "; XXX This is not used any more, because the perl script is not used any",
        "context": "; Wrapper to create proper BindLinks from the naked\n; ImplicationLinks that the perl files generate.\n;\n; XXX This is not used any more, because the perl script is not used any\n; more.  This is currently kept here because it might still come in \n; handy during the conversion of the RelEx frame rules into pure\n; opencog.  Delete this file when frames have been removed from RelEx\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/random-sentence-generator.scm",
        "line": 1,
        "type": "FIXME",
        "content": "; XXX Temp quick hacks for the upcoming demos",
        "context": "; XXX Temp quick hacks for the upcoming demos\n; The design is horrible to call the generator like this\n\n; Example usage of the generator directly from the command line\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
        "line": 41,
        "type": "FIXME",
        "content": ";; XXX FIXME -- remove the IRC debug response below.",
        "context": "            ; nlp-parse returns (SentenceNode \"sentence@45c470a6-29...\")\n            (define sent-node (car (nlp-parse query)))\n\n            ;; XXX FIXME -- remove the IRC debug response below.\n            (display \"Hello \")\n            (display user)\n            (display \", you said: \\\"\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
        "line": 66,
        "type": "FIXME",
        "content": "; XXX Use AIML here to say something snarky.",
        "context": "                    )\n                    ((equal? utr (DefinedLinguisticConceptNode \"DeclarativeSpeechAct\"))\n                        (display \"You made a Declarative SpeechAct\\n\")\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                    ((equal? utr (DefinedLinguisticConceptNode \"ImperativeSpeechAct\"))\n                        (display \"You made a Imperative SpeechAct\\n\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
        "line": 72,
        "type": "FIXME",
        "content": "; XXX Use AIML here to say something snarky.",
        "context": "                        (display \"You made a Imperative SpeechAct\\n\")\n                        ; Make the robot do whatever ...\n\t\t                    ; (imperative_process sent-node)\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                    (else\n                        (display \"Sorry, I can't identify the speech act type\\n\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
        "line": 76,
        "type": "FIXME",
        "content": "; XXX Use AIML here to say something snarky.",
        "context": "                    )\n                    (else\n                        (display \"Sorry, I can't identify the speech act type\\n\")\n                        ; XXX Use AIML here to say something snarky.\n                    )\n                )\n            )\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/bot-api.scm",
        "line": 108,
        "type": "FIXME",
        "content": "; XXX FIXME This also definitely requires change after the backward",
        "context": ";-------------------------------------------------------------------\n; Used by 'truth_query_process' to find the input for the backward\n; chaining.\n; XXX FIXME This also definitely requires change after the backward\n; chaining is completed.\n;-------------------------------------------------------------------\n(define (fAtom querySentence)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
        "line": 34,
        "type": "FIXME",
        "content": "; FIXME: maybe opencog's internal time octime should",
        "context": "  Associate time to the last sentence\n\"\n\t(AtTimeLink\n\t\t; FIXME: maybe opencog's internal time octime should\n\t\t; be used. Will do for now, assuming a single instance\n\t\t; deals with a single conversation.\n\t\tsent\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
        "line": 222,
        "type": "FIXME",
        "content": "; XXX FIXME -- sentiment analysis should not be done here.",
        "context": "\t\t(if nlp-stimulate-parses\n\t\t\t(nlp-stimulate sent-node nlp-stimulation-value))\n\n\t\t; XXX FIXME -- sentiment analysis should not be done here.\n\t\t; (perform-sentiment-analysis sent-node)\n\n\t\t; Track some counts needed by R2L.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/fuzzy.scm",
        "line": 54,
        "type": "FIXME",
        "content": "; XXX FIXME the Microplanner should use the same speech-act types as",
        "context": "\"\n\n    ; Find the speech act from the SetLink and use it for Microplanning\n    ; XXX FIXME the Microplanner should use the same speech-act types as\n    ; everyone else, so that we don't have to do this horrific string\n    ; manginling.\n    (define (get-speech-act setlink)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
        "line": 89,
        "type": "FIXME",
        "content": "; XXX how to handle \"mine\", \"hers\", \"theirs\", etc?  Seems these will mostly",
        "context": ";\n; The modified form will be based on the noun's usage (subject/object).\n;\n; XXX how to handle \"mine\", \"hers\", \"theirs\", etc?  Seems these will mostly\n; appear within some be-inheritance? (eg.  \"That car is her car\" becoming\n; \"That car is hers\")  Can also appear in \"That car of hers is yellow.\"\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
        "line": 178,
        "type": "FIXME",
        "content": "; XXX might on some special occassion want the supersets?",
        "context": "; meaning of the original sentence stays true.  Randomly return one with\n; some weights.\n;\n; XXX might on some special occassion want the supersets?\n;\n(define-method (get-lexical-node (ni <noun-item>))\n\t(define (determine-lexical)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
        "line": 183,
        "type": "FIXME",
        "content": "; XXX also accept links that inherit the abstracted version? currently not doing that",
        "context": "(define-method (get-lexical-node (ni <noun-item>))\n\t(define (determine-lexical)\n\t\t(define the-noun-node (get-noun-node ni))\n\t\t; XXX also accept links that inherit the abstracted version? currently not doing that\n\t\t; since the anchor is also a ConceptNode, cog-get-link will return each link twice, so need to delete duplicates\n\t\t(define all-inheritances (delete-duplicates (cog-get-link 'InheritanceLink 'ConceptNode the-noun-node)))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora.scm",
        "line": 46,
        "type": "FIXME",
        "content": "; XXX possibly better algorithm for choosing between pronoun vs lexical noun phrase?",
        "context": "\t\t\t\t\t\t(cog-new-node (cog-type old-noun-node) (get-modified-pronomial ni forms) (cog-tv old-noun-node))\n\t\t\t\t\t)\n\t\t\t\t\t; otherwise, try getting a node with the lexical noun\n\t\t\t\t\t; XXX possibly better algorithm for choosing between pronoun vs lexical noun phrase?\n\t\t\t\t\t(if (is-lexical-safe? ni)\n\t\t\t\t\t \t(if (get-association n-lst ni)\n\t\t\t \t\t\t\t(get-lexical-node (get-association n-lst ni))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/helpers.scm",
        "line": 253,
        "type": "FIXME",
        "content": "; XXX optimization possible? This makes the whole function O(mn) rather than O(n)",
        "context": ";\n(define (distance-transform main-list anchor-list)\n\t; initialize where the anchors are\n\t; XXX optimization possible? This makes the whole function O(mn) rather than O(n)\n\t(define len (length main-list))\n\t(define result-list (map (lambda (i) (if (member i anchor-list) 0 1)) main-list))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
        "line": 83,
        "type": "FIXME",
        "content": "; XXX FIXME utterance-type should be an atom, not a string!",
        "context": "  OPTION is a <chunks-option> object\n  ANAPHORA can be #t or #f.\n\"\n\t; XXX FIXME utterance-type should be an atom, not a string!\n\t; viz (DefinedLinguisticConceptNode \"DeclarativeSpeechAct\") etc.\n\t; this would avoid a lot of string-matching/downcasing/appending\n\t; tomfoolery i.e. simplify the code.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
        "line": 351,
        "type": "FIXME",
        "content": "; XXX could possibly allow choosing different",
        "context": "\t\t\t\t\t\t\t(else\n\t\t\t\t\t\t\t\t; Find the first link in atomW-not-tried that\n\t\t\t\t\t\t\t\t; contains one of the solo words.\n\t\t\t\t\t\t\t\t; XXX could possibly allow choosing different\n\t\t\t\t\t\t\t\t; link to generate multiple chunking result.\n\t\t\t\t\t\t\t\t(set! temp-var1\n\t\t\t\t\t\t\t\t\t(find (lambda (a)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 26,
        "type": "FIXME",
        "content": "; XXX FIXME this method is really bad because for each new type of",
        "context": "; corresponding ConceptNode or PredicateNode or NumberNode or\n; DefinedLinguisticPredicateNode created by R2L helper.\n;\n; XXX FIXME this method is really bad because for each new type of\n; node that R2L uses, it needs to be added here.  There needs some\n; different way for linking R2L nodes to WordInstanceNodes other\n; than node name! e.g. maybe an R2LLink ?\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 53,
        "type": "FIXME",
        "content": "; XXX FIXME except that we can have (EvaluationLink \"not\" \"run@1234\") which",
        "context": "; Given a link, check if it only contains one instanced node.  Used to\n; ignore links that do not need to be post-processed.\n;\n; XXX FIXME except that we can have (EvaluationLink \"not\" \"run@1234\") which\n;     appears unary but should be post-processed.  A more long term\n;     solution is needed.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 140,
        "type": "FIXME",
        "content": "; XXX FIXME should be changed to just use sha-256 -- that would make it",
        "context": "; random-UUID -- Generate a new UUID version 4\n;\n; Returns UUID version 4 (ie, mostly just random hex with some fixed values)\n; XXX FIXME should be changed to just use sha-256 -- that would make it\n; faster, better.\n;\n(define (random-UUID)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 361,
        "type": "FIXME",
        "content": ";XXX FIXME using the hacky word-get-r2l-node, bad idea!",
        "context": "  update:\n  - #t or #f to signal the update of etv in the abstracted r2l outputs returned\n\"\n;XXX FIXME using the hacky word-get-r2l-node, bad idea!\n\t; get all the nodes linked by this link\n\t(define old-oset (cog-outgoing-set ilink))\n\t(define (replace-old old-atom)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 371,
        "type": "FIXME",
        "content": "; XXX what would an abstracted VariableNode be like?",
        "context": "\t\t      ; if node needed to be abstracted\n\t\t      ((member? old-atom lone-nodes)\n\t\t\t\t\t(if (equal? 'VariableNode (cog-type old-atom))\n\t\t\t\t\t\t; XXX what would an abstracted VariableNode be like?\n\t\t\t\t\t\told-atom\n\t\t\t\t\t\t; fail-safe for when R2L rule is incomplete and\n\t\t\t\t\t\t; never created the abstract node\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 386,
        "type": "FIXME",
        "content": ";  ; FIXME: Why create a node with new-instance name? Is this for",
        "context": "\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t      )\n\t\t\t;  ; FIXME: Why create a node with new-instance name? Is this for\n\t\t\t; anaphora-resolution?\n\t\t    ;  ; If node needed to be cloned with new instance name\n\t\t    ;  (a-pair\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
        "line": 480,
        "type": "FIXME",
        "content": ";FIXME: Why occurence of a node in more than one relation",
        "context": "\t\t\t(lambda (n)\n\t\t\t\t(and\n\t\t\t\t\t(is-r2l-inst? n)\n\t\t\t\t\t;FIXME: Why occurence of a node in more than one relation\n\t\t\t\t\t; matter? One reason is if the instance-node is renamed\n\t\t\t\t\t; then one wouldn't want to rename the same instance to\n\t\t\t\t\t; different nodes, but then again why create new\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/relex2logic.scm",
        "line": 39,
        "type": "FIXME",
        "content": "; XXX maybe this should be part of the ure module??",
        "context": "        ; from the FC, then delete it and return a list of\n        ; its contents, else return a list holding A-LINK.\n        ;\n        ; XXX maybe this should be part of the ure module??\n        (if (or (equal? 'ListLink (cog-type A-LINK)) IS-FROM-FC)\n            (let ((returned-list (cog-outgoing-set A-LINK)))\n                    (cog-extract! A-LINK)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/relex2logic.scm",
        "line": 63,
        "type": "FIXME",
        "content": "; FIXME: Presently, only a single interpretation is created for",
        "context": "    )\n\n    (define (interpret PARSE-NODE)\n        ; FIXME: Presently, only a single interpretation is created for\n        ; each parse. Multiple interpreation should be handled, when\n        ; word-sense-disambiguation, anaphora-resolution and other\n        ; post-processing are added to the pipeline.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 510,
        "type": "FIXME",
        "content": "; XXX this rule is not used anywhere!",
        "context": "; -----------------------------------------------------------------------\n; unary rules\n; -----------------------------------------------------------------------\n; XXX this rule is not used anywhere!\n(define-public (entity-rule word word_instance)\n\t(ListLink\n\t\t(InheritanceLink (SpecificEntityNode word_instance) (ConceptNode word)))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 516,
        "type": "FIXME",
        "content": "; FIXME: this is bad because in SV, SVO type rules the same word is",
        "context": "\t\t(InheritanceLink (SpecificEntityNode word_instance) (ConceptNode word)))\n)\n\n; FIXME: this is bad because in SV, SVO type rules the same word is\n; ConceptNode instead\n(define-public (gender-rule lemma word_inst gender)\n\t(define word (cog-name lemma))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 634,
        "type": "FIXME",
        "content": ";; XXX FIXME: right now, this says ImplicationScopeLink",
        "context": "\t(cond\n\t\t((or (string=? determiner \"those\") (string=? determiner \"these\"))\n\t\t\t(ListLink\n\t\t\t\t;; XXX FIXME: right now, this says ImplicationScopeLink\n\t\t\t\t;; But I think the intended meaning is a for-all link:\n\t\t\t\t;; (ForAllLink (VariableNode var_name) (ImplicationLink ...))\n\t\t\t\t;; Right?\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 649,
        "type": "FIXME",
        "content": "; XXX Just to avoid getting the `#<Invalid handle>` error",
        "context": "\t\t\t\t(InheritanceLink (VariableNode var_name) (ConceptNode concept)))\n\t\t)\n\n\t\t; XXX Just to avoid getting the `#<Invalid handle>` error\n\t\t; TODO Need to add more to the list (e.g. \"the\") to cover all cases\n\t\t; or update the below to generate something reasonable\n\t\t(else (ListLink))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 696,
        "type": "FIXME",
        "content": "; XXX this rule is not used anywhere!",
        "context": "; -----------------------------------------------------------------------\n; misc rules\n; -----------------------------------------------------------------------\n; XXX this rule is not used anywhere!\n(define-public (number-rule noun noun_instance num num_instance)\n\t(define noun_ins_concept (ConceptNode noun_instance))\n\t(ListLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 706,
        "type": "FIXME",
        "content": "; XXX this rule is not used anywhere!",
        "context": "\t)\n)\n\n; XXX this rule is not used anywhere!\n(define-public (about-rule verb verb_instance  noun noun_instance)\n\t(ListLink\n\t\t(ImplicationLink (PredicateNode verb_instance) (PredicateNode verb))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 725,
        "type": "FIXME",
        "content": "; XXX FIXME these two are not returned ???",
        "context": "\t(define n1_instance (cog-name n1-inst ))\n\t(define n2 (cog-name n2-lemma))\n\t(define n2_instance (cog-name n2-inst ))\n; XXX FIXME these two are not returned ???\n\t(r2l-wordinst-concept n1_instance)\n\t(r2l-wordinst-concept n2_instance)\n\t(ListLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1345,
        "type": "FIXME",
        "content": "; XXX all-rule is not used anywhere ...",
        "context": "; \"All Canadians write.\"                 -> (all-rule \"Canadians@333\")\n; \"All right-handed Canadians write.\"    -> (all-rule \"Canadians@333\")\n;\n; XXX all-rule is not used anywhere ...\n(define-public (all-rule noun_instance)\n\t(ListLink\n\t\t(r2l-wordinst-concept noun_instance)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1363,
        "type": "FIXME",
        "content": "; XXX this rule is not used anywhere ...",
        "context": "; passive verb rules\n; -----------------------------------------------------------------------\n; Example: \"The books were written by Charles Dickens.\"\n; XXX this rule is not used anywhere ...\n(define-public (passive-rule1 verb verb_instance obj obj_instance passive_obj passive_obj_instance)\n    (ListLink\n\t (ImplicationLink (PredicateNode verb_instance) (PredicateNode verb))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1593,
        "type": "FIXME",
        "content": "; XXX that-rule is not used anywhere!",
        "context": "; \"He ran so quickly that he flew.\"\n; A that-rule for \"object clause\", \"content clause\", \"complement clause\",\n; etc, but not \"adjective clause\"\n; XXX that-rule is not used anywhere!\n;(define (that-rule main main_instance sub sub_instance)\n;\t(ListLink\n;\t\t(ImplicationLink (PredicateNode main_instance) (PredicateNode main))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1619,
        "type": "FIXME",
        "content": "; XXX before-after-rule is not used anywhere!",
        "context": "; https://github.com/opencog/opencog/pull/993\n; Examples: \"She went home before I left\", \"I went after him\", \"He sleeps\n; before he is tired\"\n; XXX before-after-rule is not used anywhere!\n;(define (before-after-rule $x_instance $y_instance $y_pos $before_or_after)\n;    (define y-node\n;        (if (or (string=? $y_pos \"verb\") (string=? $y_pos \"adj\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1637,
        "type": "FIXME",
        "content": "; XXX time-rule is not used anywhere!",
        "context": ";\n; -----------------------------------------------------------------------\n; Examples: \"I had dinner at 6 pm\", \"I went to sleep at 1 am\"\n; XXX time-rule is not used anywhere!\n;(define (time-rule $hour $period $v_instance)\n;    (define time-node\n;        (if (string=? $period \"am\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1652,
        "type": "FIXME",
        "content": "; XXX FIXME: there is no such thing as a \"TruthValueGreaterThanLink\",",
        "context": "; -----------------------------------------------------------------------\n; functions without R2L rule, not working, unneeded, etc\n; -----------------------------------------------------------------------\n; XXX FIXME: there is no such thing as a \"TruthValueGreaterThanLink\",\n; so this rule is borken.\n;(define (comparative-rule w1 w1_instance w2 w2_instance adj adj_instance)\n;\t(ListLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1669,
        "type": "FIXME",
        "content": "; XXX on-rule is not used anywhere!",
        "context": ";)\n;\n;---------------------------------------------------------------\n; XXX on-rule is not used anywhere!\n;(define (on-rule w1 w1_instance w2 w2_instance)\n;\t(ListLink\n;\t(InheritanceLink (ConceptNode w1_instance) (ConceptNode w1))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-utils.scm",
        "line": 7,
        "type": "FIXME",
        "content": "; XXX why is this public?",
        "context": "; Some generic rule utilities, not limited to r2l.\n;\n;--------------------------------------------------------------------\n; XXX why is this public?\n(define-public r2l-rules (ConceptNode \"R2L-en-RuleBase\"))\n\n;--------------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rules/passive.scm",
        "line": 2,
        "type": "FIXME",
        "content": "; XXX Fix relex so that we don't have to make such string searches!",
        "context": "; check the tense if it is passive\n; XXX Fix relex so that we don't have to make such string searches!\n(define-public (check-tense tense)\n\t(if (string-contains (cog-name tense) \"passive\") (stv 1 1) (stv 0 1))\n)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/oc.scm",
        "line": 20,
        "type": "FIXME",
        "content": "; XXX What? nothing else anywhere needs this! FIXME, somethings broke.",
        "context": "(include-from-path \"opencog/nlp/oc/processing-utils.scm\")\n\n; Weird ... MUST say `(export)` or no define-publics are visible!\n; XXX What? nothing else anywhere needs this! FIXME, somethings broke.\n(export)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/parse-rank.scm",
        "line": 174,
        "type": "FIXME",
        "content": "; XXX Umm, actually, this routine was intended for a",
        "context": "\n\t; Iterate over a list graph edges, and return the edge with the\n\t; highest weight.\n\t; XXX Umm, actually, this routine was intended for a\n\t; maximum-spanning-tree algorithm, but we don't actually need that\n\t; algo to properly rank parse scores. So this is actually some dead\n\t; code that we're not using just right now ...\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
        "line": 8,
        "type": "FIXME",
        "content": "; XXX This is currently not used anywhere, but if it was fixed up,",
        "context": "; RelEx types. These are \"anti-syntactic sugar\", and avoid the need\n; for new atom types, such as \"GenderNode\" or \"TenseNode\", etc.\n;\n; XXX This is currently not used anywhere, but if it was fixed up,\n; it could be, I guess ...\n;\n; Copyright (c) 2008 Linas Vepstas\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
        "line": 13,
        "type": "FIXME",
        "content": "; XXX This list is *probably* incomplete, and needs to be reviewed! XXX",
        "context": ";\n; Copyright (c) 2008 Linas Vepstas\n;\n; XXX This list is *probably* incomplete, and needs to be reviewed! XXX\n; In particular, the tense list is incomplete. The part-of-speech list\n; might be incomplete.\n; The list of entities (person, locatin, date, money) is incomplete.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
        "line": 21,
        "type": "FIXME",
        "content": "; XXX This list could be auto-generated by using",
        "context": "; documenting these things. See\n; http://opencog.org/wiki/RelEx_Semantic_Relationship_Extractor\n;\n; XXX This list could be auto-generated by using\n; (module-define! (current-module) ,var ,val))\n;\n; Better solution:\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
        "line": 128,
        "type": "FIXME",
        "content": "; XXX this list is highly incomplete",
        "context": "\n;; -------------------------------------------------------------------\n; tense in RelEx\n; XXX this list is highly incomplete\n;\n(InheritanceLink\n\t(DefinedLinguisticConceptNode \"past\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/oc/relex-utils.scm",
        "line": 176,
        "type": "FIXME",
        "content": "; FIXME: this is a dumb way to get other type",
        "context": "\"\n\t(let ((wlist (cog-chase-link 'LemmaLink 'WordNode word-inst)))\n\t\t(if (nil? wlist)\n\t\t\t; FIXME: this is a dumb way to get other type\n\t\t\t(let ((nlist (cog-chase-link 'LemmaLink 'NumberNode word-inst)))\n\t\t\t\t(if (nil? nlist)\n\t\t\t\t\t'()\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sureal/sureal.scm",
        "line": 3,
        "type": "FIXME",
        "content": "; XXX Huh ???",
        "context": "; Links relex-to-logic output with relex-opencog-output\n; It is temporary until the r2l rules are moved into the URE\n; XXX Huh ???\n\n; Test sentence : \"This is a sentence.\"\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sureal/surface-realization.scm",
        "line": 291,
        "type": "FIXME",
        "content": "; FIXME: This results in 'result' being 'Invalid handle' sometimes.",
        "context": "    (define result (cog-execute! (MapLink filter-in-pattern filter-from)))\n\n    ; Delete the filter-from SetLink and its encompasing MapLink.\n    ; FIXME: This results in 'result' being 'Invalid handle' sometimes.\n    ;(cog-extract-recursive! filter-from)\n\n    result\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd-post/cluster.scm",
        "line": 67,
        "type": "FIXME",
        "content": ";; XXX not tail recursive; get performance boost if it was.",
        "context": "\n;; --------------------------------------------------------------------\n;; create a list of disjuncts by merging those from two coord lists\n;; XXX not tail recursive; get performance boost if it was.\n\n(define (make-dj-list coords-a coords-b)\n\t; Add dj to list, but only if not in list\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd-post/collect-stats/disjunct-list.scm",
        "line": 12,
        "type": "FIXME",
        "content": "; XXX This code is deprecated and/or obsolete. Why?",
        "context": "; is a link-grammar link relations, with an appended + or - indicating\n; whether the connection is to the right or left.\n;\n; XXX This code is deprecated and/or obsolete. Why?\n; 1) Because disjuncts can now be obtained directly from relex and LG.\n;    They use the ConnectorNode, LgAndLink and LgDisjunct to specifiy\n;    them. Grep the viterbi code for details; see also the sureal code.\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd-post/collect-stats/stats-collection.scm",
        "line": 359,
        "type": "FIXME",
        "content": "; XXX The method used here, of tagging documents with \"finished\"",
        "context": "; Return all of the documents for which WSD has been completed,\n; but disjunct processing has not been.\n;\n; XXX The method used here, of tagging documents with \"finished\"\n; tags, is rather ad-hoc, and is meant to be a stop-gap until\n; opencog offers some way of defining a processing pipeline.\n;\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 89,
        "type": "FIXME",
        "content": "; FIXME -- can we have a shorter/better name for this method?",
        "context": ")\n\n; --------------------------------------------------------------\n; FIXME -- can we have a shorter/better name for this method?\n;\n(define (psi-rule-set-atomese-weight psi-rule weight)\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 104,
        "type": "FIXME",
        "content": "; FIXME - the long-term design calls for the use of an AtTimeLink",
        "context": "  if multiple rules have the same name, then all of thise rules will\n  also have the same weight.\n\"\n    ; FIXME - the long-term design calls for the use of an AtTimeLink\n    ; instead of a StateLink, here.\n    ;\n    ; FIXME -- if there are multiple names for a rule, this will\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 107,
        "type": "FIXME",
        "content": "; FIXME -- if there are multiple names for a rule, this will",
        "context": "    ; FIXME - the long-term design calls for the use of an AtTimeLink\n    ; instead of a StateLink, here.\n    ;\n    ; FIXME -- if there are multiple names for a rule, this will\n    ; use all of those names in the StateLink.  If a rule is given\n    ; a second or third name later on, this will cause dead StateLinks\n    ; to linger in the atomspace. FIXME -- make sure that a rule can\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 169,
        "type": "FIXME",
        "content": "(StateLink ; FIXME should use AtTimeLink",
        "context": "                    (VariableNode \"psi-rule-alias\")\n                    (TypeNode \"ConceptNode\")))\n            (AndLink\n                (StateLink ; FIXME should use AtTimeLink\n                    (ListLink\n                        (VariableNode \"psi-rule-alias\")\n                        (ConceptNode (string-append psi-prefix-str \"weight\")))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 272,
        "type": "FIXME",
        "content": "(StateLink ; FIXME should use AtTimeLink",
        "context": "            (MemberLink\n                (Variable \"controlled-rule\")\n                psi-controller-demand)\n            (StateLink ; FIXME should use AtTimeLink\n                (ListLink\n                    (VariableNode \"psi-rule-alias\")\n                    (ConceptNode (string-append psi-prefix-str \"weight\")))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/main.scm",
        "line": 94,
        "type": "FIXME",
        "content": "; XXX FIXME -- right now, this assumes that a single thread, running",
        "context": "\n; --------------------------------------------------------------\n;\n; XXX FIXME -- right now, this assumes that a single thread, running\n; at no more than 100 steps per second, is sufficient to run all of the\n; psi rules.  For now, this is OK, but at some point, this will become\n; a bottleneck, as we will need to evaluate more rules more often.\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 240,
        "type": "FIXME",
        "content": ";; XXX this is not an efficient way of searching for goals.  If",
        "context": "    A goal is associated with an action whenever the goal appears in\n    a psi-rule with that action in it.\n\"\n  ;; XXX this is not an efficient way of searching for goals.  If\n  ;; this method is used a lot, we should search for the goals directly\n  ;; See https://github.com/opencog/opencog/pull/2899.\n  (let* (\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 294,
        "type": "FIXME",
        "content": "; XXX FIXME How about actually using a SequentialAndLink?",
        "context": "  ; map-in-order is used to simulate AndLink assuming\n  ; psi-get-context maintains, which is unlikely. What other options\n  ; are there?\n  ; XXX FIXME How about actually using a SequentialAndLink?\n  ; then the code will be faster, and there won't be this problem.\n  ; TODO: This calculation can be done in OpenPsiImplicator::grounding or\n  ; when the rule is being added. Since it unlikely to change except\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/utilities.scm",
        "line": 14,
        "type": "FIXME",
        "content": "; XXX TODO: does this really need to be public? change into atom.",
        "context": "(use-modules (opencog) (opencog exec))\n\n; --------------------------------------------------------------\n; XXX TODO: does this really need to be public? change into atom.\n(define psi-prefix-str \"OpenPsi: \")\n\n; --------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/utilities.scm",
        "line": 18,
        "type": "FIXME",
        "content": "; XXX TODO: does this really need to be public?",
        "context": "(define psi-prefix-str \"OpenPsi: \")\n\n; --------------------------------------------------------------\n; XXX TODO: does this really need to be public?\n(define (psi-suffix-str a-string)\n\"\n  psi-suffix-str STRING\n"
      },
      {
        "file": "components/integration/opencog/tests/openpsi/psi-implicator.scm",
        "line": 39,
        "type": "FIXME",
        "content": "; FIXME: Using psi-goal results in the failure of OpenPsiRulesUTest",
        "context": "\n(define (component-1) (psi-component \"component-1\"))\n\n; FIXME: Using psi-goal results in the failure of OpenPsiRulesUTest\n; and OpenPsiImplicatorUTest\n;(define goal-1 (psi-goal \"goal-1\" 1))\n(define goal-1 (Concept \"goal-1\"))\n"
      },
      {
        "file": "components/language/learn/attic/repair/word-merge.scm",
        "line": 197,
        "type": "FIXME",
        "content": "; XXX technically, this is wrong, we should be renaming these...",
        "context": "\t)\n\n\t; Discard alternates\n\t; XXX technically, this is wrong, we should be renaming these...\n\t(define (bug-cleanup laid)\n\t\t(if (< 0 laid)\n;\t\t\t(let* ((aud (get-eval-uuid laid)))\n"
      },
      {
        "file": "components/language/learn/attic/run-v3/run-common/export-dictionary.scm",
        "line": 26,
        "type": "FIXME",
        "content": "; XXX this and above steps should move to `marginals-dict.scm` !?",
        "context": "(asc 'create-hi-count-singles 1)\n\n; Compute MI. This is needed for LG costs.\n; XXX this and above steps should move to `marginals-dict.scm` !?\n(display \"Computing Link Grammar costs\\n\")\n(define gcs (add-pair-stars gca))\n(define gcf (add-wordclass-filter gcs))\n"
      },
      {
        "file": "components/language/learn/attic/run-v3/run-common/export-dictionary.scm",
        "line": 40,
        "type": "FIXME",
        "content": "; XXX put INCLUDE-UNKNOWN into the environment.",
        "context": "\n; Perform the actual export. The dictionary name and locale\n; are taken from environment variables.\n; XXX put INCLUDE-UNKNOWN into the environment.\n(display \"Exporting Dictionary\\n\")\n(use-modules (opencog nlp lg-export))\n(export-csets gcf\n"
      },
      {
        "file": "components/language/learn/attic/run-v3/run-common/marginals-mst-shape.scm",
        "line": 34,
        "type": "FIXME",
        "content": "; XXX The current merge code tracks stats that requires the MI",
        "context": "\n(print-matrix-summary-report csc)\n\n; XXX The current merge code tracks stats that requires the MI\n; for word-disjunct pairs to be computed. These stats are not\n; required, but are interesting to observe. To get these, the\n; MI needs to be computed, as below:\n"
      },
      {
        "file": "components/language/learn/attic/run-v3/run-common/trim-pair.scm",
        "line": 22,
        "type": "FIXME",
        "content": "; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry",
        "context": "(barrier storage-node)\n\n; Trim the dataset.\n; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry\n; for why these are chosen, instead of something else. Basically,\n; trimming this much raises the average MI of the dataset to its\n; highest value. It also cuts the number of word pairs about half.\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/disjunct-cross.scm",
        "line": 32,
        "type": "FIXME",
        "content": "; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.",
        "context": "\n(define pca (make-pseudo-cset-api))\n(define psa (add-pair-stars pca))\n; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.\n(define psc (add-pair-count-api psa))\n(define psf (add-pair-freq-api psa))\n(define psu (add-support-api psa))\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/disjunct-stats.scm",
        "line": 39,
        "type": "FIXME",
        "content": "; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.",
        "context": "\n(define pca (make-pseudo-cset-api))\n(define psa (add-pair-stars pca))\n; XXX FIXME add-pair-count-api is obsolete; use add-support-api instead.\n(define psc (add-pair-count-api psa))\n(define psf (add-pair-freq-api psa))\n(define psu (add-support-api psa))\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/ortho-compute.scm",
        "line": 57,
        "type": "FIXME",
        "content": "; XXX todo store mean-rms on any-node.",
        "context": "(goe 'mean-rms)\n(gor 'mean-rms)\n\n; XXX todo store mean-rms on any-node.\n\n(define gos (add-similarity-api ami #f \"goe\"))\n\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/word-cosines.scm",
        "line": 31,
        "type": "FIXME",
        "content": "; XXX FIXME add-pair-count-api is osolete; use add-support-api instead.",
        "context": "\n(define pseudo-cset-api (make-pseudo-cset-api))\n\n; XXX FIXME add-pair-count-api is osolete; use add-support-api instead.\n(define pseudo-cset-count-api (add-pair-count-api pseudo-cset-api))\n(define pseudo-cset-freq-api (add-pair-freq-api pseudo-cset-api))\n(define pseudo-cset-support-api (add-support-api pseudo-cset-api))\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/word-classes/word-classes.scm",
        "line": 9,
        "type": "FIXME",
        "content": "; XXX Don't use this; use ((make-gram-class-api) 'fetch-pairs) instead.",
        "context": "(use-modules (srfi srfi-1))\n;\n; Load all grammatical classes from storage\n; XXX Don't use this; use ((make-gram-class-api) 'fetch-pairs) instead.\n(define (fetch-all-gram-classes)\n\t(load-atoms-of-type 'WordClassNode)\n\t(for-each\n"
      },
      {
        "file": "components/language/learn/run-common/cogserver.scm",
        "line": 97,
        "type": "FIXME",
        "content": "; XXX Is this needed? Didn't cogserver already get the top?",
        "context": "\t#:prompt (getenv \"OCPROMPT\")\n\t#:logfile (getenv \"LOGFILE\"))\n\n; XXX Is this needed? Didn't cogserver already get the top?\n(when (< 0 (length frame-tops))\n\t(set-cogserver-atomspace! (cog-atomspace)))\n\n"
      },
      {
        "file": "components/language/learn/run-common/marginals-mst-shape.scm",
        "line": 35,
        "type": "FIXME",
        "content": "; XXX The current merge code tracks stats that requires the MI",
        "context": "\n(print-matrix-summary-report csc)\n\n; XXX The current merge code tracks stats that requires the MI\n; for word-disjunct pairs to be computed. These stats are not\n; required, but are interesting to observe. To get these, the\n; MI needs to be computed, as below:\n"
      },
      {
        "file": "components/language/learn/run-common/trim-pair.scm",
        "line": 23,
        "type": "FIXME",
        "content": "; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry",
        "context": "(barrier storage-node)\n\n; Trim the dataset.\n; XXX This includes some ad-hoc constants. See the Sept 2021 diary entry\n; for why these are chosen, instead of something else. Basically,\n; trimming this much raises the average MI of the dataset to its\n; highest value. It also cuts the number of word pairs about half.\n"
      },
      {
        "file": "components/language/learn/run-common/attic/export-dictionary.scm",
        "line": 26,
        "type": "FIXME",
        "content": "; XXX this and above steps should move to `marginals-dict.scm` !?",
        "context": "(asc 'create-hi-count-singles 1)\n\n; Compute MI. This is needed for LG costs.\n; XXX this and above steps should move to `marginals-dict.scm` !?\n(display \"Computing Link Grammar costs\\n\")\n(define gcs (add-pair-stars gca))\n(define gcf (add-wordclass-filter gcs))\n"
      },
      {
        "file": "components/language/learn/run-common/attic/export-dictionary.scm",
        "line": 40,
        "type": "FIXME",
        "content": "; XXX put INCLUDE-UNKNOWN into the environment.",
        "context": "\n; Perform the actual export. The dictionary name and locale\n; are taken from environment variables.\n; XXX put INCLUDE-UNKNOWN into the environment.\n(display \"Exporting Dictionary\\n\")\n(use-modules (opencog nlp lg-export))\n(export-csets gcf\n"
      },
      {
        "file": "components/language/learn/scm/common.scm",
        "line": 14,
        "type": "FIXME",
        "content": "; XXX TODO FIXME All users of the three functions below need to be",
        "context": "(use-modules (srfi srfi-1))\n(use-modules (opencog) (opencog persist))\n\n; XXX TODO FIXME All users of the three functions below need to be\n; converted into users of the add-count-api, add-storage-count and\n; add-marginal-count API's. The three functions below are\n; deprecated/obsolete.\n"
      },
      {
        "file": "components/language/learn/scm/learn.scm",
        "line": 15,
        "type": "FIXME",
        "content": "(include-from-path \"opencog/learn/pipe-count.scm\") ; XXX experimental",
        "context": "(include-from-path \"opencog/learn/waiter.scm\")\n\n; Pipe stuff\n(include-from-path \"opencog/learn/pipe-count.scm\") ; XXX experimental\n\n; Pair stuff.\n(include-from-path \"opencog/learn/pair-api.scm\")\n"
      },
      {
        "file": "components/language/learn/scm/lg-compare.scm",
        "line": 365,
        "type": "FIXME",
        "content": "; XXX Temp hack. Currently, the test dicts are missing",
        "context": "\t\t\t(define right-wall (WordNode \"###RIGHT-WALL###\"))\n\n\t\t\t; Get the list of words in the standard dict.\n\t\t\t; XXX Temp hack. Currently, the test dicts are missing\n\t\t\t; RIGHT-WALL and so we filter it out manually. This\n\t\t\t; should be made more elegant. Argh. And the gold dict\n\t\t\t; is missing them too ...\n"
      },
      {
        "file": "components/language/learn/scm/attic/singletons.scm",
        "line": 5,
        "type": "FIXME",
        "content": "; XXX This is not currently used, and should maybe be deleted.",
        "context": "; singletons.scm\n;\n; Stuff for working with singltons.\n; XXX This is not currently used, and should maybe be deleted.\n; It probably does not even work right.\n;\n; Copyright (c) 2017 Linas Vepstas\n"
      },
      {
        "file": "components/language/learn/scm/attic/summary.scm",
        "line": 5,
        "type": "FIXME",
        "content": "; XXX This is stale and semi-abandoned and needs to be modernized.",
        "context": "; summary.scm\n;\n; Print a summary report for a dataset.\n; XXX This is stale and semi-abandoned and needs to be modernized.\n;\n; Copyright (c) 2017 Linas Vepstas\n;\n"
      },
      {
        "file": "components/language/learn/scm/attic/summary.scm",
        "line": 51,
        "type": "FIXME",
        "content": "; XXX FIXME work on the singletons API so that we don't",
        "context": "\t; Fetch them, if needed.\n\t(if (eqv? 0.0 nww)\n\t\t(begin\n\t\t\t; XXX FIXME work on the singletons API so that we don't\n\t\t\t; need to fetch the words.\n\t\t\t(display \"Start loading words ...\\n\")\n\t\t\t(call-only-once fetch-all-words)\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 381,
        "type": "FIXME",
        "content": "; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,",
        "context": ";     else they might fit. Viz, many words have both noun and verb\n;     forms, and thus need to go into multiple classes.\n;\n; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,\n; words in the DONE-LIST have a good chance of being completely\n; neutered, with almost nothing left in them. They should get dropped.\n;\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 385,
        "type": "FIXME",
        "content": "; XXX Maybe-FIXME: There's some amount of pointless recomputation of",
        "context": "; words in the DONE-LIST have a good chance of being completely\n; neutered, with almost nothing left in them. They should get dropped.\n;\n; XXX Maybe-FIXME: There's some amount of pointless recomputation of\n; cosines between the word-list, and the existing grammatical classes.\n; During the construction of the classes, a greedy search was formed\n; part-way down the word-list. Thus, when resuming the search, its\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 567,
        "type": "FIXME",
        "content": "; XXX There is a user-adjustable parameter used below, `diag-block-size`,",
        "context": "; measured, confirmed, tested, yet. It seems to be the case, but\n; actual measurements have not been made.\n;\n; XXX There is a user-adjustable parameter used below, `diag-block-size`,\n; to specify the initial block size.  This could be exposed in the API,\n; maybe.  On the other hand, it could stay hard-coded forever, for all\n; practical purposes.\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 586,
        "type": "FIXME",
        "content": "; XXX the block sizes are by powers of 2...",
        "context": "\t\t\t\t\t; perform clustering\n\t\t\t\t\t(new-clist (block-assign-to-classes MERGER chunk clist)))\n\t\t\t\t; Recurse and do the next block.\n\t\t\t\t; XXX the block sizes are by powers of 2...\n\t\t\t\t; perhaps they should be something else?\n\t\t\t\t(diag-blocks rest (* 2 size) new-clist)\n\t\t\t)\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 667,
        "type": "FIXME",
        "content": "; XXX FIXME ... at the conclusion of this, we have a done list,",
        "context": "\n\t(print-concluding-report)\n\n\t; XXX FIXME ... at the conclusion of this, we have a done list,\n\t; which, because of repeated merging, might possibly have been\n\t; reduced to single senses, which can now be classified.\n)\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
        "line": 680,
        "type": "FIXME",
        "content": "; XXX FIXME, should probably use",
        "context": ";\n(define (load-stuff)\n\t(define start-time (get-internal-real-time))\n\t; XXX FIXME, should probably use\n\t; ((make-gram-class-api) 'fetch-pairs) instead.\n\t(display \"Start loading words and word-classes\\n\")\n\t(load-atoms-of-type 'WordNode)\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/agglo-pairwise.scm",
        "line": 51,
        "type": "FIXME",
        "content": "; XXX The below needs routines defined in `agglo-rank.scm`",
        "context": "(use-modules (opencog) (opencog matrix) (opencog persist))\n\n; ---------------------------------------------------------------\n; XXX The below needs routines defined in `agglo-rank.scm`\n\n(define-public (pair-wise-cluster LLOBJ NRANK LOOP-CNT)\n\"\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/cset-merge.scm",
        "line": 90,
        "type": "FIXME",
        "content": "; XXX Incomplete, in development.",
        "context": "(use-modules (opencog) (opencog sheaf) (opencog persist))\n\n; ---------------------------------------------------------------\n; XXX Incomplete, in development.\n\n(define (matching-sequences CON-A CON-B)\n\"\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/cset-merge.scm",
        "line": 149,
        "type": "FIXME",
        "content": "; XXX this is maybe-dead code, its only used by `fetch-mergable-sections`",
        "context": "; In most cases, this is not strictly necessary, as the usual case is\n; that all words and word-classes are already in RAM.\n;\n; XXX this is maybe-dead code, its only used by `fetch-mergable-sections`\n; below, which is not used anywhere...\n;\n(define (fetch-class-words CLS-LST)\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
        "line": 313,
        "type": "FIXME",
        "content": "; XXX TODO this should not be exported, not really.",
        "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (start-cluster LLOBJ CLS WA WB FRAC-FN NOISE MRG-CON)\n\"\n  start-cluster LLOBJ CLS WA WB FRAC-FN NOISE MRG-CON --\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
        "line": 409,
        "type": "FIXME",
        "content": "; XXX TODO this should not be exported, not really.",
        "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (merge-into-cluster LLOBJ CLS WA FRAC-FN NOISE MRG-CON)\n\"\n  merge-into-cluster LLOBJ CLS WA FRAC-FN MRG-CON --\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
        "line": 494,
        "type": "FIXME",
        "content": "; XXX TODO this should not be exported, not really.",
        "context": "\n; ---------------------------------------------------------------------\n\n; XXX TODO this should not be exported, not really.\n(define-public (merge-clusters LLOBJ CLA CLB MRG-CON)\n\"\n  merge-clusters LLOBJ CLA CLB FRAC-FN MRG-CON --\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
        "line": 592,
        "type": "FIXME",
        "content": "; XXX TODO once make-merge-majority is done, this can be reimplemented",
        "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO once make-merge-majority is done, this can be reimplemented\n; as a special case of that. That means that the above three functions\n; can be discarded. It also means that `gram-class-api` 'make-cluster\n; method can be discarded or refactored.\n"
      },
      {
        "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
        "line": 19,
        "type": "FIXME",
        "content": ";; XXX hack alert:",
        "context": ";\n; Needs the guile-dbi interfaces, in order to write the SQL files.\n;;\n;; XXX hack alert:\n;; TODO WordClassNode support might be .. funky.\n;; In particular, if a WordNode appears in a connector, it is replaced\n;; by all WordClasses that it might be a part of. This is an\n"
      },
      {
        "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
        "line": 94,
        "type": "FIXME",
        "content": "; XXX It would be nicer if we could avoid creating the ListLink",
        "context": "\t\t; cache is what is able to detect and re-emit a previously\n\t\t; issued link name.\n\t\t;\n\t\t; XXX It would be nicer if we could avoid creating the ListLink\n\t\t; below... use a pair-caching function of some kind ...\n\t\t(lambda (left-word right-word)\n\t\t\t(cache (ListLink left-word right-word)))\n"
      },
      {
        "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
        "line": 343,
        "type": "FIXME",
        "content": "; XXX This is a temp hack, because the classification code",
        "context": "\t\t\t(mk-cls-str germ-str) dj-str COST))\n\n\t\t; Might fail with \"UNIQUE constraint failed:\" so just warn.\n\t\t; XXX This is a temp hack, because the classification code\n\t\t; is not yet written.\n\t\t(let ((err-code (car (dbi-get_status db-obj)))\n\t\t\t\t(err-msg (cdr (dbi-get_status db-obj))))\n"
      },
      {
        "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
        "line": 72,
        "type": "FIXME",
        "content": "; XXX FIXME Both of these are global and stateful in LG and",
        "context": "  Parses are counted by updating the count on `(ParseNode \\\"MST\\\")`.\n  XXX TODO Make above configurable.\n\"\n\t; XXX FIXME Both of these are global and stateful in LG and\n\t; should be a property of the dict. They must not change,\n\t; once set.\n\t(define stol (if STORAGE (list STORAGE) '()))\n"
      },
      {
        "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
        "line": 132,
        "type": "FIXME",
        "content": "(count-one-atom mst-start)   ;; XXX tmp hack",
        "context": "\t\t\t(cog-extract-recursive! phrali)\n\t\t)\n\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n"
      },
      {
        "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
        "line": 133,
        "type": "FIXME",
        "content": "(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack",
        "context": "\t\t)\n\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n\t\t(monitor-parse-rate #f)\n"
      },
      {
        "file": "components/language/learn/scm/attic/mpg-parse/lg-parser.scm",
        "line": 134,
        "type": "FIXME",
        "content": "(if timeo (count-one-atom mst-timeo)) ; XXX temp hack",
        "context": "\t\t(catch #t pthunk (lambda (key . args) (set! timeo #t)))\n(count-one-atom mst-start)   ;; XXX tmp hack\n(count-inc-atom mst-elaps (- (current-time) start)) ; XXX temp hack\n(if timeo (count-one-atom mst-timeo)) ; XXX temp hack\n\n\t\t(monitor-parse-rate #f)\n\t)\n"
      },
      {
        "file": "components/language/learn/scm/attic/pair-count-new/word-pair-count.scm",
        "line": 121,
        "type": "FIXME",
        "content": "; XXX TODO: this should probably be converted to an 1xN matrix",
        "context": "\n\t; update-word-counts -- update the count of the individual words\n\t; in a parse.\n\t; XXX TODO: this should probably be converted to an 1xN matrix\n\t; and handled with a matrix API. The sentence count and parse\n\t; count should be marginals on this thing.\n\t(define (update-word-counts WRD-LIST)\n"
      },
      {
        "file": "components/language/learn/scm/attic/pair-count/clique-pair-count.scm",
        "line": 22,
        "type": "FIXME",
        "content": "; XXX FIXME we should probably not store this way. We should probably",
        "context": "; of N, a given word-pair might be observed with every possible\n; distance between them, i.e. up to N times.\n;\n; XXX FIXME we should probably not store this way. We should probably\n; have just one word-pair, and hold the counts in different values,\n; instead. This needs a code redesign. XXX\n;\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/agglo-mi-rank.scm",
        "line": 205,
        "type": "FIXME",
        "content": "; XXX Is this really needed? Detailed balance means that neither",
        "context": "\t; count by the total count, and nothing more. The 'cache-left-entropy\n\t; just takes some logs, and nothing more.\n\t;\n\t; XXX Is this really needed? Detailed balance means that neither\n\t; the marginal counts on the DJ's, nor the marginal frrequency or\n\t; entropy should change. Validating that nothing changed could be\n\t; a reasonable data-integrity check.\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
        "line": 57,
        "type": "FIXME",
        "content": "; XXX todo store mean-rms on any-node.",
        "context": "\t(define goe (add-gaussian-ortho-api ami))\n\t(goe 'mean-rms)\n\n; XXX todo store mean-rms on any-node.\n\n\t(define gos (add-similarity-api ami #f \"goe\"))\n\t(define goec (add-similarity-compute goe))\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/gram-class-api.scm",
        "line": 65,
        "type": "FIXME",
        "content": "; XXX FIXME: this won't work for some classes, which store",
        "context": "\t(define (get-left-wildcard DJ) (ListLink any-left DJ))\n\n\t; Recycle the right wildcard from the parent class.\n\t; XXX FIXME: this won't work for some classes, which store\n\t; marginals in a different format than pairs. That is, the\n\t; 'right-element method will work correctly on pairs only,\n\t; not on marginals. For example, direct-sum is like that.\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/gram-class-api.scm",
        "line": 133,
        "type": "FIXME",
        "content": "; XXX FIXME the semantics of this thing is ugly, and should be",
        "context": "\t; return the existing class. If this is called a second time\n\t; with the same arguments, then a new, unique name is generated!\n\t; Therefore, this should never be called than once!\n\t; XXX FIXME the semantics of this thing is ugly, and should be\n\t; moved to the caller. We shouldn't have to second-guess the\n\t; callers dsired behavior!\n\t(define (make-cluster A-ATOM B-ATOM)\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/gram-majority.scm",
        "line": 205,
        "type": "FIXME",
        "content": "; XXX TODO this should be either",
        "context": "\t\t\t(<= vote-thresh\n\t\t\t\t(fold\n\t\t\t\t\t(lambda (WRD CNT)\n\t\t\t\t\t\t; XXX TODO this should be either\n\t\t\t\t\t\t; (if (< 0 (LLOBJ 'pair-count WRD DJ)) ...)\n\t\t\t\t\t\t; or it should be\n\t\t\t\t\t\t; (if (< NOISE (LLOBJ 'pair-count WRD DJ)) ...)\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/gram-majority.scm",
        "line": 465,
        "type": "FIXME",
        "content": "; XXX It would be nice to preserve history somehow, but how?",
        "context": "\t\t\t\tsublist)\n\n\t\t\t; Get rid of the class-membership.  This erases the history.\n\t\t\t; XXX It would be nice to preserve history somehow, but how?\n\t\t\t(cog-delete! dmemb))\n\n\t\t(for-each (lambda (WRD)\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/shape-project.scm",
        "line": 307,
        "type": "FIXME",
        "content": "; XXX TODO -- generic deletion should be moved to a method",
        "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO -- generic deletion should be moved to a method\n; on the base object -- probably to add-pair-stars. The extra\n; stuff like deleting crosses belongs in the shape-vec API.\n(define (remove-empty-sections LLOBJ ROW RMX)\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/shape-project.scm",
        "line": 369,
        "type": "FIXME",
        "content": "; FIXME but how?",
        "context": "\t; After doing the above, we may find that ROW has no more users,\n\t; anywhere, except in the marginals. We should clean those up\n\t; too, except we don't know what the marginals are. Alas!\n\t; FIXME but how?\n\n\t; (format #t \"Deleted ~A secs, ~A crosses for ~A\" ns nx ROW)\n)\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/shape-vec.scm",
        "line": 583,
        "type": "FIXME",
        "content": "; XXX FIXME: we should give the star-wild a unique name,",
        "context": "\t\t\t; (for-each extract-cross (LLOBJ 'get-all-elts))\n\n\t\t\t; Extracting the star-wild will clobber all CrossSections.\n\t\t\t; XXX FIXME: we should give the star-wild a unique name,\n\t\t\t; so we don't accidentally clobber CrossSections in other\n\t\t\t; objects.\n\t\t\t(for-each cog-extract-recursive! (cog-incoming-set star-wild))\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/singletons.scm",
        "line": 58,
        "type": "FIXME",
        "content": "; XXX this is broken",
        "context": "\t\t(throw 'missing-method 'add-singleton-classes\n\t\t\t\"The 'flatten method is needed to create singletons\\nUse `add-covering-sections` to get it.\"))\n\n\t; XXX this is broken\n\t(define (delete-singles)\n\t\t; delete each word-class node..\n\t\t(throw 'not-implemented 'add-singleton-classes\n"
      },
      {
        "file": "components/language/learn/scm/parse/lg-pipe-parser.scm",
        "line": 17,
        "type": "FIXME",
        "content": "; XXX FIXME. The next 30 lines of code are a cut-n-paste of the",
        "context": "(use-modules (opencog nlp) (opencog nlp lg-parse))\n(use-modules (opencog matrix))\n\n; XXX FIXME. The next 30 lines of code are a cut-n-paste of the\n; pair parsing pipeline code. It is needed because the batch processor\n; force-feeds use text, instead of allowing us to read on our own.\n; It just wires up a pipeline to feed text.\n"
      },
      {
        "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
        "line": 195,
        "type": "FIXME",
        "content": "; XXX Hack to fetch sentence count from storage. XXX we should not",
        "context": "\t(define DICT (LgDict \"any\"))\n\t(define any-parse (ParseNode \"ANY\"))\n\n\t; XXX Hack to fetch sentence count from storage. XXX we should not\n\t; do it this way, and use a cleaner design but I'm in a hurry so....\n\t; XXX Need to fetch any-parse, too.\n\t; (define any-sent (SentenceNode \"ANY\"))\n"
      },
      {
        "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
        "line": 197,
        "type": "FIXME",
        "content": "; XXX Need to fetch any-parse, too.",
        "context": "\n\t; XXX Hack to fetch sentence count from storage. XXX we should not\n\t; do it this way, and use a cleaner design but I'm in a hurry so....\n\t; XXX Need to fetch any-parse, too.\n\t; (define any-sent (SentenceNode \"ANY\"))\n\t; (cog-execute! (FetchValueOf any-sent COUNT-PRED STORAGE\n\t;    (FloatValueOf COUNT-ZERO)))\n"
      },
      {
        "file": "components/language/learn/scm/utils/utilities.scm",
        "line": 377,
        "type": "FIXME",
        "content": "; FIXME: use a thread-safe test-n-set instead.",
        "context": "\t\t(define old (if v (cog-value->list v) '()))\n\t\t(define new (append old (list val)))\n\n\t\t; FIXME: use a thread-safe test-n-set instead.\n\t\t(cog-set-value! ATOM KEY (cog-new-value typ new)))\n)\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/lg-dict.scm",
        "line": 51,
        "type": "FIXME",
        "content": "; XXX Argh. This function gets called in par-map in sureal,",
        "context": "\t(define djset (cog-incoming-by-type WORD 'LgDisjunct))\n\t(if (nil? djset)\n\t\t(let ((dentry (LgDictEntry WORD (LgDictNode \"en\"))))\n\t\t\t; XXX Argh. This function gets called in par-map in sureal,\n\t\t\t; and because it races, the dentry could already be deleted\n\t\t\t; by now, in another thread. If so, the the cog-extract! throws.\n\t\t\t; Yuck.\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/TypeNode.h",
        "line": 90,
        "type": "FIXME",
        "content": "// XXX TODO ... Some types are defined. In this case,",
        "context": "\tstatic void validate(const std::string& str)\n\t{\n\t\tType t = nameserver().getType(str);\n\t\t// XXX TODO ... Some types are defined. In this case,\n\t\t// verify that the string occurs as a name inside\n\t\t// some DefineLink... if it does, then it's valid.\n\t\t// If it does not, then it's invalid.\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
        "line": 267,
        "type": "FIXME",
        "content": "if (itm->_handle == _handle) return true; // XXX maybe quote?",
        "context": "\n\tbool contained_in(const std::vector<PatternTermPtr>& vect) {\n\t\tfor (const PatternTermPtr& itm : vect)\n\t\t\tif (itm->_handle == _handle) return true; // XXX maybe quote?\n\t\treturn false;\n\t}\n\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.h",
        "line": 524,
        "type": "FIXME",
        "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
        "context": "\n    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n"
      },
      {
        "file": "atomspace/opencog/cython/PyIncludeWrapper.h",
        "line": 4,
        "type": "FIXME",
        "content": "// XXX Cython currently conflicts with standard C library definitions.",
        "context": "\n#ifdef HAVE_CYTHON\n\n// XXX Cython currently conflicts with standard C library definitions.\n// The push/pop below should hush it, for now. (needed for cython\n// 0.15.1 and maybe other versions)  FIXME someday...\n#ifdef _GNU_SOURCE\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX Extended to support optional arguments as list of handles",
        "context": "\t\t// These wrappers abstract the atomspace away.\n\t\tHandle (*_func_h_ah)(AtomSpace*, const Handle&);\n\t\tHandle (*_func_h_ahz)(AtomSpace*, const Handle&, size_t);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tHandle (*_func_h_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tHandle as_wrapper_h_h(Handle);\n\t\tHandle as_wrapper_h_hz(Handle, size_t);\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 55,
        "type": "FIXME",
        "content": "// XXX Extended to support optional arguments as list of handles",
        "context": "\t\t// These wrappers return a TruthValuePtr and abstract the\n\t\t// atomspace away.\n\t\tTruthValuePtr (*_pred_ah)(AtomSpace*, const Handle&);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tTruthValuePtr (*_pred_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tTruthValuePtr as_wrapper_p_h(Handle);\n\t\tTruthValuePtr as_wrapper_p_h_seq(Handle, const HandleSeq&);\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 61,
        "type": "FIXME",
        "content": "// XXX Extended to support optional arguments as list of handles",
        "context": "\t\tTruthValuePtr as_wrapper_p_h_seq(Handle, const HandleSeq&);\n\n\t\tValuePtr (*_proto_ah)(AtomSpace*, const Handle&);\n\t\t// XXX Extended to support optional arguments as list of handles\n\t\tValuePtr (*_proto_ah_seq)(AtomSpace*, const Handle&, const HandleSeq&);\n\t\tValuePtr as_wrapper_v_h(Handle);\n\t\tValuePtr as_wrapper_v_h_seq(Handle, const HandleSeq&);\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 72,
        "type": "FIXME",
        "content": "// XXX Added support for optional arguments as list of handles",
        "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(Handle (*)(AtomSpace*, const Handle&, size_t),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(Handle (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&),\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 77,
        "type": "FIXME",
        "content": "// XXX Added support for optional arguments as list of handles",
        "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(TruthValuePtr (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&),\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX Added support for optional arguments as list of handles",
        "context": "\t\t             const char*, const char*);\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&),\n\t\t             const char*, const char*);\n\t\t// XXX Added support for optional arguments as list of handles\n\t\tFunctionWrap(ValuePtr (*)(AtomSpace*, const Handle&, const HandleSeq&),\n\t\t             const char*, const char*);\n};\n"
      },
      {
        "file": "cogutil/opencog/util/sigslot.h",
        "line": 74,
        "type": "FIXME",
        "content": "// XXX Something like this should work, but I can't get it to go.",
        "context": "\n#if BORKEN_FOR_SOME_REASON\n\t\t// Connect member of a given object.\n\t\t// XXX Something like this should work, but I can't get it to go.\n\t\t//\n\t\t// class Bar { public:\n\t\t//     void baz(int x, std::vector<int> y) {\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 2846,
        "type": "FIXME",
        "content": "// FIXME: add the other members of fixed_depth_iterator.",
        "context": "    return *this;\n}\n\n        // FIXME: add the other members of fixed_depth_iterator.\n\n\n// Sibling iterator\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 101,
        "type": "FIXME",
        "content": "// XXX This should be obsoleted by cond, at some point.",
        "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 98,
        "type": "FIXME",
        "content": "// XXX FIXME TODO: change the implementation, per the above note.",
        "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1089,
        "type": "FIXME",
        "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
        "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1287,
        "type": "FIXME",
        "content": "// XXX TODO, it would be easier if KLD took a sorted list",
        "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1296,
        "type": "FIXME",
        "content": "// XXX review this, is this really correct?  At any rate,",
        "context": "        }\n\n        // KLD is negative; we want the IC to be postive.\n        // XXX review this, is this really correct?  At any rate,\n        // feature selection utterly fails with negative IC.\n        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1301,
        "type": "FIXME",
        "content": "// XXX TODO remove this print, for better performance.",
        "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/algo/simple.h",
        "line": 150,
        "type": "FIXME",
        "content": "//  XXX or use partial_sort, as mentioned above...",
        "context": "        }\n    } else {\n        // stair-step distribution: keep the top num_desired only.\n        //  XXX or use partial_sort, as mentioned above...\n        for (auto pr = sorted_flist.begin(); pr != sorted_flist.end(); pr++) {\n            final.insert(*pr->second.begin());\n            num_desired --;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/local_structure.h",
        "line": 268,
        "type": "FIXME",
        "content": "// XXX ??? Huh? More details, please...",
        "context": "\n    // Now that we have created all of the dtrees, construct a\n    // feasible order that respects the initial dependencies\n    // XXX ??? Huh? More details, please... \n    randomized_topological_sort(_initial_deps, _ordering.begin());\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 189,
        "type": "FIXME",
        "content": "// XXX wouldn't it be better to store ints here ??",
        "context": "/// by a single call of the deme expander. The initial metapopulation\n/// comes from demeID \"0\".\n//\n// XXX wouldn't it be better to store ints here ??\nstruct demeID_t : public std::string\n{\n    demeID_t(unsigned expansion = 0 /* default initial deme */);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX This parameter should probably be automatically adjusted with",
        "context": "    // RAM in the instance_set, and its not currently obvious that a full\n    // scan is that much better than a random sampling.  XXX Or is it?\n    //\n    // XXX This parameter should probably be automatically adjusted with\n    // free RAM availability!?  Or something like that !?\n    //\n    // Nil: If it is adjusted with free RAM it should be able to be\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 97,
        "type": "FIXME",
        "content": "// XXX I don't understand what the below is saying.",
        "context": "    // by not doing an exhaustive search, the run-time can be significantly\n    // improved.\n    //\n    // XXX I don't understand what the below is saying.\n    // One should probably try first to tweak pop_size_ratio to\n    // control the allocation of resources. However in some cases (for\n    // instance when hill_climbing is used for feature-selection),\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 103,
        "type": "FIXME",
        "content": "// XXX pop_size_ratio disabled in hill-climbing, since its definition",
        "context": "    // instance when hill_climbing is used for feature-selection),\n    // there is only one deme to explore and tweaking that parameter\n    // can make a difference (breadth vs depth)\n    // XXX pop_size_ratio disabled in hill-climbing, since its definition\n    // was insane/non-sensical.  I can't figure out how it was supposed\n    // to work.\n    double fraction_of_nn;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 110,
        "type": "FIXME",
        "content": "// XXX TODO make sure this value is appropriately updated.",
        "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 281,
        "type": "FIXME",
        "content": "// XXX In fact, all of the current code uses this entry point, no one",
        "context": "                    time_t max_time);\n\n    // Like above but assumes that init_inst is null (backward compatibility)\n    // XXX In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/optimization.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
        "context": "                     score_t _min_score_improv = 0.5);\n\n    // N = p.popsize_ratio * n^1.05\n    // XXX Why n^1.05 ??? This is going to have a significant effect\n    // (as compared to n^1.00) only when n is many thousands or bigger...\n    unsigned pop_size(const field_set& fs) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 45,
        "type": "FIXME",
        "content": "// XXX PSO parameters hardcoded just for now.",
        "context": "// Applied Soft Computing 21 (2014): 554-567.\n\n// Particle Swarm parameters\n// XXX PSO parameters hardcoded just for now.\nstruct ps_parameters\n{\n    // There isn't need to set all this parameters, for most\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX I have to find the best values for bit and disc.",
        "context": "    unsigned max_parts;\n\n    // For continuous problems, 0.7 and 1.43 are good values.\n    // XXX I have to find the best values for bit and disc.\n    // Information from: M. Clerc, L\u2019optimisation par essaim particulaire: versions\n    // param\u00e9triques et adaptatives, Hermes Science Publications, Lavoisier, Paris, 2005.\n    double bit_c1, disc_c1, cont_c1; // c1 = Individual learning rate.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 133,
        "type": "FIXME",
        "content": "// XXX If i have time, i'll put some variation here to get a better global search.",
        "context": "    // sional data sets, in: Proceedings of 22th International IEEE Conference on Tools\n    // with Artificial Intelligence IEEE-ICTAI, vol. 1, Arras, France, 27\u201329 October 2010,\n    // 2010, pp. 87\u201393.\n    // XXX If i have time, i'll put some variation here to get a better global search.\n    double bit_min_value, bit_max_value, // [0,1] <- XXX these two aren't used yet.\n           disc_min_value, disc_max_value, // [0,1] in rounding off\n           cont_min_value, cont_max_value; // [min contin_t, max contin_t]\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 253,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        check_bit_vel(vel);\n    }\n\n    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 256,
        "type": "FIXME",
        "content": "(1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)",
        "context": "    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n    }\n\n    void update_bit_particle(instance& temp, const instance& personal,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 281,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        return (disc_t) std::round(cvalue * (max_dvalue - 1)); // Return dvalue\n    }\n\n    // XXX Explanation\n    disc_t new_disc_value(double& cvalue,\n            const double& vel, const unsigned max_dvalue){\n        cvalue += vel;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 303,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        check_cont_vel(vel);\n    }\n\n    // XXX Explanation\n    contin_t new_cont_value(const contin_t& value, const double& vel){\n        // Wind dispersion enter here.\n        contin_t res = value + vel;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 340,
        "type": "FIXME",
        "content": "// XXX This could help PSO if we maintain the best particle.",
        "context": "    // Like above but assumes that init_inst is null (backward compatibility)\n    // In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    // XXX This could help PSO if we maintain the best particle.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n                    unsigned max_evals,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 213,
        "type": "FIXME",
        "content": "// XXX should be enum ...",
        "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "FIXME",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 225,
        "type": "FIXME",
        "content": "// XXX This uses reduct::logical_reduction rules; it is not clear if those",
        "context": "// A unary function knob: this knob negates (or not) a boolean-valued\n// tree underneath it.\n//\n// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 228,
        "type": "FIXME",
        "content": "// XXX what is the difference between \"present\" and \"absent\" ??? A",
        "context": "// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n// knob that is \"absent\" from a logical \"or\" is the same as \"present\n// and false\".  while one that is absent from a logical \"and\" is the\n// same as \"present and true\" So I think this is a bit confusing ...\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 237,
        "type": "FIXME",
        "content": "// XXX Also -- I think I want to rename this to \"logical unary knob\",",
        "context": "// overall, this is confusing without some sort of additional\n// justification.\n//\n// XXX Also -- I think I want to rename this to \"logical unary knob\",\n// or something like that, as it is a unary logical function ... err...\n// well, I guess all combo opers are unary, due to Currying.\n//\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 124,
        "type": "FIXME",
        "content": "// XXX TODO should be a std::valarray not a vector.",
        "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 101,
        "type": "FIXME",
        "content": "// XXX This should be obsoleted by cond, at some point.",
        "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 99,
        "type": "FIXME",
        "content": "// XXX FIXME TODO: change the implementation, per the above note.",
        "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 684,
        "type": "FIXME",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 688,
        "type": "FIXME",
        "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
        "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1126,
        "type": "FIXME",
        "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
        "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1344,
        "type": "FIXME",
        "content": "// XXX TODO, it would be easier if KLD took a sorted list",
        "context": "            }\n        }\n\n        // XXX TODO, it would be easier if KLD took a sorted list\n        // as the argument.\n        std::vector<contin_t> p, q;\n        for (auto pr : sorted_list) {\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1353,
        "type": "FIXME",
        "content": "// XXX review this, is this really correct?  At any rate,",
        "context": "        }\n\n        // KLD is negative; we want the IC to be postive.\n        // XXX review this, is this really correct?  At any rate,\n        // feature selection utterly fails with negative IC.\n        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1358,
        "type": "FIXME",
        "content": "// XXX TODO remove this print, for better performance.",
        "context": "        // Also a problem, this is returning values greater than 1.0;\n        // I thought that IC was supposed to max out at 1.0 !?\n        contin_t ic = - KLD(p,q);\n        // XXX TODO remove this print, for better performance.\n        unsigned idx = *(fs.begin());\n        logger().debug() <<\"Contin MI for feat=\" << idx << \" ic=\" << ic;\n        return ic;\n"
      },
      {
        "file": "moses/moses/feature-selection/algo/simple.h",
        "line": 150,
        "type": "FIXME",
        "content": "//  XXX or use partial_sort, as mentioned above...",
        "context": "        }\n    } else {\n        // stair-step distribution: keep the top num_desired only.\n        //  XXX or use partial_sort, as mentioned above...\n        for (auto pr = sorted_flist.begin(); pr != sorted_flist.end(); pr++) {\n            final.insert(*pr->second.begin());\n            num_desired --;\n"
      },
      {
        "file": "moses/moses/moses/eda/local_structure.h",
        "line": 268,
        "type": "FIXME",
        "content": "// XXX ??? Huh? More details, please...",
        "context": "\n    // Now that we have created all of the dtrees, construct a\n    // feasible order that respects the initial dependencies\n    // XXX ??? Huh? More details, please... \n    randomized_topological_sort(_initial_deps, _ordering.begin());\n}\n\n"
      },
      {
        "file": "moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "moses/moses/moses/moses/moses_main.h",
        "line": 102,
        "type": "FIXME",
        "content": "// XXX TODO this should be fixed, someday...",
        "context": "        // messages.  In fact, the mpi workers should not even have\n        // a printer at all, or use a null_printer.  Unfortunately,\n        // the current code structure makes this hard to implement.\n        // XXX TODO this should be fixed, someday...\n        if (is_mpi && metapop.size() == 0)\n            return;\n\n"
      },
      {
        "file": "moses/moses/moses/moses/neighborhood_sampling.h",
        "line": 327,
        "type": "FIXME",
        "content": "// XXX TODO, unroll the last tail call, just like the single-bit",
        "context": "        else\n        {\n            // Recursive call, moved for one position\n            // XXX TODO, unroll the last tail call, just like the single-bit\n            // knob case, below.\n            out = vary_n_knobs(fs, tmp_inst, dist, starting_index + 1, out, end);\n            // Left<->Right\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 189,
        "type": "FIXME",
        "content": "// XXX wouldn't it be better to store ints here ??",
        "context": "/// by a single call of the deme expander. The initial metapopulation\n/// comes from demeID \"0\".\n//\n// XXX wouldn't it be better to store ints here ??\nstruct demeID_t : public std::string\n{\n    demeID_t(unsigned expansion = 0 /* default initial deme */);\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX This parameter should probably be automatically adjusted with",
        "context": "    // RAM in the instance_set, and its not currently obvious that a full\n    // scan is that much better than a random sampling.  XXX Or is it?\n    //\n    // XXX This parameter should probably be automatically adjusted with\n    // free RAM availability!?  Or something like that !?\n    //\n    // Nil: If it is adjusted with free RAM it should be able to be\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 97,
        "type": "FIXME",
        "content": "// XXX I don't understand what the below is saying.",
        "context": "    // by not doing an exhaustive search, the run-time can be significantly\n    // improved.\n    //\n    // XXX I don't understand what the below is saying.\n    // One should probably try first to tweak pop_size_ratio to\n    // control the allocation of resources. However in some cases (for\n    // instance when hill_climbing is used for feature-selection),\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 103,
        "type": "FIXME",
        "content": "// XXX pop_size_ratio disabled in hill-climbing, since its definition",
        "context": "    // instance when hill_climbing is used for feature-selection),\n    // there is only one deme to explore and tweaking that parameter\n    // can make a difference (breadth vs depth)\n    // XXX pop_size_ratio disabled in hill-climbing, since its definition\n    // was insane/non-sensical.  I can't figure out how it was supposed\n    // to work.\n    double fraction_of_nn;\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 110,
        "type": "FIXME",
        "content": "// XXX TODO make sure this value is appropriately updated.",
        "context": "\n    // Range of scores for which to keep instances.  This *should* be\n    // set to the value given by metapopulation::useful_score_range().\n    // XXX TODO make sure this value is appropriately updated.\n    //\n    // The range of scores is used to keep the size of the deme in check.\n    // The issue is that, for large feature sets, a large number of knobs\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 281,
        "type": "FIXME",
        "content": "// XXX In fact, all of the current code uses this entry point, no one",
        "context": "                    time_t max_time);\n\n    // Like above but assumes that init_inst is null (backward compatibility)\n    // XXX In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
      },
      {
        "file": "moses/moses/moses/optimization/optimization.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
        "context": "                     score_t _min_score_improv = 0.5);\n\n    // N = p.popsize_ratio * n^1.05\n    // XXX Why n^1.05 ??? This is going to have a significant effect\n    // (as compared to n^1.00) only when n is many thousands or bigger...\n    unsigned pop_size(const field_set& fs) const;\n\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 45,
        "type": "FIXME",
        "content": "// XXX PSO parameters hardcoded just for now.",
        "context": "// Applied Soft Computing 21 (2014): 554-567.\n\n// Particle Swarm parameters\n// XXX PSO parameters hardcoded just for now.\nstruct ps_parameters\n{\n    // There isn't need to set all this parameters, for most\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX I have to find the best values for bit and disc.",
        "context": "    unsigned max_parts;\n\n    // For continuous problems, 0.7 and 1.43 are good values.\n    // XXX I have to find the best values for bit and disc.\n    // Information from: M. Clerc, L\u2019optimisation par essaim particulaire: versions\n    // param\u00e9triques et adaptatives, Hermes Science Publications, Lavoisier, Paris, 2005.\n    double bit_c1, disc_c1, cont_c1; // c1 = Individual learning rate.\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 133,
        "type": "FIXME",
        "content": "// XXX If i have time, i'll put some variation here to get a better global search.",
        "context": "    // sional data sets, in: Proceedings of 22th International IEEE Conference on Tools\n    // with Artificial Intelligence IEEE-ICTAI, vol. 1, Arras, France, 27\u201329 October 2010,\n    // 2010, pp. 87\u201393.\n    // XXX If i have time, i'll put some variation here to get a better global search.\n    double bit_min_value, bit_max_value, // [0,1] <- XXX these two aren't used yet.\n           disc_min_value, disc_max_value, // [0,1] in rounding off\n           cont_min_value, cont_max_value; // [min contin_t, max contin_t]\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 253,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        check_bit_vel(vel);\n    }\n\n    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 256,
        "type": "FIXME",
        "content": "(1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)",
        "context": "    // XXX Explanation\n    bool new_bit_value(const double& vel){\n        return (randGen().randdouble() < // Sigmoid\n                (1 / (1 + std::exp(-vel)))); // XXX if slow try f(x) = x / (1 + abs(x)) or tanh(x)\n    }\n\n    void update_bit_particle(instance& temp, const instance& personal,\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 281,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        return (disc_t) std::round(cvalue * (max_dvalue - 1)); // Return dvalue\n    }\n\n    // XXX Explanation\n    disc_t new_disc_value(double& cvalue,\n            const double& vel, const unsigned max_dvalue){\n        cvalue += vel;\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 303,
        "type": "FIXME",
        "content": "// XXX Explanation",
        "context": "        check_cont_vel(vel);\n    }\n\n    // XXX Explanation\n    contin_t new_cont_value(const contin_t& value, const double& vel){\n        // Wind dispersion enter here.\n        contin_t res = value + vel;\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 340,
        "type": "FIXME",
        "content": "// XXX This could help PSO if we maintain the best particle.",
        "context": "    // Like above but assumes that init_inst is null (backward compatibility)\n    // In fact, all of the current code uses this entry point, no one\n    // bothers to supply an initial instance.\n    // XXX This could help PSO if we maintain the best particle.\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n                    unsigned max_evals,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 213,
        "type": "FIXME",
        "content": "// XXX should be enum ...",
        "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "FIXME",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 200,
        "type": "FIXME",
        "content": "// XXX Huh?? what does this do?? Why does shifting matter,",
        "context": "    int _default;\n    int _current;   // The current knob setting.\n\n    // XXX Huh?? what does this do?? Why does shifting matter,\n    // if the only thing done is to count the number of bits set ??\n    // WTF ??  I think the shift is n the  wrong direction, yeah?\n    // If the goal is to skip over index values that are disallowed, then\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 218,
        "type": "FIXME",
        "content": "// XXX This uses reduct::logical_reduction rules; it is not clear if those",
        "context": "// A unary function knob: this knob negates (or not) a boolean-valued\n// tree underneath it.\n//\n// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 221,
        "type": "FIXME",
        "content": "// XXX what is the difference between \"present\" and \"absent\" ??? A",
        "context": "// XXX This uses reduct::logical_reduction rules; it is not clear if those\n// rules tolerate predicates.\n//\n// XXX what is the difference between \"present\" and \"absent\" ??? A\n// knob that is \"absent\" from a logical \"or\" is the same as \"present\n// and false\".  while one that is absent from a logical \"and\" is the\n// same as \"present and true\" So I think this is a bit confusing ...\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 230,
        "type": "FIXME",
        "content": "// XXX Also -- I think I want to rename this to \"logical unary knob\",",
        "context": "// overall, this is confusing without some sort of additional\n// justification.\n//\n// XXX Also -- I think I want to rename this to \"logical unary knob\",\n// or something like that, as it is a unary logical function ... err...\n// well, I guess all combo opers are unary, due to Currying.\n//\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 124,
        "type": "FIXME",
        "content": "// XXX TODO should be a std::valarray not a vector.",
        "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
      },
      {
        "file": "cogutil/opencog/util/getopt_long.c",
        "line": 110,
        "type": "FIXME",
        "content": "/* XXX: GNU ignores PC if *options == '-' */",
        "context": "                      || (IGNORE_FIRST && options[1] != ':')))\n#define IS_POSIXLY_CORRECT (getenv(\"POSIXLY_CORRECT\") != NULL)\n#define PERMUTE         (!IS_POSIXLY_CORRECT && !IGNORE_FIRST)\n/* XXX: GNU ignores PC if *options == '-' */\n#define IN_ORDER        (!IS_POSIXLY_CORRECT && *options == '-')\n\n/* return values */\n"
      },
      {
        "file": "cogutil/opencog/util/getopt_long.c",
        "line": 127,
        "type": "FIXME",
        "content": "/* XXX: set optreset to 1 rather than these two */",
        "context": "\nstatic char *place = EMSG; /* option letter processing */\n\n/* XXX: set optreset to 1 rather than these two */\nstatic int nonopt_start = -1; /* first non option argument (for permute) */\nstatic int nonopt_end = -1;   /* first option after non options (for permute) */\n\n"
      },
      {
        "file": "cogutil/opencog/util/getopt_long.c",
        "line": 306,
        "type": "FIXME",
        "content": "/* XXX: what if no long options provided (called by getopt)? */",
        "context": "        return BADCH;\n    }\n    if (optchar == 'W' && oli[1] == ';') {      /* -W long-option */\n        /* XXX: what if no long options provided (called by getopt)? */\n        if (*place) \n            return -2;\n\n"
      },
      {
        "file": "cogutil/opencog/util/getopt_long.c",
        "line": 335,
        "type": "FIXME",
        "content": "/* XXX: disable test for :: if PC? (GNU doesn't) */",
        "context": "        optarg = NULL;\n        if (*place)         /* no white space */\n            optarg = place;\n        /* XXX: disable test for :: if PC? (GNU doesn't) */\n        else if (oli[1] != ':') {   /* arg not optional */\n            if (++optind >= nargc) {    /* no arg */\n                place = EMSG;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/wordnet-import/wni.c",
        "line": 340,
        "type": "FIXME",
        "content": "// XXX ?? is there some reason these are not \"DefinedLinguisticConceptNode\" ??",
        "context": "\texit(0);\n#endif\n\n\t// XXX ?? is there some reason these are not \"DefinedLinguisticConceptNode\" ??\n\t// I'd think they should be, right ... ? Is this a bug ??\n\tprintf(\"scm\\n\");\n\tprintf(\"(define noun (ConceptNode \\\"noun\\\"))\\n\");\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 1004,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1371,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
        "line": 31,
        "type": "FIXME",
        "content": "// XXX FIXME: except for the error messages, most of this code is",
        "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/flow/FetchValueOfLink.cc",
        "line": 63,
        "type": "FIXME",
        "content": "// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]",
        "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]\n\t// are executable, then they need to be executed, first, right?\n\t// Yes, they do. But, for just right now, we don't, to stay\n\t// compatible with ValueOfLink. See comments in that code.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/flow/StoreValueOfLink.cc",
        "line": 61,
        "type": "FIXME",
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "{\n\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Because that's the\n\t// usual intent. Else they'd be wrapped in a DontExecLink, right?\n\t// I'm confused.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/CachingProxy.cc",
        "line": 48,
        "type": "FIXME",
        "content": "// XXX TODO Add support for expiration times, limited AtomSpace",
        "context": "}\n\n// Get our configuration from the ProxyParameterLink we live in.\n// XXX TODO Add support for expiration times, limited AtomSpace\n// size and whatever other whizzy caching ideas we might want.\nvoid CachingProxy::open(void)\n{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.cc",
        "line": 77,
        "type": "FIXME",
        "content": "// XXX TODO ... create this in some temp atomspace...",
        "context": "\t}\n\n\t// Ah! Its a procedure! Make it executable!\n// XXX TODO ... create this in some temp atomspace...\n\tHandle exo = _atom_space->add_link(EXECUTION_OUTPUT_LINK,\n\t\tHandleCast(rawvp),\n\t\tcreateLink(LIST_LINK, atom));\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
        "line": 141,
        "type": "FIXME",
        "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
        "context": "// Get our configuration from the DefineLink we live in.\n// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
        "line": 195,
        "type": "FIXME",
        "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
        "context": "void WriteBufferProxy::updateValue(const Handle& atom, const Handle& key,\n                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 164,
        "type": "FIXME",
        "content": "// XXX this should be nuked, and replaced by appropriate kind of proxy.",
        "context": "// -----------------------------------------------\n// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 165,
        "type": "FIXME",
        "content": "// FIXME read above comment.",
        "context": "// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n\tsize_t pos = 0;\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 181,
        "type": "FIXME",
        "content": "// XXX Hacky .. store time in float value...",
        "context": "\t\tHandle meta = Sexpr::decode_atom(cmd, pos, _space_map);\n\t\tmeta = _base_space->add_atom(meta);\n\n\t\t// XXX Hacky .. store time in float value...\n\t\t_base_space->set_value(query, meta, createFloatValue((double)time(0)));\n\t\tif (std::string::npos != cmd.find(\"#t\", pos))\n\t\t\tforce = true;\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 200,
        "type": "FIXME",
        "content": "// XXX is this correct???",
        "context": "\n\t_base_space->set_value(query, key, rslt);\n\n\t// XXX is this correct???\n\t// _proxy->store_value(query, key);\n\n\treturn Sexpr::encode_value(rslt);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 257,
        "type": "FIXME",
        "content": "h = as->add_atom(h); // XXX shouldn't this be get_atom!????",
        "context": "\tType t = Sexpr::decode_type(cmd, pos);\n\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\th = as->add_atom(h); // XXX shouldn't this be get_atom!????\n\n\tif (_proxy and _proxy->have_fetchIncomingByType)\n\t{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 302,
        "type": "FIXME",
        "content": "h = as->add_atom(h); // XXX shouldn't this be get_atom!????",
        "context": "\tsize_t pos = 0;\n\tHandle h = Sexpr::decode_atom(cmd, pos, _space_map);\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\th = as->add_atom(h); // XXX shouldn't this be get_atom!????\n\n\tif (_proxy and _proxy->have_getAtom)\n\t{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 395,
        "type": "FIXME",
        "content": "atom = as->add_atom(atom); // XXX shouldn't this be get_atom!????",
        "context": "\tHandle key = Sexpr::decode_atom(cmd, ++pos, _space_map);\n\n\tAtomSpace* as = get_opt_as(cmd, pos);\n\tatom = as->add_atom(atom); // XXX shouldn't this be get_atom!????\n\tkey = as->add_atom(key);\n\n\tif (_proxy and _proxy->have_loadValue)\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Valuation.cc",
        "line": 50,
        "type": "FIXME",
        "content": "// XXX TODO -- C++ smart pointers are not atomic; we really",
        "context": "\nvoid Valuation::setValue(const ValuePtr& v)\n{\n\t// XXX TODO -- C++ smart pointers are not atomic; we really\n\t// need to use a lock here, to avoid thread-races.\n\t_value = v;\n}\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
        "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 79,
        "type": "FIXME",
        "content": "// XXX FIXME, this is to be removed, because UnionLink,",
        "context": "\t\t// well, in that case these are interpreted as intersection,\n\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 93,
        "type": "FIXME",
        "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
        "context": "\t\t// want to forbid it in the future by maybe introducing a\n\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 110,
        "type": "FIXME",
        "content": "// XXX FIXME - fix this so it can also choose a single value",
        "context": "///           AtomZ\n///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 143,
        "type": "FIXME",
        "content": "// XXX TODO if execute() above returns FloatValue, use that!",
        "context": "\t\t\tif (hw->is_executable())\n\t\t\t\thw = HandleCast(hw->execute(as, silent));\n\n\t\t\t// XXX TODO if execute() above returns FloatValue, use that!\n\t\t\tNumberNodePtr nn(NumberNodeCast(hw));\n\t\t\tif (nullptr == nn) // goto uniform;\n\t\t\t\tthrow SyntaxException(TRACE_INFO,\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 179,
        "type": "FIXME",
        "content": "// XXX FIXME, also allow a FloatValue!!",
        "context": "\t\tstd::vector<double> weights;\n\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/TypedVariableLink.cc",
        "line": 56,
        "type": "FIXME",
        "content": "VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug",
        "context": "\t    DEFINED_TYPE_NODE != dtype and\n\t    TYPE_CHOICE != dtype and\n\t    TYPE_INTERSECTION_LINK != dtype and\n\t    VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug\n\t    SIGNATURE_LINK != dtype and\n\t    INTERVAL_LINK != dtype and\n\t    ARROW_LINK != dtype)\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Variables.cc",
        "line": 109,
        "type": "FIXME",
        "content": "// XXX FIXME URE calls us with broken handle!!",
        "context": " */\nvoid Variables::validate_vardecl(const Handle& hdecls)\n{\n\t// XXX FIXME URE calls us with broken handle!!\n\tif (nullptr == hdecls) return;\n\n\t// Expecting the declaration list to be either a single\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Variables.cc",
        "line": 437,
        "type": "FIXME",
        "content": "// XXX TODO type-checking could be lazy; if the function is not",
        "context": "\t\t\t\"Incorrect number of arguments specified, expecting %lu got %lu\",\n\t\t\tvarseq.size(), args.size());\n\n\t// XXX TODO type-checking could be lazy; if the function is not\n\t// actually using one of the args, it's type should not be checked.\n\t// Viz., one of the arguments might be undefined, and that's OK,\n\t// if that argument is never actually used.  Fixing this requires a\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/EvaluationLink.cc",
        "line": 824,
        "type": "FIXME",
        "content": "// XXX Is there a more efficient way to do this copy?",
        "context": "\t\telse\n\t\t{\n\t\t\t// Copy all but the first.\n\t\t\t// XXX Is there a more efficient way to do this copy?\n\t\t\tsize_t sz = sna.size();\n\t\t\tfor (size_t i=1; i<sz; i++) args.push_back(sna[i]);\n\t\t}\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/ExecutionOutputLink.cc",
        "line": 155,
        "type": "FIXME",
        "content": "// XXX should be be unwrapping SetLinks here?",
        "context": "\t{\n\t\tif (not h->is_executable())\n\t\t{\n\t\t\t// XXX should be be unwrapping SetLinks here?\n\t\t\texargs.push_back(h);\n\t\t\tcontinue;\n\t\t}\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 542,
        "type": "FIXME",
        "content": "// XXX Don't we need to plug in the vars, first!?",
        "context": "\t// ExecutionOutputLinks\n\tif (nameserver().isA(t, EXECUTION_OUTPUT_LINK))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Maybe this is just not tested?\n\t\tHandle eolh = reduce_exout(expr, ist);\n\t\tif (not eolh->is_executable()) return eolh;\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 553,
        "type": "FIXME",
        "content": "// XXX Don't we need to plug in the vars, first!?",
        "context": "\t// The thread-links are ambiguously executable/evaluatable.\n\tif (nameserver().isA(t, PARALLEL_LINK))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Yes, we do, but this is just not tested, right now.\n\t\treturn ValueCast(EvaluationLink::do_evaluate(_as, expr, silent));\n\t}\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 561,
        "type": "FIXME",
        "content": "// XXX Don't we need to plug in the vars, first!?",
        "context": "\t// Execute any DefinedPredicateNodes\n\tif (nameserver().isA(t, DEFINED_PREDICATE_NODE))\n\t{\n\t\t// XXX Don't we need to plug in the vars, first!?\n\t\t// Maybe this is just not tested?\n\t\treturn ValueCast(EvaluationLink::do_evaluate(_as, expr, silent));\n\t}\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 598,
        "type": "FIXME",
        "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
        "context": "\t// We do this here, instead of in walk_tree(), because adding\n\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 642,
        "type": "FIXME",
        "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
        "context": "\tif (expr->is_type(NODE) and expr->is_executable())\n\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
        "line": 278,
        "type": "FIXME",
        "content": "/// XXX Is executing the ground a good design choice? I dunno. It's the",
        "context": "/// variable).\n///\n/// Any executable terms in `ground` are executed prior to comparison.\n/// XXX Is executing the ground a good design choice? I dunno. It's the\n/// historical choice. So it goes.\n///\n/// If false is returned, the contents of valmap are invalid. If true\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FilterLink.cc",
        "line": 615,
        "type": "FIXME",
        "content": "// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,",
        "context": "\t{\n\t\tvex = _outgoing[1]->execute(as, silent);\n\n\t\t// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,\n\t\t// then we should construct another Queue as the return value,\n\t\t// and perform filtering on-demand.\n\t\tif (vex->is_type(LINK_VALUE))\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
        "line": 41,
        "type": "FIXME",
        "content": "/// XXX FIXME - in the future, some user is going to want to include",
        "context": "/// not typed, and there are *two* bodies, each body returning one\n/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
        "line": 72,
        "type": "FIXME",
        "content": "// XXX This is buggy. If the formula contains a VariableList,",
        "context": "/// This returns a SimpleTruthValue, if there are two arguments,\n/// and a CountTruthVaue, if there are three.\n//\n// XXX This is buggy. If the formula contains a VariableList,\n// and any of the two sub-parts of it use only some of the variables,\n// but not all of them, then the reduction will go wrong. The solution\n// is probably to inherit from Lambda instead, and also have multi-body\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/TruthValueOfLink.cc",
        "line": 30,
        "type": "FIXME",
        "content": "// XXX why isn't this centralized somewhere?",
        "context": "\nusing namespace opencog;\n\n// XXX why isn't this centralized somewhere?\n// Why am I writing this again, from scratch?\nstatic TruthValuePtr get_the_tv(AtomSpace* as, const Handle& h, bool silent)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/ValueOfLink.cc",
        "line": 84,
        "type": "FIXME",
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "\t// space; we can add the Atom there, and things will\n\t// trickle out properly in the end.\n\t//\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Yes, they do! We\n\t// can currently get away with not doing this for two reasons:\n\t// In all existing code, the first Atom is always an anchor,\n"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 721,
        "type": "FIXME",
        "content": "// XXX FIXME this is really dumb, using a queue and then",
        "context": "\n\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n"
      },
      {
        "file": "atomspace/opencog/atoms/parallel/ExecuteThreadedLink.cc",
        "line": 59,
        "type": "FIXME",
        "content": "/// XXX TODO: We could have a non-blocking version of this atom. We",
        "context": "/// Atoms in the set. If the NumberNode is present, then the number of\n/// threads is the smaller of the NumberNode and the seize of the Set.\n///\n/// XXX TODO: We could have a non-blocking version of this atom. We\n/// could just return the QueueValue immediately; the user could check\n/// to see if the queue is closed, to find out if the threads have\n/// finished.\n"
      },
      {
        "file": "atomspace/opencog/atoms/parallel/PureExecLink.cc",
        "line": 64,
        "type": "FIXME",
        "content": "// XXX Note that this leaks, if the execute throws.",
        "context": "\t}\n\n\t// No AtomSpace provided. Use a temporary.\n\t// XXX Note that this leaks, if the execute throws.\n\t// The transient code will catch the leak, and complain.\n\t// (There's no actual memleak; just a complaint about counting.)\n\tAtomSpace* tas = grab_transient_atomspace(as);\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 146,
        "type": "FIXME",
        "content": "// XXX FIXME, more correct would be to loop over",
        "context": "\t{\n\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 165,
        "type": "FIXME",
        "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
        "context": "\t\tunbundle_clauses(h);\n\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 407,
        "type": "FIXME",
        "content": "/// XXX No one, except unit tests, use these deprecated API's. These",
        "context": "/// a list of clauses to solve.  This is currently kind-of crippled,\n/// since no variable type restricions are possible, and no optionals,\n/// either.  This is used only for backwards-compatibility API's.\n/// XXX No one, except unit tests, use these deprecated API's. These\n/// old unit tests should be removed.\nPatternLink::PatternLink(const HandleSet& vars,\n                         const HandleSeq& clauses)\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 980,
        "type": "FIXME",
        "content": "// XXX Shouldn't we be adding this to _fixed, too?",
        "context": "\t\t\tif (not ptm->contained_in(_pat.pmandatory))\n\t\t\t\t_pat.pmandatory.push_back(ptm);\n\n\t\t\t// XXX Shouldn't we be adding this to _fixed, too?\n\t\t\treturn true;\n\t\t}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1003,
        "type": "FIXME",
        "content": "// XXX Shouldn't we be adding this to _fixed, too?",
        "context": "\t\tif (not ptm->contained_in(_pat.pmandatory))\n\t\t\t_pat.pmandatory.push_back(ptm);\n\n\t\t// XXX Shouldn't we be adding this to _fixed, too?\n\t\treturn true;\n\t}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1039,
        "type": "FIXME",
        "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
        "context": "/// If the ImplicationLink is suitably simple, it can be added\n/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1044,
        "type": "FIXME",
        "content": "/// XXX The situation here is also very dangerous: without any",
        "context": "/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n///\n/// XXX The situation here is also very dangerous: without any\n/// type constraints, we risk searching atoms created in the scratch\n/// atomspace, resulting in infinite recursion and a blown stack.\n/// Not clear how to avoid that...\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1255,
        "type": "FIXME",
        "content": "// XXX FIXME -- this is wrong. What we really want is to",
        "context": "\t\t\t_pat.have_evaluatables = true;\n\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1465,
        "type": "FIXME",
        "content": "// XXX FIXME: debug_log() above is more readable than the below.",
        "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternUtils.cc",
        "line": 55,
        "type": "FIXME",
        "content": "// XXX FIXME Are the below needed?",
        "context": "\t\t      or nameserver().isA(clause->getOutgoingAtom(0)->get_type(),\n\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n"
      },
      {
        "file": "atomspace/opencog/atoms/reduct/AccumulateLink.cc",
        "line": 71,
        "type": "FIXME",
        "content": "// XXX TODO -- we could also handle vectors of strings, by",
        "context": "\t\treturn createFloatValue(acc);\n\t}\n\n\t// XXX TODO -- we could also handle vectors of strings, by\n\t// concatenating them into one long string.  However, for this\n\t// to be generally useful, we'd want to insert whitespace in\n\t// between. But how? One way would be to pass another argument\n"
      },
      {
        "file": "atomspace/opencog/atoms/reduct/DecimateLink.cc",
        "line": 65,
        "type": "FIXME",
        "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
        "context": "\t\treturn do_execute(vmask, vi);\n\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n"
      },
      {
        "file": "atomspace/opencog/atoms/truthvalue/CountTruthValue.cc",
        "line": 168,
        "type": "FIXME",
        "content": "// XXX This is not the correct way to handle confidence ...",
        "context": "    strength_t meeny = (get_mean() * get_count() +\n                   oc->get_mean() * oc->get_count()) / cnt;\n\n    // XXX This is not the correct way to handle confidence ...\n    // The confidence will typically hold the log probability,\n    // where the probability is the normalized count.  Thus\n    // the right thing to do is probably to add the probabilities!?\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 272,
        "type": "FIXME",
        "content": "// Fixme maybe later someday, if/when this is needed.",
        "context": "\t// having one AtomSpace be placed as a member into many others,\n\t// except that we don't have any viable mechanisms for such multiple\n\t// membership, and so I don't know how to treat this right now.\n\t// Fixme maybe later someday, if/when this is needed.\n\tif (not (nullptr == _atom_space or as == nullptr))\n\t\tthrow RuntimeException(TRACE_INFO,\n\t\t\t\"At this time, an AtomSpace can only be placed in one other\\n\"\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 283,
        "type": "FIXME",
        "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
        "context": "}\n\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n"
      },
      {
        "file": "atomspace/opencog/atomspace/Transient.cc",
        "line": 43,
        "type": "FIXME",
        "content": "/// XXX FIXME. Performance has not been recently measured; there",
        "context": "/// cheaper to just have a cache of empty atomspaces, hanging around,\n/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 1427,
        "type": "FIXME",
        "content": "// XXX FIXME this does a lot of wasteful string copying.",
        "context": "\nvoid PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n"
      },
      {
        "file": "atomspace/opencog/cython/opencog/load-file.cc",
        "line": 86,
        "type": "FIXME",
        "content": "// XXX This is fairly tacky/broken, and needs a better fix.",
        "context": "    if (search_paths.empty()) {\n        // Sometimes paths are given without the \"opencog\" part.\n        // Also check the build directory for autogen'ed files.\n        // XXX This is fairly tacky/broken, and needs a better fix.\n        for (auto p : default_paths) {\n            search_paths.push_back(p);\n            search_paths.push_back(p + \"/opencog\");\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.cc",
        "line": 70,
        "type": "FIXME",
        "content": "//XXX New constructors supporting optional arguments as list of handles",
        "context": "\tdefine_scheme_primitive(_name, &FunctionWrap::as_wrapper_v_h, this, modname);\n}\n\n//XXX New constructors supporting optional arguments as list of handles\nFunctionWrap::FunctionWrap(Handle (f)(AtomSpace*, const Handle&, const HandleSeq&),\n                           const char* funcname, const char* modname)\n\t: _func_h_ah(nullptr), _func_h_ahz(nullptr), _func_h_ah_seq(f),\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.cc",
        "line": 133,
        "type": "FIXME",
        "content": "// XXX New wrapper methods supporting optional arguments as list of handles",
        "context": "\treturn _proto_ah(as, h);\n}\n\n// XXX New wrapper methods supporting optional arguments as list of handles\nHandle FunctionWrap::as_wrapper_h_h_seq(Handle h, const HandleSeq& opt_args)\n{\n\tconst AtomSpacePtr& asp = SchemeSmob::ss_get_env_as(_name);\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeSmobAtom.cc",
        "line": 84,
        "type": "FIXME",
        "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
        "context": "\n/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 70,
        "type": "FIXME",
        "content": "// XXX HACK ALERT This needs to be static, in order for python to",
        "context": "\n// ========================================================\n\n// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 73,
        "type": "FIXME",
        "content": "// XXX FIXME: can we fix cython to not do this, already?",
        "context": "// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/TypeUtilsSCM.cc",
        "line": 58,
        "type": "FIXME",
        "content": "// XXX HACK ALERT This needs to be static, in order for python to",
        "context": "\n// ========================================================\n\n// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// Oh well. I guess that's OK, since the definition is meant to be\n"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 126,
        "type": "FIXME",
        "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
        "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 370,
        "type": "FIXME",
        "content": "// XXX ?? Why incoming set ???",
        "context": "\t\t// This feels wonky. Is this correct?\n\t\tif (_starter_term->getHandle()->is_link())\n\t\t{\n\t\t\t// XXX ?? Why incoming set ???\n\t\t\tch.search_set = get_incoming_set(best_start,\n\t\t\t                              _starter_term->getHandle()->get_type());\n\t\t}\n"
      },
      {
        "file": "atomspace/opencog/query/NextSearchMixin.cc",
        "line": 167,
        "type": "FIXME",
        "content": "// XXX TODO ... Rather than counting the number of variables, we",
        "context": "// can be done in a direct fashion; it resembles the concept of\n// \"unit propagation\" in the DPLL algorithm.\n//\n// XXX TODO ... Rather than counting the number of variables, we\n// should instead look for one with the smallest incoming set.\n// That is because the very next thing that we do will be to\n// iterate over the incoming set of \"pursue\" ... so it could be\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 284,
        "type": "FIXME",
        "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
        "context": "/// Compare the contents of a Present term in the pattern to the\n/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 335,
        "type": "FIXME",
        "content": "// XXX This is almost surely wrong... if there are two",
        "context": "\t              << \" of \" << iend << \" of term=\" << ptm->to_string()\n\t              << \", choose_next=\" << _choose_next;})\n\n\t// XXX This is almost surely wrong... if there are two\n\t// nested choice links, then this will hog the steps,\n\t// and the deeper choice will fail.\n\tif (_choose_next)\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 805,
        "type": "FIXME",
        "content": "// XXX should we be clearing ... or popping this flag?",
        "context": "\tPOPSTK(_perm_more_stack, _perm_have_more);\n\tPOPSTK(_perm_breakout_stack, _perm_breakout);\n\n\t// XXX should we be clearing ... or popping this flag?\n\t_perm_go_around = false;\n\n\tPOPSTK(_perm_odo_stack, _perm_odo_state);\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 956,
        "type": "FIXME",
        "content": "// XXX why are we not doing any checks to see if the",
        "context": "\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// XXX why are we not doing any checks to see if the\n\t\t\t\t// grounding meets the variable constraints?\n\t\t\t\tglob_pos_stack.push({glob, {ip, jg}});\n\t\t\t\t_glob_state[osp] = {glob_grd, glob_pos_stack};\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1005,
        "type": "FIXME",
        "content": "// XXX Huh ???",
        "context": "\t\t\t\t}\n\n\t\t\t\t// Just in case, if the upper bound is zero...\n\t\t\t\t// XXX Huh ???\n\t\t\t\tif (not _variables->is_upper_bound(ohp, 1))\n\t\t\t\t{\n\t\t\t\t\trecord_match(glob, glob_seq);\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1116,
        "type": "FIXME",
        "content": "// XXX The current implementation is a brute-force search, and is highly",
        "context": "/// care about the rest, the moiety (which can be very large; thus\n/// \"sparse\".)\n//\n// XXX The current implementation is a brute-force search, and is highly\n// inefficient for truly sparse searches. A (vastly) superior search\n// woudld be to obtain the connected components in the search set, and\n// try to ground those.  This avoids the pointless odometer spinning.\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1159,
        "type": "FIXME",
        "content": "// XXX TODO The logic here should be updated to resemble that",
        "context": "\tDO_LOG({LAZY_LOG_FINE << \"tree_comp NEW SETUP sparse term=\"\n\t                      << ptm->to_string();})\n\n\t// XXX TODO The logic here should be updated to resemble that\n\t// in curr_perm(), which deals correctly with nested permutations\n\t// of unordered patterns. For just right now, we are not\n\t// implementing nested sparse links, mostly because I'm too lazy\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1533,
        "type": "FIXME",
        "content": "// XXX FIXME - this is not very elegant. We should probably",
        "context": "\t// If this is some other rando variable that is not part of\n\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1631,
        "type": "FIXME",
        "content": "// XXX I'm not convinced this is right, if there are mixtures",
        "context": "\t\treturn explore_upspar_branches(ptm, hg, clause);\n\n\t// Check if the pattern has globs in it.\n\t// XXX I'm not convinced this is right, if there are mixtures\n\t// of unordered and globby links in different places...\n\tif (parent->hasAnyGlobbyVar())\n\t\treturn explore_upglob_branches(ptm, hg, clause);\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1983,
        "type": "FIXME",
        "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
        "context": "/// form; see `explore_sparse_branches()`.\n///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2050,
        "type": "FIXME",
        "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
        "context": "/// functional group, and the glob will end up holding the moiety that\n/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2066,
        "type": "FIXME",
        "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
        "context": "{\n\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2176,
        "type": "FIXME",
        "content": "// XXX This `need_choice_push` thing is probably wrong; it probably",
        "context": "\n\tlogmsg(\"Begin choice branchpoint iteration loop\");\n\tdo {\n\t\t// XXX This `need_choice_push` thing is probably wrong; it probably\n\t\t// should resemble the perm_push() used for unordered links.\n\t\t// However, currently, no test case trips this up. so .. OK.\n\t\t// Whatever. This still probably needs fixing.\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2224,
        "type": "FIXME",
        "content": "/// XXX FIXME -- do the above.",
        "context": "/// -- build a connectivity map, just like the one for clauses\n/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2446,
        "type": "FIXME",
        "content": "// XXX TODO make sure that all variables in the clause have",
        "context": "\t\t                 << \"Parent has evaluatable but code path was expected to be unreachable. \"\n\t\t                 << \"Clause: \" << clause->getQuote()->to_string();\n\t\t// Continue with the evaluation anyway, but log the issue\n\t\t// XXX TODO make sure that all variables in the clause have\n\t\t// been grounded!  If they're not, something is badly wrong!\n\t\tlogmsg(\"Term inside evaluatable, move up to it's top:\",\n\t\t\t       clause->getQuote());\n"
      },
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 164,
        "type": "FIXME",
        "content": "/// XXX FIXME now I see how it can be done. The groupings should",
        "context": "/// to dribble in. Perhaps the engine search could be modified in some\n/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n"
      },
      {
        "file": "atomspace/opencog/query/SatisfyMixin.cc",
        "line": 583,
        "type": "FIXME",
        "content": "// XXX FIXME terrible hack.",
        "context": "\t\t// pure absent is found.\n\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 197,
        "type": "FIXME",
        "content": "// XXX The assert below -- if we hit this, then we have nested",
        "context": "\t\t// Unless it is quoted.\n\t\tif (ptm->isQuoted()) return true;\n\n\t\t// XXX The assert below -- if we hit this, then we have nested\n\t\t// scoped links. The correct fix would be to push these onto a\n\t\t// stack, and then alter scope_match() to walk the stack,\n\t\t// verifying alpha-convertability.\n"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 551,
        "type": "FIXME",
        "content": "// XXX TODO as discussed on the mailing list, we should perhaps first",
        "context": "\t//       Arg1Atom\n\t//       Arg2Atom\n\t//\n\t// XXX TODO as discussed on the mailing list, we should perhaps first\n\t// see if the following can be found in the atomspace:\n\t//\n\t//   EvaluationLink\n"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 702,
        "type": "FIXME",
        "content": "// XXX ... This might be buggy; I'm confused. Deep in the bowels",
        "context": "\t\t// OrLink for term-presence.  The other behavior \"all clauses\n\t\t// must be present\" is implemented by PresentLink.\n\t\t//\n\t\t// XXX ... This might be buggy; I'm confused. Deep in the bowels\n\t\t// of the pattern matcher, we make an explicit promise to explore\n\t\t// all possible choices.  Here, we are making no such promise;\n\t\t// instead, we're just responding to what higher layers have\n"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 710,
        "type": "FIXME",
        "content": "// XXX FIXME: worse: this cannot possibly be right when",
        "context": "\t\t// possibilities?  And if they failed to do so, can we even do\n\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/CogServer.cc",
        "line": 125,
        "type": "FIXME",
        "content": "// XXX FIXME. terrible terrible hack. What we should be",
        "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/ServerConsole.cc",
        "line": 261,
        "type": "FIXME",
        "content": "/// XXX escaped quotes are not handled correctly. FIXME.",
        "context": "\n\n/// Parse command line. Quotes are stripped.\n/// XXX escaped quotes are not handled correctly. FIXME.\n/// This passes over quotes embeded in the middle strings.\n/// And that OK, because what the heck did you want to happen?\nstatic std::list<std::string> simple_tokenize(const std::string& line)\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 920,
        "type": "FIXME",
        "content": "// XXX TODO - maybe load links depth-order...",
        "context": "{\n\tCHECK_OPEN;\n\t// First, load all the nodes ... then the links.\n\t// XXX TODO - maybe load links depth-order...\n\tloadAtoms(table, \"n@\");\n\tloadAtoms(table, \"l@\");\n}\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 944,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksDAG.cc",
        "line": 240,
        "type": "FIXME",
        "content": "// XXX TODO: we should probably cache the results, instead of",
        "context": "void RocksStorage::makeOrder(Handle hasp,\n                             std::map<uint64_t, Handle>& order)\n{\n// XXX TODO: we should probably cache the results, instead of\n// recomputing every time!?\n\t// As long as there's a stack of Frames, just loop.\n\twhile (true)\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 522,
        "type": "FIXME",
        "content": "// XXX this is adding to wrong atomspace!?",
        "context": "\t\tfid = \":\" + writeFrame(as);\n\n\tValuePtr vp = getValue(\"k@\" + sid + fid + \":\" + kid);\n// XXX this is adding to wrong atomspace!?\n\tif (as and vp) vp = as->add_atoms(vp);\n\th->setValue(key, vp);\n}\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1283,
        "type": "FIXME",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
        "line": 82,
        "type": "FIXME",
        "content": "// XXX FIXME -- are open and close actually needed for anything?",
        "context": "    _storage = nullptr;\n}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
        "line": 285,
        "type": "FIXME",
        "content": "(WORD_NODE == soltype) || // XXX get rid of WordNode here, someday.",
        "context": "\n\t// Word instances match only if they have the same word lemma.\n\tif ((WORD_INSTANCE_NODE == soltype) ||\n\t    (WORD_NODE == soltype) || // XXX get rid of WordNode here, someday.\n\t    (SEME_NODE == soltype))\n\t{\n\t\tbool match = word_instance_match(npat, nsoln);\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
        "line": 293,
        "type": "FIXME",
        "content": "// XXX This code is never reached !!!???",
        "context": "\t\treturn match;\n\t}\n\n\t// XXX This code is never reached !!!??? \n\t// This is a bit of dead code, which may need to be revived for more\n\t// proper relex matching ... or maybe not ... \n\tif (DEFINED_LINGUISTIC_CONCEPT_NODE == soltype)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
        "line": 361,
        "type": "FIXME",
        "content": "// XXX this needs to be replaced in the end, for now its just a cheesy",
        "context": "\tPatternMatchEngine::print_solution(var_grounding, pred_grounding);\n\n\t// And now for a cheesy hack to report the solution\n\t// XXX this needs to be replaced in the end, for now its just a cheesy\n\t// hack to pass data back to scheme.\n\tHandle hq = atom_space->addNode(ANCHOR_NODE, \"# QUERY SOLUTION\");\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sureal/SuRealSCM.cc",
        "line": 171,
        "type": "FIXME",
        "content": "// XXX perhaps it's better to write a eval_q in SchemeEval to convert",
        "context": "    const HandleSeq& qClauses = h->getOutgoingSet();\n\n    // get all the nodes to be treated as variable in the Pattern Matcher\n    // XXX perhaps it's better to write a eval_q in SchemeEval to convert\n    //     a scm list to HandleSeq, so can just use the scheme utilities?\n    UnorderedHandleSet allNodes;\n    get_all_unique_nodes(h, allNodes);\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd/SenseSimilaritySQL.cc",
        "line": 151,
        "type": "FIXME",
        "content": "// XXX however, what we should really do is to not that we have no",
        "context": "\trp.rs->release();\n\n\t// If no data, return similarity of zero!\n\t// XXX however, what we should really do is to not that we have no\n\t// data, and maybe try to gather some.\n\tif (!rp.have_data)\n\t{\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd/WordSenseProcessor.cc",
        "line": 120,
        "type": "FIXME",
        "content": "// XXX we are being called too often. this needs to be fixed.",
        "context": "{\n\trun_no_delay();\n\n\t// XXX we are being called too often. this needs to be fixed.\n\t// in truth, should only poll on new input.\n\tusleep(50*1000);\n}\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 93,
        "type": "FIXME",
        "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
        "context": "\tif (_in_server) return;\n\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1057,
        "type": "FIXME",
        "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
        "context": "\t\t{\n\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1180,
        "type": "FIXME",
        "content": "// XXX FIXME only a subset is needed.",
        "context": "\nvoid SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 239,
        "type": "FIXME",
        "content": "// XXX FIXME this does not smell right; optionals should get",
        "context": "\n    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 268,
        "type": "FIXME",
        "content": "// XXX FIXME ... using an std::map would be more efficient.",
        "context": "    // remove repeated atoms from OR\n    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 46,
        "type": "FIXME",
        "content": "// FIXME XXX -- Optionals are handled incorrectly here;",
        "context": "\n    std::vector<LGDictExpContainer> subcontainers;\n\n    // FIXME XXX -- Optionals are handled incorrectly here;\n    // they are denoted by a null Exp pointer in an OR_list!\n    // Ignoring all the nulls is just ... wrong.\n#if (LINK_MAJOR_VERSION == 5) &&  (LINK_MINOR_VERSION < 7)\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 103,
        "type": "FIXME",
        "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
        "context": "\n    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 229,
        "type": "FIXME",
        "content": "// XXX FIXME. This should be part of the LgDictNode but since",
        "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 338,
        "type": "FIXME",
        "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
        "context": "\t\t\tparse_options_set_linkage_limit(opts, max_linkages);\n\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/continmax.cc",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX Currently, this doesn't really work well, or maybe at all, in",
        "context": "// evolutionary algorithms typically do not track derivatives (which\n// is how the problem becomes easy when applying calculus).\n//\n// XXX Currently, this doesn't really work well, or maybe at all, in\n// part because the contin implementation in the field set is incomplete\n// or broken or maybe both; there is a confusion between depth and arity\n// in that code. (i.e. confusion between depth and breadth, between arity\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/nmax.cc",
        "line": 38,
        "type": "FIXME",
        "content": "// XXX setting n=2 currently fails due to a bug, see",
        "context": "// namely, a set of variables, the value of each of which is at maximum.\n// This is a generalization of the \"onemax\" problem, which is nmax with n=2.\n//\n// XXX setting n=2 currently fails due to a bug, see\n// https://bugs.launchpad.net/moses/+bug/908230\n//\n// NOTE: This is NOT a demonstration of program learning, which is what\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/ontomax.cc",
        "line": 36,
        "type": "FIXME",
        "content": "// XXX Someday, fix all of this!",
        "context": "// contin support, but for general terms arranged in an n-ary tree, \n// instead of a 2-ary tree for contin.\n//\n// XXX Someday, fix all of this!\n\nvoid recbuild(term_tree& tr, term_tree::iterator it,\n\t      int b, int maxd, int d, int s)\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
        "line": 26,
        "type": "FIXME",
        "content": "// XXX under construction XXX",
        "context": "\nusing boost::lexical_cast;\n\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
        "line": 28,
        "type": "FIXME",
        "content": "// XXX this example is broken, and will remain so until \"multivariate\"",
        "context": "\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
        "line": 31,
        "type": "FIXME",
        "content": "// XXX some of the documentation below may be misleading.",
        "context": "// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n//\n// Demonstration program for the \"bit-trap\" optimization problem.\n// This is a standard optimization demonstraton problem: a \n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX which is why we need to put structure leanring back in the code XXX",
        "context": "// scoring functions make different bits depend on one-another.  Thus,\n// the optimal solution cannot be found without structure learning; the\n// MOSES univariate() learner is a no-op, and so cannot solve this problem.\n// XXX which is why we need to put structure leanring back in the code XXX\n//\n// The correlation between variables is accomplished by using a\n// vee-shaped scoring function. The vee-shape is meant to be \"deceptive\",\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
        "line": 85,
        "type": "FIXME",
        "content": "// XXX Should probably be \"union\", yeah?",
        "context": "    //     if (p1) v1; else if (p2) v2; else if ... else y\n    //\n    // The 'value' is marked unknown, as it can be of any type.\n    // XXX Should probably be \"union\", yeah?\n    { id::cond,               \"->(arg_list(boolean unknown) unknown unknown)\" },\n\n    // Someday, contin_if will be obsolted/equivalent to above cond ...\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/iostream_combo.cc",
        "line": 440,
        "type": "FIXME",
        "content": "// XXX ?? Ahem, won't calling out<<(*m) just lead to infinite",
        "context": "    if (const enum_t* m = get<enum_t>(&v))\n        return out << m->getContent();\n\n    // XXX ?? Ahem, won't calling out<<(*m) just lead to infinite\n    // recursion ?? \n    if (const ann_type* z = get<ann_type>(&v))\n        return out << (*z);\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/eval.cc",
        "line": 530,
        "type": "FIXME",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return eval_throws_tree(bmap, exp_tr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 336,
        "type": "FIXME",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "FIXME",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 100,
        "type": "FIXME",
        "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
        "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 409,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 434,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 667,
        "type": "FIXME",
        "content": "// XXX this cannot possibly be correct, the total count is in general",
        "context": "    for (auto row_it = begin();\n         row_it != end() and idx_it != idxs.end();) {\n        auto& outputs = row_it->second;\n// XXX this cannot possibly be correct, the total count is in general\n// a fraction, not an integer; it is merely the sum of the weights\n// of the rows. It is NOT equal to the toal number of rows!\n// I cannot figure out what this algo is trying to do, so I can't\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 848,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.cc",
        "line": 599,
        "type": "FIXME",
        "content": "// XXX TODO the code below was modified to allow arg lists of",
        "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/algo/simple.cc",
        "line": 43,
        "type": "FIXME",
        "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
        "context": "    if (0 == fs_params.target_size) {\n        // Nothing happened, return all features by default\n        \n        // XXX: fsc(all_features) is skipped because that algorithm is\n        // used in combination with contin MI in\n        // feature_selectionUTest.cxxtest and contin MI does not\n        // support feature sets with more than 1 feature.\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/algo/simple.cc",
        "line": 55,
        "type": "FIXME",
        "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
        "context": "                                      fs_params.target_size,\n                                      fs_params.exp_distrib,\n                                      fs_params.threshold);\n    // XXX: fsc(all_features) is skipped because that algorithm is\n    // used in combination with contin MI in\n    // feature_selectionUTest.cxxtest and contin MI does not support\n    // feature sets with more than 1 feature.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "FIXME",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem-params.cc",
        "line": 166,
        "type": "FIXME",
        "content": "// XXX TODO: make this print correctly, instead of using brackets.",
        "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "FIXME",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "FIXME",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 487,
        "type": "FIXME",
        "content": "// XXX Eh ??? for precision/recall scorers,",
        "context": "\n        // For enum targets, like boolean targets, the score\n        // can never exceed zero (perfect score).\n        // XXX Eh ??? for precision/recall scorers,\n        // the score range is 0.0 to 1.0 so this is wrong...\n        if (0.0 < pms.moses_params.max_score) {\n            pms.moses_params.max_score = 0.0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/ensemble.cc",
        "line": 259,
        "type": "FIXME",
        "content": "// XXX the logic below is probably wrong.",
        "context": "\t\t\tconst behavioral_score& bs = sct.get_bscore();\n\t\t\tsize_t bslen = _bscorer.size();\n\n\t\t\t// XXX the logic below is probably wrong.\n\t\t\tOC_ASSERT(false, \"this doesn't work right now.\");\n\t\t\t// Now, look to see where this scorer was wrong, and bump the\n\t\t\t// bias for that.  Here, we make the defacto assumption that\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "FIXME",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "FIXME",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 577,
        "type": "FIXME",
        "content": "// XXX this lock probably doesn't have to be the same one",
        "context": "        return;\n\n    // Make this routine thread-safe.\n    // XXX this lock probably doesn't have to be the same one\n    // that merge uses.  I think.\n    std::lock_guard<std::mutex> lock(_merge_mutex);\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "FIXME",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/complexity.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX What is the complexity of contin expressions?",
        "context": "// fewer operators than either CNF or DNF, so counting operators\n// doesn't seem wrong to me ...)\n//\n// XXX What is the complexity of contin expressions?\n// Expressions containining greater_than_zero, impulse, cond?  I'm\n// somwhat confused about how thigs are being measured.   Note that\n// when we calculate the complexity of a field_set, then contins\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
        "line": 56,
        "type": "FIXME",
        "content": "// XXX When would one never expand?  Wouldn't that be a bug?",
        "context": "\n    // Attempt to create a non-empty representation, by looping\n    // over exemplars until we find one that expands.\n    // XXX When would one never expand?  Wouldn't that be a bug?\n    while (1) {\n        scored_combo_tree_ptr_set_cit exemplar = mp.select_exemplar();\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 201,
        "type": "FIXME",
        "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
        "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 307,
        "type": "FIXME",
        "content": "// XXX replace this with appropriate message back to root!",
        "context": "        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // XXX replace this with appropriate message back to root!\n            OC_ASSERT(false, \"Exemplar failed to expand!\\n\");\n        }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 420,
        "type": "FIXME",
        "content": "// XXX is mp.best_score thread safe !???? since another thread might be updating this as we",
        "context": "\n    // If we are here, then we are the root node.  The root will act\n    // as a dispatcher to all of the worker nodes.\n// XXX is mp.best_score thread safe !???? since another thread might be updating this as we\n// come around ...\n\n    size_t tot_workers = mompi.num_workers();\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 566,
        "type": "FIXME",
        "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
        "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/partial.cc",
        "line": 264,
        "type": "FIXME",
        "content": "// XXX is this correct? I think we need to ask the cscorer for the total ...",
        "context": "    // Are we done yet?\n    behavioral_score bs = _bscore->operator()(cand);\n\n    // XXX is this correct? I think we need to ask the cscorer for the total ...\n    score_t total_score = 0.0;\n    for (const score_t& sc : bs)\n        total_score += sc;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/partial.cc",
        "line": 304,
        "type": "FIXME",
        "content": "// XXX Ineffective predicates may be due to enums that have been",
        "context": "        good_count = 0;\n        effective(predicate, good_count, fail_count);\n\n        // XXX Ineffective predicates may be due to enums that have been\n        // completely accounted for ... not sure what to do about that...\n        if ((0 < good_count) || (0 < fail_count))\n            break;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/optimization.cc",
        "line": 79,
        "type": "FIXME",
        "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
        "context": "}\n\n// N = p.popsize_ratio * n^1.05\n// XXX Why n^1.05 ??? This is going to have a significant effect\n// (as compared to n^1.00) only when n is many thousands or bigger...\nunsigned optim_parameters::pop_size(const field_set& fs) const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 122,
        "type": "FIXME",
        "content": "// XXX What score do i use?",
        "context": "                            boost::bind(boost::cref(iscorer), _1));\n        current_number_of_evals += swarm_size;\n\n        // XXX What score do i use?\n        // I'll use best_score for now.\n        bool has_improved = false;\n        for (unsigned i = 0; i < swarm_size; ++i) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/star-anneal.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX TODO the annealing temperature control code should be ported over",
        "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 51,
        "type": "FIXME",
        "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
        "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 236,
        "type": "FIXME",
        "content": "// XXX TODO need to add support for \"term algebra\" knobs",
        "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 391,
        "type": "FIXME",
        "content": "// XXX This is dead code, no one uses it, and looking at the below, it",
        "context": "}\n\n#ifdef EXEMPLAR_INST_IS_UNDEAD\n// XXX This is dead code, no one uses it, and looking at the below, it\n// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 395,
        "type": "FIXME",
        "content": "// XXX why are we clearing this, instead of setting it back to the",
        "context": "// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 398,
        "type": "FIXME",
        "content": "// XXX Note that the clear_exemplar() methods on the knobs are probably",
        "context": "// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n//  not needed either!?\nvoid representation::clear_exemplar()\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/representation.cc",
        "line": 409,
        "type": "FIXME",
        "content": "// XXX that, and contin seems to be handled inconsistently with disc...",
        "context": "}\n\n// What is this doing ? seems to be clearing things out, why do we need this?\n// XXX that, and contin seems to be handled inconsistently with disc...\n// I mean, shouldn't we be setting the exemplar_inst fields so that\n// they match the exmplar?  Do we even need the exemplar_inst for anything?\nvoid representation::set_exemplar_inst()\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
        "line": 930,
        "type": "FIXME",
        "content": "/// XXX this should probably be removed! TODO FIXME",
        "context": "/// even output all the data that is required to use the resulting\n/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 213,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "      _hardness(hardness),\n      _full_bscore(true)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n\n    logger().info(\"Discriminating scorer, hardness = %f, \"\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 417,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_precision, max_precision, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 486,
        "type": "FIXME",
        "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 586,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "                       float hardness)\n    : discriminating_bscore(ct, min_diff, max_diff, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 663,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "f_one_bscore::f_one_bscore(const CTable& ct)\n    : discriminating_bscore(ct, 0.0, 1.0, 1.0e-20)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 1;\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
        "line": 108,
        "type": "FIXME",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "moses/examples/example-progs/continmax.cc",
        "line": 46,
        "type": "FIXME",
        "content": "// XXX Currently, this doesn't really work well, or maybe at all, in",
        "context": "// evolutionary algorithms typically do not track derivatives (which\n// is how the problem becomes easy when applying calculus).\n//\n// XXX Currently, this doesn't really work well, or maybe at all, in\n// part because the contin implementation in the field set is incomplete\n// or broken or maybe both; there is a confusion between depth and arity\n// in that code. (i.e. confusion between depth and breadth, between arity\n"
      },
      {
        "file": "moses/examples/example-progs/nmax.cc",
        "line": 38,
        "type": "FIXME",
        "content": "// XXX setting n=2 currently fails due to a bug, see",
        "context": "// namely, a set of variables, the value of each of which is at maximum.\n// This is a generalization of the \"onemax\" problem, which is nmax with n=2.\n//\n// XXX setting n=2 currently fails due to a bug, see\n// https://bugs.launchpad.net/moses/+bug/908230\n//\n// NOTE: This is NOT a demonstration of program learning, which is what\n"
      },
      {
        "file": "moses/examples/example-progs/ontomax.cc",
        "line": 36,
        "type": "FIXME",
        "content": "// XXX Someday, fix all of this!",
        "context": "// contin support, but for general terms arranged in an n-ary tree, \n// instead of a 2-ary tree for contin.\n//\n// XXX Someday, fix all of this!\n\nvoid recbuild(term_tree& tr, term_tree::iterator it,\n\t      int b, int maxd, int d, int s)\n"
      },
      {
        "file": "moses/examples/example-progs/trap-bit.cc",
        "line": 26,
        "type": "FIXME",
        "content": "// XXX under construction XXX",
        "context": "\nusing boost::lexical_cast;\n\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n"
      },
      {
        "file": "moses/examples/example-progs/trap-bit.cc",
        "line": 28,
        "type": "FIXME",
        "content": "// XXX this example is broken, and will remain so until \"multivariate\"",
        "context": "\n// XXX under construction XXX\n\n// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n"
      },
      {
        "file": "moses/examples/example-progs/trap-bit.cc",
        "line": 31,
        "type": "FIXME",
        "content": "// XXX some of the documentation below may be misleading.",
        "context": "// XXX this example is broken, and will remain so until \"multivariate\"\n// is ported over/re-implemented. Basically, there is no structure\n// learning at this time.  \n// XXX some of the documentation below may be misleading.\n//\n// Demonstration program for the \"bit-trap\" optimization problem.\n// This is a standard optimization demonstraton problem: a \n"
      },
      {
        "file": "moses/examples/example-progs/trap-bit.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX which is why we need to put structure leanring back in the code XXX",
        "context": "// scoring functions make different bits depend on one-another.  Thus,\n// the optimal solution cannot be found without structure learning; the\n// MOSES univariate() learner is a no-op, and so cannot solve this problem.\n// XXX which is why we need to put structure leanring back in the code XXX\n//\n// The correlation between variables is accomplished by using a\n// vee-shaped scoring function. The vee-shape is meant to be \"deceptive\",\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/descriptions.cc",
        "line": 85,
        "type": "FIXME",
        "content": "// XXX Should probably be \"union\", yeah?",
        "context": "    //     if (p1) v1; else if (p2) v2; else if ... else y\n    //\n    // The 'value' is marked unknown, as it can be of any type.\n    // XXX Should probably be \"union\", yeah?\n    { id::cond,               \"->(arg_list(boolean unknown) unknown unknown)\" },\n\n    // Someday, contin_if will be obsolted/equivalent to above cond ...\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/iostream_combo.cc",
        "line": 440,
        "type": "FIXME",
        "content": "// XXX ?? Ahem, won't calling out<<(*m) just lead to infinite",
        "context": "    if (const enum_t* m = get<enum_t>(&v))\n        return out << m->getContent();\n\n    // XXX ?? Ahem, won't calling out<<(*m) just lead to infinite\n    // recursion ?? \n    if (const ann_type* z = get<ann_type>(&v))\n        return out << (*z);\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/eval.cc",
        "line": 563,
        "type": "FIXME",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return eval_throws_tree(new_bmap, lambda_expr);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 336,
        "type": "FIXME",
        "content": "// XXX TODO: contin_if should go away.",
        "context": "            return (i == id::logical_true ? 1.0 : 0.0);\n        }\n\n        // XXX TODO: contin_if should go away.\n        case id::contin_if :\n        case id::cond : {\n            sib_it sib = it.begin();\n"
      },
      {
        "file": "moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "FIXME",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 100,
        "type": "FIXME",
        "content": "// XXX TODO: I don't understand why this is not damaging contin_if  !??",
        "context": "    // Most nodes take simple lists; but not cond. Cond takes clauses,\n    // which are pairs. If we remove the condition, we must also remove\n    // the consequent.\n// XXX TODO: I don't understand why this is not damaging contin_if  !??\n// But .. umm, maybe build_knobs is not creating any kinds of contin_if's\n// that can be damaged... well, no matter, because thes if's will be\n// replaced by cond... \n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 420,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return rhs.get_label() == label;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::abs_distance(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 445,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "    return res;\n}\n\n// XXX TODO replace this by the util p_norm function.\ncontin_t OTable::sum_squared_error(const OTable& ot) const\n{\n    OC_ASSERT(ot.size() == size());\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 678,
        "type": "FIXME",
        "content": "// XXX this cannot possibly be correct, the total count is in general",
        "context": "    for (auto row_it = begin();\n         row_it != end() and idx_it != idxs.end();) {\n        auto& outputs = row_it->second;\n// XXX this cannot possibly be correct, the total count is in general\n// a fraction, not an integer; it is merely the sum of the weights\n// of the rows. It is NOT equal to the toal number of rows!\n// I cannot figure out what this algo is trying to do, so I can't\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 859,
        "type": "FIXME",
        "content": "// XXX TODO replace this by the util p_norm function.",
        "context": "\n// -------------------------------------------------------\n\n// XXX TODO replace this by the util p_norm function.\ncomplete_truth_table::size_type\ncomplete_truth_table::hamming_distance(const complete_truth_table& other) const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.cc",
        "line": 622,
        "type": "FIXME",
        "content": "// XXX TODO the code below was modified to allow arg lists of",
        "context": "            // then check that a1 inherits from T1, and that a2, a3\n            // and a4 inherit from T2.  T3 is the output type.\n\n            // XXX TODO the code below was modified to allow arg lists of\n            // mixed type, e.g. so that the cond primitive could be\n            // supported (as the current definition of cond alternates\n            // between boolean-valued predicates, and the result type).\n"
      },
      {
        "file": "moses/moses/feature-selection/algo/simple.cc",
        "line": 43,
        "type": "FIXME",
        "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
        "context": "    if (0 == fs_params.target_size) {\n        // Nothing happened, return all features by default\n        \n        // XXX: fsc(all_features) is skipped because that algorithm is\n        // used in combination with contin MI in\n        // feature_selectionUTest.cxxtest and contin MI does not\n        // support feature sets with more than 1 feature.\n"
      },
      {
        "file": "moses/moses/feature-selection/algo/simple.cc",
        "line": 55,
        "type": "FIXME",
        "content": "// XXX: fsc(all_features) is skipped because that algorithm is",
        "context": "                                      fs_params.target_size,\n                                      fs_params.exp_distrib,\n                                      fs_params.threshold);\n    // XXX: fsc(all_features) is skipped because that algorithm is\n    // used in combination with contin MI in\n    // feature_selectionUTest.cxxtest and contin MI does not support\n    // feature sets with more than 1 feature.\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "FIXME",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "moses/moses/moses/main/problem-params.cc",
        "line": 166,
        "type": "FIXME",
        "content": "// XXX TODO: make this print correctly, instead of using brackets.",
        "context": "    using namespace std;\n\n    // Declare the supported options.\n    // XXX TODO: make this print correctly, instead of using brackets.\n    desc.add_options()\n\n        // General options\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "FIXME",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "FIXME",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 487,
        "type": "FIXME",
        "content": "// XXX Eh ??? for precision/recall scorers,",
        "context": "\n        // For enum targets, like boolean targets, the score\n        // can never exceed zero (perfect score).\n        // XXX Eh ??? for precision/recall scorers,\n        // the score range is 0.0 to 1.0 so this is wrong...\n        if (0.0 < pms.moses_params.max_score) {\n            pms.moses_params.max_score = 0.0;\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "FIXME",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "FIXME",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 577,
        "type": "FIXME",
        "content": "// XXX this lock probably doesn't have to be the same one",
        "context": "        return;\n\n    // Make this routine thread-safe.\n    // XXX this lock probably doesn't have to be the same one\n    // that merge uses.  I think.\n    std::lock_guard<std::mutex> lock(_merge_mutex);\n\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "FIXME",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "moses/moses/moses/moses/complexity.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX What is the complexity of contin expressions?",
        "context": "// fewer operators than either CNF or DNF, so counting operators\n// doesn't seem wrong to me ...)\n//\n// XXX What is the complexity of contin expressions?\n// Expressions containining greater_than_zero, impulse, cond?  I'm\n// somwhat confused about how thigs are being measured.   Note that\n// when we calculate the complexity of a field_set, then contins\n"
      },
      {
        "file": "moses/moses/moses/moses/local_moses.cc",
        "line": 56,
        "type": "FIXME",
        "content": "// XXX When would one never expand?  Wouldn't that be a bug?",
        "context": "\n    // Attempt to create a non-empty representation, by looping\n    // over exemplars until we find one that expands.\n    // XXX When would one never expand?  Wouldn't that be a bug?\n    while (1) {\n        scored_combo_tree_ptr_set_cit exemplar = mp.select_exemplar();\n\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 202,
        "type": "FIXME",
        "content": "// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.",
        "context": "/// send_deme -- send the completed deme from the worker back to root\n///\n/// This sends a pretty big glob.\n// XXX TODO -- trim the deme down, before sending, by using the worst acceptable score.\nvoid moses_mpi_comm::send_deme(const metapopulation& mp, int n_evals)\n{\n    MPI::COMM_WORLD.Send(&n_evals, 1, MPI::INT, ROOT_NODE, MSG_NUM_EVALS);\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 318,
        "type": "FIXME",
        "content": "// XXX TODO should probably fetch max_time from somewhere...",
        "context": "            continue; // Continue to next exemplar\n        }\n\n        // XXX TODO should probably fetch max_time from somewhere...\n        time_t max_time = INT_MAX;\n        dex.optimize_demes(max_evals, max_time);\n\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 424,
        "type": "FIXME",
        "content": "// XXX is mp.best_score thread safe !???? since another thread might be updating this as we",
        "context": "\n    // If we are here, then we are the root node.  The root will act\n    // as a dispatcher to all of the worker nodes.\n// XXX is mp.best_score thread safe !???? since another thread might be updating this as we\n// come around ...\n\n    size_t tot_workers = mompi.num_workers();\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 570,
        "type": "FIXME",
        "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
        "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 616,
        "type": "FIXME",
        "content": "// XXX TODO instead of overwritting the demeID it should be",
        "context": "        scored_combo_tree_set candidates;\n        stats.n_expansions ++;\n\n        // XXX TODO instead of overwritting the demeID it should be\n        // correctly defined by the worker and send back to the\n        // dispatcher. That way we can have the breadth_first\n        // componant of the demeID right.\n"
      },
      {
        "file": "moses/moses/moses/moses/partial.cc",
        "line": 264,
        "type": "FIXME",
        "content": "// XXX is this correct? I think we need to ask the cscorer for the total ...",
        "context": "    // Are we done yet?\n    behavioral_score bs = _bscore->operator()(cand);\n\n    // XXX is this correct? I think we need to ask the cscorer for the total ...\n    score_t total_score = 0.0;\n    for (const score_t& sc : bs)\n        total_score += sc;\n"
      },
      {
        "file": "moses/moses/moses/moses/partial.cc",
        "line": 304,
        "type": "FIXME",
        "content": "// XXX Ineffective predicates may be due to enums that have been",
        "context": "        good_count = 0;\n        effective(predicate, good_count, fail_count);\n\n        // XXX Ineffective predicates may be due to enums that have been\n        // completely accounted for ... not sure what to do about that...\n        if ((0 < good_count) || (0 < fail_count))\n            break;\n"
      },
      {
        "file": "moses/moses/moses/optimization/optimization.cc",
        "line": 79,
        "type": "FIXME",
        "content": "// XXX Why n^1.05 ??? This is going to have a significant effect",
        "context": "}\n\n// N = p.popsize_ratio * n^1.05\n// XXX Why n^1.05 ??? This is going to have a significant effect\n// (as compared to n^1.00) only when n is many thousands or bigger...\nunsigned optim_parameters::pop_size(const field_set& fs) const\n{\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 122,
        "type": "FIXME",
        "content": "// XXX What score do i use?",
        "context": "                            boost::bind(boost::cref(iscorer), _1));\n        current_number_of_evals += swarm_size;\n\n        // XXX What score do i use?\n        // I'll use best_score for now.\n        bool has_improved = false;\n        for (unsigned i = 0; i < swarm_size; ++i) {\n"
      },
      {
        "file": "moses/moses/moses/optimization/star-anneal.cc",
        "line": 42,
        "type": "FIXME",
        "content": "// XXX TODO the annealing temperature control code should be ported over",
        "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 51,
        "type": "FIXME",
        "content": "// XXX TODO: One might think that varying the stepsize, i.e. shrinking",
        "context": "// Stepsize should be roughly the standard-deviation of the expected\n// distribution of the contin variables.\n//\n// XXX TODO: One might think that varying the stepsize, i.e. shrinking\n// it, as the optimizers tune into a specific value, would be a good\n// thing (so that the optimizer could tune to a more precise value).\n// Unfortunately, a simple experiment in tuning (see below, surrounded\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 238,
        "type": "FIXME",
        "content": "// XXX TODO need to add support for \"term algebra\" knobs",
        "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 393,
        "type": "FIXME",
        "content": "// XXX This is dead code, no one uses it, and looking at the below, it",
        "context": "}\n\n#ifdef EXEMPLAR_INST_IS_UNDEAD\n// XXX This is dead code, no one uses it, and looking at the below, it\n// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 397,
        "type": "FIXME",
        "content": "// XXX why are we clearing this, instead of setting it back to the",
        "context": "// looks inconsistent to me. I'm going to leave it here for a while, but\n// it should be removed by 2013 or 2014 if not sooner...\n\n// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 400,
        "type": "FIXME",
        "content": "// XXX Note that the clear_exemplar() methods on the knobs are probably",
        "context": "// XXX why are we clearing this, instead of setting it back to the\n// _exemplar_inst ??? XXX is this broken??\n//\n// XXX Note that the clear_exemplar() methods on the knobs are probably\n//  not needed either!?\nvoid representation::clear_exemplar()\n{\n"
      },
      {
        "file": "moses/moses/moses/representation/representation.cc",
        "line": 411,
        "type": "FIXME",
        "content": "// XXX that, and contin seems to be handled inconsistently with disc...",
        "context": "}\n\n// What is this doing ? seems to be clearing things out, why do we need this?\n// XXX that, and contin seems to be handled inconsistently with disc...\n// I mean, shouldn't we be setting the exemplar_inst fields so that\n// they match the exmplar?  Do we even need the exemplar_inst for anything?\nvoid representation::set_exemplar_inst()\n"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.cc",
        "line": 930,
        "type": "FIXME",
        "content": "/// XXX this should probably be removed! TODO FIXME",
        "context": "/// even output all the data that is required to use the resulting\n/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 239,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "      _hardness(hardness),\n      _full_bscore(true)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n\n    logger().info(\"Discriminating scorer, hardness = %f, \"\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 443,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_precision, max_precision, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 512,
        "type": "FIXME",
        "content": "// XXX TODO -- should not return the penalties as part of the bscore,",
        "context": "                  float hardness)\n    : discriminating_bscore(ct, min_recall, max_recall, hardness)\n{\n    // XXX TODO -- should not return the penalties as part of the bscore,\n    // since this messes up boosting.\n    _size = ct.size() + 2;\n}\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 612,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "                       float hardness)\n    : discriminating_bscore(ct, min_diff, max_diff, hardness)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 2;\n}\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 646,
        "type": "FIXME",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the break-even-point for this ctable row.\nscore_t bep_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt * _true_total);\n    double best_possible_recall = 1.0 / _true_total;\n    return (best_possible_precision + best_possible_recall) / 2;\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 655,
        "type": "FIXME",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the difference for this ctable row.\nscore_t bep_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt);\n    double best_possible_recall = (0.0 < pos) ? 1.0 : 0.0;\n    return fabs(best_possible_precision - best_possible_recall);\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 674,
        "type": "FIXME",
        "content": "// XXX Currently, this scorer does not return a true behavioral score",
        "context": "f_one_bscore::f_one_bscore(const CTable& ct)\n    : discriminating_bscore(ct, 0.0, 1.0, 1.0e-20)\n{\n    // XXX Currently, this scorer does not return a true behavioral score\n    _size = 1;\n}\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 707,
        "type": "FIXME",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "// generation of best-possible score.\nscore_t f_one_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    return 1.0;\n}\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 714,
        "type": "FIXME",
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "/// Return the f_one for this ctable row.\nscore_t f_one_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / cnt;\n    double best_possible_recall = 1.0;\n    double f_one = 2 * best_possible_precision * best_possible_recall\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.cc",
        "line": 142,
        "type": "FIXME",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "unify/opencog/unify/atoms/UnifierLink.cc",
        "line": 141,
        "type": "FIXME",
        "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
        "context": "\t// I don't really understand what a solution set is.\n\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 397,
        "type": "FIXME",
        "content": "if (not implicand)  // XXX this check is never needed !?",
        "context": "{\n\tHandle implicand = get_implicand();\n\n\tif (not implicand)  // XXX this check is never needed !?\n\t\treturn false;\n\n\tType itype = implicand->get_type();\n"
      },
      {
        "file": "analyze_fixme_instances.py",
        "line": 138,
        "type": "FIXME",
        "content": "('xxx' in line_lower and (line_lower.strip().startswith('#') or line_lower.strip().startswith('//'))) or  # XXX comments",
        "context": "            \n        # Look for actual FIXME patterns in comments  \n        return (('fixme' in line_lower) or \n                ('xxx' in line_lower and (line_lower.strip().startswith('#') or line_lower.strip().startswith('//'))) or  # XXX comments\n                ('xxx' in line_lower and ('fix' in line_lower or 'todo' in line_lower)) or\n                ('todo' in line_lower and 'fixme' in line_lower))\n    \n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 13,
        "type": "FIXME",
        "content": "\"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",",
        "context": "    \"\"\"Process the specific FIXME examples from the issue description.\"\"\"\n    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 14,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",",
        "context": "    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 16,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",",
        "context": "        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 17,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",",
        "context": "        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 18,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 19,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 23,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",",
        "context": "        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 25,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",",
        "context": "        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 26,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",",
        "context": "        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 28,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",",
        "context": "        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 30,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",",
        "context": "        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 32,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",",
        "context": "        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 33,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 35,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 36,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",",
        "context": "        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 38,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",",
        "context": "        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 42,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
        "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 44,
        "type": "FIXME",
        "content": "\"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"",
        "context": "        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n    \n    # Categorize these specific examples\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 106,
        "type": "FIXME",
        "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
        "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n"
      },
      {
        "file": "fixme_resolution_tracker.py",
        "line": 169,
        "type": "FIXME",
        "content": "report.append(\"# FIXME Resolution Progress Report\")",
        "context": "    def generate_next_steps_report(self) -> str:\n        \"\"\"Generate a report implementing the next steps from the catalog.\"\"\"\n        report = []\n        report.append(\"# FIXME Resolution Progress Report\")\n        report.append(f\"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"\")\n        \n"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 250,
        "type": "FIXME",
        "content": "# FIXME Resolution Makefile Targets",
        "context": "        \n        makefile = self.repo_root / \"Makefile.fixme\"\n        makefile_content = dedent('''\n            # FIXME Resolution Makefile Targets\n            # Include this in your main Makefile with: include Makefile.fixme\n            \n            .PHONY: fixme-status fixme-easy-wins fixme-report fixme-setup\n"
      },
      {
        "file": "atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "FIXME",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
      },
      {
        "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 449,
        "type": "FIXME",
        "content": "# XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.",
        "context": "    def test_m_scheme_command(self):\n        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n"
      },
      {
        "file": "atomspace/tests/cython/atomspace/test_atomspace.py",
        "line": 362,
        "type": "FIXME",
        "content": "# XXX FIXME is testing the name of the bottom type",
        "context": "    def test_get_type_name(self):\n        self.assertEqual(get_type_name(types.Node), \"Node\")\n        self.assertEqual(get_type_name(2231), \"\")\n        # XXX FIXME is testing the name of the bottom type\n        # a sane thing to do?\n        self.assertEqual(get_type_name(types.NO_TYPE), \"*** Bottom Type! ***\")\n"
      },
      {
        "file": "components/core/atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "FIXME",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
      },
      {
        "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 449,
        "type": "FIXME",
        "content": "# XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.",
        "context": "    def test_m_scheme_command(self):\n        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 32,
        "type": "FIXME",
        "content": "log = OrderedDict()  # FIXME: log \u00bb response",
        "context": "    algorithm = kwa('kmeans', 'clustering', **kwargs)\n    verbose = kwa('none', 'verbose', **kwargs)\n\n    log = OrderedDict()  # FIXME: log \u00bb response\n    log.update({'category_learner': 'v.0.7.81231'})\n\n    cdf = pd.DataFrame(columns = ['cluster', 'cluster_words'])\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 53,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            dim = vector_space_dim(links, dict_path, tmpath, dim_max, sv_min,\n                                   verbose)\n        except:  # FIXME\n            dim = dim_max\n        log.update({'vector_space_dim': dim})\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 14,
        "type": "FIXME",
        "content": "nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?",
        "context": "    rights = Counter()  # right words in links\n    links = Counter()   # tuples: (left_word, right_word)\n    lw = Counter()      # linked words\n    nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?\n    nlws = set()        # a set of non-linked words in a sentence in a loop\n    nnlws = 0           # number of non-linked word occasions in all sentences\n    sentence = []       # a list of words (used within loops)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 37,
        "type": "FIXME",
        "content": "nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned",
        "context": "                if len(nlws) > 0:  # indices of non-parsed words in sentence\n                    nnlws += len(nlws)  # number of non-linked words\n                    for j in nlws:\n                        nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned\n                    # nlws = set()\n                # sentence = []\n                # Count only parsed words (excluding ###LEFT-WALL### and .)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 27,
        "type": "FIXME",
        "content": "if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!",
        "context": "def calc_pmi(counts, cds):  # Calculates e^PMI; PMI without the log().\n    sum_w = np.array(counts.sum(axis=1))[:, 0]\n    sum_c = np.array(counts.sum(axis=0))[0, :]\n    if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!\n    sum_total = sum_c.sum()\n    sum_w = np.reciprocal(sum_w)\n    sum_c = np.reciprocal(sum_c)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 138,
        "type": "FIXME",
        "content": "print('SVDEmbedding: transpose')    #FIXME:DEL",
        "context": "    # Context embeddings can be created with \"transpose\".\n    def __init__(self, path, normalize=True, eig=0.0, transpose=False):\n        if transpose:\n            print('SVDEmbedding: transpose')    #FIXME:DEL\n            ut = np.load(path + '.vt.npy')\n            self.wi, self.iw = load_vocabulary(path + '.contexts.vocab')\n        else:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 641,
        "type": "FIXME",
        "content": "continue  # FIXME: check case",
        "context": "                     linkage, affinity, gen, ' ---', 'fail',\n                     ' ---', ' ---', ' ---', ' ---', ' ---', ' ---']\n            details.append(dline)\n            continue  # FIXME: check case\n        if kwargs['linkage_limit'] > 0:\n            start = time.time()\n            a, f1, precision, q = pqa_meter(re['grammar_file'],\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 141,
        "type": "FIXME",
        "content": "# else:  # FIXME: raise error / assert ?",
        "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 111,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['silhouette_index'] = float(\n                silhouette_score(cd, labels, metric=clustering_metric[1]))\n        except:  # FIXME\n            metrics['silhouette_index'] = 0.0\n        try:\n            metrics['variance_ratio'] = float(\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 116,
        "type": "FIXME",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['variance_ratio'] = float(\n                calinski_harabaz_score(cd, labels))\n        except:  # FIXME\n            metrics['variance_ratio'] = 0.0\n        # try:\n        #   metrics['davies_bouldin_score'] = float(\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 124,
        "type": "FIXME",
        "content": "except:  # else:  # FIXME",
        "context": "        # except: metrics['davies_bouldin_score'] = 0.0\n\n        return labels, metrics, centroids\n    except:  # else:  # FIXME\n        print('except: skl_clustering error')\n        return np.asarray(range(cd.shape[0])), \\\n               {'clustering': 'skl_clustering error'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 208,
        "type": "FIXME",
        "content": "# FIXME: try...except",
        "context": "# 181203 cleanup\n# 190118 cleanup: remove debug printing\n# 190425 fix n_clusters > n_words case\n# FIXME: try...except\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 26,
        "type": "FIXME",
        "content": "def setUp(self):    # FIXME: should run before every test, but would not?!",
        "context": "\nclass TestGrammarLearner(unittest.TestCase):\n\n    def setUp(self):    # FIXME: should run before every test, but would not?!\n        input_parses = module_path + '/tests/data/POC-Turtle/MST_fixed_manually/'\n        batch_dir = module_path + '/output/Test_Grammar_Learner_' + str(UTC())[:10] + '/'\n        kwargs = {  # defaults\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 65,
        "type": "FIXME",
        "content": "# 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester",
        "context": "        # Additional (optional) parameters for parse_metrics (_abiity & _quality):\n        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 310,
        "type": "FIXME",
        "content": "# FIXME: check with further test_grammar updates and delete.",
        "context": "            'verbose'       :   'min'\n        }\n        # Sometimes pqa_meter(with test_grammar updated 2018-10-19) returns pa,recall = 0,0\n        # FIXME: check with further test_grammar updates and delete.\n        x = 0.\n        n = 0\n        while x < 0.1 :\n"
      }
    ],
    "TODO": [
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/behavior-rules.scm",
        "line": 35,
        "type": "TODO",
        "content": "; TODO: This one only works currently with single word matches to the globs",
        "context": "            (ConceptNode \"GORGEOUS\")))\n    (DefinedPredicateNode \"be happy\"))\n\n; TODO: This one only works currently with single word matches to the globs\n; due to https://github.com/opencog/atomspace/issues/724\n(BindLink\n        (ListLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 16,
        "type": "TODO",
        "content": "; TODO: probably can take out eva-behavior module when express.scm is moved out",
        "context": ";\n; Requires installation of opencog/ros-behavior-scripting\n\n; TODO: probably can take out eva-behavior module when express.scm is moved out\n;       of that module.\n(use-modules (opencog) (opencog query) (opencog exec) (opencog eva-model)\n    (opencog eva-behavior))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 30,
        "type": "TODO",
        "content": "; TODO: multiple globnode values are not matching (Github issue created #724)",
        "context": "(load \"behavior-defs.scm\")\n(load \"behavior-rules.scm\")\n\n; TODO: multiple globnode values are not matching (Github issue created #724)\n\n;-----------------------------------------------------------------\n; The main training rule template for natural language training\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 35,
        "type": "TODO",
        "content": "; Todo: Or / Choice links not working in antecedant for recongition, so doing a",
        "context": ";-----------------------------------------------------------------\n; The main training rule template for natural language training\n\n; Todo: Or / Choice links not working in antecedant for recongition, so doing a\n; couple different rules for now as a workaround. Potential solution: also\n; search for OR at top level with cog-recognize\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 138,
        "type": "TODO",
        "content": "; TODO: For now just using a single result, but we should handle multiple",
        "context": "; Retrieve atomspace behavior rule with antecedent that contains atomese\n; representation of the input string.\n(define (get-tree-with-antecedent listified-string)\n    ; TODO: For now just using a single result, but we should handle multiple\n    ;       returned results.\n\t; TODO: Match on multiple conditions (ie using OR)\n\t;create temp child atomspace for temporarily needed atoms\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 140,
        "type": "TODO",
        "content": "; TODO: Match on multiple conditions (ie using OR)",
        "context": "(define (get-tree-with-antecedent listified-string)\n    ; TODO: For now just using a single result, but we should handle multiple\n    ;       returned results.\n\t; TODO: Match on multiple conditions (ie using OR)\n\t;create temp child atomspace for temporarily needed atoms\n\t(cog-push-atomspace)\n    (let* ((query-pattern (PatternLink\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 195,
        "type": "TODO",
        "content": "; TODO: Create feedback response that something was learned",
        "context": ";-----------------------------------------------------------------\n; Creates new behavior rule in atomese based on a given simulus and response\n(define (create-behavior-rule stimulus response)\n; TODO: Create feedback response that something was learned\n    ; create new behavior rule with text input stimulus and behavior response\n    (define new-rule)\n    (define atomese-string)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 202,
        "type": "TODO",
        "content": "; TODO: we should check first make sure the response is a pre-defined behavior",
        "context": "    (display \"\\n(create-behavior-rule) \\n    stimulus: \")(display stimulus)\n        (display \"    response: \")(display response)(newline)\n\n    ; TODO: we should check first make sure the response is a pre-defined behavior\n\t(set! new-rule\n    \t(BindLink\n    \t\tstimulus\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 216,
        "type": "TODO",
        "content": "; TODO: move to util file",
        "context": "\n;-----------------------------------------------------------------\n; Utils\n; TODO: move to util file\n\n; shortcuts\n(define (incoming atom) (cog-incoming-set atom))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 230,
        "type": "TODO",
        "content": "; TODO: ask linas about these",
        "context": "\n\n\n; TODO: ask linas about these\n; Approach to pull the training rule from the atomspace dynamically rather than\n; relying on the scheme var.\n; maybe the DefinedType atom is being replaced in the cog-satisfy\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
        "line": 234,
        "type": "TODO",
        "content": "; TODO: let's try cog-get-partner instead",
        "context": "; Approach to pull the training rule from the atomspace dynamically rather than\n; relying on the scheme var.\n; maybe the DefinedType atom is being replaced in the cog-satisfy\n; TODO: let's try cog-get-partner instead\n; Check if an atom is the training rule\n(define (training-rule? atom)\n    (cog-satisfy\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 19,
        "type": "TODO",
        "content": "; TODO:",
        "context": "; Pause the main loop:\n;    (halt)\n;\n; TODO:\n; -----\n; The current OpenPsi framework allows much more general and flexible\n; rules than what are presented below; this geneality should be made\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
        "line": 232,
        "type": "TODO",
        "content": ";TODO: Separate out room-state into separate demands that occur before",
        "context": "\t\t\t\t(DefinedSchemaNode \"Get recognized face's face id\")\n\t\t\t\t(DefinedSchema \"Get recognized faces\")))))\n\t\t(DefinedPredicate \"look at person\")\n\t\t;TODO: Separate out room-state into separate demands that occur before\n\t\t; or after other demands are handled. How should order of execution\n\t\t; be represented?\n\t\t(DefinedPredicate \"Update status\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 6,
        "type": "TODO",
        "content": "; TODO: Make the set, get, & delete of properites into a utility template",
        "context": "(use-modules (opencog eva-model) (opencog eva-behavior))\n\n; -----------------------------------------------------------------------------\n; TODO: Make the set, get, & delete of properites into a utility template\n; similar ot change-template and timestamp-template, as similar patterns\n; will be used for modeling the world. It should also make moving to\n; protoatoms[now renamed values] simplier when they are ready.\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
        "line": 124,
        "type": "TODO",
        "content": "; TODO: Move to config file",
        "context": "; Parameters are not published by cmt_tracker and have to be pre-set, so see\n; /HEAD/src/vision/cmt_tracker/src/cmt_tracker_node.cpp#L486\n; /HEAD/src/vision/pi_vision/pi_face_tracker/nodes/face_tracker.py#L271\n; TODO: Move to config file\n(define fov 1.42)\n(define camera-width 640)\n(define camera-height 480)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
        "line": 20,
        "type": "TODO",
        "content": "; TODO: make generic for orchestration.",
        "context": "(define speech-demand-satisfied (True))\n\n; Demand for tracking faces\n; TODO: make generic for orchestration.\n(define track-demand (psi-demand \"track demand\"))\n(define track-demand-satisfied (True))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
        "line": 68,
        "type": "TODO",
        "content": "; TODO Remove after thoroughly testing behavior on robot.",
        "context": "\tface-demand-satisfied (stv 1 1) face-demand)\n\n; This rule is the old multiple-face tracking rule\n; TODO Remove after thoroughly testing behavior on robot.\n(psi-rule (list (SequentialAnd\n\t\t(NotLink (DefinedPredicate \"Skip Interaction?\"))\n\t\t(DefinedPredicate \"Someone visible?\")))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
        "line": 75,
        "type": "TODO",
        "content": "; TODO: How should rules that could run concurrently be represented, when",
        "context": "\t(DefinedPredicate \"Interact with people\")\n\tface-demand-satisfied (stv 1 1) face-demand)\n\n; TODO: How should rules that could run concurrently be represented, when\n; we have action compostion(aka Planning/Orchestration)?\n(psi-rule (list (DefinedPredicate \"Someone visible?\"))\n\t(DefinedPredicate \"Interact with face\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/behavior/psi-behavior.scm",
        "line": 82,
        "type": "TODO",
        "content": "; TODO: test the behabior when talking.",
        "context": "\ttrack-demand-satisfied (stv .5 .5) track-demand)\n\n(psi-rule (list (SequentialAnd\n\t\t; TODO: test the behabior when talking.\n\t\t; (Not (DefinedPredicate \"chatbot is talking?\"))\n\t\t(DefinedPredicate \"Someone visible?\")\n\t\t(DefinedPredicate \"Time to change interaction\")))\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
        "line": 143,
        "type": "TODO",
        "content": ";; TODO Remove this when the time-server is ready.",
        "context": "(StateLink interaction-state no-interaction)\n\n;; Record with whome she was previously intracting with.\n;; TODO Remove this when the time-server is ready.\n(define-public prev-interaction-state (AnchorNode \"Previous Interaction State\"))\n(StateLink prev-interaction-state no-interaction)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
        "line": 188,
        "type": "TODO",
        "content": "; TODO Replace with openpsi-dynamics logger when it is available.",
        "context": "\t\t\t(begin\n\t\t\t\t(psi-set-event-occurrence! room-got-bright-event)\n\t\t\t\t(set! room-was-bright #t)\n\t\t\t\t; TODO Replace with openpsi-dynamics logger when it is available.\n\t\t\t\t;(if verbose (display \"**** Room got bright *****\\n\"))\n\t\t\t)\n\t\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/eva/src/psi-dynamics.scm",
        "line": 203,
        "type": "TODO",
        "content": "; TODO Replace with openpsi-dynamics logger when it is available.",
        "context": "\t\t\t(begin\n\t\t\t\t(psi-set-event-occurrence! room-got-dark-event)\n\t\t\t\t(set! room-was-dark #t)\n\t\t\t\t; TODO Replace with openpsi-dynamics logger when it is available.\n\t\t\t\t;(if verbose (display \"**** Room got dark *****\\n\"))\n\t\t\t)\n\t\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 90,
        "type": "TODO",
        "content": "; TODO Add tester function for this",
        "context": "    ((has-match? \"global-default-rule:\" str)\n      (result:suffix 'GLOBAL-DEFAULT-RULE location #f))\n    ((has-match? \"#!\" str) ; This should be checked always before #\n      ; TODO Add tester function for this\n      (cons (make-lexical-token 'SAMPLE_INPUT location #f) \"\"))\n    ((has-match? \"*#\" str)\n      (cons (make-lexical-token 'COMMENT location #f) \"\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 139,
        "type": "TODO",
        "content": "; TODO Maybe replace with dictionary keyword sets then process it on action?",
        "context": "    ((has-match? \"[a-zA-Z]+~[a-zA-Z1-9]+\" str)\n      (result:suffix 'DICTKEY location (command-pair)))\n    ; Range-restricted Wildcards.\n    ; TODO Maybe replace with dictionary keyword sets then process it on action?\n    ((has-match? \"\\\\*~[0-9]+\" str)\n      (result:suffix '*~n location\n        (substring (string-trim-both (match:substring current-match)) 2)))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 298,
        "type": "TODO",
        "content": "(SAMPLE_INPUT) : #f ; TODO replace with a tester function",
        "context": "      (rejoinder) : $1\n      (enter) : $1\n      (COMMENT) : #f\n      (SAMPLE_INPUT) : #f ; TODO replace with a tester function\n    )\n\n    (enter\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 710,
        "type": "TODO",
        "content": "; TODO: This has a restart_matching effect. See chatscript documentation",
        "context": "      (phrase) : $1\n    )\n\n    ; TODO: This has a restart_matching effect. See chatscript documentation\n    (unordered-matching\n      (<< unordered-terms >>) :\n        (format #f \"(cons 'unordered-matching (list ~a))\" $2)\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/matcher.scm",
        "line": 176,
        "type": "TODO",
        "content": "; TODO: Return the actual action instead of a rule",
        "context": "\n  ; If there is only one action in the list, return that\n  ; Otherwise, pick one based on their weights\n  ; TODO: Return the actual action instead of a rule\n  (if (= (length rules-satisfied) 1)\n    (car rules-satisfied)\n    ; Here there are special handling for rejoinders:\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/stimulation.scm",
        "line": 32,
        "type": "TODO",
        "content": "; TODO: Find some better representation for that",
        "context": "; 'ghost-word-seq' is shared among the rules with word-related pattern\n; This is mainly to make sure the rules with only a wildcard in the pattern\n; will also get some non-zero STI.\n; TODO: Find some better representation for that\n(add-hook! (perceive-word-hook)\n  (lambda () (cog-stimulate (ghost-word-seq-pred) (/ default-stimulus 2))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/terms.scm",
        "line": 238,
        "type": "TODO",
        "content": "; TODO: Should be handled in OpenCog internally?",
        "context": "  of it before sending the whole thing out.\n  The TTS server will handle the rest afterwards.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"|\" (string-join (map cog-name (flatten-list ARGS)) \",\") \"|\")))\n\n; ----------\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/terms.scm",
        "line": 255,
        "type": "TODO",
        "content": "; TODO: Should be handled in OpenCog internally?",
        "context": "  Support things like {% set delay=2 %} in the action of a rule, which\n  set how long STT should wait before sending the input to GHOST.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"{% set delay=\" (cog-name SECOND) \" %}\"))\n)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/terms.scm",
        "line": 291,
        "type": "TODO",
        "content": "; TODO: Check to make sure the function has been defined",
        "context": "  The Scheme or Python function named NAME should have already been defined.\n  The Python name has 'py_' prefix and Scheme name has 'scm_' or no prefix.\n\"\n  ; TODO: Check to make sure the function has been defined\n  (Evaluation (GroundedPredicate (parse-method-name NAME))\n              (List (map (lambda (a) (if (equal? 'GlobNode (cog-type a))\n                                         (List a) a))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/terms.scm",
        "line": 304,
        "type": "TODO",
        "content": "; TODO: Check to make sure the function has been defined",
        "context": "  The Scheme or Python function named NAME should have already been defined.\n  The Python name has 'py_' prefix and Scheme name has 'scm_' or no prefix.\n\"\n  ; TODO: Check to make sure the function has been defined\n  (ExecutionOutput (GroundedSchema (parse-method-name NAME))\n                   (List (map (lambda (a) (if (equal? 'GlobNode (cog-type a))\n                                              (List a) a))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/test.scm",
        "line": 18,
        "type": "TODO",
        "content": "; TODO: Remove once experimentation is over",
        "context": "  (cog-logger-set-level! ghost-logger \"info\"))\n\n; ----------\n; TODO: Remove once experimentation is over\n(define expt-var '())\n(define-public (test-ghost TXT)\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/translator.scm",
        "line": 189,
        "type": "TODO",
        "content": "; TODO: The specificity of ordered vs unordered should be",
        "context": "    (for-each (lambda (t)\n      (cond ((equal? 'unordered-matching (car t))\n             (update-lists (process (cdr t)))\n             ; TODO: The specificity of ordered vs unordered should be\n             ; considered as well\n             (set! is-unordered? #t))\n            ((equal? 'word (car t))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/translator.scm",
        "line": 547,
        "type": "TODO",
        "content": "; TODO: Handle variables as well",
        "context": "  ; from the rule being reused and append it to\n  ; rule that uses the reuse function, as well as\n  ; the additional ones that are in the same TrueLink\n  ; TODO: Handle variables as well\n  (define (get-reused-action atomese)\n    (append-map\n      (lambda (x)\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/translator.scm",
        "line": 856,
        "type": "TODO",
        "content": "; TODO: Remove the geometric series as it is no longer needed?",
        "context": "        ; PsiImplicator, so psi-action-executed? will return\n        ; false for the reused rule even if its action has been\n        ; executed already, which is not the behavior we want here\n        ; TODO: Remove the geometric series as it is no longer needed?\n        (if (> (length rule-hierarchy) 0)\n          (let ((var (Variable (gen-var \"GHOST-executed-rule\" #f))))\n            (set! vars (append vars (list\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
        "line": 40,
        "type": "TODO",
        "content": "; TODO: Replace by microplanner.",
        "context": ";;       (Concept \"people\")\n;;       (Concept P-name)))))\n(define (implication-to-evaluation-s2l P Q)\n; TODO: Replace by microplanner.\n    (let ((P-name (cog-name P)))\n       (Set\n          (Evaluation\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
        "line": 62,
        "type": "TODO",
        "content": "; TODO:  Remove this check once other inference-trails are",
        "context": "    (define semantics (select-highest-tv-semantics semantics-list))\n\n    (define logic\n        ; TODO:  Remove this check once other inference-trails are\n        ; handled by different response handlers.\n        (if (equal? 'ImplicationLink (cog-type semantics))\n            (implication-to-evaluation-s2l\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-actions.scm",
        "line": 69,
        "type": "TODO",
        "content": "; TODO: Remove the check  once other inference-trails are handled",
        "context": "                (gar semantics) (gdr semantics))\n            '()))\n\n    ; TODO: Remove the check  once other inference-trails are handled\n    ; diffferently.\n    (define sureal-result (if (nil? logic) '() (sureal logic)))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
        "line": 78,
        "type": "TODO",
        "content": "; TODO: Move this to an (opencog pln) module, when there is one.",
        "context": "   a-list:\n  - This is a list of atoms, for example a list of r2l outputs\n\"\n; TODO: Move this to an (opencog pln) module, when there is one.\n    (define filter-in-pattern\n        (ScopeLink\n            (TypedVariable\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-reasoner.scm",
        "line": 191,
        "type": "TODO",
        "content": "; TODO: Add measure to choose between candidates based on query or some",
        "context": "      '()\n      (cog-outgoing-set (filter-for-sureal pln-outputs))))\n\n  ; TODO: Add measure to choose between candidates based on query or some\n  ; other method.\n  (if (nil? candidates)\n    \"\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-1.scm",
        "line": 344,
        "type": "TODO",
        "content": "; TODO: use pln-load-rules when move to new PLN API, see",
        "context": "(define (configure-pln-rbs-1)\n    (define rb (ConceptNode \"r2l-pln-1\"))\n\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    (load-from-path (pln-rule-type->filename \"term/deduction\"))\n    (load-from-path (pln-rule-type->filename \"wip/abduction\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-2.scm",
        "line": 46,
        "type": "TODO",
        "content": "; TODO: Record the acutal inference trails that have been learned and apply",
        "context": "        (Variable \"$A-subset\")\n        (Variable \"$B\")))))\n\n; TODO: Record the acutal inference trails that have been learned and apply\n; them instead of trying to randomly try different permutations.\n(define (configure-pln-rbs-2)\n    (define rb (ConceptNode \"r2l-pln-2\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-2.scm",
        "line": 51,
        "type": "TODO",
        "content": "; TODO: use pln-load-rules when move to new PLN API, see",
        "context": "(define (configure-pln-rbs-2)\n    (define rb (ConceptNode \"r2l-pln-2\"))\n\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    (load-from-path (pln-rule-type->filename \"term/deduction\"))\n    (load-from-path (pln-rule-type->filename \"wip/abduction\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/pln-trail-3.scm",
        "line": 115,
        "type": "TODO",
        "content": "; TODO: use pln-load-rules when move to new PLN API, see",
        "context": "    ; The deduction rule doesn't work when the truth-value are extremely\n    ; low. (load-gtwc) wasn't helpful\n    ;\n    ; TODO: use pln-load-rules when move to new PLN API, see\n    ; https://github.com/opencog/pln/blob/master/opencog/pln/README.md\n    ;\n    ;(load-from-path (pln-rule-type->filename \"term/deduction\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/predicates.scm",
        "line": 249,
        "type": "TODO",
        "content": ";TODO: The assumption is that this is used by an ordered goal. Make it",
        "context": "  is not passed then it will check if any of the sources have an answer, and\n  cache a random source from the list.\n\"\n  ;TODO: The assumption is that this is used by an ordered goal. Make it\n  ; handle unordered goal.\n  (define src-list (get-sources))\n  (define sent\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/predicates.scm",
        "line": 311,
        "type": "TODO",
        "content": "; TODO: Replace the ConceptNode with a PredicateNode",
        "context": "; Create the GroundedPredicateNode, and link it to a generic \"timer-predicate\"\n; so that we can stimulate the generic one and the STI will diffuse to\n; the specific predicates connecting to it\n; TODO: Replace the ConceptNode with a PredicateNode\n(Implication (GroundedPredicate \"scm: is_after_min\") timer-predicate)\n(Implication (GroundedPredicate \"scm: emotion\") (Predicate \"emotion\"))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
        "line": 387,
        "type": "TODO",
        "content": ";TODO: How to represent word said by face-id without having an",
        "context": "\n  Returns (WordNode WORD) after increasing its sti.\n\"\n  ;TODO: How to represent word said by face-id without having an\n  ; explosion of atoms.\n  (define wn (Word word))\n  (define cn (Concept word))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
        "line": 468,
        "type": "TODO",
        "content": "; TODO Move the time related helpers to the time-server. Some of this",
        "context": "  )\n)\n\n; TODO Move the time related helpers to the time-server. Some of this\n; utilities should have been provided by it.\n(define (set-event-times! model old-value new-value time)\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/procedures.scm",
        "line": 1007,
        "type": "TODO",
        "content": "; TODO: move genric steps to the pln module",
        "context": "(load \"procedures/predicates.scm\")\n(load \"procedures/schemas.scm\")\n(load \"procedures/sq-bind.scm\")\n; TODO: move genric steps to the pln module\n;(load \"procedures/pln-reasoner.scm\")\n;(load \"procedures/pln-trail-3.scm\")\n;(load \"procedures/pln-utils.scm\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
        "line": 9,
        "type": "TODO",
        "content": "; TODO: List out the DefinedPredicates that are used as API, so as to",
        "context": "; NOTE: For testing use (opencog eva-behavior) module. For\n; running use (opencog movement) module. This is because the\n; APIs are atomese DefinedPredicates.\n; TODO: List out the DefinedPredicates that are used as API, so as to\n; use delete-definition. Also adapt the scheme function naming convention\n; to make remembering easier.\n; --------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
        "line": 322,
        "type": "TODO",
        "content": "; TODO: Replace by an actual sentence splitter",
        "context": "  (define query (source-query sent))\n  ; A very crude and limited way to get the first sentence\n  ; from the respond, but is OK in this context\n  ; TODO: Replace by an actual sentence splitter\n  (define (get-first-sentence str)\n    (define default-length 50)\n    (if (< (string-length str) default-length)\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
        "line": 405,
        "type": "TODO",
        "content": "; TODO: use query for filtering results, by using similarity measures b/n",
        "context": "(define pln-src (def-source \"pln\" \"ask-pln\"))\n\n(define* (ask-pln sent #:optional (steps 24))\n  ; TODO: use query for filtering results, by using similarity measures b/n\n  ; the query and the inferred outputs. There may be multiple layers of\n  ; filters.\n  (define query (source-query sent))\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
        "line": 409,
        "type": "TODO",
        "content": "; TODO: How to choose an appropriate trail or set of trails?",
        "context": "  ; the query and the inferred outputs. There may be multiple layers of\n  ; filters.\n  (define query (source-query sent))\n  ; TODO: How to choose an appropriate trail or set of trails?\n  (update-inferences rb-trail-3 steps (pln-get-recorded-time))\n  (source-set-result! sent pln-src (pln->sureal rb-trail-3))\n)\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/procedures/schemas.scm",
        "line": 808,
        "type": "TODO",
        "content": "; TODO: When there is an api to get information about the range of volume",
        "context": "; The *voice* schemas follow from ssml were 'speed' == 'rate'\n; See https://www.w3.org/TR/speech-synthesis/#edef_prosody\n;\n; TODO: When there is an api to get information about the range of volume\n; and speeds that is possible to use.\n(define (increase_voice_speed percent)\n  (set-parameter (Concept \"speech\") (Concept \"rate\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
        "line": 247,
        "type": "TODO",
        "content": "; TODO: Maybe it is better to get these rules using GetLink + SignatureLink,",
        "context": "\n\t(define (get-rules)\n\t\t; For getting those \"wildcard\" rules\n\t\t; TODO: Maybe it is better to get these rules using GetLink + SignatureLink,\n\t\t; but at the moment it does not support unordered link, and doing it this\n\t\t; way is fast...\n\t\t(define wildcard-rule-context\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
        "line": 14,
        "type": "TODO",
        "content": "(let* (; TODO: Should be bias according to the score",
        "context": "(define (pick-and-generate list-of-results)\n    (if (equal? (length list-of-results) 0)\n        '()\n        (let* (; TODO: Should be bias according to the score\n               (picked (list-ref list-of-results (random (length list-of-results))))\n               ; TODO: Should use gen-sentences when new microplanner is ready\n               (generated (sureal (gar picked))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
        "line": 16,
        "type": "TODO",
        "content": "; TODO: Should use gen-sentences when new microplanner is ready",
        "context": "        '()\n        (let* (; TODO: Should be bias according to the score\n               (picked (list-ref list-of-results (random (length list-of-results))))\n               ; TODO: Should use gen-sentences when new microplanner is ready\n               (generated (sureal (gar picked))))\n            (if (nil? generated)\n                ; Do it again if the chosen one can't be used to generate a sentence\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
        "line": 156,
        "type": "TODO",
        "content": "; TODO: Should actually clean up the WordNodes instead",
        "context": "    ; indicates that a grammatical interpretation of the sentence is\n    ; found by deleting this word in the sentence using null links)\n    ; The backslash is sometimes generated by AIML rules\n    ; TODO: Should actually clean up the WordNodes instead\n    (set! utterance (string-trim (string-filter\n        (lambda (c) (not (or (char=? #\\[ c) (char=? #\\] c) (char=? #\\\\ c)))) utterance)))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/chatscript.scm",
        "line": 40,
        "type": "TODO",
        "content": "; TODO: Parse the reply?",
        "context": "        ; Ignore the first part of it\n        (set! reply (regexp-substitute/global #f regex reply 'pre \"\" 'post))\n\n        ; TODO: Parse the reply?\n        (State chatscript-reply (List (map Word (string-split reply #\\ ))))\n        (State chatscript process-finished)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/contexts.scm",
        "line": 241,
        "type": "TODO",
        "content": "; TODO: May want to check more than time elapsed",
        "context": "\n(Define\n    (DefinedPredicate \"no-other-fast-reply?\")\n    ; TODO: May want to check more than time elapsed\n    (Evaluation (GroundedPredicate \"scm: long-time-elapsed\") (List))\n)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/external-sources.scm",
        "line": 29,
        "type": "TODO",
        "content": "; TODO: Do something better for getting the first sentence of a paragraph, though",
        "context": "    (State duckduckgo process-started)\n\n    (begin-thread\n        ; TODO: Do something better for getting the first sentence of a paragraph, though\n        ; it isn't that critical here\n        (define (get-first-sentence str)\n            (define default-length 50)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-psi/pln-contexts.scm",
        "line": 16,
        "type": "TODO",
        "content": "; TODO: Replace with what has been assked to be inferred upon.",
        "context": "(define (is-pln-inferred-related?)\n  ;; (cog-logger-info \"[PLN-Context] is-pln-inferred-related?\")\n\n  ; TODO: Replace with what has been assked to be inferred upon.\n  (let ((sentence-names (get-input-utterance-names)))\n    (if (lset<= equal? must-have-names sentence-names)\n        (stv 1 1)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
        "line": 25,
        "type": "TODO",
        "content": "; TODO: Replace these time related utilities with one from TimeMap, when it is",
        "context": "             (opencog nlp relex2logic))\n\n; -----------------------------------------------------------------------\n; TODO: Replace these time related utilities with one from TimeMap, when it is\n; ready.\n(define time-domain (DialogNode \"Dialogue-System\"))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/chat-utils.scm",
        "line": 96,
        "type": "TODO",
        "content": "; TODO use the timeserver when it is ready.",
        "context": "  - The time in seconds since 1970-01-01 00:00:00 UTC. (current-time) gives\n    such time.\n\"\n; TODO use the timeserver when it is ready.\n    (define query\n        (Get\n            (VariableList\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/fuzzy.scm",
        "line": 157,
        "type": "TODO",
        "content": "; TODO: Subject to change, currently it returns the top ones that",
        "context": "    ; Post processing for the results found by the fuzzy-matchers. May\n    ; be generally useful, if we have multiple results and we want to\n    ; merge or ignore some of them.\n    ; TODO: Subject to change, currently it returns the top ones that\n    ; have the same similarity score.\n    (define (post-process fset)\n        (let ( (max-score 0)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-noun-item.scm",
        "line": 55,
        "type": "TODO",
        "content": "; TODO recognition of \"our group\" -> \"we\" and \"our cars\" -> \"they\"",
        "context": "\t\t\t)\n\t\t)\n\n\t\t; TODO recognition of \"our group\" -> \"we\" and \"our cars\" -> \"they\"\n\n\t\t(cond ; if already a pronoun, change it to the base form\n\t\t      (is-pronoun\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora-nouns-list.scm",
        "line": 243,
        "type": "TODO",
        "content": "; TODO sometimes it is OK depends on the main subject (current and previous sentence)",
        "context": "\t   0\n\t)\n\n\t; TODO sometimes it is OK depends on the main subject (current and previous sentence)\n\t; (eg.  John helped Sam to prepare his project.)\n\t; (eg.  John helped Sam to feed himself.)\n)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora.scm",
        "line": 23,
        "type": "TODO",
        "content": "; TODO also insert anaphora for missing subjects/objects",
        "context": "; Accepts a <chunks-set>.  Returns new <chunks-set> with anaphora inserted\n; (as new atoms).\n;\n; TODO also insert anaphora for missing subjects/objects\n;\n(define (insert-anaphora inputs-set)\n\t(define results-set (clone-set inputs-set))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
        "line": 53,
        "type": "TODO",
        "content": "; TODO: Describe what these variables are for.",
        "context": "; Some constants\n; =======================================================================\n\n; TODO: Describe what these variables are for.\n(define *microplanning_not_sayable* 0)\n(define *microplanning_sayable* 1)\n(define *microplanning_too_long* 2)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
        "line": 164,
        "type": "TODO",
        "content": "; TODO Keep some of the atoms (those that do not",
        "context": "\t\t\t\t; make-sentence made a new chunk; make more chunks\n\t\t\t\t; with the remaining atoms.\n\t\t\t\t((not (nil? new-atomW-chunk))\n\t\t\t\t\t; TODO Keep some of the atoms (those that do not\n\t\t\t\t\t; satisfy sentence forms) for later use?\n\t\t\t\t\t(recursive-helper\n\t\t\t\t\t\t(lset-difference equal? atomW-unused new-atomW-chunk)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 50,
        "type": "TODO",
        "content": "; TODO: do the same for non-instanced node",
        "context": ")\n; -----------------------------------------------------------------------\n; Connect WordInstanceNode With ConceptNode\n; TODO: do the same for non-instanced node\n(define (r2l-wordinst-concept inst-name)\n\t(ReferenceLink\n\t\t(ConceptNode inst-name)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 59,
        "type": "TODO",
        "content": "; TODO: do the same for non-instanced node",
        "context": ")\n; -----------------------------------------------------------------------\n; Connect WordInstanceNode With PredicateNode\n; TODO: do the same for non-instanced node\n(define (r2l-wordinst-predicate inst-name)\n\t(ReferenceLink\n\t\t(PredicateNode inst-name)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 650,
        "type": "TODO",
        "content": "; TODO Need to add more to the list (e.g. \"the\") to cover all cases",
        "context": "\t\t)\n\n\t\t; XXX Just to avoid getting the `#<Invalid handle>` error\n\t\t; TODO Need to add more to the list (e.g. \"the\") to cover all cases\n\t\t; or update the below to generate something reasonable\n\t\t(else (ListLink))\n\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/tv-utilities.scm",
        "line": 11,
        "type": "TODO",
        "content": "; TODO: move this to (opencog data) module when it is created.",
        "context": "  Populate the atomspace with ConceptNodes drived from Google's Trillion Word\n  Corpus.\n\"\n; TODO: move this to (opencog data) module when it is created.\n    (let ((path \"/var/opencog/data/gtwc-en-333333-words.scm\"))\n        (if (file-exists? path)\n            (primitive-load path)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sureal/surface-realization.scm",
        "line": 163,
        "type": "TODO",
        "content": "; TODO: There could be too many... skip if seen before?",
        "context": "                            (if (equal? (cog-type n) 'PredicateNode)\n                                (map\n                                    (lambda (p)\n                                        ; TODO: There could be too many... skip if seen before?\n                                        (lg-dict-entry (word-inst-get-word p))\n                                    )\n                                    (cog-chase-link 'LemmaLink 'WordInstanceNode (r2l-get-word n))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/action-selector.scm",
        "line": 81,
        "type": "TODO",
        "content": "; TODO Why have a cutoff? That is why return a list of rules",
        "context": "\n  ; Recursively move through the list of rules, until the\n  ; sum of the weights of the rules exceeds the cutoff.\n  ; TODO Why have a cutoff? That is why return a list of rules\n  ; instead of just picking the one with the highest weight.\n  (define (pick-rule wcut rule-list)\n    ; Subtract weight of the first rule.\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 218,
        "type": "TODO",
        "content": "; TODO: Use categories instead of aliases for categorization",
        "context": "  - a list with psi-rules.\n\"\n    (receive (filtered other)\n        ; TODO: Use categories instead of aliases for categorization\n        (psi-partition-rule-with-alias rule-alias psi-rule-list)\n        (map\n            (lambda (psi-rule) (psi-rule-set-atomese-weight psi-rule 0.0))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/control.scm",
        "line": 239,
        "type": "TODO",
        "content": "; TODO: Use categories instead of aliases for categorization",
        "context": "  - a list with psi-rules.\n\"\n    (receive (filtered other)\n      ; TODO: Use categories instead of aliases for categorization\n        (psi-partition-rule-with-alias rule-alias psi-rule-list)\n        (map\n            (lambda (psi-rule) (psi-rule-set-atomese-weight psi-rule 0.9))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/main.scm",
        "line": 35,
        "type": "TODO",
        "content": "; TODO: Adding  a component to a category makes no sense",
        "context": "; but there activities are defined using openpsi-rules and action-selectors\n; associated with it.\n(define psi-component-node (ConceptNode \"component\"))\n; TODO: Adding  a component to a category makes no sense\n(psi-add-category psi-component-node)\n\n; --------------------------------------------------------------\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 128,
        "type": "TODO",
        "content": "; TODO: Add utilities for declaring custom urge formula.",
        "context": "  where GOAL_VALUE is the present value of the goal, and DGV is the\n  desired-goal-value for the GOAL.\n\"\n  ; TODO: Add utilities for declaring custom urge formula.\n  (- (psi-dgv goal) (psi-goal-value goal))\n)\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 142,
        "type": "TODO",
        "content": "; TODO: Add utilities for declaring custom decrease-urge formula.",
        "context": "  goal-value, thus VALUE should be a positive number. This assumes\n  the desired-goal-value to be 1.\n\"\n  ; TODO: Add utilities for declaring custom decrease-urge formula.\n  (let* ((u (psi-urge goal))\n    (gv (- 1 (- u (abs value)))))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 161,
        "type": "TODO",
        "content": "; TODO: Add utilities for declaring custom increase-urge formula.",
        "context": "  Return GOAL after increasing the magnitude of the urge by VALUE. VALUE\n  should be a positive number. This assumes the desired-goal-value to be 1.\n\"\n  ; TODO: Add utilities for declaring custom increase-urge formula.\n  (let* ((u (psi-urge goal))\n    (gv (- 1 (+ u (abs value)))))\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 197,
        "type": "TODO",
        "content": "; TODO Uncomment after testing with ghost",
        "context": "      rule\n      (ConceptNode name)))\n\n  ; TODO Uncomment after testing with ghost\n  ;(cog-set-value!\n  ;  rule\n  ;  psi-rule-name-predicate-node\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 223,
        "type": "TODO",
        "content": "; TODO Uncomment after testing with ghost",
        "context": "          (QuoteLink rule)  ;; ?? why is a Quote needed here?\n          (VariableNode \"rule-alias\"))))))\n\n  ; TODO Uncomment after testing with ghost\n  ;(let ((alias-value (cog-value rule psi-rule-name-predicate-node)))\n  ;  (if (nil? alias-value)\n  ;    '()\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/rule.scm",
        "line": 296,
        "type": "TODO",
        "content": "; TODO: This calculation can be done in OpenPsiImplicator::grounding or",
        "context": "  ; are there?\n  ; XXX FIXME How about actually using a SequentialAndLink?\n  ; then the code will be faster, and there won't be this problem.\n  ; TODO: This calculation can be done in OpenPsiImplicator::grounding or\n  ; when the rule is being added. Since it unlikely to change except\n  ; during learning it can be saved in the AndLink.\n  (context-stv (map-in-order cog-evaluate! (psi-get-context rule)))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/modulator.scm",
        "line": 48,
        "type": "TODO",
        "content": "; todo: cog-chase-link bug? - it is returning the anchor node in the results",
        "context": ")\n\n(define (psi-get-modulators)\n\t; todo: cog-chase-link bug? - it is returning the anchor node in the results\n\t;(cog-chase-link 'InheritanceLink 'ConceptNode psi-modulator-node))\n\t(cog-outgoing-set (cog-execute!\n\t\t(Get (Inheritance (Variable \"$mod\") psi-modulator-node)))))\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/sec.scm",
        "line": 67,
        "type": "TODO",
        "content": "; Todo: add variable names (?) and add getters for agent-state secs",
        "context": "(define (psi-is-sec? atom)\n\t(member atom (psi-get-secs)))\n\n; Todo: add variable names (?) and add getters for agent-state secs\n\n; =============================================================================\n; CREATE SECs\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 38,
        "type": "TODO",
        "content": "; TODO Replace verbose & logger variable in openpsi/dyanmics/updater.scm with",
        "context": "(load \"interaction-rule.scm\")\n(load \"event.scm\")\n\n; TODO Replace verbose & logger variable in openpsi/dyanmics/updater.scm with\n; cog-logger-component for this module.\n(define logging #t)\n(define verbose #f)\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 47,
        "type": "TODO",
        "content": "; Todo: Move these to a config file",
        "context": "\n; --------------------------------------------------------------\n; Config Parameters\n; Todo: Move these to a config file\n\n; Multiplier that can be tweaked to increase or decrease the sensitivity of\n; interactactions between openpsi entities. Default is 1.\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 69,
        "type": "TODO",
        "content": "; Todo: implement these tables in the atomspace",
        "context": "\n; --------------------------------------------------------------\n\n; Todo: implement these tables in the atomspace\n(define prev-value-table (make-hash-table 40))\n(define prev-most-recent-ts-table (make-hash-table 40))\n(define psi-event-detection-callbacks '())\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 112,
        "type": "TODO",
        "content": "; Todo: Add a general callback function that is called once each loop",
        "context": "\t\t(append psi-event-detection-callbacks (list callback)))\n)\n\n; Todo: Add a general callback function that is called once each loop\n\n(define (psi-updater-init)\n\"\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 375,
        "type": "TODO",
        "content": "; todo: Could optimize by only calling rules containing the changed params",
        "context": "\t\t\t\t(close-output-port output-port))))\n\n\t; Grab and evaluate the interaction rules\n\t; todo: Could optimize by only calling rules containing the changed params\n\t(let ((rules (psi-get-interaction-rules)))\n\t\t(map psi-evaluate-interaction-rule rules)\n\t)\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 532,
        "type": "TODO",
        "content": "; TODO: handle current value = #f (or not number in general)",
        "context": "\t\t; Increasing slope increases the degree change at all levels\n\t\t(set! slope 10000)\n\t\t;(format #t \"current value: ~a\\n\" current-value)\n\t\t; TODO: handle current value = #f (or not number in general)\n\t\t; finagle the extreme cases because the curve is not exactly how we want\n\t\t(if (> alpha 0)\n\t\t\t(if (>= alpha .5)\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
        "line": 748,
        "type": "TODO",
        "content": "; Todo: Perhaps will want to integrate this into the main OpenPsi loop, but OTOH",
        "context": "; --------------------------------------------------------------\n; Updater Loop Control\n; --------------------------------------------------------------\n; Todo: Perhaps will want to integrate this into the main OpenPsi loop, but OTOH\n; we may want them running at different frequencies.\n\n(define psi-updater-is-running #f)\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/utilities.scm",
        "line": 39,
        "type": "TODO",
        "content": "; Todo: Could potential optimize? here by using",
        "context": "\"\n\t;(define result #f)\n\n\t; Todo: Could potential optimize? here by using\n\t; psi-value-representation-type fucntion\n\n\t; First check for StateLink value\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/dynamics/utilities.scm",
        "line": 114,
        "type": "TODO",
        "content": "; Todo: this will probably need to be changed to handle",
        "context": "\t\t\t        ; If PredicateNode, then set node TV\n\t\t\t        (cog-set-tv! entity (stv value 1))\n\t\t\t        ; else wrap it in an EvaluationLink\n\t\t\t        ; Todo: this will probably need to be changed to handle\n\t\t\t        ; arguments.\n\t\t\t\t    (Evaluation entity (List) (stv value 1))))\n\t\t\t((equal? value-rep-type executable)\n"
      },
      {
        "file": "components/language/learn/attic/run-poc/fetch-word-pairs.scm",
        "line": 25,
        "type": "TODO",
        "content": "(set! star-obj (add-pair-stars pair-obj)) ;TODO: Can it be left out??",
        "context": "         (equal? cnt-mode \"clique-dist\"))\n      (set! pair-obj (make-clique-pair-api))))\n\n  (set! star-obj (add-pair-stars pair-obj)) ;TODO: Can it be left out??\n  (pair-obj 'fetch-pairs)\n\n  ; Print the sql stats\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/ortho-compute.scm",
        "line": 21,
        "type": "TODO",
        "content": "; TODO filter the top lists",
        "context": "(smi 'fetch-pairs) ;;; same as (load-atoms-of-type 'Similarity)\n\n; -------------------------------------\n; TODO filter the top lists\n; (define (filter the top list...\n\n; Wrap similarity, to create a new base object.\n"
      },
      {
        "file": "components/language/learn/learn-lang-diary/utils/orthogonal-ensemble.scm",
        "line": 52,
        "type": "TODO",
        "content": "; TODO filter the top lists",
        "context": "\t(close csv))\n\n; -------------------------------------\n; TODO filter the top lists\n; (define (filter the top list...\n\n; Wrap similarity, to create a new base object.\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/cset-class.scm",
        "line": 148,
        "type": "TODO",
        "content": "; TODO: Evaluate if this function provides meaningful functionality.",
        "context": "; a disjunct with a connector that belongs to an existing WordClass.\n; The goal is to trim the list of sections to something smaller.\n;\n; TODO: Evaluate if this function provides meaningful functionality.\n; Consider refactoring or removing if performance impact is minimal.\n(define (get-all-sections-in-classes WCL)\n\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
        "line": 188,
        "type": "TODO",
        "content": "; TODO",
        "context": "; of the two is already a word-class, then the counts are simply moved\n; from the word to the class.\n;\n; TODO\n; ----\n; It might be useful to move the management of the MemberLink's to\n; the `add-gram-class-api` object.\n"
      },
      {
        "file": "components/language/learn/scm/attic/cluster/shape-project.scm",
        "line": 266,
        "type": "TODO",
        "content": "; todo",
        "context": "\t; updated CrossSection.\n\t(define (revise-xsect XST)\n; xxxxx\n; todo\n\t\t#f\n\t)\n\n"
      },
      {
        "file": "components/language/learn/scm/attic/lg-export/export-disjuncts.scm",
        "line": 20,
        "type": "TODO",
        "content": ";; TODO WordClassNode support might be .. funky.",
        "context": "; Needs the guile-dbi interfaces, in order to write the SQL files.\n;;\n;; XXX hack alert:\n;; TODO WordClassNode support might be .. funky.\n;; In particular, if a WordNode appears in a connector, it is replaced\n;; by all WordClasses that it might be a part of. This is an\n;; over-generalization, but needed for just right now.\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/agglo-mi-rank.scm",
        "line": 45,
        "type": "TODO",
        "content": "; TODO:",
        "context": "; Main entry point:\n; * Call `in-group-mi-cluster`, below.\n;\n; TODO:\n; * Before each merge step, a new AtomSpace frame should be created, so\n;   that the pre-merge data remains available.  This is not being done.\n;   It's really easy to add, but ... nothing needs this yet.\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
        "line": 22,
        "type": "TODO",
        "content": "; TODO filter the top lists",
        "context": "  LLOBJ\n\n\"\n\t; TODO filter the top lists\n\t; (define (filter the top list...\n\n\t; TODO check if LLOBJ is a similrity object\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/goe-similarity.scm",
        "line": 25,
        "type": "TODO",
        "content": "; TODO check if LLOBJ is a similrity object",
        "context": "\t; TODO filter the top lists\n\t; (define (filter the top list...\n\n\t; TODO check if LLOBJ is a similrity object\n\n\t; Wrap similarity, to create a new base object.\n\t(define sob (add-pair-stars LLOBJ))\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/shape-vec.scm",
        "line": 109,
        "type": "TODO",
        "content": "; TODO: with appropriate cleanup, this probably should be moved",
        "context": ";       (WordNode \"level\")\n;       (Shape ... the above shape))\n;\n; TODO: with appropriate cleanup, this probably should be moved\n; to a generic \"section\" or \"sheaf\" module.  That is because it\n; generically explodes a section into all of it's constituent\n; connector-shape pairs, which is presumably something everyone\n"
      },
      {
        "file": "components/language/learn/scm/pair-count/word-pair-pipe.scm",
        "line": 24,
        "type": "TODO",
        "content": "; TODO:",
        "context": "; and\n;    run-common/cogserver-pair.scm:(define (observe-block-pairs TXT)\n;\n; TODO:\n; * Need ((add-count-api LLOBJ) 'count-key) to replace hard-coded count\n;   But this is not urgent, because the count-api itself is hard coded.\n\n"
      },
      {
        "file": "components/language/learn/scm/pipe-parse/pipe-count.scm",
        "line": 39,
        "type": "TODO",
        "content": "; TODO:",
        "context": ";   of the individual Edges in that Section. (The edges are effectively\n;   word-pairs, although this depends on the dictionary.)\n;\n; TODO:\n; * Need ((add-count-api LLOBJ) 'count-key) to replace hard-coded count\n;   But this is not urgent, because the count-api itself is hard coded.\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/scm/attic/nlp-utils.scm",
        "line": 134,
        "type": "TODO",
        "content": "; TODO: Consider refactoring this pattern to use GetLink syntax.",
        "context": "  one of DeclarativeSpeechAct, InterrogativeSpeechAct,\n  TruthQuerySpeechAct, etc...\n\"\n\t; TODO: Consider refactoring this pattern to use GetLink syntax.\n\t; A more concise GetLink syntax would improve readability and\n\t; allow writing link chases as sequences rather than nested calls.\n\n"
      },
      {
        "file": "ure/opencog/scm/opencog/ure/ure-utils.scm",
        "line": 1261,
        "type": "TODO",
        "content": "; TODO: Move logic to ForwardChainer.",
        "context": "\"\n; NOTE: It is simple b/c it doesn't try to restrict inference over a\n; certain source atoms.\n; TODO: Move logic to ForwardChainer.\n    (let* ((result (cog-fc RB-NODE (Set) #:focus-set (Set FOCUS-SET)))\n           (result-list (cog-outgoing-set result)))\n        ; Cleanup\n"
      },
      {
        "file": "ure/tests/ure/backwardchainer/scm/green-balls-targets.scm",
        "line": 105,
        "type": "TODO",
        "content": ";; TODO: the type of G should be further specified, such the number of",
        "context": "      ;; Evidence\n      (Set G))))\n\n;; TODO: the type of G should be further specified, such the number of\n;; elements, or possible range, as well as possible the type of each\n;; element, e.g. List, once the backward chainer supports deep types.\n"
      },
      {
        "file": "ure/tests/ure/rules/conditional-direct-evaluation.scm",
        "line": 11,
        "type": "TODO",
        "content": ";; TODO: we should make the evidence as premises. One way to do that",
        "context": ";; like an ImplicationLink, ImplicationScopeLink, InheritanceLink,\n;; etc.\n;;\n;; TODO: we should make the evidence as premises. One way to do that\n;; would be to calculate incrementally, keeping track of all evidence\n;; that have been used to calculate its TV and choose one that hasn't\n;; so been used so far. This would allow to evaluate evidence if\n"
      },
      {
        "file": "ure/tests/ure/rules/conditional-direct-evaluation.scm",
        "line": 22,
        "type": "TODO",
        "content": ";; TODO: turn that into a generator",
        "context": "(use-modules (opencog exec))\n(use-modules (opencog logger))\n\n;; TODO: turn that into a generator\n;; Implemented as a generator pattern for evidence calculation\n\n(define (evidence-generator antecedent-terms consequent-terms)\n"
      },
      {
        "file": "ure/tests/ure/rules/evidence-based-conditional-direct-evaluation.scm",
        "line": 31,
        "type": "TODO",
        "content": ";; TODO: resume once GlobNode is supported",
        "context": ";; evidence of the implication scope in the premise, and E is the new\n;; term of evidence.\n\n;; TODO: resume once GlobNode is supported\n\n(define evidence-based-conditional-direct-evaluation-implication-scope-rule\n  ;; (let* ((X (Variable \"$X\"))\n"
      },
      {
        "file": "ure/tests/ure/rules/implication-and-lambda-factorization-rule.scm",
        "line": 4,
        "type": "TODO",
        "content": ";; TODO: Replace this by higher order fact",
        "context": ";; =======================================================================\n;; ImplicationLink AndLink Lambda Factorization Rule\n;;\n;; TODO: Replace this by higher order fact\n;;\n;; AndLink\n;;    LambdaLink\n"
      },
      {
        "file": "ure/tests/ure/rules/implication-instantiation-rule.scm",
        "line": 141,
        "type": "TODO",
        "content": ";; TODO: To make this function better a form of partial pattern",
        "context": ";; 3. calculates its TV (just the TV on the implication link for now,\n;; in principle there might better ways)\n;;\n;; TODO: To make this function better a form of partial pattern\n;; matching should be supported. Probably enabling self grounding in\n;; the pattern matcher would do the trick (see\n;; PatternMatchEngine::self_compare)\n"
      },
      {
        "file": "ure/tests/ure/rules/implication-scope-to-implication-rule.scm",
        "line": 27,
        "type": "TODO",
        "content": ";; TODO: support VariableSet",
        "context": "        (VariableNode \"$TyVs\")\n        (TypeChoice\n           (TypeNode \"TypedVariableLink\")\n           ;; TODO: support VariableSet\n           (TypeNode \"VariableList\")))\n     (VariableNode \"$P\")\n     (VariableNode \"$Q\")))\n"
      },
      {
        "file": "ure/tests/ure/rules/intensional-inheritance-direct-introduction.scm",
        "line": 50,
        "type": "TODO",
        "content": ";; TODO: in order to add the Attraction links in the premises maybe an",
        "context": ";; relevant attraction links to be present in the atomspace in order\n;; to correctly calculate the TV.\n\n;; TODO: in order to add the Attraction links in the premises maybe an\n;; idea would be to introduce a has-closure predicate, such as\n;;\n;; Evaluation (stv 1 1)\n"
      },
      {
        "file": "ure/tests/ure/rules/pln-implication-and-lambda-factorization-rule.scm",
        "line": 4,
        "type": "TODO",
        "content": ";; TODO: Replace this by higher order fact",
        "context": ";; =======================================================================\n;; ImplicationLink AndLink Lambda Factorization Rule\n;;\n;; TODO: Replace this by higher order fact\n;;\n;; AndLink\n;;    LambdaLink\n"
      },
      {
        "file": "atomspace-restful/lib/zmq/zhelpers.hpp",
        "line": 31,
        "type": "TODO",
        "content": "// todo: package updated zmq.hpp",
        "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n"
      },
      {
        "file": "components/core/atomspace-restful/lib/zmq/zhelpers.hpp",
        "line": 31,
        "type": "TODO",
        "content": "// todo: package updated zmq.hpp",
        "context": "\n#include <zmq.hpp>\n//#include <lib/zmq/zmq.hpp>\n// todo: package updated zmq.hpp\n\n#include <iostream>\n#include <iomanip>\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/csv/table_read.h",
        "line": 38,
        "type": "TODO",
        "content": "// TODO: Should this be a StringValue?",
        "context": "\nnamespace opencog {\n\n// TODO: Should this be a StringValue?\ntypedef std::vector<std::string> string_seq;\n\n/**\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.h",
        "line": 224,
        "type": "TODO",
        "content": "// TODO: we probably want to",
        "context": "\t */\n\tHandle consume_quotations() const;\n\tstatic Handle consume_quotations(const Variables& variables, const Handle& h,\n\t                                 // TODO: we probably want to\n\t                                 // move quotation,\n\t                                 // needless_quotation,\n\t                                 // clause_root and more in\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
        "line": 80,
        "type": "TODO",
        "content": "// TODO: it would probably be more efficient to swap which of these",
        "context": "\tHandle _handle;\n\tHandle _quote;\n\n\t// TODO: it would probably be more efficient to swap which of these\n\t// two is weak, since I think _outgoing is requested far more often\n\t// than _parent, and having it run faster would be a performance win.\n\tPatternTermPtr _parent;\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.h",
        "line": 44,
        "type": "TODO",
        "content": "// TODO Why would one need to reset during psi-loop?",
        "context": "  friend class OpenPsiSatisfier;\n\n  // Needed for resetting private cache.\n  // TODO Why would one need to reset during psi-loop?\n  friend class ::OpenPsiImplicatorUTest;\n\npublic:\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 105,
        "type": "TODO",
        "content": "// TODO:add predicate to check for membership of category.",
        "context": "   * @param new_category The node reprsenting the new category.\n   * @return ConceptNode that represents the category.\n   */\n   // TODO:add predicate to check for membership of category.\n  Handle add_category(const Handle& new_category);\n\n  /**\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 126,
        "type": "TODO",
        "content": "// TODO Should these entries be a member of Rules class?",
        "context": "   * where queryis a PatternLink that isn't added to the atomspace, and\n   * is used to check if the rule is satisfiable.\n   */\n  // TODO Should these entries be a member of Rules class?\n  typedef std::tuple<HandleSeq, Handle, Handle, PatternLinkPtr> PsiTuple;\n\n  /**\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 136,
        "type": "TODO",
        "content": "// TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,",
        "context": "   */\n  std::map<Handle, PsiTuple> _psi_rules;\n\n  // TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,\n  // because it might hinder interoperability with other components that\n  // expect an explicit ontological representation. For historic reasons we\n  // continue using such convention but should be replaced with graph that\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "TODO",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "TODO",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.h",
        "line": 137,
        "type": "TODO",
        "content": "// TODO: reimplement loadITable with the same model of loadTable and",
        "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "TODO",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/local_structure.h",
        "line": 285,
        "type": "TODO",
        "content": "// TODO: Clarify what statistics are being accumulated and where they are stored.",
        "context": "// each variable in the field set (and more, for contins & terms).  So,\n// iterate over the dtrees, and accumulate statistics.\n//\n// TODO: Clarify what statistics are being accumulated and where they are stored.\n// This function processes decision trees and updates the destination model.\ntemplate<typename It>\nvoid local_structure_probs_learning::operator()(const field_set& fs,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "TODO",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "TODO",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "TODO",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 154,
        "type": "TODO",
        "content": "// TODO: pso description",
        "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 315,
        "type": "TODO",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 283,
        "type": "TODO",
        "content": "// TODO: Clarify the canonization behavior for parent-child relationships.",
        "context": "#define MAX_PERM_ACTIONS 128\n\n// Note - children aren't canonized when parents are called.\n// TODO: Clarify the canonization behavior for parent-child relationships.\nstruct action_subtree_knob : public discrete_knob<MAX_PERM_ACTIONS>\n{\n    typedef combo_tree::pre_order_iterator pre_it;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "TODO",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "TODO",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.h",
        "line": 137,
        "type": "TODO",
        "content": "// TODO: reimplement loadITable with the same model of loadTable and",
        "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "TODO",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
      },
      {
        "file": "moses/moses/moses/eda/local_structure.h",
        "line": 285,
        "type": "TODO",
        "content": "// TODO: Clarify what statistics are being accumulated and where they are stored.",
        "context": "// each variable in the field set (and more, for contins & terms).  So,\n// iterate over the dtrees, and accumulate statistics.\n//\n// TODO: Clarify what statistics are being accumulated and where they are stored.\n// This function processes decision trees and updates the destination model.\ntemplate<typename It>\nvoid local_structure_probs_learning::operator()(const field_set& fs,\n"
      },
      {
        "file": "moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "TODO",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "TODO",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "TODO",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 154,
        "type": "TODO",
        "content": "// TODO: pso description",
        "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 315,
        "type": "TODO",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 276,
        "type": "TODO",
        "content": "// TODO: Clarify the canonization behavior for parent-child relationships.",
        "context": "#define MAX_PERM_ACTIONS 128\n\n// Note - children aren't canonized when parents are called.\n// TODO: Clarify the canonization behavior for parent-child relationships.\nstruct action_subtree_knob : public discrete_knob<MAX_PERM_ACTIONS>\n{\n    typedef combo_tree::pre_order_iterator pre_it;\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 48,
        "type": "TODO",
        "content": "// TODO: the notion of equality between 2 CHandles might one where",
        "context": "public:\n\t// Contextual Handle\n\t//\n\t// TODO: the notion of equality between 2 CHandles might one where\n\t// the Context isn't necessarily equal but where the 2 handles\n\t// (besides being equal) have the same quotation and same\n\t// (free inter shadow) variables.\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 159,
        "type": "TODO",
        "content": "// TODO: the type of a typed block is currently a handle of the",
        "context": "\t// the simplest satisfiable solution set.\n\tstatic const Partitions empty_partition_singleton;\n\n\t// TODO: the type of a typed block is currently a handle of the\n\t// variable or ground it is exists, instead of an actual type.\n\tstruct SolutionSet : Partitions\n\t{\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 188,
        "type": "TODO",
        "content": "// TODO: maybe we could simplify a great deal of code by replacing",
        "context": "\t// Subtitution values and their corresponding variable declaration\n\t// after substitution (cause some values may be variables).\n\t//\n\t// TODO: maybe we could simplify a great deal of code by replacing\n\t// Handle by Variables.\n\ttypedef std::map<HandleCHandleMap, Handle> TypedSubstitutions;\n\ttypedef std::pair<HandleCHandleMap, Handle> TypedSubstitution;\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 521,
        "type": "TODO",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t// Memoization cache for unification results\n\tmutable std::map<std::pair<CHandle, CHandle>, SolutionSet> _unify_cache;\n\npublic:                         // TODO: being friend with UnifyUTest\n\t/**\n\t * Set Unify::_variables given the variable declarations of the\n\t * two terms to unify.\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 601,
        "type": "TODO",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t */\n\tSolutionSet mkvarsol(CHandle lhs, CHandle rhs) const;\n\npublic:                         // TODO: being friend with UnifyUTest\n                                // somehow doesn't work\n\t/**\n\t * Join 2 solution sets. Generate the product of all consistent\n"
      },
      {
        "file": "ure/opencog/ure/Rule.h",
        "line": 373,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\t// True if the rule has already been applied.\n\tbool _exhausted;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n\n\t// Return a copy of the rule with the variables alpha-converted\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.h",
        "line": 72,
        "type": "TODO",
        "content": "// TODO: Maybe this should be moved to BackwardChainer",
        "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.h",
        "line": 232,
        "type": "TODO",
        "content": "// TODO: perhaps move that under BIT",
        "context": "\t// Structure holding the Back Inference Tree\n\tBIT _bit;\n\n\t// TODO: perhaps move that under BIT\n\tAndBITFitness _andbit_fitness;\n\n\t// In charge of recording the inference traces\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/ControlPolicy.h",
        "line": 45,
        "type": "TODO",
        "content": "// TODO: maybe wrap that in a class, and use it in foward chainer",
        "context": "// selected rule fulfills the objective, which must be passed\n// to the BIT to calculate the and-BIT complexity.\n//\n// TODO: maybe wrap that in a class, and use it in foward chainer\ntypedef std::pair<RuleTypedSubstitutionPair, double> RuleSelection;\n\nclass ControlPolicy\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 75,
        "type": "TODO",
        "content": "// TODO: we may want to move the arguments in its own class if it",
        "context": "\t\tTrace\n\t};\n\n\t// TODO: we may want to move the arguments in its own class if it\n\t// grows bigger.\n\tAndBITFitness(FitnessType ft=Uniform,\n\t              const std::set<ContentHash>& tr=std::set<ContentHash>());\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 92,
        "type": "TODO",
        "content": "// TODO: replace by class dedicated to hold the parameters",
        "context": "\tdouble operator()(const AndBIT& andbit) const;\n\nprivate:\n\t// TODO: replace by class dedicated to hold the parameters\n\tstd::set<ContentHash> _trace;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
        "line": 94,
        "type": "TODO",
        "content": "// TODO: the TV on the evaluation link should be more carefully",
        "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/FCStat.h",
        "line": 76,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tstd::vector<InferenceRecord> _inf_rec;\n\tAtomSpace* _trace_as;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 237,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\n\tbool _search_focus_set;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 241,
        "type": "TODO",
        "content": "// TODO: use shared mutexes",
        "context": "\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n\t// TODO: use shared mutexes\n\tmutable std::mutex _rules_mutex;\n\n\t// Keep track of the number of threads to make sure\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceRuleSet.h",
        "line": 102,
        "type": "TODO",
        "content": "// TODO: implement tournament selection as well, as a cheaper",
        "context": "\t */\n\tstd::pair<SourceRule, TruthValuePtr> thompson_select();\n\n\t// TODO: implement tournament selection as well, as a cheaper\n\t// alternative to Thompson sampling.\n\n\t/**\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 54,
        "type": "TODO",
        "content": "// TODO: this class has thing in common with AndBIT, maybe their",
        "context": " *\n * 4. a flag call indicating if the source expansions have been exhausted.\n */\n// TODO: this class has thing in common with AndBIT, maybe their\n// common things could be placed in a parent class.\nclass Source : public boost::totally_ordered<Source>\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 151,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tRuleSet rules;\n\nprivate:\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 165,
        "type": "TODO",
        "content": "// TODO: this class has things in common with BIT, maybe their common",
        "context": "/**\n * Population of sources to forwardly expand. Primary owner.\n */\n// TODO: this class has things in common with BIT, maybe their common\n// things could be placed in a parent class.\nclass SourceSet\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 223,
        "type": "TODO",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "private:\n\tconst UREConfig& _config;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 296,
        "type": "TODO",
        "content": "// TODO: the following has no unit test!!! Yet it introduces a",
        "context": "\t// Base case\n\tif (h->is_node())\n\t{\n\t\t// TODO: the following has no unit test!!! Yet it introduces a\n\t\t// bug covered by RewriteLinkUTest::test_consume_quotations_4(),\n\t\t// thus this code is disabled till a unit test it created for it\n\t\t// and we understand what it fixes and how it fixes.\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 340,
        "type": "TODO",
        "content": "// TODO: generalize with when Unquote and Quote are apart",
        "context": "\t\t\t// A succession of (Unquote (Quote ..)) is an involution\n\t\t\t// and thus can be remove.\n\t\t\t//\n\t\t\t// TODO: generalize with when Unquote and Quote are apart\n\t\t\tif (child->get_type() == QUOTE_LINK)\n\t\t\t{\n\t\t\t\tquotation.update(child->get_type());\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 288,
        "type": "TODO",
        "content": "// TODO: what about globs?",
        "context": "\t\t\treturn expr;\n\n\t\t// If it is a quoted or shadowed variable don't substitute.\n\t\t// TODO: what about globs?\n\t\tif (VARIABLE_NODE == t and not context_cp.is_free_variable(expr))\n\t\t\treturn expr;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 69,
        "type": "TODO",
        "content": "// TODO: Handle executable _outgoing[0] by executing it first.",
        "context": "\n\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 70,
        "type": "TODO",
        "content": "// TODO: Support complex type signatures beyond simple TYPE_NODE.",
        "context": "\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n\t\tthrow InvalidParamException(TRACE_INFO,\n"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 549,
        "type": "TODO",
        "content": "/// TODO: it might be faster to use hash tables instead of rb-trees",
        "context": "/// think of any way of combining steps (2) and (3) that would avoid\n/// step (4) ... or even would reduce the work for stpe (4). Oh well.\n///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 138,
        "type": "TODO",
        "content": "// TODO: this should probably be moved to a method on class Atom.",
        "context": "        }\n\n        // Check the values...\n        // TODO: this should probably be moved to a method on class Atom.\n        if (check_values)\n        {\n            HandleSet keys_first = atom_first->getKeys();\n"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 382,
        "type": "TODO",
        "content": "// TODO -- weed out duplicates!",
        "context": "\t}\n\telse\n\t{\n\t\t// TODO -- weed out duplicates!\n\t}\n\treturn true;\n}\n"
      },
      {
        "file": "atomspace/opencog/query/Recognizer.cc",
        "line": 126,
        "type": "TODO",
        "content": "// TODO: Change to something better if possible...",
        "context": "\t// mis-matched types are a dead-end.\n\tif (lpat->get_type() != lsoln->get_type()) return false;\n\n\t// TODO: Change to something better if possible...\n\t// What is happening here is to manually call the\n\t// fuzzy_match callback immediately if and only if\n\t// lsoln has one or more GlobNodes AND lpat and lsoln\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/Fuzzy.cc",
        "line": 81,
        "type": "TODO",
        "content": "// TODO: Extend to find similar links as well",
        "context": "    {\n        if (h->is_node())\n        {\n            // TODO: Extend to find similar links as well\n            if (lp->get_type() == SIMILARITY_LINK)\n                sl.emplace_back(lp->get_handle());\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatchBasic.cc",
        "line": 106,
        "type": "TODO",
        "content": "// TODO: May use Truth Value instead",
        "context": "\tdouble similarity = common_nodes.size();\n\n\t// Roughly estimate how \"rare\" each node is by using 1 / incoming set size\n\t// TODO: May use Truth Value instead\n\t// for (const Handle& common_node : common_nodes)\n\t// \tsimilarity += 1.0 / common_node->getIncomingSetSize();\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 41,
        "type": "TODO",
        "content": "// TODO:",
        "context": "TruthValuePtr OpenPsiImplicator::check_satisfiability(const Handle& rule,\n    OpenPsiRules& opr)\n{\n  // TODO:\n  // Solve for multithreaded access. Create a rule class and lock\n  // the rule when updating the cache.\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 49,
        "type": "TODO",
        "content": "// TODO: Add cache per atomspace.",
        "context": "  Handle query_body = query->get_pattern().body;\n\n  // Always update cache to clear any previous result.\n  // TODO: Add cache per atomspace.\n  _satisfiability_cache.erase(query_body);\n  _pattern_seen.insert(query_body);\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 68,
        "type": "TODO",
        "content": "// TODO: Test thoroughly, or develop an alternative. See discussion",
        "context": "      _psi_rules[rule] = std::make_tuple(context, action, goal, query);\n  } else {\n    // This is for backward compatability.\n    // TODO: Test thoroughly, or develop an alternative. See discussion\n    // @ https://github.com/opencog/opencog/pull/2899 for what the\n    // alternative might be.\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 101,
        "type": "TODO",
        "content": "// TODO But why make the add_category public then?",
        "context": "{\n  _as->add_link(MEMBER_LINK, rule, category);\n  // Add the category just in case it hasn't been declared.\n  // TODO But why make the add_category public then?\n  add_category(category);\n  _category_index[category].insert(rule);\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 115,
        "type": "TODO",
        "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
        "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 124,
        "type": "TODO",
        "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
        "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 91,
        "type": "TODO",
        "content": "// TODO: Should this be a singleton? What could be the issues that need",
        "context": "  const Handle& goal, const TruthValuePtr stv, const Handle& category)\n{\n  AtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"psi-rule\");\n  // TODO: Should this be a singleton? What could be the issues that need\n  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 95,
        "type": "TODO",
        "content": "// TODO: Add to multiple categories using scheme rest list.",
        "context": "  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n  // TODO: Add to multiple categories using scheme rest list.\n  openpsi_cache(asp.get()).add_to_category(rule, category);\n  return rule;\n}\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 42,
        "type": "TODO",
        "content": "// TODO: Saperated component patterns aren't handled by this function",
        "context": "bool OpenPsiSatisfier::grounding(const HandleMap &var_soln,\n                                  const HandleMap &term_soln)\n{\n  // TODO: Saperated component patterns aren't handled by this function\n  // as PMCGroundings is used instead. Update to handle such cases.\n\n  // The psi-rule weight calculations could be done here.\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 56,
        "type": "TODO",
        "content": "// TODO: If we are here it means the suggested groundings doesn't have",
        "context": "      }\n    }\n\n    // TODO: If we are here it means the suggested groundings doesn't have\n    // VariableNodes, and can be cached. This doesn't account for terms\n    // that are under QuoteLink, or other similar type links. How should\n    // such cases be handled?\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 76,
        "type": "TODO",
        "content": "// TODO: This happens when InitiateSearchCB::no_search has groundings.",
        "context": "    _implicator -> _satisfiability_cache[_pattern_body] = var_soln;\n    return true;\n  } else {\n    // TODO: This happens when InitiateSearchCB::no_search has groundings.\n    // Cases for when this happens hasn't been tested yet. Explore the\n    // behavior and find a better solution. For now, log it and continue\n    // searching.\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1028,
        "type": "TODO",
        "content": "// TODO: it would be nice to pass exceptions on through, but",
        "context": "\t}\n\texpr = scm_cons(sfunc, expr);\n\n\t// TODO: it would be nice to pass exceptions on through, but\n\t// this currently breaks unit tests.\n\t// if (_in_eval)\n\t//    return scm_eval(expr, scm_interaction_environment());\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/continmax.cc",
        "line": 67,
        "type": "TODO",
        "content": "// TODO: Expand documentation to match style of onemax/nmax examples.",
        "context": "// -- the number that is -log_2(epsilon) where epsilon is the smallest\n//    distinction between continuous variables what will be drawn.\n//\n// TODO: Expand documentation to match style of onemax/nmax examples.\n// Add parameter descriptions, usage examples, and expected output.\n\nint main(int argc, char** argv)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "TODO",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "TODO",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "TODO",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "TODO",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 955,
        "type": "TODO",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1078,
        "type": "TODO",
        "content": "// TODO: this could definitely be optimized",
        "context": "\n    if (is_sparse) {\n        // fallback on the old loader\n        // TODO: this could definitely be optimized\n        OC_ASSERT(timestamp_feature.empty(), \"Timestamp feature not implemented\");\n        return istreamTable_OLD(in, tab, target_feature, ignore_features);\n    } else {\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1256,
        "type": "TODO",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "TODO",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "TODO",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "TODO",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "TODO",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 304,
        "type": "TODO",
        "content": "if (!dex.create_demes(exemplar, 0 /* TODO replace with the",
        "context": "        mompi.recv_exemplar(exemplar);\n        logger().info() << \"Allowed \" << max_evals \n                        << \" evals for recvd exemplar \" << exemplar;\n        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // XXX replace this with appropriate message back to root!\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 482,
        "type": "TODO",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "TODO",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 197,
        "type": "TODO",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 236,
        "type": "TODO",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "TODO",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "TODO",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "TODO",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "TODO",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "TODO",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "TODO",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 99,
        "type": "TODO",
        "content": "// TODO: This routine should be extended so that comments that start",
        "context": "/// This ignores lines that start with a 'standard comment char'\n///\n//\n// TODO: This routine should be extended so that comments that start\n// somewhere other than column 0 are also ignored.\n//\n// The signature of this routine is the same as std:getline()\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 930,
        "type": "TODO",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 1241,
        "type": "TODO",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "TODO",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "TODO",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "TODO",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
      },
      {
        "file": "moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "TODO",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 305,
        "type": "TODO",
        "content": "if (!dex.create_demes(exemplar, 0 /* TODO replace with the",
        "context": "        mompi.recv_exemplar(exemplar);\n        logger().info() << \"Allowed \" << max_evals \n                        << \" evals for recvd exemplar \" << exemplar;\n        if (!dex.create_demes(exemplar, 0 /* TODO replace with the\n                                                 right expansion\n                                                 count */)) {\n            // Notify root of failure and continue processing\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 486,
        "type": "TODO",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
      },
      {
        "file": "moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "TODO",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 197,
        "type": "TODO",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 236,
        "type": "TODO",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "TODO",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
      },
      {
        "file": "moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "TODO",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
      },
      {
        "file": "ure/opencog/ure/BetaDistribution.cc",
        "line": 33,
        "type": "TODO",
        "content": "// TODO should be replaced by tv->get_mode() once implemented",
        "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 58,
        "type": "TODO",
        "content": "// TODO: could certainly be optimized by not systematically",
        "context": "\nvoid RuleSet::expand_meta_rules(AtomSpace& as)\n{\n\t// TODO: could certainly be optimized by not systematically\n\t// recollecting and re-instantiating meta-rules.\n\tRuleSet meta_rules;\n\tfor (RulePtr rule : *this) {\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 121,
        "type": "TODO",
        "content": "set_leaf2bitnode();         // TODO: might differ till needed to optimize",
        "context": "AndBIT::AndBIT(const Handle& f, double cpx, const AtomSpace* qas)\n\t: fcs(f), complexity(cpx), exhausted(false), queried_as(qas)\n{\n\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 374,
        "type": "TODO",
        "content": "// TODO: is this merging necessary?",
        "context": "\tHandle nrewrite = expand_fcs_rewrite(nfcs_rewrite, rule.first);\n\n\t// Generate new vardecl\n\t// TODO: is this merging necessary?\n\tHandle merged_vardecl = merge_vardecl(nfcs_vardecl, rule_vardecl);\n\tHandle nvardecl = filter_vardecl(merged_vardecl, {npattern, nrewrite});\n\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
        "line": 288,
        "type": "TODO",
        "content": "// TODO: Maybe we could take advantage of the new read-only",
        "context": "\t// of concerns instead of the atoms themselves, and only modify\n\t// the atoms if there are existing results to copy back to _as.\n\t//\n\t// TODO: Maybe we could take advantage of the new read-only\n\t// capabilities of the AtomSpace.\n\tHandle hresult = HandleCast(fcs->execute(tmp_as.get()));\n\tHandleSeq results;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 101,
        "type": "TODO",
        "content": "// TODO: For now the FC follows the old standard. We may move to",
        "context": "\n\t// Set rules.\n\t_rules = _config.get_rules();\n\t// TODO: For now the FC follows the old standard. We may move to\n\t// the new standard when all rules have been ported to the new one.\n\tfor (RulePtr rule : _rules)\n\t\trule->premises_as_clauses = true;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 165,
        "type": "TODO",
        "content": "// TODO: if creating/destroying threads is too expensive, use a thread",
        "context": "\twhile (not termination()) do_step(_iteration++);\n}\n\n// TODO: if creating/destroying threads is too expensive, use a thread\n// pool (see boost::asio::thread_pool).\nvoid ForwardChainer::do_steps_multithread()\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 289,
        "type": "TODO",
        "content": "// TODO: This can be simplified but is let here until do_step is",
        "context": "\t\t// before being passed to the new source constructor, as this\n\t\t// one will take it into account.\n\t\t//\n\t\t// TODO: This can be simplified but is let here until do_step is\n\t\t// replaced by do_step_srpi.\n\t\tdouble weight = std::min(1.0, slc_sr.source->weight);\n\t\tdouble prob = success_plty / weight;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 372,
        "type": "TODO",
        "content": "// TODO: refine mutex",
        "context": "\nSourcePtr ForwardChainer::select_source(const std::string& msgprfx)\n{\n\t// TODO: refine mutex\n\tstd::unique_lock<std::mutex> lock(_part_mutex);\n\n\tstd::vector<double> weights = _sources.get_weights();\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 409,
        "type": "TODO",
        "content": "// TODO: This has the effect of deallocating the rules, which",
        "context": "\t\tif (_config.get_retry_exhausted_sources()) {\n\t\t\ture_logger().debug() << msgprfx\n\t\t\t                     << \"Reset all exhausted flags to retry them\";\n\t\t\t// TODO: This has the effect of deallocating the rules, which\n\t\t\t// might cause a memory corruption if another thread is\n\t\t\t// attempting to apply that rule at the same time.\n\t\t\t_sources.reset_exhausted();\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 523,
        "type": "TODO",
        "content": "std::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine",
        "context": "\nRuleSet ForwardChainer::get_valid_rules(const Source& source)\n{\n\tstd::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine\n\n\t// Generate all valid rules\n\tRuleSet valid_rules;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.cc",
        "line": 48,
        "type": "TODO",
        "content": "// TODO:",
        "context": "\t// The minimum value is 1e-16 to not ignore completely the source\n\t// when the it is a default TV.\n\t//\n\t// TODO:\n\t// 1. Support more fitness functions\n\t// 2. Explicitely turn the fitness into a probability of success\n\tTruthValuePtr tv = bdy->getTruthValue();\n"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 83,
        "type": "TODO",
        "content": "echo \"   // TODO: Implement error handling for edge case X\"",
        "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n"
      },
      {
        "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 456,
        "type": "TODO",
        "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
        "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
      },
      {
        "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 456,
        "type": "TODO",
        "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
        "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/clustering.py",
        "line": 361,
        "type": "TODO",
        "content": "# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids",
        "context": "# 80809 update: (30,60,3,[3]) - old range + repeat / (120,30,3) -- search opt\n# 80825 random_clusters\n# 81022 refactoring\n# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids\n# 81231 cleanup\n# 90104 resolve Turtle MST LW crash: 1 cluster\n# 90209 group_links: add min_word_count to 80925 legacy version\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 112,
        "type": "TODO",
        "content": "# TODO: update - see GitHub issue?",
        "context": "\n# 80802 poc05 restructured: moved here from pparser.py\n# 80829,31 unpws, unlws\n# TODO: update - see GitHub issue?\n# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 116,
        "type": "TODO",
        "content": "# TODO: update sentence length count to parsed words?",
        "context": "# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n# TODO: update sentence length count to parsed words?\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 133,
        "type": "TODO",
        "content": "else:  # 81130: prune clusters with empty dj sets  # TODO: update",
        "context": "                    new_dj.append(ordnung.index(abs(index)) * sign(index))\n                new_rule.append(tuple(new_dj))\n            new_cats['disjuncts'][rule] = set(new_rule)\n        else:  # 81130: prune clusters with empty dj sets  # TODO: update\n            print(('rule', rule, '- 0 djs in new_cats[disjuncts][rule]:',\n                   new_cats['disjuncts'][rule]))\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 179,
        "type": "TODO",
        "content": "# TODO: list of merged clusters - to delete",
        "context": "    if aggregation == 'jaccard':\n        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 180,
        "type": "TODO",
        "content": "# TODO: delete merged clusters",
        "context": "        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n        while z > 1 and threshold > aggr_threshold:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 206,
        "type": "TODO",
        "content": "# TODO: delete merged clusters?",
        "context": "    cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n    sims = [x for x in similarities]  # if x < threshold]\n    threshold = max(sims) - 0.01\n    # TODO: delete merged clusters?\n\n    z = len(similarities)\n    while z > 1 and threshold > aggr_threshold:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 215,
        "type": "TODO",
        "content": "# Renumber connectors in disjuncts # TODO: for all clusters?",
        "context": "        threshold = max(sims) - 0.01\n        z = len(sims)\n\n    # Renumber connectors in disjuncts # TODO: for all clusters?\n    clusters = [i for i, x in enumerate(cats['cluster'])\n                if i > 0 and x is not None]\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 277,
        "type": "TODO",
        "content": "# TODO: delete merged clusters?",
        "context": "        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        sims = [x for x in similarities]  # if x < threshold]\n        threshold = max(sims) - 0.01\n        # TODO: delete merged clusters?\n        z = len(similarities)\n        while z > 1 and threshold > aggr_threshold:\n            cats, similarities = aggregate(cats, threshold, jaccard, verbose)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 356,
        "type": "TODO",
        "content": "cats['parent'][cluster] = new_cluster_id  # TODO: don't change",
        "context": "\n        for cluster in mset:\n            cats['top'][cluster] = new_cluster_id  # 81123\n            cats['parent'][cluster] = new_cluster_id  # TODO: don't change\n            cats['words'][new_cluster_id].update(cats['words'][cluster])\n            cats['disjuncts'][new_cluster_id].update(cats['disjuncts'][cluster])\n            cats['djs'][new_cluster_id].update(cats['djs'][cluster])\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 414,
        "type": "TODO",
        "content": "# TODO: aggregate_cosine?",
        "context": "# 80725 POC 0.1-0.4 deleted, 0.5 restructured\n# 80802 poc05.py restructured, cats2list moved to category_learner.py,\n# cats2list copied to poc05.py for tmp compatibility\n# TODO: aggregate_cosine?\n# 80802 fix compatibility with dj_counts & max_disjuncts, delete ...05.py?\n# 81121 generalise_rules\n# 81217 FIXME? generalize_categories [F] with new reorder (Turtle tests)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 358,
        "type": "TODO",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    logger.info(f'SVD matrix (3 files .npy) saved: {len(ut[0])} vectors, ut: {len(ut)} s: {len(s)} vt:{len(vt)}')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 439,
        "type": "TODO",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    list2tsv(explicit.ic, svd_path + '.contexts.vocab')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 466,
        "type": "TODO",
        "content": "# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?",
        "context": "# Notes:\n\n# 80329 added vector_space_dim\n# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?\n# 90221 minor updates for Grammar Learner tutorial\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 33,
        "type": "TODO",
        "content": "# TODO: cleanup here or in a separate constructor?",
        "context": "            if us[-1] != '\\n' :  us += '\\n'\n        us += s\n        if us[-1] != '\\n' :  us += '\\n'\n    # TODO: cleanup here or in a separate constructor?\n    re = OrderedDict([('read_files', UTC()),\n                      ('input_path', kwargs['input_path']),\n                      ('read_files_number', len(files)),\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 25,
        "type": "TODO",
        "content": "elif clustering == 'group':  # TODO: call ILE clustering?",
        "context": "            clustering = ('kmeans', 'k-means++', 10)\n        elif clustering in ['mean_shift', 'mean shift', 'meanshift']:\n            clustering = ('mean_shift', 2)  # Note: 'auto' bandwidth not yet implemented\n        elif clustering == 'group':  # TODO: call ILE clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 29,
        "type": "TODO",
        "content": "elif clustering == 'random':  # TODO: call random clustering?",
        "context": "            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n        elif clustering == 'random':  # TODO: call random clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'random not supported in skl_clustering'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 56,
        "type": "TODO",
        "content": "# TODO: int / dict",
        "context": "            if len(clustering) > 3:  # connectivity\n                if type(clustering[3]) is int and clustering[3] > 0:\n                    neighbors = clustering[3]\n                    # TODO: int / dict \n                    connectivity = kneighbors_graph(cd, neighbors,\n                                                    include_self=False)\n            if len(clustering) > 4:  # compute_full_tree\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 172,
        "type": "TODO",
        "content": "elif len(crange) == 3:  # TODO: replace with SGD?",
        "context": "                    l, m, c = skl_clustering(cd, crange[0], **kwargs)\n                    if m['silhouette_index'] > metrics['silhouette_index']:\n                        labels, metrics, centroids = l, m, c\n        elif len(crange) == 3:  # TODO: replace with SGD?\n            n_min = min(crange[0], crange[1])\n            n_max = max(crange[0], crange[1])\n            labels, metrics, centroids = \\\n"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 70,
        "type": "TODO",
        "content": "#  TODO: To be reviewed and changed if necessary",
        "context": "                tree.append(['', m+1, cats[j][2], cats[j][3]])\n        else:\n            print('WTF?', k, v)\n    #  TODO: To be reviewed and changed if necessary\n    if verbose not in ['none', 'min']:\n        display(html_table([['Code', 'Parent', 'Id', 'Words']] + tree))\n\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 212,
        "type": "TODO",
        "content": "# TODO: Remove these commented lines in next cleanup cycle.",
        "context": "        }\n        re = learn_grammar(**kwargs)\n        # NOTE: Legacy test code commented out for historical reference.\n        # TODO: Remove these commented lines in next cleanup cycle.\n        # a, q, qa = pqa_meter(re['grammar_file'], outpath, cp, rp, **kwargs)\n        # print('parse-ability, parse-quality:', a, q)\n        # assert a*q > 0.99\n"
      }
    ],
    "NotImplementedError": [
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1274,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define verb_instance (cog-name verb_inst))\n\t(define obj_concept (cog-name obj_lemma))\n\t(define obj_instance (cog-name obj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjSVIOQ-rule\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1287,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define obj_instance (cog-name obj_inst))\n\t(define iobj_concept (cog-name iobj_lemma))\n\t(define iobj_instance (cog-name iobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichobjSVIOQ-rule\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1300,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define obj_instance (cog-name obj_inst))\n\t(define iobj_concept (cog-name iobj_lemma))\n\t(define iobj_instance (cog-name iobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichpobjQ-rule\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1311,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define prep_instance (cog-name prep_inst))\n\t(define pobj_concept (cog-name pobj_lemma))\n\t(define pobj_instance (cog-name pobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjpobjQ-rule\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1322,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define prep_instance (cog-name prep_inst))\n\t(define pobj_concept (cog-name pobj_lemma))\n\t(define pobj_instance (cog-name pobj_inst))\n\t(throw 'not-implemented)\n)\n\n(define-public (whichsubjSVQ-rule\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
        "line": 1331,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented)",
        "context": "\t(define subj_instance (cog-name subj_inst))\n\t(define verb (cog-name verb_lemma))\n\t(define verb_instance (cog-name verb_inst))\n\t(throw 'not-implemented)\n)\n\n;\n"
      },
      {
        "file": "components/language/learn/scm/gram-class/singletons.scm",
        "line": 61,
        "type": "NotImplementedError",
        "content": "(throw 'not-implemented 'add-singleton-classes",
        "context": "\t; XXX this is broken\n\t(define (delete-singles)\n\t\t; delete each word-class node..\n\t\t(throw 'not-implemented 'add-singleton-classes\n\t\t\t\"This method is borken and don't work right!\")\n\t\t(for-each cog-delete-recursive!\n\t\t\t; make a list of word-classes containing only one word...\n"
      },
      {
        "file": "verify_implementations.py",
        "line": 222,
        "type": "NotImplementedError",
        "content": "r'throw.*not\\s+implemented',",
        "context": "    def _check_for_placeholders(self, content: str, item: TodoItem) -> bool:\n        \"\"\"Check for placeholder implementations\"\"\"\n        placeholder_patterns = [\n            r'throw.*not\\s+implemented',\n            r'return.*TODO',\n            r'return.*STUB',\n            r'return.*PLACEHOLDER',\n"
      },
      {
        "file": "find_placeholders.py",
        "line": 21,
        "type": "NotImplementedError",
        "content": "'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
        "context": "        self.patterns = {\n            'TODO': r'(//|#|;|/\\*)\\s*TODO[:\\s]',\n            'FIXME': r'(//|#|;|/\\*)\\s*(FIXME|XXX)[:\\s]',\n            'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',\n            'pass_only': r'def\\s+\\w+\\([^)]*\\):\\s*pass\\s*$',\n            'empty_function': r'def\\s+\\w+\\([^)]*\\):\\s*\\.\\.\\.\\s*$',\n            'stub': r'(//|#|;)\\s*STUB[:\\s]',\n"
      },
      {
        "file": "scripts/generate_todo_catalog.py",
        "line": 56,
        "type": "NotImplementedError",
        "content": "r'throw.*IOException.*\"Not implemented\"',",
        "context": "            r'NOT IMPLEMENTED',\n            r'STUB\\s*:?\\s*(.*)',\n            r'PLACEHOLDER\\s*:?\\s*(.*)',\n            r'throw.*IOException.*\"Not implemented\"',\n            r'OC_ASSERT\\s*\\(\\s*false\\s*,\\s*\"[^\"]*not implemented[^\"]*\"',\n            r'Ensemble scoring not implemented',\n        ]\n"
      }
    ],
    "stub": [
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 550,
        "type": "stub",
        "content": "// Stub: just log the evaluation",
        "context": "    }\n    \n    void eval(const std::string& expression) {\n        // Stub: just log the evaluation\n        logger().debug(\"SchemeEval: %s\", expression.c_str());\n    }\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 555,
        "type": "stub",
        "content": "// Stub: return undefined handle",
        "context": "    }\n    \n    Handle eval_h(const std::string& expression) {\n        // Stub: return undefined handle\n        logger().debug(\"SchemeEval eval_h: %s\", expression.c_str());\n        return Handle::UNDEFINED;\n    }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 561,
        "type": "stub",
        "content": "// Stub: return empty string",
        "context": "    }\n    \n    std::string eval_str(const std::string& expression) {\n        // Stub: return empty string\n        logger().debug(\"SchemeEval eval_str: %s\", expression.c_str());\n        return \"\";\n    }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/ggml-cpu.h",
        "line": 16,
        "type": "stub",
        "content": "// Stub implementation",
        "context": "\n// CPU backend initialization (stub - does nothing)\nstatic inline void ggml_cpu_init(void) {\n    // Stub implementation\n}\n\n#ifdef __cplusplus\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 136,
        "type": "stub",
        "content": "// Stub types when Link Grammar is not available",
        "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 138,
        "type": "stub",
        "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
        "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 139,
        "type": "stub",
        "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
        "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n"
      },
      {
        "file": "ggml-tensor-kernel/src/ggml_stub.c",
        "line": 136,
        "type": "stub",
        "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
        "context": "\n// Math operations (simplified stubs)\nstruct ggml_tensor* ggml_add(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_mul(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/ggml_stub.c",
        "line": 140,
        "type": "stub",
        "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
        "context": "}\n\nstruct ggml_tensor* ggml_mul(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_mul_mat(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/ggml_stub.c",
        "line": 144,
        "type": "stub",
        "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
        "context": "}\n\nstruct ggml_tensor* ggml_mul_mat(struct ggml_context* ctx, struct ggml_tensor* a, struct ggml_tensor* b) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_soft_max(struct ggml_context* ctx, struct ggml_tensor* a) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/ggml_stub.c",
        "line": 148,
        "type": "stub",
        "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
        "context": "}\n\nstruct ggml_tensor* ggml_soft_max(struct ggml_context* ctx, struct ggml_tensor* a) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_relu(struct ggml_context* ctx, struct ggml_tensor* a) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/ggml_stub.c",
        "line": 152,
        "type": "stub",
        "content": "return ggml_dup_tensor(ctx, a); // Stub: just return copy of a",
        "context": "}\n\nstruct ggml_tensor* ggml_relu(struct ggml_context* ctx, struct ggml_tensor* a) {\n    return ggml_dup_tensor(ctx, a); // Stub: just return copy of a\n}\n\nstruct ggml_tensor* ggml_new_f32(struct ggml_context* ctx, float value) {\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 667,
        "type": "stub",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 667,
        "type": "stub",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 128,
        "type": "stub",
        "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
        "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 129,
        "type": "stub",
        "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
        "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n"
      }
    ]
  },
  "files_with_most_placeholders": [
    [
      "components/integration/opencog/opencog/nlp/relex2logic/rule-helpers.scm",
      23
    ],
    [
      "analyze_issue_examples.py",
      19
    ],
    [
      "atomspace/opencog/query/PatternMatchEngine.cc",
      15
    ],
    [
      "components/integration/opencog/opencog/eva/attic/chatbot-train/simple-training.scm",
      10
    ],
    [
      "components/integration/opencog/opencog/eva/behavior/behavior.scm",
      10
    ],
    [
      "components/learning/moses/moses/moses/optimization/particle-swarm.h",
      10
    ],
    [
      "moses/moses/moses/optimization/particle-swarm.h",
      10
    ],
    [
      "atomspace/opencog/atoms/pattern/PatternLink.cc",
      9
    ],
    [
      "moses/moses/moses/scoring/discriminating_bscore.cc",
      9
    ],
    [
      "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
      8
    ],
    [
      "components/integration/opencog/opencog/nlp/aiml/aiml.scm",
      8
    ],
    [
      "components/integration/opencog/opencog/openpsi/rule.scm",
      8
    ],
    [
      "language-learning/src/grammar_learner/generalization.py",
      8
    ],
    [
      "language-learning/src/grammar_learner/skl_clustering.py",
      8
    ],
    [
      "components/integration/opencog/opencog/eva/model/self-model.scm",
      7
    ],
    [
      "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
      7
    ],
    [
      "components/integration/opencog/opencog/openpsi/control.scm",
      7
    ],
    [
      "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
      7
    ],
    [
      "moses/moses/comboreduct/table/table.h",
      7
    ],
    [
      "atomspace-storage/opencog/persist/sexcom/Commands.cc",
      7
    ]
  ]
}