{
  "total": 110,
  "categories": {
    "thread_safety": 1,
    "optimization": 1,
    "error_handling": 6,
    "documentation": 0,
    "refactoring": 1,
    "feature_incomplete": 0,
    "other": 101
  },
  "fixmes_by_category": {
    "thread_safety": [
      {
        "file": "./components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 93,
        "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
        "context": "\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n"
      }
    ],
    "optimization": [
      {
        "file": "./atomspace/opencog/atomspace/Transient.cc",
        "line": 43,
        "content": "/// XXX FIXME. Performance has not been recently measured; there",
        "context": "/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n"
      }
    ],
    "error_handling": [
      {
        "file": "./atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
        "line": 31,
        "content": "// XXX FIXME: except for the error messages, most of this code is",
        "context": "namespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/TypeChoice.cc",
        "line": 254,
        "content": "// For now, just avoid throwing an exception. XXX FIXME.",
        "context": "\t\t// using a SignatureLink, but its not. As a result, it\n\t\t// gets undefined behavior and incorrect results. Too bad.\n\t\t// For now, just avoid throwing an exception. XXX FIXME.\n\t\treturn;\n\t}\n\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/TypeUtils.cc",
        "line": 421,
        "content": "// returned. XXX FIXME -- surely this should be a throw, instead!!!",
        "context": "\t// If we're here we have failed to recognize vardecl as a useful\n\t// and well-formed variable declaration, so Handle::UNDEFINED is\n\t// returned. XXX FIXME -- surely this should be a throw, instead!!!\n\treturn Handle::UNDEFINED;\n}\n\n"
      },
      {
        "file": "./components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1057,
        "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
        "context": "\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      },
      {
        "file": "./moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      }
    ],
    "documentation": [],
    "refactoring": [
      {
        "file": "./atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 196,
        "content": "/// cleanly separated from each other. (XXX FIXME, these need to be",
        "context": "/// walk_tree() performs a kind-of eager-evaluation of function arguments.\n/// The code in here is a mashup of several different ideas that are not\n/// cleanly separated from each other. (XXX FIXME, these need to be\n/// cleanly separated; its impeding overall clean design/implementation.)\n/// Roughly, it goes like so:\n///\n"
      }
    ],
    "feature_incomplete": [],
    "other": [
      {
        "file": "./atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 1004,
        "content": "// XXX FIXME. We would like to call",
        "context": "void MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "./atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1371,
        "content": "// XXX FIXME. We would like to call",
        "context": "\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/flow/FetchValueOfLink.cc",
        "line": 63,
        "content": "// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]",
        "context": "\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of _outgoing[0] or _outgoing[1]\n\t// are executable, then they need to be executed, first, right?\n\t// Yes, they do. But, for just right now, we don't, to stay\n\t// compatible with ValueOfLink. See comments in that code.\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/flow/StoreValueOfLink.cc",
        "line": 61,
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "\tStorageNodePtr stnp = StorageNodeCast(_outgoing[2]);\n\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Because that's the\n\t// usual intent. Else they'd be wrapped in a DontExecLink, right?\n\t// I'm confused.\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
        "line": 141,
        "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
        "context": "// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/proxy/ProxyNode.h",
        "line": 62,
        "content": "// updated at some later date. XXX FIXME.",
        "context": "\t// Virtual methods from the BackingStore API. These provide some default\n\t// implementations. Some of these are stop-gap, and will need to be\n\t// updated at some later date. XXX FIXME.\n\n\tvirtual void create(void) {} // stop-gap. FIXME\n\tvirtual void destroy(void);  //stop-gap. FIXME\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
        "line": 195,
        "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
        "context": "                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/sexpr/ValueSexpr.cc",
        "line": 82,
        "content": "* XXX FIXME This needs to be fuzzed; it is very likely to crash",
        "context": " * open-paren, and the string encoding the value.\n *\n * XXX FIXME This needs to be fuzzed; it is very likely to crash\n * and/or contain bugs if it is given strings of unexpected formats.\n */\nValuePtr Sexpr::decode_value(const std::string& stv, size_t& pos)\n"
      },
      {
        "file": "./atomspace-storage/opencog/persist/tlb/UuidSCM.cc",
        "line": 83,
        "content": "// what the heck. I'm gonna punt. XXX FIXME.",
        "context": "\t// atomspaces, and really, we should have nested hierarchical TLB\n\t// resolvers for nested atomspaces. But for now, no one uses this so\n\t// what the heck. I'm gonna punt. XXX FIXME.\n\tconst AtomSpacePtr& asp = SchemeSmob::ss_get_env_as(\"uuid\");\n\t_tlb.set_resolver(asp.get());\n\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/Checkers.cc",
        "line": 42,
        "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
        "context": "/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/Checkers.cc",
        "line": 79,
        "content": "// XXX FIXME, this is to be removed, because UnionLink,",
        "context": "\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/Checkers.cc",
        "line": 93,
        "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
        "context": "\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/FindUtils.h",
        "line": 146,
        "content": "* XXX FIXME: what if it appears quoted in one place, and unquoted",
        "context": " * QuoteLink.\n *\n * XXX FIXME: what if it appears quoted in one place, and unquoted\n * in another? then what?\n */\nbool is_quoted_in_tree(const Handle& tree, const Handle& atom);\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 110,
        "content": "// XXX FIXME - fix this so it can also choose a single value",
        "context": "///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n"
      },
      {
        "file": "./atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 179,
        "content": "// XXX FIXME, also allow a FloatValue!!",
        "context": "\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n"
      },
      {
        "file": "./atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 598,
        "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
        "context": "\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n"
      },
      {
        "file": "./atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 642,
        "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
        "context": "\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n"
      },
      {
        "file": "./atomspace/opencog/atoms/flow/FilterLink.cc",
        "line": 615,
        "content": "// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,",
        "context": "\t\tvex = _outgoing[1]->execute(as, silent);\n\n\t\t// XXX TODO FIXME -- if vex is a stream, e.g. a QueueValue,\n\t\t// then we should construct another Queue as the return value,\n\t\t// and perform filtering on-demand.\n\t\tif (vex->is_type(LINK_VALUE))\n"
      },
      {
        "file": "./atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
        "line": 41,
        "content": "/// XXX FIXME - in the future, some user is going to want to include",
        "context": "/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n"
      },
      {
        "file": "./atomspace/opencog/atoms/flow/ValueOfLink.cc",
        "line": 84,
        "content": "// XXX TODO FIXME ... if either of these are executable, then",
        "context": "\t// trickle out properly in the end.\n\t//\n\t// XXX TODO FIXME ... if either of these are executable, then\n\t// they need to be executed, first, right? Yes, they do! We\n\t// can currently get away with not doing this for two reasons:\n\t// In all existing code, the first Atom is always an anchor,\n"
      },
      {
        "file": "./atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 550,
        "content": "/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.",
        "context": "///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n{\n"
      },
      {
        "file": "./atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 721,
        "content": "// XXX FIXME this is really dumb, using a queue and then",
        "context": "\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/BindLink.cc",
        "line": 79,
        "content": "// Shoot. XXX FIXME. Most of the unit tests require that the atom",
        "context": "#define PLACE_RESULTS_IN_ATOMSPACE\n#ifdef PLACE_RESULTS_IN_ATOMSPACE\n\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\n\t// that we return is in the atomspace. But it would be nice if we\n\t// could defer this indefinitely, until its really needed.\n\trewr = as->add_atom(rewr);\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/GetLink.cc",
        "line": 62,
        "content": "// Shoot. XXX FIXME. Most of the unit tests require that the atom",
        "context": "#define PLACE_RESULTS_IN_ATOMSPACE\n#ifdef PLACE_RESULTS_IN_ATOMSPACE\n\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\n\t// that we return is in the atomspace. But it would be nice if we\n\t// could defer this indefinitely, until its really needed.\n\tif (as) satset = as->add_atom(satset);\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 146,
        "content": "// XXX FIXME, more correct would be to loop over",
        "context": "\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 165,
        "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
        "context": "\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 721,
        "content": "// BUG - XXX FIXME. This extracts PresentLink's from the",
        "context": "\t                     OR_LINK, SEQUENTIAL_OR_LINK, NOT_LINK});\n\n\t// BUG - XXX FIXME. This extracts PresentLink's from the\n\t// Sequentials. This is not really correct, because the\n\t// evaluation of the sequential might terminate *before*\n\t// the PresentLink is reached. Whereas the current design\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1039,
        "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
        "context": "/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1255,
        "content": "// XXX FIXME -- this is wrong. What we really want is to",
        "context": "\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1465,
        "content": "// XXX FIXME: debug_log() above is more readable than the below.",
        "context": "DEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n"
      },
      {
        "file": "./atomspace/opencog/atoms/pattern/PatternUtils.cc",
        "line": 55,
        "content": "// XXX FIXME Are the below needed?",
        "context": "\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n"
      },
      {
        "file": "./atomspace/opencog/atoms/reduct/DecimateLink.cc",
        "line": 65,
        "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
        "context": "\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n"
      },
      {
        "file": "./atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 283,
        "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
        "context": "\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n"
      },
      {
        "file": "./atomspace/opencog/atomspace/AtomSpace.h",
        "line": 524,
        "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
        "context": "    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n"
      },
      {
        "file": "./atomspace/opencog/cython/PythonEval.cc",
        "line": 1427,
        "content": "// XXX FIXME this does a lot of wasteful string copying.",
        "context": "void PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n"
      },
      {
        "file": "./atomspace/opencog/guile/SchemeSmobAtom.cc",
        "line": 84,
        "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
        "context": "/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n"
      },
      {
        "file": "./atomspace/opencog/guile/SchemeSmobAtom.cc",
        "line": 210,
        "content": "printf(\"XXX FIXME Bad string %s\\nconverted to %s\\n\", (char *) data, wbuf);",
        "context": "\ticonv(cd, &inbuf, &ilen, &obuf, &olen);\n\tobuf[olen] = 0x0;\n\tprintf(\"XXX FIXME Bad string %s\\nconverted to %s\\n\", (char *) data, wbuf);\n\tSCM str = scm_from_utf8_string(obuf);\n\tfree(wbuf);\n\treturn str;\n"
      },
      {
        "file": "./atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 73,
        "content": "// XXX FIXME: can we fix cython to not do this, already?",
        "context": "// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n"
      },
      {
        "file": "./atomspace/opencog/haskell/AtomSpace_CWrapper.h",
        "line": 112,
        "content": "* XXX FIXME no one should be using Handle's to work with atoms,",
        "context": "    /**\n     * AtomSpace_getAtomByHandle Gets an atom back from the atomspace.\n     * XXX FIXME no one should be using Handle's to work with atoms,\n     * except for the database and communications back-ends.  The\n     * Handle's were never intended as a user interface to atoms, and,\n     * in particular, language bindings should not be using them.\n"
      },
      {
        "file": "./atomspace/opencog/haskell/PatternMatcher_CWrapper.h",
        "line": 8,
        "content": "* XXX FIXME: atoms must never be accessed by UUID except by the",
        "context": " * An interface necessary for haskell bindings.\n * (ghc supports FFI for c libraries)\n * XXX FIXME: atoms must never be accessed by UUID except by the\n * communication and database layers. The UUID is not meant to be\n * a public interface.\n */\n"
      },
      {
        "file": "./atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 126,
        "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
        "context": "\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n"
      },
      {
        "file": "./atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 270,
        "content": "// So we are good to go. XXX FIXME -- we could try again, to find",
        "context": "\n\t\t// If we encountered choices, then we have enumerated all of them.\n\t\t// So we are good to go. XXX FIXME -- we could try again, to find\n\t\t// some thinner set of choices. Later, some other time.\n\t\tif (0 < _start_choices.size()) break;\n\t}\n"
      },
      {
        "file": "./atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 732,
        "content": "// no unit test triggers this, but its not clear why. XXX FIXME??",
        "context": "// If this is used in a way such that the handle appears under a\n// ChoiceLink, then an incomplete search will result!  Right now,\n// no unit test triggers this, but its not clear why. XXX FIXME??\n// For this case, use the `term_choices_of_handle` below.\nPatternTermPtr InitiateSearchMixin::term_of_handle(const Handle& h,\n                                     const PatternTermPtr& root)\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 284,
        "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
        "context": "/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1532,
        "content": "// XXX FIXME - this is not very elegant. We should probably",
        "context": "\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1982,
        "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
        "context": "///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2049,
        "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
        "context": "/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2065,
        "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
        "context": "\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2223,
        "content": "/// XXX FIXME -- do the above.",
        "context": "/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n"
      },
      {
        "file": "./atomspace/opencog/query/PatternMatchEngine.h",
        "line": 189,
        "content": "// with it. XXX Needs to move to the Mixin class... XXX FIXME.",
        "context": "\t// State that manages the next PresentLink subterm to be grounded.\n\t// Similar to the next-clause, above, and someday should be unified\n\t// with it. XXX Needs to move to the Mixin class... XXX FIXME.\n\n\tbool next_untried_present(const PatternTermPtr&,\n\t                          const PatternTermPtr&,\n"
      },
      {
        "file": "./atomspace/opencog/query/RewriteMixin.cc",
        "line": 118,
        "content": "// See issue #950 and pull req #962. XXX FIXME later.",
        "context": "\t// nothing.  In practice it is difficult to insure, so\n\t// meanwhile this try-catch is used.\n\t// See issue #950 and pull req #962. XXX FIXME later.\n\t// Tested by BuggyBindLinkUTest and NoExceptionUTest.\n\t// Well, given that URE is dead meat, maybe we can remove this?\n\ttry {\n"
      },
      {
        "file": "./atomspace/opencog/query/RewriteMixin.cc",
        "line": 164,
        "content": "/// XXX FIXME now I see how it can be done. The groupings should",
        "context": "/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n"
      },
      {
        "file": "./atomspace/opencog/query/SatisfyMixin.cc",
        "line": 583,
        "content": "// XXX FIXME terrible hack.",
        "context": "\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n"
      },
      {
        "file": "./atomspace/opencog/query/TermMatchMixin.cc",
        "line": 710,
        "content": "// XXX FIXME: worse: this cannot possibly be right when",
        "context": "\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n"
      },
      {
        "file": "./cogserver/opencog/cogserver/attic/proxy/WriteThruProxy.cc",
        "line": 114,
        "content": "// which seems inefficient. But still ... XXX FIXME ?",
        "context": "\t// Sexpr::decode_slist to return a list of keys,\n\t// and then we'd have to store one key at a time,\n\t// which seems inefficient. But still ... XXX FIXME ?\n\tfor (const StorageNodePtr& snp : _targets)\n\t\tsnp->store_atom(atom);\n}\n"
      },
      {
        "file": "./cogserver/opencog/cogserver/server/CogServer.cc",
        "line": 125,
        "content": "// XXX FIXME. terrible terrible hack. What we should be",
        "context": "            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n"
      },
      {
        "file": "./cogserver/opencog/cogserver/server/CogServer.cc",
        "line": 216,
        "content": "// assumes a singleton instance, so we leave this for now. XXX FIXME.",
        "context": "// interesting use cases where one might want to run multiple\n// cogservers. However, at this time, too much of the code (???)\n// assumes a singleton instance, so we leave this for now. XXX FIXME.\n\n// The guile module needs to be able to delete this singleton.\n// So put it where the guile module can find it.\n"
      },
      {
        "file": "./components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 944,
        "content": "// XXX FIXME. We would like to call",
        "context": "void MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "./components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 694,
        "content": "/// Note: currently broken for multi-space usage, XXX FIXME.",
        "context": "/// Backend callback - find the Link. This is used ONLY to implement\n/// the backend Query call, and is not otherwised used.\n/// Note: currently broken for multi-space usage, XXX FIXME.\nHandle RocksStorage::getLink(Type t, const HandleSeq& hs)\n{\n\tCHECK_OPEN;\n"
      },
      {
        "file": "./components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1283,
        "content": "// XXX FIXME. We would like to call",
        "context": "\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "./components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
        "line": 82,
        "content": "// XXX FIXME -- are open and close actually needed for anything?",
        "context": "}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n"
      },
      {
        "file": "./components/integration/opencog/opencog/neighbors/Neighbors.h",
        "line": 58,
        "content": "* XXX FIXME -- this function is curently not used anywhere. Perhaps",
        "context": " * @return      an UnorderedHandleSet of neighbors\n *\n * XXX FIXME -- this function is curently not used anywhere. Perhaps\n * it should be deleted?\n */\nUnorderedHandleSet get_distant_neighbors(const Handle& h, int dist = 1);\n"
      },
      {
        "file": "./components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1180,
        "content": "// XXX FIXME only a subset is needed.",
        "context": "void SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 239,
        "content": "// XXX FIXME this does not smell right; optionals should get",
        "context": "    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 268,
        "content": "// XXX FIXME ... using an std::map would be more efficient.",
        "context": "    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 87,
        "content": "* XXX FIXME -- this gives incorrect results if the word has non-trivial",
        "context": " * appear anywhere.\n*\n* XXX FIXME -- this gives incorrect results if the word has non-trivial\n* morphology e.g. if its Russian, and can be split into a stem and a\n* suffix.  The problem is that in LG, both stem and suffix count as\n* distinct words, and so word splitting must be done first.\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 103,
        "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
        "context": "    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-dict/LGDictUtils.cc",
        "line": 53,
        "content": "XXX FIXME -- this currently fails to correctly handle the head-tail",
        "context": " * Check if two connectors' type matches.\n\nXXX FIXME -- this currently fails to correctly handle the head-tail\nindicators on link types.  Perhaps it would be better to just call\nthe same matchinng routines the link-grammar uses?\n *\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 229,
        "content": "// XXX FIXME. This should be part of the LgDictNode but since",
        "context": "\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n"
      },
      {
        "file": "./components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 338,
        "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
        "context": "\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n"
      },
      {
        "file": "./components/learning/moses/moses/comboreduct/combo/descriptions.cc",
        "line": 94,
        "content": "// type. XXX FIXME...",
        "context": "    // testing for booleans, contin as well, but not today. \n    // Fixing this will require work in typechecker, and use of union\n    // type. XXX FIXME...\n    { id::equ,                  \"->(enum enum boolean)\" },\n};\n\n"
      },
      {
        "file": "./components/learning/moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "content": "// XXX FIXME",
        "context": "\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/main/problem-params.h",
        "line": 46,
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "namespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/metapopulation/ensemble.h",
        "line": 55,
        "content": "* XXX FIXME: right now, the ensemble is attached to the metapop, its",
        "context": " * from the metapopulation, which has no particular admission criteria.\n *\n * XXX FIXME: right now, the ensemble is attached to the metapop, its\n * kind-of coming along for the ride, because that's easier for now.\n * Someday, it should have an independent existance.\n */\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 90,
        "content": "* XXX FIXME: right now, the ensemble is attached to the metapop, its",
        "context": " * for inference, the metapopulation for breeding.\n *\n * XXX FIXME: right now, the ensemble is attached to the metapop, its\n * kind-of coming along for the ride, because that's easier for now.\n * Someday, it should have an independent existance.\n *\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/scoring/bscores.cc",
        "line": 930,
        "content": "/// XXX this should probably be removed! TODO FIXME",
        "context": "/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
      },
      {
        "file": "./components/learning/moses/moses/moses/scoring/scoring_base.cc",
        "line": 108,
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "./moses/moses/comboreduct/combo/descriptions.cc",
        "line": 94,
        "content": "// type. XXX FIXME...",
        "context": "    // testing for booleans, contin as well, but not today. \n    // Fixing this will require work in typechecker, and use of union\n    // type. XXX FIXME...\n    { id::equ,                  \"->(enum enum boolean)\" },\n};\n\n"
      },
      {
        "file": "./moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "content": "// XXX FIXME",
        "context": "\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "./moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "./moses/moses/moses/main/problem-params.h",
        "line": 46,
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "namespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "./moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "./moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "./moses/moses/moses/metapopulation/ensemble.h",
        "line": 55,
        "content": "* XXX FIXME: right now, the ensemble is attached to the metapop, its",
        "context": " * from the metapopulation, which has no particular admission criteria.\n *\n * XXX FIXME: right now, the ensemble is attached to the metapop, its\n * kind-of coming along for the ride, because that's easier for now.\n * Someday, it should have an independent existance.\n */\n"
      },
      {
        "file": "./moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "./moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "./moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "./moses/moses/moses/metapopulation/metapopulation.h",
        "line": 90,
        "content": "* XXX FIXME: right now, the ensemble is attached to the metapop, its",
        "context": " * for inference, the metapopulation for breeding.\n *\n * XXX FIXME: right now, the ensemble is attached to the metapop, its\n * kind-of coming along for the ride, because that's easier for now.\n * Someday, it should have an independent existance.\n *\n"
      },
      {
        "file": "./moses/moses/moses/scoring/bscores.cc",
        "line": 930,
        "content": "/// XXX this should probably be removed! TODO FIXME",
        "context": "/// formula (the edges, with are printed by hand, below).\n///\n/// XXX this should probably be removed! TODO FIXME\n\ncluster_bscore::cluster_bscore(const ITable& itable)\n    : _itable(itable)\n"
      },
      {
        "file": "./moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 646,
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "score_t bep_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt * _true_total);\n    double best_possible_recall = 1.0 / _true_total;\n    return (best_possible_precision + best_possible_recall) / 2;\n"
      },
      {
        "file": "./moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 655,
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "score_t bep_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / (cnt);\n    double best_possible_recall = (0.0 < pos) ? 1.0 : 0.0;\n    return fabs(best_possible_precision - best_possible_recall);\n"
      },
      {
        "file": "./moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 707,
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "score_t f_one_bscore::get_fixed(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    return 1.0;\n}\n\n"
      },
      {
        "file": "./moses/moses/moses/scoring/discriminating_bscore.cc",
        "line": 714,
        "content": "// XXX TODO FIXME is this really correct?",
        "context": "score_t f_one_bscore::get_variable(score_t pos, score_t neg, unsigned cnt) const\n{\n    // XXX TODO FIXME is this really correct?\n    double best_possible_precision = pos / cnt;\n    double best_possible_recall = 1.0;\n    double f_one = 2 * best_possible_precision * best_possible_recall\n"
      },
      {
        "file": "./moses/moses/moses/scoring/scoring_base.cc",
        "line": 152,
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "./unify/opencog/unify/atoms/UnifierLink.cc",
        "line": 141,
        "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
        "context": "\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n"
      }
    ]
  }
}