name: 'Generate Cognitive Grammar'
description: 'Scan enterprise and generate ggml cognitive grammar with hypergraph topology'
author: 'OpenCog Community'

inputs:
  enterprise:
    description: 'Enterprise name'
    required: true
    default: 'cosmos'
  cognitive-mode:
    description: 'fold | unfold | project | embed'
    required: false
    default: 'fold'
  tensor-dimensions:
    description: 'Comma-separated tensor dimensions'
    required: false
    default: '7,3,10,50,100'
  github-token:
    description: 'GitHub token for API access'
    required: true

outputs:
  tensor-shape:
    description: 'Generated tensor shape'
    value: ${{ steps.tensor-calc.outputs.shape }}
  membrane-state:
    description: 'Cognitive membrane state'
    value: ${{ steps.membrane-scan.outputs.state }}
  grammar-file:
    description: 'Path to generated grammar file'
    value: ${{ steps.grammar-gen.outputs.file }}

runs:
  using: 'composite'
  steps:
    - name: Install Cognitive Dependencies
      shell: bash
      run: |
        pip install numpy torch transformers PyGithub pyyaml
        npm install -g @octokit/graphql
    
    - name: Calculate Tensor Shape
      id: tensor-calc
      shell: bash
      run: |
        # Parse tensor dimensions from input
        IFS=',' read -ra DIMS <<< "${{ inputs.tensor-dimensions }}"
        SHAPE=$(printf "[%s]" "$(IFS=,; echo "${DIMS[*]}")")
        
        echo "ðŸ”¢ Calculated tensor shape: $SHAPE"
        echo "shape=$SHAPE" >> $GITHUB_OUTPUT

    - name: Generate Enterprise Scanner
      shell: bash
      run: |
        cat > enterprise_cognitive_scanner.py << 'EOF'
        import os
        import json
        import numpy as np
        from datetime import datetime
        
        class EnterpriseScanner:
            def __init__(self, enterprise="cosmos"):
                self.enterprise = enterprise
                self.topology = {}
                
            def scan_cognitive_topology(self):
                """Scan the cognitive topology across the enterprise"""
                print(f"ðŸŒ Scanning cognitive topology for enterprise: {self.enterprise}")
                
                organizations = ['cogpilot', 'OzCog', 'cosmos']
                topology = {
                    'enterprise': self.enterprise,
                    'scan_timestamp': datetime.utcnow().isoformat(),
                    'organizations': {},
                    'tensor_mapping': {}
                }
                
                for org_name in organizations:
                    topology['organizations'][org_name] = self.scan_organization(org_name)
                    
                topology['tensor_mapping'] = self.calculate_tensor_mapping(topology['organizations'])
                self.topology = topology
                return topology
                
            def scan_organization(self, org_name):
                """Scan organization for cognitive patterns"""
                repo_configs = {
                    'cogpilot': ['cognitive-cities', 'neural-transport'],
                    'OzCog': ['opencog-unified', 'atomspace-extensions'],
                    'cosmos': ['membrane-sync', 'cognitive-grammar']
                }
                
                org_data = {
                    'name': org_name,
                    'prime_factor': {'cogpilot': 2, 'OzCog': 3, 'cosmos': 5}.get(org_name, 7),
                    'repositories': {},
                    'membrane_type': f"{org_name}_membrane"
                }
                
                for repo_name in repo_configs.get(org_name, []):
                    complexity = len(repo_name) * 0.5 + np.random.random() * 2
                    shape = [2, 2, 2] if 'cognitive' in repo_name else [3, 1, 1]
                    
                    org_data['repositories'][repo_name] = {
                        'tensor_shape': shape,
                        'complexity_score': complexity,
                        'membrane_permeability': 'bidirectional'
                    }
                    
                return org_data
                
            def calculate_tensor_mapping(self, organizations):
                """Calculate tensor field mapping"""
                total_complexity = sum(
                    sum(repo['complexity_score'] for repo in org['repositories'].values())
                    for org in organizations.values()
                )
                
                return {
                    'enterprise_tensor_shape': [7, len(organizations), 10, int(total_complexity), 100],
                    'total_complexity': total_complexity,
                    'memory_efficiency': min(1.0, 50.0 / total_complexity) if total_complexity > 0 else 1.0
                }
                
            def fold_to_markdown(self):
                """Generate markdown representation"""
                markdown = f"""# ðŸŒŒ {self.enterprise.title()} Enterprise Cognitive Topology

**Scan Timestamp**: {self.topology['scan_timestamp']}
**Enterprise Tensor Shape**: {self.topology['tensor_mapping']['enterprise_tensor_shape']}
**Total Complexity**: {self.topology['tensor_mapping']['total_complexity']:.2f}

## Organizational Membranes

"""
                
                for org_name, org_data in self.topology['organizations'].items():
                    markdown += f"### ({org_name}) - Prime: {org_data['prime_factor']}\n"
                    for repo_name, repo_data in org_data['repositories'].items():
                        shape_str = "Ã—".join(map(str, repo_data['tensor_shape']))
                        markdown += f"#### [{repo_name}] - Shape: [{shape_str}]\n"
                    markdown += "\n"
                
                return markdown
                
            def generate_ggml_grammar(self):
                """Generate ggml-compatible grammar"""
                return {
                    'cognitive_grammar': {
                        'version': '2.0',
                        'enterprise': self.enterprise,
                        'topology': self.topology,
                        'tensor_optimization': {
                            'method': 'prime_factorization',
                            'memory_layout': 'cognitive_hierarchy'
                        }
                    }
                }
        
        # Execute scanning
        if __name__ == "__main__":
            enterprise = os.getenv('INPUT_ENTERPRISE', 'cosmos')
            scanner = EnterpriseScanner(enterprise)
            topology = scanner.scan_cognitive_topology()
            
            # Save results
            with open('enterprise-topology.json', 'w') as f:
                json.dump(topology, f, indent=2)
                
            markdown = scanner.fold_to_markdown()
            with open('enterprise-cognitive-topology.md', 'w') as f:
                f.write(markdown)
                
            grammar = scanner.generate_ggml_grammar()
            with open('cognitive-grammar-enterprise.ggml', 'w') as f:
                json.dump(grammar, f, indent=2)
                
            print("âœ… Enterprise cognitive scanning completed")
        EOF

    - name: Scan Cognitive Topology  
      id: membrane-scan
      shell: bash
      env:
        INPUT_ENTERPRISE: ${{ inputs.enterprise }}
      run: |
        echo "ðŸŒ Executing enterprise cognitive topology scan..."
        python enterprise_cognitive_scanner.py
        
        if [ -f "enterprise-topology.json" ]; then
          echo "state=scanned" >> $GITHUB_OUTPUT
        else
          echo "state=failed" >> $GITHUB_OUTPUT
        fi

    - name: Generate Enhanced Grammar
      id: grammar-gen
      shell: bash
      run: |
        cat > grammar_enhancer.py << 'EOF'
        import json
        from pathlib import Path
        
        def enhance_grammar():
            # Load existing grammar
            with open('cognitive-grammar-enterprise.ggml') as f:
                grammar = json.load(f)
                
            # Add cognitive primitives
            cognitive_primitives = {
                'attention_mechanisms': {
                    'tensor_shape': [7, 7, 1],
                    'complexity': 49,
                    'operations': ['attend', 'focus', 'distribute']
                },
                'memory_consolidation': {
                    'tensor_shape': [5, 3, 2], 
                    'complexity': 30,
                    'operations': ['store', 'retrieve', 'consolidate']
                },
                'pattern_recognition': {
                    'tensor_shape': [3, 3, 3],
                    'complexity': 27,
                    'operations': ['detect', 'classify', 'generalize']
                }
            }
            
            grammar['cognitive_grammar']['primitives'] = cognitive_primitives
            grammar['cognitive_grammar']['total_primitive_complexity'] = sum(p['complexity'] for p in cognitive_primitives.values())
            
            return grammar
            
        enhanced_grammar = enhance_grammar()
        
        with open('cognitive-grammar-enhanced.ggml', 'w') as f:
            json.dump(enhanced_grammar, f, indent=2)
            
        print("âœ… Enhanced cognitive grammar generated")
        EOF
        
        python grammar_enhancer.py
        
        if [ -f "cognitive-grammar-enhanced.ggml" ]; then
          echo "file=cognitive-grammar-enhanced.ggml" >> $GITHUB_OUTPUT
        else
          echo "file=" >> $GITHUB_OUTPUT
        fi

    - name: Summary Report
      shell: bash
      run: |
        echo "ðŸ“Š Cognitive Grammar Generation Summary"
        echo "======================================"
        echo "Enterprise: ${{ inputs.enterprise }}"
        echo "Mode: ${{ inputs.cognitive-mode }}"
        echo "Tensor Shape: ${{ steps.tensor-calc.outputs.shape }}"
        echo "Membrane State: ${{ steps.membrane-scan.outputs.state }}"
        echo "Grammar File: ${{ steps.grammar-gen.outputs.file }}"