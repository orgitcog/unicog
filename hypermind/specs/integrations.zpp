(*
 * HyperMind Integration Contracts Formal Specification
 * Z++ Specification of External System Integrations
 *
 * This module defines the contracts and protocols for integrating
 * with external systems: GPU hardware, PostgreSQL database, and network.
 *)

(* Import previous specifications *)
include data_model
include system_state
include operations

(* ============================================ *)
(* GPU Integration Contract                    *)
(* ============================================ *)

(*
 * GPU Operation Types
 *)
GPUOperationType ::= 
  | MatrixMultiply    (* Matrix multiplication *)
  | Activation        (* Activation function *)
  | Gradient          (* Gradient computation *)
  | MemoryCopy        (* Memory transfer *)

(*
 * GPUOperation - Represents a GPU computation request
 *)
schema GPUOperation
  operation_id: ID                         (* Unique operation ID *)
  op_type: GPUOperationType                (* Type of operation *)
  input_arrays: seq NDArray                (* Input data *)
  output_shape: seq â„•                      (* Expected output shape *)
  stream_id: ID                            (* Target GPU stream *)
  priority: â„•                              (* Operation priority *)
  timeout: â„•                               (* Timeout in milliseconds *)
where
  (* Valid operation ID *)
  operation_id > 0
  
  (* At least one input *)
  #input_arrays > 0
  
  (* All inputs on GPU or CPU *)
  (âˆ€ arr : ran input_arrays @ arr.device âˆˆ {GPU, CPU})
  
  (* Output shape is valid *)
  #output_shape > 0 âˆ§ (âˆ€ dim : ran output_shape @ dim > 0)
  
  (* Priority in valid range *)
  priority â‰¥ 0 âˆ§ priority â‰¤ 10
  
  (* Timeout is positive *)
  timeout > 0
end

(*
 * GPUResult - Result of GPU operation
 *)
schema GPUResult
  operation_id: ID                         (* Corresponding operation *)
  success: ð”¹                               (* Success status *)
  output: NDArray                          (* Result array *)
  execution_time: â„•                        (* Execution time in microseconds *)
  error_message: String                    (* Error if failed *)
where
  (* Valid operation reference *)
  operation_id > 0
  
  (* On success, output must be valid *)
  success â‡’ (#output.data > 0 âˆ§ output.device = GPU)
  
  (* On failure, error message provided *)
  Â¬success â‡’ error_message â‰  ""
  
  (* Execution time is non-negative *)
  execution_time â‰¥ 0
end

(*
 * SubmitGPUComputation - Contract for submitting GPU work
 *)
schema SubmitGPUComputation
  Î”GPUStream
  op?: GPUOperation                        (* Input: operation to execute *)
  op_id!: ID                               (* Output: assigned operation ID *)
pre
  (* Stream is active *)
  is_active
  
  (* Sufficient memory available *)
  (âˆ‘{arr : ran op?.input_arrays @ #arr.data * 4}) + memory_allocated 
    â‰¤ memory_capacity
  
  (* Stream matches operation *)
  op?.stream_id = stream_id
post
  (* Operation added to pending *)
  op_id! âˆˆ pending_ops' âˆ§ op_id! âˆ‰ pending_ops
  
  (* Operation queued *)
  op_id! âˆˆ ran operation_queue'
  
  (* Memory allocated *)
  memory_allocated' = memory_allocated + 
    (âˆ‘{arr : ran op?.input_arrays @ #arr.data * 4})
  
  (* Queue maintains order *)
  operation_queue' = operation_queue âŒ¢ âŸ¨op_id!âŸ©
end

(*
 * CompleteGPUComputation - Contract for GPU result handling
 *)
schema CompleteGPUComputation
  Î”GPUStream
  result?: GPUResult                       (* Input: computation result *)
pre
  (* Operation was pending *)
  result?.operation_id âˆˆ pending_ops
  
  (* Stream is active *)
  is_active
post
  (* Operation moved to completed *)
  result?.operation_id âˆ‰ pending_ops' âˆ§
  result?.operation_id âˆˆ completed_ops'
  
  (* Operation removed from queue *)
  result?.operation_id âˆ‰ ran operation_queue'
  
  (* Memory freed *)
  memory_allocated' < memory_allocated
end

(*
 * GPU Stream Lifecycle Invariants
 *)
schema GPUStreamInvariants
  GPUStream
where
  (* Pending operations are in queue *)
  ran operation_queue âŠ† pending_ops
  
  (* No operation in both pending and completed *)
  pending_ops âˆ© completed_ops = âˆ…
  
  (* Memory usage is realistic *)
  memory_allocated â‰¤ memory_capacity âˆ§ memory_allocated â‰¥ 0
  
  (* Active stream has capacity *)
  is_active â‡’ memory_capacity > 0
end

(* ============================================ *)
(* PostgreSQL Database Integration Contract    *)
(* ============================================ *)

(*
 * Database Query Types
 *)
DatabaseQueryType ::=
  | INSERT          (* Insert new record *)
  | UPDATE          (* Update existing record *)
  | SELECT          (* Retrieve records *)
  | DELETE          (* Delete records *)
  | BATCH_INSERT    (* Batch insert operation *)

(*
 * DatabaseQuery - Represents a database operation
 *)
schema DatabaseQuery
  query_id: ID                             (* Unique query ID *)
  query_type: DatabaseQueryType            (* Type of query *)
  table_name: String                       (* Target table *)
  data: seq Byte                           (* Serialized query data *)
  session_id: ID                           (* Associated session *)
  timeout: â„•                               (* Query timeout *)
where
  (* Valid query ID *)
  query_id > 0
  
  (* Valid session *)
  session_id > 0
  
  (* Table name is non-empty *)
  table_name â‰  ""
  
  (* Data is present for mutation queries *)
  query_type âˆˆ {INSERT, UPDATE, BATCH_INSERT} â‡’ #data > 0
  
  (* Timeout is positive *)
  timeout > 0
end

(*
 * DatabaseResult - Result of database operation
 *)
schema DatabaseResult
  query_id: ID                             (* Corresponding query *)
  success: ð”¹                               (* Success status *)
  rows_affected: â„•                         (* Rows inserted/updated/deleted *)
  result_data: seq Byte                    (* Retrieved data if SELECT *)
  execution_time: â„•                        (* Execution time in microseconds *)
  error_message: String                    (* Error if failed *)
where
  (* Valid query reference *)
  query_id > 0
  
  (* On success, rows affected is non-negative *)
  success â‡’ rows_affected â‰¥ 0
  
  (* On failure, error message provided *)
  Â¬success â‡’ error_message â‰  ""
  
  (* SELECT queries return data on success *)
  success âˆ§ rows_affected > 0 â‡’ #result_data > 0
  
  (* Execution time is non-negative *)
  execution_time â‰¥ 0
end

(*
 * SubmitDatabaseOperation - Contract for database requests
 *)
schema SubmitDatabaseOperation
  Î”DatabasePipe
  query?: DatabaseQuery                    (* Input: query to execute *)
  query_id!: ID                            (* Output: assigned query ID *)
pre
  (* Pipe is connected *)
  is_connected
  
  (* Connection string is valid *)
  connection_string â‰  ""
  
  (* Query queue not full *)
  #query_queue < 1000
  
  (* Buffer has capacity *)
  #result_buffer < buffer_capacity
post
  (* Query added to pending *)
  query_id! âˆˆ pending_queries' âˆ§ query_id! âˆ‰ pending_queries
  
  (* Query queued *)
  query_id! âˆˆ ran query_queue'
  
  (* Queue maintains order *)
  query_queue' = query_queue âŒ¢ âŸ¨query_id!âŸ©
end

(*
 * CompleteDatabaseOperation - Contract for database result handling
 *)
schema CompleteDatabaseOperation
  Î”DatabasePipe
  result?: DatabaseResult                  (* Input: query result *)
pre
  (* Query was pending *)
  result?.query_id âˆˆ pending_queries
  
  (* Pipe is connected *)
  is_connected
post
  (* Query moved to completed *)
  result?.query_id âˆ‰ pending_queries' âˆ§
  result?.query_id âˆˆ completed_queries'
  
  (* Query removed from queue *)
  result?.query_id âˆ‰ ran query_queue'
  
  (* Result event added to buffer if space *)
  #result_buffer' â‰¤ buffer_capacity
end

(*
 * Database Connection Management
 *)
schema EstablishDatabaseConnection
  Î”DatabasePipe
  conn_string?: String                     (* Input: connection string *)
pre
  (* Not currently connected *)
  Â¬is_connected
  
  (* Valid connection string *)
  conn_string? â‰  ""
post
  (* Connection established *)
  is_connected' âˆ§
  connection_string' = conn_string?
  
  (* Queues initialized *)
  pending_queries' = âˆ… âˆ§
  completed_queries' = âˆ… âˆ§
  query_queue' = âŸ¨âŸ© âˆ§
  result_buffer' = âŸ¨âŸ©
end

schema CloseDatabaseConnection
  Î”DatabasePipe
pre
  (* Currently connected *)
  is_connected
  
  (* No pending queries *)
  pending_queries = âˆ…
  
  (* Queue is empty *)
  #query_queue = 0
post
  (* Connection closed *)
  Â¬is_connected' âˆ§
  connection_string' = ""
  
  (* All state cleared *)
  pending_queries' = âˆ… âˆ§
  completed_queries' = âˆ…
end

(*
 * Database Pipe Invariants
 *)
schema DatabasePipeInvariants
  DatabasePipe
where
  (* Pending queries are in queue *)
  ran query_queue âŠ† pending_queries
  
  (* No query in both pending and completed *)
  pending_queries âˆ© completed_queries = âˆ…
  
  (* Buffer respects capacity *)
  #result_buffer â‰¤ buffer_capacity
  
  (* Connected pipe has valid connection string *)
  is_connected â‡’ connection_string â‰  ""
end

(* ============================================ *)
(* Network Communication Contract              *)
(* ============================================ *)

(*
 * Network Message Envelope
 *)
schema NetworkEnvelope
  source_address: String                   (* Source network address *)
  dest_address: String                     (* Destination address *)
  message: Message                         (* Encapsulated message *)
  sequence_number: â„•                       (* Message sequence number *)
  checksum: â„•                              (* Message checksum *)
  timestamp: â„•                             (* Send timestamp *)
where
  (* Valid addresses *)
  source_address â‰  "" âˆ§ dest_address â‰  ""
  
  (* Sequence number is non-negative *)
  sequence_number â‰¥ 0
  
  (* Timestamp is valid *)
  timestamp > 0
end

(*
 * SendNetworkMessage - Contract for network send
 *)
schema SendNetworkMessage
  Î”SystemState
  envelope?: NetworkEnvelope               (* Input: message envelope *)
pre
  (* Source reactor exists *)
  (âˆƒ r : reactors @ r.reactor_id = envelope?.message.sender_id)
  
  (* Destination reactor exists (may be on another machine) *)
  envelope?.message.receiver_id > 0
  
  (* Network topology allows communication *)
  (âˆƒ sender_id : dom network_topology @ 
    sender_id = envelope?.message.sender_id âˆ§
    envelope?.message.receiver_id âˆˆ network_topology(sender_id))
post
  (* Message eventually delivered to receiver's external queue *)
  (âˆƒ r : reactors' | r.reactor_id = envelope?.message.receiver_id @
    envelope?.message âˆˆ ran r.external_queue.items) âˆ¨
  (* Or queued for delivery if receiver not local *)
  (envelope?.message.receiver_id âˆ‰ {r : reactors @ r.reactor_id})
  
  (* Checksum validated *)
  envelope?.checksum > 0
end

(*
 * ReceiveNetworkMessage - Contract for network receive
 *)
schema ReceiveNetworkMessage
  Î”SystemState
  envelope?: NetworkEnvelope               (* Input: received envelope *)
pre
  (* Destination reactor exists locally *)
  (âˆƒ r : reactors @ r.reactor_id = envelope?.message.receiver_id)
  
  (* Checksum is valid *)
  envelope?.checksum > 0
post
  (* Message added to receiver's queue *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = envelope?.message.receiver_id âˆ§
    r_old.reactor_id = envelope?.message.receiver_id @
    envelope?.message âˆˆ ran r'.external_queue.items âˆ§
    envelope?.message âˆ‰ ran r_old.external_queue.items)
end

(* ============================================ *)
(* Integration Error Handling                  *)
(* ============================================ *)

(*
 * Error Severity Levels
 *)
ErrorSeverity ::= 
  | WARNING       (* Recoverable issue *)
  | ERROR         (* Operation failed *)
  | CRITICAL      (* System integrity at risk *)

(*
 * IntegrationError - Error in external integration
 *)
schema IntegrationError
  error_id: ID                             (* Unique error ID *)
  source: EventSource                      (* Error source *)
  severity: ErrorSeverity                  (* Error severity *)
  message: String                          (* Error description *)
  timestamp: â„•                             (* Error occurrence time *)
  related_operation: ID                    (* Related operation ID *)
where
  (* Valid error ID *)
  error_id > 0
  
  (* Message is non-empty *)
  message â‰  ""
  
  (* Timestamp is valid *)
  timestamp > 0
  
  (* Related operation is valid *)
  related_operation > 0
end

(*
 * HandleIntegrationError - Error handling contract
 *)
schema HandleIntegrationError
  Î”SystemState
  error?: IntegrationError                 (* Input: error to handle *)
pre
  (* Error source is valid *)
  error?.source âˆˆ {GPUStream, DatabasePipe, NetworkInterface}
post
  (* Critical errors stop affected component *)
  error?.severity = CRITICAL â‡’
    ((error?.source = GPUStream â‡’
      (âˆƒ g : gpu_streams', g_old : gpu_streams @ 
        Â¬g'.is_active âˆ§ g_old.is_active)) âˆ¨
     (error?.source = DatabasePipe â‡’
      (âˆƒ d : db_pipes', d_old : db_pipes @ 
        Â¬d'.is_connected âˆ§ d_old.is_connected)))
  
  (* Related session marked as failed *)
  (âˆƒ r : reactors', h : dom r'.session_map @
    r'.session_map(h).state = FAILED)
end

(* ============================================ *)
(* Integration Health Monitoring               *)
(* ============================================ *)

(*
 * HealthStatus - Component health state
 *)
HealthStatus ::= HEALTHY | DEGRADED | UNHEALTHY | UNKNOWN

(*
 * ComponentHealth - Health metrics for external component
 *)
schema ComponentHealth
  component: EventSource                   (* Component being monitored *)
  status: HealthStatus                     (* Current health status *)
  latency_ms: â„•                            (* Average latency *)
  error_rate: â„                            (* Error rate (0.0 to 1.0) *)
  last_check: â„•                            (* Last health check timestamp *)
where
  (* Error rate is valid percentage *)
  error_rate â‰¥ 0.0 âˆ§ error_rate â‰¤ 1.0
  
  (* Latency is non-negative *)
  latency_ms â‰¥ 0
  
  (* Last check is valid *)
  last_check > 0
  
  (* Status reflects metrics *)
  (error_rate < 0.01 âˆ§ latency_ms < 100 â‡’ status = HEALTHY) âˆ§
  (error_rate > 0.1 âˆ¨ latency_ms > 1000 â‡’ status âˆˆ {DEGRADED, UNHEALTHY})
end

(*
 * MonitorIntegrationHealth - Health check operation
 *)
schema MonitorIntegrationHealth
  ÎžSystemState
  health!: seq ComponentHealth             (* Output: health status *)
where
  (* Health reported for all external components *)
  #health! â‰¥ 3 âˆ§
  
  (* GPU streams monitored *)
  (âˆƒ h : ran health! @ h.component = GPUStream) âˆ§
  
  (* Database pipes monitored *)
  (âˆƒ h : ran health! @ h.component = DatabasePipe) âˆ§
  
  (* Network monitored *)
  (âˆƒ h : ran health! @ h.component = NetworkInterface)
end

(* ============================================ *)
(* Rate Limiting and Backpressure              *)
(* ============================================ *)

(*
 * RateLimiter - Rate limiting configuration
 *)
schema RateLimiter
  max_requests_per_second: â„•               (* Request rate limit *)
  current_window_requests: â„•               (* Requests in current window *)
  window_start: â„•                          (* Current window start time *)
  window_duration_ms: â„•                    (* Window duration *)
where
  (* Valid rate limit *)
  max_requests_per_second > 0
  
  (* Current count within limit *)
  current_window_requests â‰¤ max_requests_per_second
  
  (* Window duration is positive *)
  window_duration_ms > 0
end

(*
 * ApplyRateLimit - Rate limiting check
 *)
schema ApplyRateLimit
  Î”RateLimiter
  current_time?: â„•                         (* Input: current timestamp *)
  allowed!: ð”¹                              (* Output: request allowed *)
pre
  (* Valid timestamp *)
  current_time? > 0
post
  (* Window reset if expired *)
  (current_time? > window_start + window_duration_ms â‡’
    window_start' = current_time? âˆ§
    current_window_requests' = 0)
  
  (* Request allowed if under limit *)
  allowed! â‡” current_window_requests < max_requests_per_second
  
  (* Counter incremented if allowed *)
  allowed! â‡’ current_window_requests' = current_window_requests + 1
end

(*
 * BackpressureSignal - Backpressure indication
 *)
schema BackpressureSignal
  component: EventSource                   (* Component signaling *)
  severity: â„•                              (* Pressure level 0-10 *)
  recommended_delay_ms: â„•                  (* Suggested delay *)
  timestamp: â„•                             (* Signal timestamp *)
where
  (* Severity in range *)
  severity â‰¥ 0 âˆ§ severity â‰¤ 10
  
  (* Delay is reasonable *)
  recommended_delay_ms â‰¥ 0 âˆ§ recommended_delay_ms â‰¤ 10000
  
  (* Timestamp is valid *)
  timestamp > 0
end

(*
 * HandleBackpressure - Backpressure response
 *)
schema HandleBackpressure
  Î”SystemState
  signal?: BackpressureSignal              (* Input: backpressure signal *)
pre
  (* Signal from valid source *)
  signal?.component âˆˆ {GPUStream, DatabasePipe, NetworkInterface}
post
  (* High severity reduces operation submission *)
  signal?.severity > 7 â‡’
    (âˆ€ r : reactors' @ 
      #r'.command_queue.items â‰¤ #r.command_queue.items)
  
  (* Medium severity pauses new sessions *)
  signal?.severity > 4 âˆ§ signal?.severity â‰¤ 7 â‡’
    (âˆ€ i : initiators' @ 
      #i'.active_sessions â‰¤ #i.active_sessions)
end
