(*
 * HyperMind Operations Formal Specification
 * Z++ Specification of System Operations and State Transitions
 *
 * This module defines all operations that modify system state,
 * including their preconditions, postconditions, and invariant preservation.
 *)

(* Import previous specifications *)
include data_model
include system_state

(* ============================================ *)
(* Session Management Operations               *)
(* ============================================ *)

(*
 * CreateSession - Initiates a new neural network computation session
 *)
schema CreateSession
  Î”SystemState                            (* System state changes *)
  i?: ID                                   (* Input: initiator ID *)
  session_id!: ID                          (* Output: new session ID *)
  layers?: seq ID                          (* Input: layer sequence *)
pre
  (* Initiator exists and is running *)
  (âˆƒ init : initiators @ init.initiator_id = i? âˆ§ init.is_running)
  
  (* Layer sequence is valid *)
  #layers? > 0 âˆ§ (âˆ€ l : ran layers? @ l âˆˆ dom layer_registry)
  
  (* At least one reactor is available *)
  (âˆƒ init : initiators | init.initiator_id = i? @ 
    #init.available_reactors > 0)
post
  (* New session ID is unique *)
  session_id! âˆ‰ (â‹ƒ{init : initiators @ init.active_sessions âˆª 
                                         init.completed_sessions âˆª 
                                         init.failed_sessions})
  
  (* Session added to initiator's active sessions *)
  (âˆƒ init : initiators', init_old : initiators | 
    init.initiator_id = i? âˆ§ init_old.initiator_id = i? @
    init.active_sessions = init_old.active_sessions âˆª {session_id!} âˆ§
    init.sessions_created = init_old.sessions_created + 1)
  
  (* SessionState created in a reactor *)
  (âˆƒ r : reactors', h : hash_t @ 
    h âˆˆ dom r.session_map âˆ§
    r.session_map(h).session_id = session_id! âˆ§
    r.session_map(h).state = INIT âˆ§
    r.session_map(h).layer_index = 0 âˆ§
    r.session_map(h).completed_layers = âˆ… âˆ§
    r.session_map(h).pending_operations = 0)
  
  (* Reactor marked as busy *)
  (âˆƒ init : initiators', r : reactors', init_old : initiators |
    init.initiator_id = i? âˆ§ init_old.initiator_id = i? @
    r.reactor_id âˆˆ init.busy_reactors âˆ§
    r.reactor_id âˆ‰ init_old.busy_reactors)
  
  (* System timestamp updated *)
  system_time' > system_time
end

(*
 * GetSessionState - Retrieves current state of a session
 *)
schema GetSessionState
  ÎSystemState                            (* System state unchanged *)
  session_id?: ID                          (* Input: session ID *)
  state!: SessionState                     (* Output: session state *)
pre
  (* Session exists in some reactor *)
  (âˆƒ r : reactors @ 
    (âˆƒ h : dom r.session_map @ 
      r.session_map(h).session_id = session_id?))
post
  (* Returned state matches session *)
  (âˆƒ r : reactors, h : dom r.session_map @ 
    r.session_map(h).session_id = session_id? âˆ§
    state! = r.session_map(h))
end

(*
 * CompleteSession - Marks a session as completed
 *)
schema CompleteSession
  Î”SystemState
  session_id?: ID                          (* Input: session ID *)
  success?: ğ”¹                              (* Input: success status *)
pre
  (* Session exists and is active *)
  (âˆƒ init : initiators @ session_id? âˆˆ init.active_sessions)
  
  (* Session state indicates completion *)
  (âˆƒ r : reactors, h : dom r.session_map @ 
    r.session_map(h).session_id = session_id? âˆ§
    r.session_map(h).pending_operations = 0)
post
  (* Session moved to appropriate set *)
  (âˆƒ init : initiators', init_old : initiators @ 
    session_id? âˆˆ init_old.active_sessions âˆ§
    session_id? âˆ‰ init'.active_sessions âˆ§
    (success? â‡’ session_id? âˆˆ init'.completed_sessions) âˆ§
    (Â¬success? â‡’ session_id? âˆˆ init'.failed_sessions))
  
  (* Session removed from reactor *)
  (âˆ€ r : reactors' @ 
    (âˆ€ h : dom r.session_map @ 
      r.session_map(h).session_id â‰  session_id?))
  
  (* Reactor marked as available *)
  (âˆƒ init : initiators', r_old : reactors, init_old : initiators |
    (âˆƒ h : dom r_old.session_map @ 
      r_old.session_map(h).session_id = session_id?) @
    r_old.reactor_id âˆˆ init_old.busy_reactors âˆ§
    r_old.reactor_id âˆ‰ init'.busy_reactors)
end

(* ============================================ *)
(* Command Processing Operations               *)
(* ============================================ *)

(*
 * EnqueueCommand - Adds a command to a reactor's command queue
 *)
schema EnqueueCommand
  Î”NeuralReactor                          (* Reactor state changes *)
  cmd?: Command                            (* Input: command to enqueue *)
  priority?: â„•                             (* Input: command priority *)
pre
  (* Reactor is running *)
  is_running
  
  (* Command queue not full *)
  Â¬(command_queue.is_full)
  
  (* Command references valid session *)
  (âˆƒ h : dom session_map @ 
    session_map(h).session_id = cmd?.session_id)
  
  (* Priority is valid *)
  priority? â‰¥ 0 âˆ§ priority? â‰¤ 10
post
  (* Command added to queue maintaining priority order *)
  cmd? âˆˆ ran command_queue'.items âˆ§
  #command_queue'.items = #command_queue.items + 1 âˆ§
  
  (* Queue remains sorted by priority *)
  (âˆ€ i, j : 1..#command_queue'.priorities | i < j @ 
    command_queue'.priorities(i) â‰¤ command_queue'.priorities(j))
end

(*
 * ExecuteCommand - Processes a command from the queue
 *)
schema ExecuteCommand
  Î”SystemState
  reactor_id?: ID                          (* Input: executing reactor *)
pre
  (* Reactor exists and is running *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id? âˆ§ r.is_running)
  
  (* Command queue has items *)
  (âˆƒ r : reactors | r.reactor_id = reactor_id? @ 
    #r.command_queue.items > 0)
post
  (* Command removed from queue *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    #r'.command_queue.items = #r_old.command_queue.items - 1)
  
  (* Processed message count incremented *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    r'.processed_messages = r_old.processed_messages + 1)
  
  (* System timestamp updated *)
  system_time' > system_time
end

(*
 * ExecuteFeedForward - Executes a feedforward computation command
 *)
schema ExecuteFeedForward
  Î”SystemState
  cmd?: FeedForward                        (* Input: feedforward command *)
  reactor_id?: ID                          (* Input: executing reactor *)
  result!: NDArray                         (* Output: computation result *)
pre
  (* Reactor exists *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id?)
  
  (* Session exists in reactor *)
  (âˆƒ r : reactors, h : dom r.session_map | r.reactor_id = reactor_id? @ 
    r.session_map(h).session_id = cmd?.session_id)
  
  (* Input array is valid *)
  #cmd?.input.data > 0 âˆ§ #cmd?.input.shape > 0
  
  (* Layer exists in registry *)
  cmd?.layer.layer_ref âˆˆ dom layer_registry
post
  (* Result array has correct shape *)
  (âˆƒ layer : ran layer_registry | layer.layer_id = cmd?.layer.layer_ref @
    result!.shape = âŸ¨layer.output_sizeâŸ©)
  
  (* Session state updated *)
  (âˆƒ r : reactors', r_old : reactors, h : dom r'.session_map | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? âˆ§
    r'.session_map(h).session_id = cmd?.session_id @
    r'.session_map(h).layer_index = r_old.session_map(h).layer_index + 1 âˆ§
    r'.session_map(h).completed_layers = 
      r_old.session_map(h).completed_layers âˆª {r_old.session_map(h).layer_index})
  
  (* Result stored in ndarray_map *)
  (âˆƒ r : reactors', h : hash_t | r.reactor_id = reactor_id? @
    h âˆˆ dom r'.ndarray_map âˆ§ r'.ndarray_map(h) = result!)
  
  (* Next commands enqueued if present *)
  #cmd?.next_commands > 0 â‡’
    (âˆƒ r : reactors', r_old : reactors | 
      r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
      #r'.command_queue.items â‰¥ #r_old.command_queue.items)
end

(* ============================================ *)
(* Message Handling Operations                 *)
(* ============================================ *)

(*
 * SendMessage - Sends a message from one reactor to another
 *)
schema SendMessage
  Î”SystemState
  sender?: ID                              (* Input: sender reactor ID *)
  receiver?: ID                            (* Input: receiver reactor ID *)
  msg?: Message                            (* Input: message to send *)
pre
  (* Sender and receiver exist *)
  (âˆƒ r1 : reactors @ r1.reactor_id = sender?) âˆ§
  (âˆƒ r2 : reactors @ r2.reactor_id = receiver?)
  
  (* Message fields are consistent *)
  msg?.sender_id = sender? âˆ§ msg?.receiver_id = receiver?
  
  (* Receiver queue not full *)
  (âˆƒ r : reactors | r.reactor_id = receiver? @ 
    Â¬r.external_queue.is_full)
  
  (* Sender is running *)
  (âˆƒ r : reactors | r.reactor_id = sender? @ r.is_running)
post
  (* Message added to receiver's external queue *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = receiver? âˆ§ r_old.reactor_id = receiver? @
    msg? âˆˆ ran r'.external_queue.items âˆ§
    #r'.external_queue.items = #r_old.external_queue.items + 1)
  
  (* Queue maintains priority order *)
  (âˆƒ r : reactors' | r.reactor_id = receiver? @
    (âˆ€ i, j : 1..#r.external_queue.priorities | i < j @ 
      r.external_queue.priorities(i) â‰¤ r.external_queue.priorities(j)))
end

(*
 * ReceiveMessage - Retrieves and processes message from queue
 *)
schema ReceiveMessage
  Î”NeuralReactor
  msg!: Message                            (* Output: received message *)
pre
  (* Reactor is running *)
  is_running
  
  (* External queue has messages *)
  #external_queue.items > 0
post
  (* Highest priority message removed *)
  msg! = external_queue.items(1) âˆ§
  external_queue'.items = tail external_queue.items âˆ§
  external_queue'.priorities = tail external_queue.priorities
  
  (* Processed count incremented *)
  processed_messages' = processed_messages + 1
end

(*
 * HandleActivateMessage - Processes activation message
 *)
schema HandleActivateMessage
  Î”NeuralReactor
  session_id?: ID                          (* Input: session ID *)
  sum_array?: ValueArray                   (* Input: activation sum *)
pre
  (* Session exists *)
  (âˆƒ h : dom session_map @ session_map(h).session_id = session_id?)
  
  (* Sum array is valid *)
  #sum_array?.array.data > 0
post
  (* Session state updated *)
  (âˆƒ h : dom session_map', h_old : dom session_map | 
    session_map'(h).session_id = session_id? âˆ§
    session_map(h_old).session_id = session_id? @
    session_map'(h).state = PROCESSING âˆ§
    session_map'(h).pending_operations = 
      session_map(h_old).pending_operations + 1)
  
  (* Array stored in map *)
  (âˆƒ h : hash_t @ 
    h âˆˆ dom ndarray_map' âˆ§ 
    ndarray_map'(h) = sum_array?.array)
end

(* ============================================ *)
(* GPU Event Handling Operations               *)
(* ============================================ *)

(*
 * SubmitGPUOperation - Submits computation to GPU
 *)
schema SubmitGPUOperation
  Î”SystemState
  reactor_id?: ID                          (* Input: requesting reactor *)
  op_id!: ID                               (* Output: operation ID *)
  input?: NDArray                          (* Input: data to process *)
pre
  (* Reactor exists and is running *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id? âˆ§ r.is_running)
  
  (* GPU stream available *)
  (âˆƒ g : gpu_streams @ 
    g.is_active âˆ§ 
    g.memory_allocated + #input?.data * 4 â‰¤ g.memory_capacity)
  
  (* Input is on GPU or can be transferred *)
  input?.device âˆˆ {GPU, CPU}
post
  (* Operation added to GPU stream *)
  (âˆƒ g : gpu_streams', g_old : gpu_streams @ 
    op_id! âˆˆ g'.pending_ops âˆ§
    op_id! âˆ‰ g_old.pending_ops âˆ§
    op_id! âˆˆ ran g'.operation_queue)
  
  (* Memory allocated for operation *)
  (âˆƒ g : gpu_streams', g_old : gpu_streams @ 
    g'.memory_allocated = g_old.memory_allocated + #input?.data * 4)
  
  (* Reactor session marked as waiting *)
  (âˆƒ r : reactors', h : dom r'.session_map | r.reactor_id = reactor_id? @
    r'.session_map(h).state = WAITING_GPU)
end

(*
 * HandleGPUEvent - Processes GPU completion event
 *)
schema HandleGPUEvent
  Î”SystemState
  event?: Event                            (* Input: GPU event *)
  reactor_id?: ID                          (* Input: reactor handling event *)
pre
  (* Event is GPU event *)
  event?.source = GPUStream
  
  (* Reactor exists *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id?)
  
  (* Event in reactor's GPU queue *)
  (âˆƒ r : reactors | r.reactor_id = reactor_id? @ 
    event? âˆˆ ran r.gpu_queue)
post
  (* Event removed from queue *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    event? âˆ‰ ran r'.gpu_queue âˆ§ event? âˆˆ ran r_old.gpu_queue)
  
  (* Operation marked complete in GPU stream *)
  (âˆƒ g : gpu_streams', g_old : gpu_streams, op_id : ID @ 
    op_id âˆˆ g_old.pending_ops âˆ§
    op_id âˆ‰ g'.pending_ops âˆ§
    op_id âˆˆ g'.completed_ops)
  
  (* Memory freed *)
  (âˆƒ g : gpu_streams', g_old : gpu_streams @ 
    g'.memory_allocated < g_old.memory_allocated)
  
  (* Session state updated *)
  (âˆƒ r : reactors', h : dom r'.session_map | r.reactor_id = reactor_id? @
    r'.session_map(h).state = PROCESSING âˆ§
    r'.session_map(h).pending_operations = 
      r.session_map(h).pending_operations - 1)
end

(* ============================================ *)
(* Database Operations                         *)
(* ============================================ *)

(*
 * SubmitDatabaseQuery - Submits persistence query
 *)
schema SubmitDatabaseQuery
  Î”SystemState
  reactor_id?: ID                          (* Input: requesting reactor *)
  query_id!: ID                            (* Output: query ID *)
  data?: NDArray                           (* Input: data to persist *)
pre
  (* Reactor exists *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id?)
  
  (* Database pipe available and connected *)
  (âˆƒ d : db_pipes @ 
    d.is_connected âˆ§ #d.query_queue < 1000)
  
  (* Data is valid *)
  #data?.data > 0
post
  (* Query added to database pipe *)
  (âˆƒ d : db_pipes', d_old : db_pipes @ 
    query_id! âˆˆ d'.pending_queries âˆ§
    query_id! âˆ‰ d_old.pending_queries âˆ§
    query_id! âˆˆ ran d'.query_queue)
  
  (* Session marked as waiting *)
  (âˆƒ r : reactors', h : dom r'.session_map | r.reactor_id = reactor_id? @
    r'.session_map(h).state = WAITING_DB âˆ§
    r'.session_map(h).pending_operations = 
      r.session_map(h).pending_operations + 1)
end

(*
 * HandleDatabaseEvent - Processes database result
 *)
schema HandleDatabaseEvent
  Î”SystemState
  event?: Event                            (* Input: database event *)
  reactor_id?: ID                          (* Input: reactor handling event *)
pre
  (* Event is database event *)
  event?.source = DatabasePipe
  
  (* Reactor exists *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id?)
  
  (* Event in reactor's DB queue *)
  (âˆƒ r : reactors | r.reactor_id = reactor_id? @ 
    event? âˆˆ ran r.db_queue)
post
  (* Event removed from queue *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    event? âˆ‰ ran r'.db_queue âˆ§ event? âˆˆ ran r_old.db_queue)
  
  (* Query marked complete *)
  (âˆƒ d : db_pipes', d_old : db_pipes, query_id : ID @ 
    query_id âˆˆ d_old.pending_queries âˆ§
    query_id âˆ‰ d'.pending_queries âˆ§
    query_id âˆˆ d'.completed_queries)
  
  (* Session state updated *)
  (âˆƒ r : reactors', h : dom r'.session_map | r.reactor_id = reactor_id? @
    r'.session_map(h).state = PROCESSING âˆ§
    r'.session_map(h).pending_operations = 
      r.session_map(h).pending_operations - 1)
end

(* ============================================ *)
(* Reactor Lifecycle Operations                *)
(* ============================================ *)

(*
 * StartReactor - Initializes and starts a reactor
 *)
schema StartReactor
  Î”SystemState
  reactor_id?: ID                          (* Input: reactor to start *)
  rank?: Rank                              (* Input: reactor rank *)
pre
  (* Reactor exists but is not running *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id? âˆ§ Â¬r.is_running)
  
  (* System has capacity for another running reactor *)
  #reactors < max_reactors
post
  (* Reactor marked as running *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    r'.is_running âˆ§ Â¬r_old.is_running âˆ§
    r'.rank = rank?)
end

(*
 * StopReactor - Gracefully stops a reactor
 *)
schema StopReactor
  Î”SystemState
  reactor_id?: ID                          (* Input: reactor to stop *)
pre
  (* Reactor exists and is running *)
  (âˆƒ r : reactors @ r.reactor_id = reactor_id? âˆ§ r.is_running)
  
  (* No active sessions *)
  (âˆƒ r : reactors | r.reactor_id = reactor_id? @ 
    #r.session_map = 0)
  
  (* All queues empty *)
  (âˆƒ r : reactors | r.reactor_id = reactor_id? @ 
    #r.internal_queue.items = 0 âˆ§
    #r.external_queue.items = 0 âˆ§
    #r.command_queue.items = 0)
post
  (* Reactor marked as stopped *)
  (âˆƒ r : reactors', r_old : reactors | 
    r.reactor_id = reactor_id? âˆ§ r_old.reactor_id = reactor_id? @
    Â¬r'.is_running âˆ§ r_old.is_running)
  
  (* Reactor removed from busy set *)
  (âˆ€ init : initiators' @ reactor_id? âˆ‰ init'.busy_reactors)
end

(*
 * ReactorRunLoop - Main execution loop iteration
 *)
schema ReactorRunLoop
  Î”NeuralReactor
pre
  (* Reactor is running *)
  is_running
post
  (* Process highest priority item from available queues *)
  ((#external_queue.items > 0) âˆ¨
   (#command_queue.items > 0) âˆ¨
   (#gpu_queue > 0) âˆ¨
   (#db_queue > 0)) â‡’
   processed_messages' > processed_messages
  
  (* Queues maintain invariants *)
  #session_map' â‰¤ max_sessions
end
