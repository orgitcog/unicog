(*
 * HyperMind System State Formal Specification
 * Z++ Specification of System-Wide State and Actor State
 *
 * This module defines the complete system state including all actors,
 * their internal state, queues, and global system invariants.
 *)

(* Import data model definitions *)
include data_model

(* ============================================ *)
(* Queue Structures                            *)
(* ============================================ *)

(*
 * PriorityQueue - Priority-based message queue
 * Messages with lower priority values are processed first
 *)
schema PriorityQueue[T]
  items: seq T             (* Queue items *)
  priorities: seq â„•        (* Corresponding priorities *)
  capacity: â„•              (* Maximum queue capacity *)
where
  (* Items and priorities have same length *)
  #items = #priorities
  
  (* Queue respects capacity constraint *)
  #items â‰¤ capacity
  
  (* Items are ordered by priority (ascending) *)
  (âˆ€ i, j : 1..#priorities | i < j @ priorities(i) â‰¤ priorities(j))
  
  (* Capacity is positive *)
  capacity > 0
end

(*
 * Queue state predicates
 *)
schema QueuePredicates[T]
  queue: PriorityQueue[T]
where
  is_empty â‡” #queue.items = 0
  is_full â‡” #queue.items = queue.capacity
  has_items â‡” #queue.items > 0
end

(* ============================================ *)
(* NeuralReactor State                         *)
(* ============================================ *)

(*
 * NeuralReactor represents the complete state of a single reactor actor.
 * It manages sessions, arrays, and processes messages from multiple queues.
 *)
schema NeuralReactor
  reactor_id: ID                          (* Unique reactor identifier *)
  
  (* State Maps *)
  session_map: SessionMap                  (* Active sessions *)
  ndarray_map: NDArrayMap                  (* Cached NDArrays *)
  
  (* Communication Queues *)
  internal_queue: PriorityQueue[Message]   (* Self-messages *)
  external_queue: PriorityQueue[Message]   (* External messages *)
  command_queue: PriorityQueue[Command]    (* Command queue *)
  
  (* Event Streams *)
  gpu_queue: seq Event                     (* GPU event stream *)
  db_queue: seq Event                      (* Database event stream *)
  
  (* Reactor Configuration *)
  rank: Rank                               (* Reactor rank *)
  max_sessions: â„•                          (* Max concurrent sessions *)
  
  (* Execution State *)
  is_running: ð”¹                            (* Whether reactor is active *)
  processed_messages: â„•                    (* Total messages processed *)
  
where
  (* Valid reactor ID *)
  reactor_id > 0
  
  (* Session count respects maximum *)
  #(dom session_map) â‰¤ max_sessions
  
  (* Queue capacities are reasonable *)
  internal_queue.capacity > 0 âˆ§
  external_queue.capacity > 0 âˆ§
  command_queue.capacity > 0
  
  (* GPU and DB queues are bounded *)
  #gpu_queue â‰¤ 1000 âˆ§ #db_queue â‰¤ 1000
  
  (* All messages in queues reference this reactor *)
  (âˆ€ m : ran internal_queue.items @ m.receiver_id = reactor_id) âˆ§
  (âˆ€ m : ran external_queue.items @ m.receiver_id = reactor_id)
  
  (* All sessions in map are in valid states *)
  (âˆ€ h : dom session_map @ 
    session_map(h).state â‰¥ 0 âˆ§
    session_map(h).pending_operations â‰¥ 0)
  
  (* Hash map invariants hold *)
  HashMapInvariants(session_map, ndarray_map)
  
  (* Max sessions is positive *)
  max_sessions > 0
  
  (* Processed message count is non-negative *)
  processed_messages â‰¥ 0
end

(* ============================================ *)
(* SessionInitiator State                      *)
(* ============================================ *)

(*
 * SessionInitiator orchestrates neural network computation sessions
 * by distributing work to NeuralReactors.
 *)
schema SessionInitiator
  initiator_id: ID                        (* Unique initiator identifier *)
  
  (* Session Management *)
  active_sessions: â„™ ID                   (* Currently active session IDs *)
  completed_sessions: â„™ ID                (* Completed session IDs *)
  failed_sessions: â„™ ID                   (* Failed session IDs *)
  
  (* Reactor Pool *)
  available_reactors: seq ID              (* Available reactor IDs *)
  busy_reactors: â„™ ID                     (* Busy reactor IDs *)
  
  (* Network Configuration *)
  layer_sequence: seq ID                  (* Network layer order *)
  
  (* Execution State *)
  is_running: ð”¹                            (* Whether initiator is active *)
  sessions_created: â„•                     (* Total sessions created *)
  
where
  (* Valid initiator ID *)
  initiator_id > 0
  
  (* Sessions are properly partitioned *)
  active_sessions âˆ© completed_sessions = âˆ…
  active_sessions âˆ© failed_sessions = âˆ…
  completed_sessions âˆ© failed_sessions = âˆ…
  
  (* Busy reactors are subset of available *)
  busy_reactors âŠ† ran available_reactors
  
  (* All reactors in pool are valid *)
  (âˆ€ r : ran available_reactors @ r > 0)
  
  (* No duplicate reactors *)
  #available_reactors = #(ran available_reactors)
  
  (* Layer sequence is non-empty *)
  #layer_sequence > 0
  
  (* All layers in sequence are valid *)
  (âˆ€ l : ran layer_sequence @ l > 0)
  
  (* Sessions created count is valid *)
  sessions_created = #active_sessions + #completed_sessions + #failed_sessions
end

(* ============================================ *)
(* GPU Stream State                            *)
(* ============================================ *)

(*
 * GPUStream represents the state of GPU computation resources
 * including pending operations and completed results.
 *)
schema GPUStream
  stream_id: ID                           (* Unique stream identifier *)
  
  (* Operation Tracking *)
  pending_ops: â„™ ID                       (* Pending operation IDs *)
  completed_ops: â„™ ID                     (* Completed operation IDs *)
  
  (* Resource State *)
  device_id: â„•                            (* GPU device number *)
  memory_allocated: â„•                     (* Bytes allocated *)
  memory_capacity: â„•                      (* Total GPU memory *)
  
  (* Operation Queue *)
  operation_queue: seq ID                 (* Queued operations *)
  
  (* State *)
  is_active: ð”¹                            (* Stream is active *)
  
where
  (* Valid stream ID *)
  stream_id > 0
  
  (* Operations are properly partitioned *)
  pending_ops âˆ© completed_ops = âˆ…
  
  (* Memory constraint *)
  memory_allocated â‰¤ memory_capacity
  
  (* Valid device ID *)
  device_id â‰¥ 0
  
  (* All queued operations are pending *)
  ran operation_queue âŠ† pending_ops
  
  (* Memory values are non-negative *)
  memory_capacity > 0
end

(* ============================================ *)
(* Database Pipe State                         *)
(* ============================================ *)

(*
 * DatabasePipe represents the state of database connection
 * including pending queries and result buffer.
 *)
schema DatabasePipe
  pipe_id: ID                             (* Unique pipe identifier *)
  
  (* Connection State *)
  connection_string: String               (* Database connection *)
  is_connected: ð”¹                         (* Connection status *)
  
  (* Operation Tracking *)
  pending_queries: â„™ ID                   (* Pending query IDs *)
  completed_queries: â„™ ID                 (* Completed query IDs *)
  
  (* Query Queue *)
  query_queue: seq ID                     (* Queued queries *)
  
  (* Buffer *)
  result_buffer: seq Event                (* Result event buffer *)
  buffer_capacity: â„•                      (* Max buffer size *)
  
where
  (* Valid pipe ID *)
  pipe_id > 0
  
  (* Connection string is non-empty when connected *)
  is_connected â‡’ connection_string â‰  ""
  
  (* Queries are properly partitioned *)
  pending_queries âˆ© completed_queries = âˆ…
  
  (* All queued queries are pending *)
  ran query_queue âŠ† pending_queries
  
  (* Result buffer respects capacity *)
  #result_buffer â‰¤ buffer_capacity
  
  (* Buffer capacity is positive *)
  buffer_capacity > 0
end

(* ============================================ *)
(* Global System State                         *)
(* ============================================ *)

(*
 * SystemState represents the complete state of the HyperMind system
 * including all actors, external resources, and global invariants.
 *)
schema SystemState
  (* Actors *)
  reactors: â„™ NeuralReactor               (* All reactor actors *)
  initiators: â„™ SessionInitiator          (* All initiator actors *)
  
  (* External Resources *)
  gpu_streams: â„™ GPUStream                (* GPU computation streams *)
  db_pipes: â„™ DatabasePipe                (* Database connections *)
  
  (* Global State *)
  network_topology: ID â‡¸ â„™ ID             (* Reactor connectivity graph *)
  layer_registry: ID â‡¸ Layer              (* All network layers *)
  
  (* System Configuration *)
  max_reactors: â„•                         (* Maximum reactor instances *)
  system_time: â„•                          (* Current system timestamp *)
  
where
  (* All reactor IDs are unique *)
  (âˆ€ r1, r2 : reactors | r1 â‰  r2 @ r1.reactor_id â‰  r2.reactor_id)
  
  (* All initiator IDs are unique *)
  (âˆ€ i1, i2 : initiators | i1 â‰  i2 @ i1.initiator_id â‰  i2.initiator_id)
  
  (* Reactor count respects maximum *)
  #reactors â‰¤ max_reactors
  
  (* Network topology references valid reactors *)
  dom network_topology âŠ† {r : reactors @ r.reactor_id}
  (âˆ€ id : dom network_topology @ 
    ran network_topology(id) âŠ† {r : reactors @ r.reactor_id})
  
  (* All GPU streams have unique IDs *)
  (âˆ€ g1, g2 : gpu_streams | g1 â‰  g2 @ g1.stream_id â‰  g2.stream_id)
  
  (* All DB pipes have unique IDs *)
  (âˆ€ d1, d2 : db_pipes | d1 â‰  d2 @ d1.pipe_id â‰  d2.pipe_id)
  
  (* Layer registry contains valid layers *)
  (âˆ€ l : ran layer_registry @ 
    l.input_size > 0 âˆ§ l.output_size > 0)
  
  (* At least one reactor exists if system is operational *)
  #initiators > 0 â‡’ #reactors > 0
  
  (* System time is monotonically increasing *)
  system_time â‰¥ 0
  
  (* Max reactors is positive *)
  max_reactors > 0
end

(* ============================================ *)
(* Distributed System Invariants               *)
(* ============================================ *)

(*
 * Global invariants that ensure system consistency in distributed setting
 *)
schema DistributedInvariants
  SystemState
where
  (* No session is simultaneously in multiple reactors with different states *)
  (âˆ€ r1, r2 : reactors | r1 â‰  r2 @ 
    (âˆ€ h1 : dom r1.session_map @ 
      (âˆ€ h2 : dom r2.session_map @ 
        r1.session_map(h1).session_id = r2.session_map(h2).session_id â‡’
        r1.session_map(h1).state = r2.session_map(h2).state)))
  
  (* Message receiver references valid reactor *)
  (âˆ€ r : reactors @ 
    (âˆ€ m : ran r.external_queue.items @ 
      (âˆƒ sender : reactors @ sender.reactor_id = m.sender_id)))
  
  (* GPU operations don't exceed stream capacity *)
  (âˆ€ g : gpu_streams @ 
    #g.pending_ops â‰¤ 1000)
  
  (* Database connections are properly managed *)
  (âˆ€ d : db_pipes @ 
    d.is_connected â‡’ #d.pending_queries < 1000)
end

(* ============================================ *)
(* Session Consistency                         *)
(* ============================================ *)

(*
 * Ensures session state consistency across the distributed system
 *)
schema SessionConsistency
  SystemState
where
  (* Each active session exists in at least one reactor *)
  (âˆ€ i : initiators @ 
    (âˆ€ s : i.active_sessions @ 
      (âˆƒ r : reactors @ 
        (âˆƒ h : dom r.session_map @ 
          r.session_map(h).session_id = s))))
  
  (* Completed sessions are not in any reactor *)
  (âˆ€ i : initiators @ 
    (âˆ€ s : i.completed_sessions @ 
      (âˆ€ r : reactors @ 
        (âˆ€ h : dom r.session_map @ 
          r.session_map(h).session_id â‰  s))))
  
  (* Session layer index is within network bounds *)
  (âˆ€ r : reactors @ 
    (âˆ€ h : dom r.session_map @ 
      (âˆƒ i : initiators @ 
        r.session_map(h).layer_index < #i.layer_sequence)))
end

(* ============================================ *)
(* Resource Allocation Invariants              *)
(* ============================================ *)

(*
 * Ensures proper resource allocation and prevents resource leaks
 *)
schema ResourceInvariants
  SystemState
where
  (* Total GPU memory allocation is bounded *)
  (âˆ‘{g : gpu_streams @ g.memory_allocated}) â‰¤ 
    (âˆ‘{g : gpu_streams @ g.memory_capacity})
  
  (* Each reactor's NDArrays fit in available GPU memory *)
  (âˆ€ r : reactors @ 
    (âˆƒ g : gpu_streams @ 
      (âˆ‘{h : dom r.ndarray_map | r.ndarray_map(h).device = GPU @ 
        #r.ndarray_map(h).data * 4}) â‰¤ g.memory_capacity))
  
  (* Queue capacities prevent unbounded growth *)
  (âˆ€ r : reactors @ 
    #r.internal_queue.items + #r.external_queue.items < 10000)
end

(* ============================================ *)
(* Liveness Properties                         *)
(* ============================================ *)

(*
 * Properties ensuring system progress and preventing deadlock
 *)
schema LivenessProperties
  SystemState
where
  (* If there are pending messages, at least one reactor is running *)
  ((âˆƒ r : reactors @ #r.external_queue.items > 0) â‡’
   (âˆƒ r : reactors @ r.is_running))
  
  (* If there are active sessions, at least one initiator is running *)
  ((âˆƒ i : initiators @ #i.active_sessions > 0) â‡’
   (âˆƒ i : initiators @ i.is_running))
  
  (* GPU streams with pending operations are active *)
  (âˆ€ g : gpu_streams @ #g.pending_ops > 0 â‡’ g.is_active)
  
  (* Connected DB pipes with pending queries process them *)
  (âˆ€ d : db_pipes @ 
    d.is_connected âˆ§ #d.pending_queries > 0 â‡’ #d.query_queue > 0)
end
