[
  {
    "file": "atomspace-storage/opencog/persist/proxy/CachingProxy.cc",
    "line": 48,
    "type": "FIXME",
    "content": "// XXX TODO Add support for expiration times, limited AtomSpace",
    "context": "}\n\n// Get our configuration from the ProxyParameterLink we live in.\n// XXX TODO Add support for expiration times, limited AtomSpace\n// size and whatever other whizzy caching ideas we might want.\nvoid CachingProxy::open(void)\n{\n"
  },
  {
    "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
    "line": 164,
    "type": "FIXME",
    "content": "// XXX this should be nuked, and replaced by appropriate kind of proxy.",
    "context": "// -----------------------------------------------\n// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n"
  },
  {
    "file": "atomspace/opencog/atoms/execution/ExecutionOutputLink.cc",
    "line": 155,
    "type": "FIXME",
    "content": "// XXX should be be unwrapping SetLinks here?",
    "context": "\t{\n\t\tif (not h->is_executable())\n\t\t{\n\t\t\t// XXX should be be unwrapping SetLinks here?\n\t\t\texargs.push_back(h);\n\t\t\tcontinue;\n\t\t}\n"
  },
  {
    "file": "atomspace/opencog/guile/modules/TypeUtilsSCM.cc",
    "line": 58,
    "type": "FIXME",
    "content": "// XXX HACK ALERT This needs to be static, in order for python to",
    "context": "\n// ========================================================\n\n// XXX HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// Oh well. I guess that's OK, since the definition is meant to be\n"
  },
  {
    "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
    "line": 126,
    "type": "FIXME",
    "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
    "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n"
  },
  {
    "file": "atomspace/opencog/query/PatternMatchEngine.cc",
    "line": 1116,
    "type": "FIXME",
    "content": "// XXX The current implementation is a brute-force search, and is highly",
    "context": "/// care about the rest, the moiety (which can be very large; thus\n/// \"sparse\".)\n//\n// XXX The current implementation is a brute-force search, and is highly\n// inefficient for truly sparse searches. A (vastly) superior search\n// woudld be to obtain the connected components in the search set, and\n// try to ground those.  This avoids the pointless odometer spinning.\n"
  },
  {
    "file": "atomspace/opencog/query/PatternMatchEngine.cc",
    "line": 1159,
    "type": "FIXME",
    "content": "// XXX TODO The logic here should be updated to resemble that",
    "context": "\tDO_LOG({LAZY_LOG_FINE << \"tree_comp NEW SETUP sparse term=\"\n\t                      << ptm->to_string();})\n\n\t// XXX TODO The logic here should be updated to resemble that\n\t// in curr_perm(), which deals correctly with nested permutations\n\t// of unordered patterns. For just right now, we are not\n\t// implementing nested sparse links, mostly because I'm too lazy\n"
  },
  {
    "file": "atomspace/opencog/query/PatternMatchEngine.cc",
    "line": 2066,
    "type": "FIXME",
    "content": "// XXX TODO FIXME. The ptm needs to be decomposed into connected",
    "context": "{\n\tlogmsg(\"Explore sparse: Start exploration\");\n\n\t// XXX TODO FIXME. The ptm needs to be decomposed into connected\n\t// components. Then only the connected components need to be walked\n\t// over.  That would be much more efficient.\n\tdo\n"
  },
  {
    "file": "cogserver/opencog/cogserver/server/CogServer.cc",
    "line": 125,
    "type": "FIXME",
    "content": "// XXX FIXME. terrible terrible hack. What we should be",
    "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
    "line": 361,
    "type": "FIXME",
    "content": "// XXX this needs to be replaced in the end, for now its just a cheesy",
    "context": "\tPatternMatchEngine::print_solution(var_grounding, pred_grounding);\n\n\t// And now for a cheesy hack to report the solution\n\t// XXX this needs to be replaced in the end, for now its just a cheesy\n\t// hack to pass data back to scheme.\n\tHandle hq = atom_space->addNode(ANCHOR_NODE, \"# QUERY SOLUTION\");\n\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/wsd/WordSenseProcessor.cc",
    "line": 120,
    "type": "FIXME",
    "content": "// XXX we are being called too often. this needs to be fixed.",
    "context": "{\n\trun_no_delay();\n\n\t// XXX we are being called too often. this needs to be fixed.\n\t// in truth, should only poll on new input.\n\tusleep(50*1000);\n}\n"
  },
  {
    "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
    "line": 229,
    "type": "FIXME",
    "content": "// XXX FIXME. This should be part of the LgDictNode but since",
    "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n"
  },
  {
    "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
    "line": 1256,
    "type": "TODO",
    "content": "// TODO: implement timestamp support",
    "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
  },
  {
    "file": "components/learning/moses/moses/moses/main/table-problems.cc",
    "line": 138,
    "type": "FIXME",
    "content": "// XXX FIXME -- the multiple tables should be merged into one.",
    "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
  },
  {
    "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
    "line": 566,
    "type": "FIXME",
    "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
    "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
  },
  {
    "file": "components/learning/moses/moses/moses/optimization/star-anneal.cc",
    "line": 42,
    "type": "FIXME",
    "content": "// XXX TODO the annealing temperature control code should be ported over",
    "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
  },
  {
    "file": "components/learning/moses/moses/moses/representation/representation.cc",
    "line": 236,
    "type": "FIXME",
    "content": "// XXX TODO need to add support for \"term algebra\" knobs",
    "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
  },
  {
    "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
    "line": 108,
    "type": "FIXME",
    "content": "// XXX FIXME complexity_t should be a double not an int ...",
    "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
  },
  {
    "file": "moses/moses/comboreduct/table/table_io.cc",
    "line": 99,
    "type": "TODO",
    "content": "// TODO: This routine should be extended so that comments that start",
    "context": "/// This ignores lines that start with a 'standard comment char'\n///\n//\n// TODO: This routine should be extended so that comments that start\n// somewhere other than column 0 are also ignored.\n//\n// The signature of this routine is the same as std:getline()\n"
  },
  {
    "file": "moses/moses/comboreduct/table/table_io.cc",
    "line": 1241,
    "type": "TODO",
    "content": "// TODO: implement timestamp support",
    "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
  },
  {
    "file": "moses/moses/moses/main/table-problems.cc",
    "line": 138,
    "type": "FIXME",
    "content": "// XXX FIXME -- the multiple tables should be merged into one.",
    "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
  },
  {
    "file": "moses/moses/moses/moses/mpi_moses.cc",
    "line": 570,
    "type": "FIXME",
    "content": "print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);",
    "context": "    bool done = false;\n\n    // Print legend for the columns of the stats.\n    print_stats_header(NULL, false /* XXX stats for diversity, should be fixed */);\n\n    // Main worker dispatch loop\n    while (true)\n"
  },
  {
    "file": "moses/moses/moses/moses/mpi_moses.cc",
    "line": 616,
    "type": "FIXME",
    "content": "// XXX TODO instead of overwritting the demeID it should be",
    "context": "        scored_combo_tree_set candidates;\n        stats.n_expansions ++;\n\n        // XXX TODO instead of overwritting the demeID it should be\n        // correctly defined by the worker and send back to the\n        // dispatcher. That way we can have the breadth_first\n        // componant of the demeID right.\n"
  },
  {
    "file": "moses/moses/moses/optimization/star-anneal.cc",
    "line": 42,
    "type": "FIXME",
    "content": "// XXX TODO the annealing temperature control code should be ported over",
    "context": "// Star-shaped search  //\n/////////////////////////\n\n// XXX TODO the annealing temperature control code should be ported over\n// to the hill-climbing code, thus rendering the below obsolete.  The\n// hill-climbing code is much more sophisticated in every way: correct\n// definition of the temperature, termination conditions, exploration of\n"
  },
  {
    "file": "moses/moses/moses/representation/representation.cc",
    "line": 238,
    "type": "FIXME",
    "content": "// XXX TODO need to add support for \"term algebra\" knobs",
    "context": "/// the instance supplied as the argument.\nvoid representation::transform(const instance& inst)\n{\n    // XXX TODO need to add support for \"term algebra\" knobs\n\n    contin_map_it ckb = contin.begin();\n    for (field_set::const_contin_iterator ci = _fields.begin_contin(inst);\n"
  },
  {
    "file": "moses/moses/moses/scoring/scoring_base.cc",
    "line": 142,
    "type": "FIXME",
    "content": "// XXX FIXME complexity_t should be a double not an int ...",
    "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
  },
  {
    "file": "ure/opencog/ure/BetaDistribution.cc",
    "line": 33,
    "type": "TODO",
    "content": "// TODO should be replaced by tv->get_mode() once implemented",
    "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n"
  },
  {
    "file": "analyze_issue_examples.py",
    "line": 13,
    "type": "FIXME",
    "content": "\"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",",
    "context": "    \"\"\"Process the specific FIXME examples from the issue description.\"\"\"\n    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n"
  },
  {
    "file": "analyze_issue_examples.py",
    "line": 42,
    "type": "FIXME",
    "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
    "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n"
  },
  {
    "file": "analyze_issue_examples.py",
    "line": 106,
    "type": "FIXME",
    "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
    "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n"
  },
  {
    "file": "implement_functional_fixes.py",
    "line": 42,
    "type": "TODO",
    "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
    "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n"
  },
  {
    "file": "implement_scheme_stubs.py",
    "line": 89,
    "type": "TODO",
    "content": "impl = indent_str + '; TODO: Implement full question handling logic\\n'",
    "context": "        # Question rule patterns\n        if 'Q-rule' in func_name or 'question' in func_name.lower():\n            # Return a query structure\n            impl = indent_str + '; TODO: Implement full question handling logic\\n'\n            impl += indent_str + '(display \"Warning: ' + func_name + ' not fully implemented\\\\n\")\\n'\n            impl += indent_str + '(ListLink)\\n'\n            return impl\n"
  },
  {
    "file": "implement_scheme_stubs.py",
    "line": 96,
    "type": "TODO",
    "content": "impl = indent_str + '; TODO: Implement full SVO/SVIO relationship logic\\n'",
    "context": "        \n        # Subject-Verb-Object patterns\n        elif any(pattern in func_name for pattern in ['SVO', 'SVIO', 'subj', 'obj']):\n            impl = indent_str + '; TODO: Implement full SVO/SVIO relationship logic\\n'\n            impl += indent_str + '(display \"Warning: ' + func_name + ' not fully implemented\\\\n\")\\n'\n            impl += indent_str + '(ListLink)\\n'\n            return impl\n"
  },
  {
    "file": "implement_scheme_stubs.py",
    "line": 103,
    "type": "TODO",
    "content": "impl = indent_str + '; TODO: Implement prepositional object handling\\n'",
    "context": "        \n        # Prepositional object patterns\n        elif 'pobj' in func_name.lower():\n            impl = indent_str + '; TODO: Implement prepositional object handling\\n'\n            impl += indent_str + '(display \"Warning: ' + func_name + ' not fully implemented\\\\n\")\\n'\n            impl += indent_str + '(ListLink)\\n'\n            return impl\n"
  },
  {
    "file": "implement_scheme_stubs.py",
    "line": 110,
    "type": "TODO",
    "content": "impl = indent_str + '; TODO: Implement ' + func_name + ' functionality\\n'",
    "context": "        \n        # Generic implementation\n        else:\n            impl = indent_str + '; TODO: Implement ' + func_name + ' functionality\\n'\n            impl += indent_str + '(display \"Warning: ' + func_name + ' not fully implemented\\\\n\")\\n'\n            impl += indent_str + '#f\\n'\n            return impl\n"
  },
  {
    "file": "setup_fixme_environment.py",
    "line": 83,
    "type": "TODO",
    "content": "echo \"   // TODO: Implement error handling for edge case X\"",
    "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n"
  },
  {
    "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
    "line": 456,
    "type": "TODO",
    "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
    "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
  },
  {
    "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
    "line": 456,
    "type": "TODO",
    "content": "# TODO: The Python module \"graphviz\" needs to be added to ocpkg, so",
    "context": "        # properly defined DOT header created and the correct atoms are\n        # included in the description\n\n        # TODO: The Python module \"graphviz\" needs to be added to ocpkg, so\n        # that this dependency will be available for the continuous integration\n        # system\n        try:\n"
  },
  {
    "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
    "line": 101,
    "type": "FIXME",
    "content": "// XXX This should be obsoleted by cond, at some point.",
    "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
  },
  {
    "file": "components/learning/moses/moses/comboreduct/table/table.h",
    "line": 98,
    "type": "FIXME",
    "content": "// XXX FIXME TODO: change the implementation, per the above note.",
    "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
  },
  {
    "file": "components/learning/moses/moses/comboreduct/table/table.h",
    "line": 1089,
    "type": "FIXME",
    "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
    "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
  },
  {
    "file": "components/learning/moses/moses/comboreduct/table/table_io.h",
    "line": 137,
    "type": "TODO",
    "content": "// TODO: reimplement loadITable with the same model of loadTable and",
    "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
  },
  {
    "file": "components/learning/moses/moses/moses/main/problem-params.h",
    "line": 46,
    "type": "FIXME",
    "content": "// XXX FIXME TODO The structure below should be split into multiple",
    "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
  },
  {
    "file": "components/learning/moses/moses/moses/moses/types.h",
    "line": 210,
    "type": "TODO",
    "content": "// TODO this should be a std::valarray not std::vector but I am too",
    "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
  },
  {
    "file": "components/learning/moses/moses/moses/representation/field_set.h",
    "line": 213,
    "type": "FIXME",
    "content": "// XXX should be enum ...",
    "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
  },
  {
    "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
    "line": 89,
    "type": "FIXME",
    "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
    "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
  },
  {
    "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
    "line": 124,
    "type": "FIXME",
    "content": "// XXX TODO should be a std::valarray not a vector.",
    "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
  },
  {
    "file": "moses/moses/comboreduct/combo/vertex.h",
    "line": 101,
    "type": "FIXME",
    "content": "// XXX This should be obsoleted by cond, at some point.",
    "context": "    lambda,\n    apply,\n\n    // XXX This should be obsoleted by cond, at some point.\n    // Maybe action_boolean_if too, I guess?\n    contin_if,\n\n"
  },
  {
    "file": "moses/moses/comboreduct/table/table.h",
    "line": 99,
    "type": "FIXME",
    "content": "// XXX FIXME TODO: change the implementation, per the above note.",
    "context": "// of the columns has a different type than the others.  Someday, the\n// design here should be changed, so that the space-savings is still\n// realized, while also allowing different types for different columns.\n// XXX FIXME TODO: change the implementation, per the above note.\n\ntypedef std::vector<builtin> builtin_seq;\ntypedef std::vector<contin_t> contin_seq;\n"
  },
  {
    "file": "moses/moses/comboreduct/table/table.h",
    "line": 1126,
    "type": "FIXME",
    "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
    "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n"
  },
  {
    "file": "moses/moses/comboreduct/table/table_io.h",
    "line": 137,
    "type": "TODO",
    "content": "// TODO: reimplement loadITable with the same model of loadTable and",
    "context": "OTable loadOTable(const std::string& file_name,\n                  const std::string& target_feature);\n\n// TODO: reimplement loadITable with the same model of loadTable and\n// remove loadITable_optimized\nITable loadITable(\n    const std::string& file_name,\n"
  },
  {
    "file": "moses/moses/moses/main/problem-params.h",
    "line": 46,
    "type": "FIXME",
    "content": "// XXX FIXME TODO The structure below should be split into multiple",
    "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
  },
  {
    "file": "moses/moses/moses/moses/moses_main.h",
    "line": 102,
    "type": "FIXME",
    "content": "// XXX TODO this should be fixed, someday...",
    "context": "        // messages.  In fact, the mpi workers should not even have\n        // a printer at all, or use a null_printer.  Unfortunately,\n        // the current code structure makes this hard to implement.\n        // XXX TODO this should be fixed, someday...\n        if (is_mpi && metapop.size() == 0)\n            return;\n\n"
  },
  {
    "file": "moses/moses/moses/moses/types.h",
    "line": 210,
    "type": "TODO",
    "content": "// TODO this should be a std::valarray not std::vector but I am too",
    "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
  },
  {
    "file": "moses/moses/moses/representation/field_set.h",
    "line": 213,
    "type": "FIXME",
    "content": "// XXX should be enum ...",
    "context": "            return step_size / contin_t(1UL << depth);\n        }\n\n        // XXX should be enum ...\n        static const disc_t Stop;  // 0\n        static const disc_t Left;  // 1\n        static const disc_t Right; // 2\n"
  },
  {
    "file": "moses/moses/moses/representation/instance_scorer.h",
    "line": 89,
    "type": "FIXME",
    "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
    "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
  },
  {
    "file": "moses/moses/moses/scoring/scoring_base.h",
    "line": 124,
    "type": "FIXME",
    "content": "// XXX TODO should be a std::valarray not a vector.",
    "context": "\n    /// A vector of per-bscore weights, used to tote up the behavioral\n    /// score into a single number.\n    // XXX TODO should be a std::valarray not a vector.\n    virtual void update_weights(const std::vector<double>&);\n\n    /// Return the amount by which the bscore differs from a perfect\n"
  },
  {
    "file": "ure/opencog/ure/backwardchainer/BIT.h",
    "line": 72,
    "type": "TODO",
    "content": "// TODO: Maybe this should be moved to BackwardChainer",
    "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n"
  },
  {
    "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
    "line": 94,
    "type": "TODO",
    "content": "// TODO: the TV on the evaluation link should be more carefully",
    "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n"
  },
  {
    "file": "ure/opencog/ure/forwardchainer/SourceRuleSet.h",
    "line": 102,
    "type": "TODO",
    "content": "// TODO: implement tournament selection as well, as a cheaper",
    "context": "\t */\n\tstd::pair<SourceRule, TruthValuePtr> thompson_select();\n\n\t// TODO: implement tournament selection as well, as a cheaper\n\t// alternative to Thompson sampling.\n\n\t/**\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
    "line": 147,
    "type": "FIXME",
    "content": ";; XXX Needs to be replaced by OpenPsi emotional state modelling.",
    "context": "\n\n;; Interact with the current face target.\n;; XXX Needs to be replaced by OpenPsi emotional state modelling.\n(DefineLink\n\t(DefinedPredicate \"Interact with face\")\n\t(SequentialAnd\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
    "line": 179,
    "type": "FIXME",
    "content": "; XXX FIXME this should be a part of \"Show random expression\"",
    "context": "\t(SequentialAnd\n\t\t(DefinedPredicate \"was room empty?\")\n\t\t; Record a new emotional state (for self-awareness)\n\t\t; XXX FIXME this should be a part of \"Show random expression\"\n\t\t; below ...\n\t\t(Put (DefinedPredicate \"Request Set Face Expression\")\n\t\t\t(ListLink bhv-source (Concept \"new-arrival\")))\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/behavior/behavior.scm",
    "line": 378,
    "type": "FIXME",
    "content": "; XXX incomplete!  need the face study saccade stuff...",
    "context": "\t\t\t\t(SequentialOr\n\t\t\t\t\t(SequentialAnd\n\t\t\t\t\t\t(DefinedPredicateNode \"dice-roll: face study\")\n; XXX incomplete!  need the face study saccade stuff...\n; I am confused ... has this been superceeded by the ROS-saccades,\n; or is this still means to be used?\n\t\t\t\t\t\t(False)\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/behavior/face-priority.scm",
    "line": 74,
    "type": "FIXME",
    "content": "; FIXME: There should never be an empty set. The value should be set",
    "context": "                            (DefinedSchema \"Get face priority\")\n                            (Number face-id))))\n    (if (equal? (Set) result)\n        ; FIXME: There should never be an empty set. The value should be set\n        ; during acknowledgment.\n        (begin\n            (set-priority! face-id ordinary-face-priority)\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/chatbot-eva/imperative-rules.scm",
    "line": 45,
    "type": "FIXME",
    "content": "; XXX needs to be public, so that cog-execute! can find this...",
    "context": "; ---------\n(define (print-msg node) (display (cog-name node)) (newline) (stv 1 1))\n\n; XXX needs to be public, so that cog-execute! can find this...\n(define-public (show-arg node) (display node) node)\n\n; ---------------------------------------------------------------\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
    "line": 258,
    "type": "FIXME",
    "content": "; XXX FIXME -- Implement-me, actually -- need to do the above, but for",
    "context": "\t\t(ConceptNode \"look-at-cmd\")\n\t\t(ConceptNode \"schema-thing\")))\n\n; XXX FIXME -- Implement-me, actually -- need to do the above, but for\n; the self-model, rather than the direct robot action.  The self-model\n; is not being updated by these imperatives.\n;--------------------------------------------------------------------\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
    "line": 358,
    "type": "FIXME",
    "content": "; XXX a bunch of verb synonyms -- handled manually. These should be",
    "context": "; Grounding of words for facial expressions by animations in the Eva\n; blender model: happy, sad, confused, etc. See below for full list.\n\n; XXX a bunch of verb synonyms -- handled manually. These should be\n; automated via synonymous phrase support. Total hack, needs fixing.\n; Each verb here must also be handled by a corresponding rule in the\n; `imperative-rules.scm` file.\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/chatbot-eva/knowledge.scm",
    "line": 404,
    "type": "FIXME",
    "content": "; XXX FIXME -- this list contains lots of synonyms; needs to be replaced",
    "context": "; not being correctly used, and/or R2L in its current form is not\n; quite usable for this (it's too fragile, among other things).\n;\n; XXX FIXME -- this list contains lots of synonyms; needs to be replaced\n; by proper synonym support.\n;\n; XXX Note that some synonyms have multiple \"meanings\" e.g. \"anguish\"\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/chatbot-eva/model-query.scm",
    "line": 156,
    "type": "FIXME",
    "content": "; XXX this should be moved to cog-utils. Also needs to be fixed",
    "context": "\n;--------------------------------------------------------------------\n;\n; XXX this should be moved to cog-utils. Also needs to be fixed\n; to not detect bound variables. We already have C++ code that\n; does  the right thing, here, so we should use that.\n(define (cog-grounded? EXPR)\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/model/self-model.scm",
    "line": 374,
    "type": "FIXME",
    "content": ";; XXX FIXME -- the psi subsystem should be performing this action,",
    "context": ";; If there are no visible faces, and something \"salient\" is seen, with\n;; a degree greater than 13, then it's considered as salient. The robot\n;; should then look at the salient position and show curious expression.\n;; XXX FIXME -- the psi subsystem should be performing this action,\n;; instead of hard-coding it here.\n\n;; Coordinates for the salient location\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
    "line": 9,
    "type": "FIXME",
    "content": "; XXX FIXME -- some of the below should be handled as psi-rules,",
    "context": "; direction the sound is coming from, as compared to the position\n; of the face.\n;\n; XXX FIXME -- some of the below should be handled as psi-rules,\n; instead of being hard-coded, here.  That is, we are interested\n; in the locations of sound events in general, not just for determing\n; who is speaking.\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
    "line": 161,
    "type": "FIXME",
    "content": ";; XXX FIXME -- this kind of crazy angle computation should be",
    "context": ";assuming sound was saved with co-oridinate transform applied for camera\n;angle in radians\n;\n;; XXX FIXME -- this kind of crazy angle computation should be\n;; happenening in the space-time server, and not here.\n;;\n(define (angle_face_id_snd FACE-ID xx yy zz)\n"
  },
  {
    "file": "components/integration/opencog/opencog/eva/model/time-map.scm",
    "line": 196,
    "type": "FIXME",
    "content": ";; XXX FIXME -- this kind of tulity needs to be in the space-time",
    "context": ";; A face is near if the sound direction is within 15 degrees of\n;; the face.  Returns the atom for the face, or the emtpy list.\n;;\n;; XXX FIXME -- this kind of tulity needs to be in the space-time\n;; server, and not here.\n(define (face-nearest-sound xx yy zz)\n\n"
  },
  {
    "file": "components/integration/opencog/opencog/ghost/terms.scm",
    "line": 238,
    "type": "TODO",
    "content": "; TODO: Should be handled in OpenCog internally?",
    "context": "  of it before sending the whole thing out.\n  The TTS server will handle the rest afterwards.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"|\" (string-join (map cog-name (flatten-list ARGS)) \",\") \"|\")))\n\n; ----------\n"
  },
  {
    "file": "components/integration/opencog/opencog/ghost/terms.scm",
    "line": 255,
    "type": "TODO",
    "content": "; TODO: Should be handled in OpenCog internally?",
    "context": "  Support things like {% set delay=2 %} in the action of a rule, which\n  set how long STT should wait before sending the input to GHOST.\n\"\n  ; TODO: Should be handled in OpenCog internally?\n  (Word (string-append \"{% set delay=\" (cog-name SECOND) \" %}\"))\n)\n\n"
  },
  {
    "file": "components/integration/opencog/opencog/ghost/translator.scm",
    "line": 189,
    "type": "TODO",
    "content": "; TODO: The specificity of ordered vs unordered should be",
    "context": "    (for-each (lambda (t)\n      (cond ((equal? 'unordered-matching (car t))\n             (update-lists (process (cdr t)))\n             ; TODO: The specificity of ordered vs unordered should be\n             ; considered as well\n             (set! is-unordered? #t))\n            ((equal? 'word (car t))\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/question-pipeline.scm",
    "line": 230,
    "type": "FIXME",
    "content": ";; XXX someday, this needs to be an or-list of WH- words.",
    "context": "\t\t\twh-clause  ; the prep-phrase we are matching!\n\t\t\t(r-decl-vartype \"PrepositionalRelationshipNode\" \"$tripl\")\n\n\t\t\t;; XXX someday, this needs to be an or-list of WH- words.\n\t\t\t(r-rlx-flag wh-word \"$qvar\")\n\t\t\t(r-decl-lemma  \"$word-inst\" \"$word\")\n\t\t\t(r-decl-lemma  \"$join-inst\" \"$word\")\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/chatbot-old/triples/rule-tools.scm",
    "line": 617,
    "type": "FIXME",
    "content": "; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX",
    "context": ";\n; Assumes that both \"prep\" and \"prep-word\" are vairables, \n; and declares \"prep\" to be of type DefinedLinguisticRelationshipNode\n; XXX this is wrong, it should be PrepositionalRelationshipNode ??? XXX\n;\n; Returns an r-expression.\n;\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/chatbot-psi/actions.scm",
    "line": 14,
    "type": "TODO",
    "content": "(let* (; TODO: Should be bias according to the score",
    "context": "(define (pick-and-generate list-of-results)\n    (if (equal? (length list-of-results) 0)\n        '()\n        (let* (; TODO: Should be bias according to the score\n               (picked (list-ref list-of-results (random (length list-of-results))))\n               ; TODO: Should use gen-sentences when new microplanner is ready\n               (generated (sureal (gar picked))))\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/microplanning/anaphora.scm",
    "line": 23,
    "type": "TODO",
    "content": "; TODO also insert anaphora for missing subjects/objects",
    "context": "; Accepts a <chunks-set>.  Returns new <chunks-set> with anaphora inserted\n; (as new atoms).\n;\n; TODO also insert anaphora for missing subjects/objects\n;\n(define (insert-anaphora inputs-set)\n\t(define results-set (clone-set inputs-set))\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/microplanning/main.scm",
    "line": 83,
    "type": "FIXME",
    "content": "; XXX FIXME utterance-type should be an atom, not a string!",
    "context": "  OPTION is a <chunks-option> object\n  ANAPHORA can be #t or #f.\n\"\n\t; XXX FIXME utterance-type should be an atom, not a string!\n\t; viz (DefinedLinguisticConceptNode \"DeclarativeSpeechAct\") etc.\n\t; this would avoid a lot of string-matching/downcasing/appending\n\t; tomfoolery i.e. simplify the code.\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/relex2logic/post-processing.scm",
    "line": 140,
    "type": "FIXME",
    "content": "; XXX FIXME should be changed to just use sha-256 -- that would make it",
    "context": "; random-UUID -- Generate a new UUID version 4\n;\n; Returns UUID version 4 (ie, mostly just random hex with some fixed values)\n; XXX FIXME should be changed to just use sha-256 -- that would make it\n; faster, better.\n;\n(define (random-UUID)\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/relex2logic/relex2logic.scm",
    "line": 39,
    "type": "FIXME",
    "content": "; XXX maybe this should be part of the ure module??",
    "context": "        ; from the FC, then delete it and return a list of\n        ; its contents, else return a list holding A-LINK.\n        ;\n        ; XXX maybe this should be part of the ure module??\n        (if (or (equal? 'ListLink (cog-type A-LINK)) IS-FROM-FC)\n            (let ((returned-list (cog-outgoing-set A-LINK)))\n                    (cog-extract! A-LINK)\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
    "line": 13,
    "type": "FIXME",
    "content": "; XXX This list is *probably* incomplete, and needs to be reviewed! XXX",
    "context": ";\n; Copyright (c) 2008 Linas Vepstas\n;\n; XXX This list is *probably* incomplete, and needs to be reviewed! XXX\n; In particular, the tense list is incomplete. The part-of-speech list\n; might be incomplete.\n; The list of entities (person, locatin, date, money) is incomplete.\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/scm/type-definitions.scm",
    "line": 128,
    "type": "FIXME",
    "content": "; XXX this list is highly incomplete",
    "context": "\n;; -------------------------------------------------------------------\n; tense in RelEx\n; XXX this list is highly incomplete\n;\n(InheritanceLink\n\t(DefinedLinguisticConceptNode \"past\")\n"
  },
  {
    "file": "components/integration/opencog/opencog/nlp/wsd-post/collect-stats/stats-collection.scm",
    "line": 359,
    "type": "FIXME",
    "content": "; XXX The method used here, of tagging documents with \"finished\"",
    "context": "; Return all of the documents for which WSD has been completed,\n; but disjunct processing has not been.\n;\n; XXX The method used here, of tagging documents with \"finished\"\n; tags, is rather ad-hoc, and is meant to be a stop-gap until\n; opencog offers some way of defining a processing pipeline.\n;\n"
  },
  {
    "file": "components/integration/opencog/opencog/openpsi/dynamics/updater.scm",
    "line": 69,
    "type": "TODO",
    "content": "; Todo: implement these tables in the atomspace",
    "context": "\n; --------------------------------------------------------------\n\n; Todo: implement these tables in the atomspace\n(define prev-value-table (make-hash-table 40))\n(define prev-most-recent-ts-table (make-hash-table 40))\n(define psi-event-detection-callbacks '())\n"
  },
  {
    "file": "components/language/learn/attic/repair/word-merge.scm",
    "line": 197,
    "type": "FIXME",
    "content": "; XXX technically, this is wrong, we should be renaming these...",
    "context": "\t)\n\n\t; Discard alternates\n\t; XXX technically, this is wrong, we should be renaming these...\n\t(define (bug-cleanup laid)\n\t\t(if (< 0 laid)\n;\t\t\t(let* ((aud (get-eval-uuid laid)))\n"
  },
  {
    "file": "components/language/learn/scm/attic/summary.scm",
    "line": 5,
    "type": "FIXME",
    "content": "; XXX This is stale and semi-abandoned and needs to be modernized.",
    "context": "; summary.scm\n;\n; Print a summary report for a dataset.\n; XXX This is stale and semi-abandoned and needs to be modernized.\n;\n; Copyright (c) 2017 Linas Vepstas\n;\n"
  },
  {
    "file": "components/language/learn/scm/attic/cluster/agglo-loops.scm",
    "line": 381,
    "type": "FIXME",
    "content": "; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,",
    "context": ";     else they might fit. Viz, many words have both noun and verb\n;     forms, and thus need to go into multiple classes.\n;\n; XXX FIXME: The DONE-LIST should be scrubbed for short junk. That is,\n; words in the DONE-LIST have a good chance of being completely\n; neutered, with almost nothing left in them. They should get dropped.\n;\n"
  },
  {
    "file": "components/language/learn/scm/attic/cluster/cset-merge.scm",
    "line": 90,
    "type": "FIXME",
    "content": "; XXX Incomplete, in development.",
    "context": "(use-modules (opencog) (opencog sheaf) (opencog persist))\n\n; ---------------------------------------------------------------\n; XXX Incomplete, in development.\n\n(define (matching-sequences CON-A CON-B)\n\"\n"
  },
  {
    "file": "components/language/learn/scm/attic/cluster/gram-pairwise.scm",
    "line": 592,
    "type": "FIXME",
    "content": "; XXX TODO once make-merge-majority is done, this can be reimplemented",
    "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO once make-merge-majority is done, this can be reimplemented\n; as a special case of that. That means that the above three functions\n; can be discarded. It also means that `gram-class-api` 'make-cluster\n; method can be discarded or refactored.\n"
  },
  {
    "file": "components/language/learn/scm/gram-class/gram-class-api.scm",
    "line": 133,
    "type": "FIXME",
    "content": "; XXX FIXME the semantics of this thing is ugly, and should be",
    "context": "\t; return the existing class. If this is called a second time\n\t; with the same arguments, then a new, unique name is generated!\n\t; Therefore, this should never be called than once!\n\t; XXX FIXME the semantics of this thing is ugly, and should be\n\t; moved to the caller. We shouldn't have to second-guess the\n\t; callers dsired behavior!\n\t(define (make-cluster A-ATOM B-ATOM)\n"
  },
  {
    "file": "components/language/learn/scm/gram-class/gram-majority.scm",
    "line": 205,
    "type": "FIXME",
    "content": "; XXX TODO this should be either",
    "context": "\t\t\t(<= vote-thresh\n\t\t\t\t(fold\n\t\t\t\t\t(lambda (WRD CNT)\n\t\t\t\t\t\t; XXX TODO this should be either\n\t\t\t\t\t\t; (if (< 0 (LLOBJ 'pair-count WRD DJ)) ...)\n\t\t\t\t\t\t; or it should be\n\t\t\t\t\t\t; (if (< NOISE (LLOBJ 'pair-count WRD DJ)) ...)\n"
  },
  {
    "file": "components/language/learn/scm/gram-class/shape-project.scm",
    "line": 307,
    "type": "FIXME",
    "content": "; XXX TODO -- generic deletion should be moved to a method",
    "context": "\n; ---------------------------------------------------------------\n\n; XXX TODO -- generic deletion should be moved to a method\n; on the base object -- probably to add-pair-stars. The extra\n; stuff like deleting crosses belongs in the shape-vec API.\n(define (remove-empty-sections LLOBJ ROW RMX)\n"
  },
  {
    "file": "components/language/learn/scm/gram-class/shape-vec.scm",
    "line": 109,
    "type": "TODO",
    "content": "; TODO: with appropriate cleanup, this probably should be moved",
    "context": ";       (WordNode \"level\")\n;       (Shape ... the above shape))\n;\n; TODO: with appropriate cleanup, this probably should be moved\n; to a generic \"section\" or \"sheaf\" module.  That is because it\n; generically explodes a section into all of it's constituent\n; connector-shape pairs, which is presumably something everyone\n"
  },
  {
    "file": "components/language/learn/scm/gram-class/singletons.scm",
    "line": 61,
    "type": "TODO",
    "content": "; TODO: Implement delete functionality",
    "context": "\t; XXX this is broken\n\t(define (delete-singles)\n\t\t; delete each word-class node..\n  ; TODO: Implement delete functionality\n  (display \"Warning: delete not fully implemented\\n\")\n  #f\n\t\t\t\"This method is borken and don't work right!\")\n"
  },
  {
    "file": "ure/tests/ure/backwardchainer/scm/green-balls-targets.scm",
    "line": 105,
    "type": "TODO",
    "content": ";; TODO: the type of G should be further specified, such the number of",
    "context": "      ;; Evidence\n      (Set G))))\n\n;; TODO: the type of G should be further specified, such the number of\n;; elements, or possible range, as well as possible the type of each\n;; element, e.g. List, once the backward chainer supports deep types.\n"
  }
]