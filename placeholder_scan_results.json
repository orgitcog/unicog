{
  "total": 1841,
  "high_priority": 81,
  "medium_priority": 1472,
  "low_priority": 288,
  "by_type": {
    "empty_function": 1463,
    "fixme_comment": 112,
    "return_none": 27,
    "todo_comment": 149,
    "pass_only": 80,
    "raise_not_implemented": 1,
    "stub_function": 9
  },
  "categorized": {
    "high": [
      {
        "file": "entelechy_introspection.py",
        "line": 627,
        "type": "pass_only",
        "content": "pass",
        "context": "                                if re.search(r'\\bSTUB\\b', line, re.IGNORECASE):\n                                    markers['STUB'] += 1\n                except Exception:\n                    pass\n        \n        return markers\n    \n"
      },
      {
        "file": "entelechy_marker_prioritizer.py",
        "line": 133,
        "type": "pass_only",
        "content": "pass",
        "context": "                        })\n                        \n        except Exception as e:\n            pass\n    \n    def _get_component(self, file_path: Path) -> str:\n        \"\"\"Determine component from file path\"\"\"\n"
      },
      {
        "file": "find_actual_stubs.py",
        "line": 59,
        "type": "raise_not_implemented",
        "content": "elif 'raise NotImplementedError' in first_impl:",
        "context": "                            elif re.match(r'^\\s*\\.\\.\\.\\s*$', first_impl):\n                                is_stub = True\n                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n"
      },
      {
        "file": "find_actual_stubs.py",
        "line": 76,
        "type": "pass_only",
        "content": "pass",
        "context": "                                    'context': '\\n'.join(lines[max(0, i-2):min(i+8, len(lines))])\n                                })\n        except Exception as e:\n            pass\n    \n    return stubs\n\n"
      },
      {
        "file": "find_placeholders.py",
        "line": 48,
        "type": "pass_only",
        "content": "pass",
        "context": "                            'context': self._get_context(lines, i-1)\n                        })\n        except Exception as e:\n            pass\n            \n    def _get_context(self, lines, line_idx, context_size=3):\n        \"\"\"Get surrounding context for a placeholder\"\"\"\n"
      },
      {
        "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 450,
        "type": "pass_only",
        "content": "pass",
        "context": "        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n        # properly defined DOT header created and the correct atoms are\n"
      },
      {
        "file": "atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 472,
        "type": "pass_only",
        "content": "pass",
        "context": "            assert \"bird\" in get_result\n            assert get_result.count(\"label\") == 2\n        except ImportError:\n            pass\n"
      },
      {
        "file": "atomspace/tests/cython/guile/test_pattern.py",
        "line": 25,
        "type": "pass_only",
        "content": "pass",
        "context": "                    os.environ['PROJECT_SOURCE_DIR'] + '/opencog/scm\")')\n\n    def tearDown(self):\n        pass\n\n    # Load several different scheme files, containing atom type\n    # declarations, and utilities. They should load just fine.\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 388,
        "type": "pass_only",
        "content": "pass",
        "context": "            else:\n                return int(value_string)\n        except ValueError:\n            pass\n        \n        # Parse booleans\n        if value_string.lower() == 'true':\n"
      },
      {
        "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 450,
        "type": "pass_only",
        "content": "pass",
        "context": "        # Test an arbitrary Scheme command to ensure the binding is working\n        # properly\n        # XXX Emptied because the scheme command (i.e cog-af-boundary) has been removed.\n        pass \n    def test_n_dot_export(self):\n        # Export the atomspace to DOT format and ensure that there is a\n        # properly defined DOT header created and the correct atoms are\n"
      },
      {
        "file": "components/core/atomspace-restful/tests/python/restapi/test_restapi.py",
        "line": 472,
        "type": "pass_only",
        "content": "pass",
        "context": "            assert \"bird\" in get_result\n            assert get_result.count(\"label\") == 2\n        except ImportError:\n            pass\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sentiment/basic_sentiment_analysis.py",
        "line": 38,
        "type": "pass_only",
        "content": "pass",
        "context": "class POSTagger(object):\n\n    def __init__(self):\n        pass\n\n    def pos_tag(self, sentences):\n        \"\"\"\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 216,
        "type": "pass_only",
        "content": "pass",
        "context": "            if response.status_code == 200:\n                return response.json()\n        except:\n            pass\n        return {}\n    \n    def get_embodiment_tensor(self, agent_id: str) -> Dict:\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 226,
        "type": "pass_only",
        "content": "pass",
        "context": "            if response.status_code == 200:\n                return response.json()\n        except:\n            pass\n        return {}\n\nclass WebSocketStreamDemo:\n"
      },
      {
        "file": "entelechy/introspector.py",
        "line": 556,
        "type": "pass_only",
        "content": "pass",
        "context": "                        markers['FIXME'] += len(re.findall(r'\\bFIXME\\b', content, re.IGNORECASE))\n                        markers['STUB'] += len(re.findall(r'\\bSTUB\\b', content, re.IGNORECASE))\n                except Exception:\n                    pass\n        \n        return markers\n    \n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 22,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass DashboardError(Exception):\n    pass\n\n\nclass AbstractDashboardClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 32,
        "type": "pass_only",
        "content": "pass",
        "context": "    \"\"\"\n    @abstractmethod\n    def set_cell_by_indexes(self, row_index: int, col_index: int, value: object):\n        pass\n\n    @abstractmethod\n    def set_cell_by_names(self, row_name: str, col_name: str, value: object):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 36,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    @abstractmethod\n    def set_cell_by_names(self, row_name: str, col_name: str, value: object):\n        pass\n\n    @abstractmethod\n    def update_dashboard(self):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 41,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def update_dashboard(self):\n        \"\"\" Update dashboard values \"\"\"\n        pass\n\n\nclass AbstractConfigClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 58,
        "type": "pass_only",
        "content": "pass",
        "context": "        :param comp_name:       Component name string.\n        :return:                Dictionary instance holding configuration parameters.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def save_config(self, config_name: str, comp_name: str) -> None:\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 69,
        "type": "pass_only",
        "content": "pass",
        "context": "        :param comp_name:       Component name string.\n        :return:                None\n        \"\"\"\n        pass\n\n\nclass AbstractProgressClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 78,
        "type": "pass_only",
        "content": "pass",
        "context": "    \"\"\"\n    @abstractmethod\n    def update(self, increment: int) -> None:\n        pass\n\n    @abstractmethod\n    def set_total(self, total: int) -> None:\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 82,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    @abstractmethod\n    def set_total(self, total: int) -> None:\n        pass\n\n\nclass AbstractGrammarTestClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 92,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def test(self, dict_path: str, corpus_path: str, output_path: str, reference_path: str, options: int,\n             progress: AbstractProgressClient = None) -> (ParseMetrics, ParseQuality):\n        pass\n\n\nclass AbstractFileParserClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 102,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def parse(self, dict_path: str, corpus_path: str, output_path: str, ref_file: str, options: int,\n              progress: AbstractProgressClient = None, **kwargs) -> (ParseMetrics, ParseQuality):\n        pass\n\n\nclass AbstractStatEventHandler(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 111,
        "type": "pass_only",
        "content": "pass",
        "context": "    \"\"\"\n    @abstractmethod\n    def on_statistics(self, nodes: list, metrics: ParseMetrics, quality: ParseQuality) -> None:\n        pass\n\n\nclass AbstractPipelineComponent(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 125,
        "type": "pass_only",
        "content": "pass",
        "context": "            method should check all of the parameters print error messages and return False if at least one parameter\n            is invalid.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def run(self, **kwargs) -> dict:\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 130,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def run(self, **kwargs) -> dict:\n        \"\"\" Run component execution. In case of severe errors exceptions should be raised to stop pipeline execution \"\"\"\n        pass\n\n\nclass AbstractSerializer(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 140,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def open(self):\n        \"\"\" Open data storage \"\"\"\n        pass\n\n    @abstractmethod\n    def close(self):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 145,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def close(self):\n        \"\"\" Close data storage \"\"\"\n        pass\n\n    @abstractmethod\n    def read(self):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 150,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def read(self):\n        \"\"\" Read a single record/datum \"\"\"\n        pass\n\n    @abstractmethod\n    def write(self, record):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 155,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def write(self, record):\n        \"\"\" Write a single record/datum \"\"\"\n        pass\n\n    @abstractmethod\n    def load(self):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 160,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def load(self):\n        \"\"\" Deserialize data from a storage \"\"\"\n        pass\n\n    @abstractmethod\n    def dump(self, data_structure):\n"
      },
      {
        "file": "language-learning/src/common/absclient.py",
        "line": 165,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def dump(self, data_structure):\n        \"\"\" Serialize data to a storage \"\"\"\n        pass\n\n"
      },
      {
        "file": "language-learning/src/common/sentencecount.py",
        "line": 16,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass SentCountError(Exception):\n    pass\n\n\ndef get_sentence_count(corpus_path: str, options: int) -> int:\n"
      },
      {
        "file": "language-learning/src/common/tokencount.py",
        "line": 20,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass TokenCountError(Exception):\n    pass\n\n\ndef unbox_tokens(tokens: List[str]) -> List[str]:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 23,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    def __init__(self, **kwargs):\n        # check_kwargs(**kwargs)\n        pass\n\n    def validate_parameters(self, **kwargs):\n        \"\"\" Validate configuration parameters \"\"\"\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 311,
        "type": "pass_only",
        "content": "pass",
        "context": "            clustering = ['mean_shift', 'auto']\n        elif clustering == 'group':  # ILE clustering\n            # ILE (Identical Link Entries) clustering is handled in group_links()\n            pass\n        elif clustering == 'random':  # Random clustering\n            # Random clustering is handled in random_clusters()\n            pass\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 314,
        "type": "pass_only",
        "content": "pass",
        "context": "            pass\n        elif clustering == 'random':  # Random clustering\n            # Random clustering is handled in random_clusters()\n            pass\n        else:\n            clustering = ['agglomerative', 'ward', 'euclidean']\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 542,
        "type": "pass_only",
        "content": "pass",
        "context": "            clustering = ['mean_shift', 'auto']\n        elif clustering == 'group':  # ILE clustering\n            # ILE (Identical Link Entries) clustering is handled in group_links()\n            pass\n        elif clustering == 'random':  # Random clustering\n            # Random clustering is handled in random_clusters()\n            pass\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 545,
        "type": "pass_only",
        "content": "pass",
        "context": "            pass\n        elif clustering == 'random':  # Random clustering\n            # Random clustering is handled in random_clusters()\n            pass\n        else:\n            clustering = ['agglomerative', 'ward', 'euclidean']\n\n"
      },
      {
        "file": "language-learning/src/grammar_tester/grammartester.py",
        "line": 29,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass GrammarTestError(Exception):\n    pass\n\nCONF_MIN_WORD_CNT = \"min_word_count\"\nCONF_MAX_SENT_LEN = \"max_sentence_len\"\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lgmisc.py",
        "line": 20,
        "type": "pass_only",
        "content": "pass",
        "context": "logger = logging.getLogger(__name__)\n\nclass ParserError(Exception):\n    pass\n\nclass LGParseError(ParserError):\n    pass\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lgmisc.py",
        "line": 23,
        "type": "pass_only",
        "content": "pass",
        "context": "    pass\n\nclass LGParseError(ParserError):\n    pass\n\n\ndef get_dir_name(file_name: str) -> (str, str):\n"
      },
      {
        "file": "language-learning/src/grammar_tester/linkgrammarver.py",
        "line": 6,
        "type": "pass_only",
        "content": "pass",
        "context": "import os\n\nclass LGVersionParseError(Exception):\n    pass\n\n\ndef handle_version_response(text: str) -> Tuple[str, str]:\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 34,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass SentenceError(Exception):\n    pass\n\n\nclass EvalError(Exception):\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 461,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    \"\"\"\n    def __init__(self, **kwargs):\n        pass\n\n    def validate_parameters(self, **kwargs):\n        \"\"\" Validate configuration parameters \"\"\"\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 49,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_data(self, text: str, options: int):\n        \"\"\" Called when buffer is filled with parses to process \"\"\"\n        pass\n\n\nclass AbstractLGStreamParser(AbstractStreamParser):\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 59,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def setup(self):\n        \"\"\" Called to initialize all necessary data to start parsing stream data \"\"\"\n        pass\n\n    @abstractmethod\n    def cleanup(self):\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 64,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def cleanup(self):\n        \"\"\" Called to clean up after stream parsing is done \"\"\"\n        pass\n\n    @abstractmethod\n    def on_sentence_init(self, sentence: SentenceParse) -> bool:\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 69,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_sentence_init(self, sentence: SentenceParse) -> bool:\n        \"\"\" Called to initialize SentenceParse instance \"\"\"\n        pass\n\n    @abstractmethod\n    def on_sentence_done(self, sentence: SentenceParse) -> bool:\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 74,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_sentence_done(self, sentence: SentenceParse) -> bool:\n        \"\"\" Called to clean up SentenceParse instance \"\"\"\n        pass\n\n    @abstractmethod\n    def on_linkage_init(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 79,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_linkage_init(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n        \"\"\" Called to perform all necessary initialization before linkage parsing is started \"\"\"\n        pass\n\n    @abstractmethod\n    def on_parsed_linkage(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 84,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_parsed_linkage(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n        \"\"\" Called when linkage is completely parsed and lists with tokens and links are prepared \"\"\"\n        pass\n\n    @abstractmethod\n    def on_linkage_done(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgdatastructures.py",
        "line": 89,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_linkage_done(self, sentence: SentenceParse, linkage: Linkage) -> bool:\n        \"\"\" Called to perform clean up after linkage parsing is done \"\"\"\n        pass\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgparsequalityestimator.py",
        "line": 53,
        "type": "pass_only",
        "content": "pass",
        "context": "    def cleanup(self):\n        # self._parse_metrics.sentences = self._sentence_count\n        # self._parse_quality.sentences = self._sentence_count\n        pass\n\n    def on_sentence_init(self, sentence: PQSentenceParse):\n        sentence.linkage_count = 0\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgparsequalityestimator.py",
        "line": 98,
        "type": "pass_only",
        "content": "pass",
        "context": "        # sentence.linkage_count += 1\n\n    def on_linkage_done(self, sentence: PQSentenceParse, linkage: Linkage):\n        pass\n\n    def get_pa_pq(self) -> (ParseMetrics, ParseQuality):\n        return self._parse_metrics, self._parse_quality\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgpsstreamparser.py",
        "line": 10,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass BreakCycle(Exception):\n    pass\n\n\nclass ContinueCycle(Exception):\n"
      },
      {
        "file": "language-learning/src/link_grammar/lgpsstreamparser.py",
        "line": 14,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass ContinueCycle(Exception):\n    pass\n\n\nclass LGPSStreamParser(AbstractLGStreamParser):\n"
      },
      {
        "file": "language-learning/src/observer/lgobserver.py",
        "line": 20,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    def cleanup(self):\n        # self._pairs.count_mi()\n        pass\n\n    def on_sentence_init(self, sentence: PQSentenceParse):\n        sentence.linkage_count = 0\n"
      },
      {
        "file": "language-learning/src/observer/wordpairs.py",
        "line": 7,
        "type": "pass_only",
        "content": "pass",
        "context": "__all__ = [\"WordPair\", \"WordPairs\"]\n\nclass WordPairError(Exception):\n    pass\n\n\nclass WordPair:\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelineexceptions.py",
        "line": 49,
        "type": "pass_only",
        "content": "pass",
        "context": "\n\nclass FatalPipelineException(Exception):\n    pass\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 35,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def validate_parameters(self, **kwargs):\n        return True\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 60,
        "type": "pass_only",
        "content": "pass",
        "context": "    \"\"\"\n    def __init__(self, **kwargs):\n        # check_kwargs(**kwargs)\n        pass\n\n    def validate_parameters(self, **kwargs):\n        \"\"\" Validate configuration parameters \"\"\"\n"
      },
      {
        "file": "language-learning/src/web/api/lgclient.py",
        "line": 46,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_linkages(self, linkages):\n        \"\"\" Linkages processig callback method \"\"\"\n        pass\n\n    @abstractmethod\n    def on_linkage(self, linkage):\n"
      },
      {
        "file": "language-learning/src/web/api/lgclient.py",
        "line": 51,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_linkage(self, linkage):\n        \"\"\" Linkage processig callback method \"\"\"\n        pass\n\n    @abstractmethod\n    def on_link(self, link):\n"
      },
      {
        "file": "language-learning/src/web/api/lgclient.py",
        "line": 56,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def on_link(self, link):\n        \"\"\" Link processig callback method \"\"\"\n        pass\n\n\nclass LGClient(metaclass=ABCMeta):\n"
      },
      {
        "file": "language-learning/src/web/api/lgclient.py",
        "line": 88,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def parse_cbf(self, line, callback, param1=None, param2=None):\n        \"\"\" Parse sentense using specified callback function for processing linkages \"\"\"\n        pass\n\n    @abstractmethod\n    def parse(self, line, callback):\n"
      },
      {
        "file": "language-learning/src/web/api/lgclient.py",
        "line": 93,
        "type": "pass_only",
        "content": "pass",
        "context": "    @abstractmethod\n    def parse(self, line, callback):\n        \"\"\" Parse sentense using specified class callback instance for processing linkages \"\"\"\n        pass\n\n\nclass LGClientLib(LGClient):\n"
      },
      {
        "file": "language-learning/src/web/api/examples/clscallback.py",
        "line": 33,
        "type": "pass_only",
        "content": "pass",
        "context": "\n    def on_link(self, link):\n        \"\"\" on_link is ment to be called for each link when processing links \"\"\"\n        pass\n\n\ndef main():\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 66,
        "type": "pass_only",
        "content": "pass",
        "context": "        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n    def test_turtle_diled(self):\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 173,
        "type": "pass_only",
        "content": "pass",
        "context": "                        if keyword in content.lower():\n                            functions.append(keyword)\n        except Exception:\n            pass\n        \n        return list(set(functions))\n    \n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 195,
        "type": "pass_only",
        "content": "pass",
        "context": "                            'estimated_complexity': content.count('class') + content.count('struct')\n                        }\n        except Exception:\n            pass\n        \n        return signatures\n    \n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 221,
        "type": "pass_only",
        "content": "pass",
        "context": "                        if len(parts) > 2:\n                            dependencies.extend(parts[2:])\n        except Exception:\n            pass\n        \n        return dependencies\n    \n"
      },
      {
        "file": "tests/test_entelechy_framework.py",
        "line": 179,
        "type": "pass_only",
        "content": "pass",
        "context": "        tracker = EntelechyTracker(str(self.temp_dir))\n        # Note: This will fail in temp dir without proper structure\n        # In real tests, use actual repo\n        pass\n\n\nclass TestResonanceDetection(unittest.TestCase):\n"
      },
      {
        "file": "tests/integration/test_atomspace-restful.py",
        "line": 19,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_atomspace_restful_import(self):\n        \"\"\"Test that atomspace-restful can be imported\"\"\"\n"
      },
      {
        "file": "tests/integration/test_atomspace-rocks.py",
        "line": 19,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_atomspace_rocks_import(self):\n        \"\"\"Test that atomspace-rocks can be imported\"\"\"\n"
      },
      {
        "file": "tests/integration/test_learn.py",
        "line": 19,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_learn_import(self):\n        \"\"\"Test that learn can be imported\"\"\"\n"
      },
      {
        "file": "tests/integration/test_lg-atomese.py",
        "line": 19,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_lg-atomese_import(self):\n        \"\"\"Test that lg-atomese can be imported\"\"\"\n"
      },
      {
        "file": "tests/integration/test_moses.py",
        "line": 20,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_moses_import(self):\n        \"\"\"Test that moses can be imported\"\"\"\n"
      },
      {
        "file": "tests/integration/test_opencog.py",
        "line": 19,
        "type": "pass_only",
        "content": "pass",
        "context": "    \n    def setUp(self):\n        \"\"\"Set up test environment\"\"\"\n        pass\n        \n    def test_opencog_import(self):\n        \"\"\"Test that opencog can be imported\"\"\"\n"
      }
    ],
    "medium": [
      {
        "file": "analyze_fixme_instances.py",
        "line": 152,
        "type": "empty_function",
        "content": "pattern_matches = {}",
        "context": "        full_text = (instance.fixme_text + ' ' + ' '.join(instance.context_lines)).lower()\n        \n        # Count pattern matches\n        pattern_matches = {}\n        for pattern_name, pattern in self.patterns.items():\n            matches = len(re.findall(pattern, full_text, re.IGNORECASE))\n            if matches > 0:\n"
      },
      {
        "file": "build_optimizer.py",
        "line": 46,
        "type": "empty_function",
        "content": "available_parallel = {}",
        "context": "        available_topo = [comp for comp in report['build_sequence']['topological_order'] \n                         if comp in self.available_components]\n        \n        available_parallel = {}\n        for level, components in report['build_sequence']['parallel_groups'].items():\n            available_comps = [comp for comp in components if comp in self.available_components]\n            if available_comps:\n"
      },
      {
        "file": "build_optimizer.py",
        "line": 133,
        "type": "empty_function",
        "content": "external_deps = {}",
        "context": "    \n    def _get_available_external_deps(self) -> Dict[str, List[str]]:\n        \"\"\"Get external dependencies for available components\"\"\"\n        external_deps = {}\n        for comp in self.available_components:\n            if comp in self.analyzer.components:\n                deps = list(self.analyzer.components[comp].external_deps)\n"
      },
      {
        "file": "cognitive_membrane_scanner.py",
        "line": 33,
        "type": "empty_function",
        "content": "self.attention_weights = {}",
        "context": "    def __init__(self, enterprise=\"cosmos\"):\n        self.enterprise = enterprise\n        self.tensor_shape = []\n        self.attention_weights = {}\n        self.membrane_state = {}\n        self.topology = {}\n        \n"
      },
      {
        "file": "cognitive_membrane_scanner.py",
        "line": 34,
        "type": "empty_function",
        "content": "self.membrane_state = {}",
        "context": "        self.enterprise = enterprise\n        self.tensor_shape = []\n        self.attention_weights = {}\n        self.membrane_state = {}\n        self.topology = {}\n        \n    def fold_enterprise(self, level='enterprise'):\n"
      },
      {
        "file": "cognitive_membrane_scanner.py",
        "line": 35,
        "type": "empty_function",
        "content": "self.topology = {}",
        "context": "        self.tensor_shape = []\n        self.attention_weights = {}\n        self.membrane_state = {}\n        self.topology = {}\n        \n    def fold_enterprise(self, level='enterprise'):\n        \"\"\"Collapse higher dimensions into markdown representation\"\"\"\n"
      },
      {
        "file": "cognitive_membrane_scanner.py",
        "line": 60,
        "type": "empty_function",
        "content": "'organizations': {},",
        "context": "        topology = {\n            'enterprise': self.enterprise,\n            'timestamp': datetime.utcnow().isoformat(),\n            'organizations': {},\n            'tensor_dimensions': self.calculate_tensor_dimensions(),\n            'cognitive_state': 'scanning'\n        }\n"
      },
      {
        "file": "cognitive_membrane_scanner.py",
        "line": 92,
        "type": "empty_function",
        "content": "repos = {}",
        "context": "            'cosmos': ['membrane-sync', 'cognitive-grammar']\n        }\n        \n        repos = {}\n        for repo_name in repo_configs.get(org, []):\n            repos[repo_name] = {\n                'shape': self.calculate_repo_shape(repo_name),\n"
      },
      {
        "file": "core_self_awareness_integration.py",
        "line": 19,
        "type": "empty_function",
        "content": "return {}",
        "context": "    if entelechy_file.exists():\n        with open(entelechy_file, 'r') as f:\n            return json.load(f)\n    return {}\n\ndef generate_core_self_awareness_report() -> Dict[str, Any]:\n    \"\"\"Generate core self-awareness integration report\"\"\"\n"
      },
      {
        "file": "core_self_awareness_integration.py",
        "line": 54,
        "type": "empty_function",
        "content": "\"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72),",
        "context": "            \"identity_dimensions\": {\n                \"ontological\": {\n                    \"description\": \"What the system IS\",\n                    \"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72),\n                    \"components_present\": 14,\n                    \"architectural_completeness\": 1.286\n                },\n"
      },
      {
        "file": "core_self_awareness_integration.py",
        "line": 60,
        "type": "empty_function",
        "content": "\"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72),",
        "context": "                },\n                \"teleological\": {\n                    \"description\": \"What the system is BECOMING\",\n                    \"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72),\n                    \"actualization_progress\": 0.72,\n                    \"current_generation\": 0\n                },\n"
      },
      {
        "file": "core_self_awareness_integration.py",
        "line": 73,
        "type": "empty_function",
        "content": "\"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"coherence_score\", 0.65),",
        "context": "                },\n                \"relational\": {\n                    \"description\": \"How the system INTEGRATES\",\n                    \"score\": entelechy.get(\"entelechy_assessment\", {}).get(\"coherence_score\", 0.65),\n                    \"dependency_satisfaction\": 1.0,\n                    \"system_coherence\": 0.65\n                },\n"
      },
      {
        "file": "core_self_awareness_integration.py",
        "line": 102,
        "type": "empty_function",
        "content": "\"actualization_score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72)",
        "context": "            \"entelechy_introspection\": {\n                \"integrated\": True,\n                \"last_run\": entelechy.get(\"timestamp\", \"N/A\"),\n                \"actualization_score\": entelechy.get(\"entelechy_assessment\", {}).get(\"actualization_score\", 0.72)\n            }\n        },\n        \n"
      },
      {
        "file": "dependency_analyzer.py",
        "line": 29,
        "type": "empty_function",
        "content": "self.components = {}",
        "context": "    \"\"\"Analyzes OpenCog component dependencies and generates optimal build sequences\"\"\"\n    \n    def __init__(self):\n        self.components = {}\n        self.dependency_graph = nx.DiGraph()\n        self.external_deps = set()\n        self._initialize_dependencies()\n"
      },
      {
        "file": "dependency_analyzer.py",
        "line": 236,
        "type": "empty_function",
        "content": "return {}",
        "context": "        \"\"\"Find components that can be built in parallel at each level\"\"\"\n        topo_order = self.topological_sort()\n        if not topo_order:\n            return {}\n        \n        # Assign levels based on maximum dependency depth\n        levels = {}\n"
      },
      {
        "file": "dependency_analyzer.py",
        "line": 239,
        "type": "empty_function",
        "content": "levels = {}",
        "context": "            return {}\n        \n        # Assign levels based on maximum dependency depth\n        levels = {}\n        for node in topo_order:\n            if not list(self.dependency_graph.predecessors(node)):\n                levels[node] = 0\n"
      },
      {
        "file": "dependency_analyzer.py",
        "line": 255,
        "type": "empty_function",
        "content": "complexity = {}",
        "context": "    \n    def analyze_component_complexity(self) -> Dict[str, Dict]:\n        \"\"\"Analyze build complexity for each component\"\"\"\n        complexity = {}\n        \n        for comp_name, component in self.components.items():\n            # Complexity metrics\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 265,
        "type": "empty_function",
        "content": "results = {}",
        "context": "            'integration': ['opencog']\n        }\n        \n        results = {}\n        for layer_name, components in layers.items():\n            present = [c for c in components if (self.repo_path / c).exists()]\n            results[layer_name] = {\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 306,
        "type": "empty_function",
        "content": "return {}",
        "context": "    def _assess_development_phases(self) -> Dict:\n        \"\"\"Assess 5-phase development roadmap\"\"\"\n        if not self.component_config:\n            return {}\n        \n        phases = self.component_config.get('integration_phases', {})\n        phase_assessment = {}\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 308,
        "type": "empty_function",
        "content": "phases = self.component_config.get('integration_phases', {})",
        "context": "        if not self.component_config:\n            return {}\n        \n        phases = self.component_config.get('integration_phases', {})\n        phase_assessment = {}\n        \n        for phase_id, phase_data in phases.items():\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 309,
        "type": "empty_function",
        "content": "phase_assessment = {}",
        "context": "            return {}\n        \n        phases = self.component_config.get('integration_phases', {})\n        phase_assessment = {}\n        \n        for phase_id, phase_data in phases.items():\n            components = phase_data.get('components', [])\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 461,
        "type": "empty_function",
        "content": "all_components = self.component_config.get('opencog_unified_components', {})",
        "context": "        if not self.component_config:\n            return {'health': 0.0}\n        \n        all_components = self.component_config.get('opencog_unified_components', {})\n        total_deps = 0\n        satisfied_deps = 0\n        \n"
      },
      {
        "file": "entelechy_marker_resolver.py",
        "line": 51,
        "type": "empty_function",
        "content": "self.resolutions: Dict[str, MarkerResolution] = {}",
        "context": "        self.tracking_file = self.repo_root / 'entelechy_marker_resolution_tracking.json'\n        \n        self.analysis_data = None\n        self.resolutions: Dict[str, MarkerResolution] = {}\n        \n        self._load_analysis()\n        self._load_tracking()\n"
      },
      {
        "file": "find_actual_stubs.py",
        "line": 88,
        "type": "empty_function",
        "content": "by_file = {}",
        "context": "    print(f\"\\nFound {len(stubs)} stub implementations:\\n\")\n    \n    # Group by file\n    by_file = {}\n    for stub in stubs:\n        if stub['file'] not in by_file:\n            by_file[stub['file']] = []\n"
      },
      {
        "file": "fixme_resolution_tracker.py",
        "line": 53,
        "type": "empty_function",
        "content": "self.resolutions: Dict[str, FIXMEResolution] = {}",
        "context": "    def __init__(self, repo_root: str):\n        self.repo_root = Path(repo_root)\n        self.tracking_file = self.repo_root / \"fixme_resolution_progress.json\"\n        self.resolutions: Dict[str, FIXMEResolution] = {}\n        self.load_progress()\n        \n    def load_progress(self):\n"
      },
      {
        "file": "fixme_resolution_tracker.py",
        "line": 70,
        "type": "empty_function",
        "content": "data = {}",
        "context": "                \n    def save_progress(self):\n        \"\"\"Save current progress data.\"\"\"\n        data = {}\n        for key, resolution in self.resolutions.items():\n            data[key] = asdict(resolution)\n        \n"
      },
      {
        "file": "generate_progress_report.py",
        "line": 33,
        "type": "empty_function",
        "content": "obsolete_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('obsolete_comment', [])[:3]])",
        "context": "    stub_func_count=len(stubs)\n    total_fixes=impl_report['summary']['total_fixes_applied'] + feature_report['summary']['total_implementations']\n    obsolete_fixes_count=impl_report['summary']['by_type'].get('obsolete_comment', 0)\n    obsolete_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('obsolete_comment', [])[:3]])\n    clarification_fixes_count=impl_report['summary']['by_type'].get('clarification_added', 0)\n    clarification_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('clarification_added', [])[:3]])\n    actionable_count=len(actionable)\n"
      },
      {
        "file": "generate_progress_report.py",
        "line": 35,
        "type": "empty_function",
        "content": "clarification_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('clarification_added', [])[:3]])",
        "context": "    obsolete_fixes_count=impl_report['summary']['by_type'].get('obsolete_comment', 0)\n    obsolete_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('obsolete_comment', [])[:3]])\n    clarification_fixes_count=impl_report['summary']['by_type'].get('clarification_added', 0)\n    clarification_examples='\\n'.join([f\"- `{fix['file']}:{fix['line']}`\" for fix in impl_report.get('by_type', {}).get('clarification_added', [])[:3]])\n    actionable_count=len(actionable)\n    \n    # --- Report Content ---\n"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 139,
        "type": "empty_function",
        "content": "'by_type': {}",
        "context": "            'summary': {\n                'total_fixes_applied': len(self.fixes_applied),\n                'total_fixes_failed': len(self.fixes_failed),\n                'by_type': {}\n            },\n            'fixes_applied': self.fixes_applied,\n            'fixes_failed': self.fixes_failed\n"
      },
      {
        "file": "implement_placeholders.py",
        "line": 111,
        "type": "empty_function",
        "content": "by_type = {}",
        "context": "    \n    def generate_report(self):\n        \"\"\"Generate implementation report\"\"\"\n        by_type = {}\n        for fix in self.fixes_applied:\n            fix_type = fix['type']\n            if fix_type not in by_type:\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 14,
        "type": "empty_function",
        "content": "reports = {}",
        "context": "\ndef load_reports() -> Dict:\n    \"\"\"Load all generated analysis reports\"\"\"\n    reports = {}\n    \n    files_to_load = [\n        (\"dependency_analysis\", \"dependency_analysis_report.json\"),\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 27,
        "type": "empty_function",
        "content": "reports[name] = {}",
        "context": "                reports[name] = json.load(f)\n        except FileNotFoundError:\n            print(f\"Warning: {filename} not found\")\n            reports[name] = {}\n    \n    return reports\n\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 44,
        "type": "empty_function",
        "content": "dep_analysis = reports.get(\"dependency_analysis\", {})",
        "context": "    ]\n    \n    # Get analysis data\n    dep_analysis = reports.get(\"dependency_analysis\", {})\n    build_opt = reports.get(\"build_optimization\", {})\n    \n    if dep_analysis:\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 45,
        "type": "empty_function",
        "content": "build_opt = reports.get(\"build_optimization\", {})",
        "context": "    \n    # Get analysis data\n    dep_analysis = reports.get(\"dependency_analysis\", {})\n    build_opt = reports.get(\"build_optimization\", {})\n    \n    if dep_analysis:\n        summary = dep_analysis.get(\"analysis_summary\", {})\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 48,
        "type": "empty_function",
        "content": "summary = dep_analysis.get(\"analysis_summary\", {})",
        "context": "    build_opt = reports.get(\"build_optimization\", {})\n    \n    if dep_analysis:\n        summary = dep_analysis.get(\"analysis_summary\", {})\n        lines.extend([\n            f\"- **Total Components Analyzed**: {summary.get('total_components', 'N/A')}\",\n            f\"- **Available Components**: {build_opt.get('total_available', 'N/A')}\",\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 126,
        "type": "empty_function",
        "content": "dep_count = {}",
        "context": "        ])\n        \n        # Count most common external dependencies\n        dep_count = {}\n        for comp, deps in ext_deps.items():\n            for dep in deps:\n                dep_count[dep] = dep_count.get(dep, 0) + 1\n"
      },
      {
        "file": "optimal_build_summary.py",
        "line": 253,
        "type": "empty_function",
        "content": "phases = build_opt.get('build_phases', {})",
        "context": "            max_parallel = max(len(comps) for comps in build_opt['parallel_groups'].values())\n            print(f\"   Max Parallel Jobs: {max_parallel}\")\n        \n        phases = build_opt.get('build_phases', {})\n        print(f\"   Build Phases: {len(phases)}\")\n    \n    return 0\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 84,
        "type": "empty_function",
        "content": "self.pattern_frequencies = {}",
        "context": "    \n    def __init__(self, threshold: float = 0.7):\n        self.pattern_threshold = threshold\n        self.pattern_frequencies = {}\n        \n    def extract_emergent_patterns(self, nodes: List[CognitiveNode]) -> List[str]:\n        \"\"\"Extract emergent patterns from cognitive nodes\"\"\"\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 149,
        "type": "empty_function",
        "content": "self.agents = {}",
        "context": "    \"\"\"Phase II.3: Distributed Cognition Engine implementation\"\"\"\n    \n    def __init__(self):\n        self.agents = {}\n        self.shared_context = {}\n        self.context_lock = Lock()\n        \n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 150,
        "type": "empty_function",
        "content": "self.shared_context = {}",
        "context": "    \n    def __init__(self):\n        self.agents = {}\n        self.shared_context = {}\n        self.context_lock = Lock()\n        \n    def create_cognitive_agent(self, agent_id: str, initial_state: List[float]) -> CognitiveAgent:\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 215,
        "type": "empty_function",
        "content": "self.nodes = {}",
        "context": "    \"\"\"Phase II.4: Interactive Cognitive Visualization implementation\"\"\"\n    \n    def __init__(self):\n        self.nodes = {}\n        self.attention_overlays = {}\n        self.patterns = {}\n        \n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 216,
        "type": "empty_function",
        "content": "self.attention_overlays = {}",
        "context": "    \n    def __init__(self):\n        self.nodes = {}\n        self.attention_overlays = {}\n        self.patterns = {}\n        \n    def update_cognitive_state(self, nodes: List[CognitiveNode], patterns: List[str]):\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 217,
        "type": "empty_function",
        "content": "self.patterns = {}",
        "context": "    def __init__(self):\n        self.nodes = {}\n        self.attention_overlays = {}\n        self.patterns = {}\n        \n    def update_cognitive_state(self, nodes: List[CognitiveNode], patterns: List[str]):\n        \"\"\"Update visualization with current cognitive state\"\"\"\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 224,
        "type": "empty_function",
        "content": "self.attention_overlays = {}",
        "context": "        self.nodes = {node.id: node for node in nodes}\n        \n        # Update attention overlays\n        self.attention_overlays = {}\n        for node in nodes:\n            if node.attention > 0.5:\n                self.attention_overlays[node.id] = {\n"
      },
      {
        "file": "phase-ii-demo.py",
        "line": 466,
        "type": "empty_function",
        "content": "test_results = {}",
        "context": "        print(\"\\n\ud83e\uddea AUTOMATED TESTING SUITE\")\n        print(\"-\" * 30)\n        \n        test_results = {}\n        \n        # Test 1: Perceptual processing\n        test_input = [0.5, 0.8, 0.3, 0.9, 0.1]\n"
      },
      {
        "file": "roadmap_tracker.py",
        "line": 163,
        "type": "empty_function",
        "content": "status = {}",
        "context": "            if info[\"phase\"] == phase_num\n        }\n        \n        status = {}\n        for component_name in phase_components:\n            status[component_name] = self.check_component_status(component_name)\n            \n"
      },
      {
        "file": "roadmap_tracker.py",
        "line": 173,
        "type": "empty_function",
        "content": "\"foundation_status\": {},",
        "context": "        \"\"\"Generate comprehensive status report\"\"\"\n        report = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"foundation_status\": {},\n            \"phase_status\": {},\n            \"overall_progress\": {}\n        }\n"
      },
      {
        "file": "roadmap_tracker.py",
        "line": 174,
        "type": "empty_function",
        "content": "\"phase_status\": {},",
        "context": "        report = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"foundation_status\": {},\n            \"phase_status\": {},\n            \"overall_progress\": {}\n        }\n        \n"
      },
      {
        "file": "roadmap_tracker.py",
        "line": 175,
        "type": "empty_function",
        "content": "\"overall_progress\": {}",
        "context": "            \"timestamp\": datetime.now().isoformat(),\n            \"foundation_status\": {},\n            \"phase_status\": {},\n            \"overall_progress\": {}\n        }\n        \n        # Check foundation components\n"
      },
      {
        "file": "test_multi_agent_framework.py",
        "line": 19,
        "type": "empty_function",
        "content": "self.test_results = {}",
        "context": "\nclass MultiAgentTestSuite:\n    def __init__(self):\n        self.test_results = {}\n        self.performance_metrics = {}\n        \n    def run_comprehensive_tests(self):\n"
      },
      {
        "file": "test_multi_agent_framework.py",
        "line": 20,
        "type": "empty_function",
        "content": "self.performance_metrics = {}",
        "context": "class MultiAgentTestSuite:\n    def __init__(self):\n        self.test_results = {}\n        self.performance_metrics = {}\n        \n    def run_comprehensive_tests(self):\n        \"\"\"Run all test categories\"\"\"\n"
      },
      {
        "file": "validate-integration.py",
        "line": 24,
        "type": "empty_function",
        "content": "\"validations\": {},",
        "context": "        self.components_dir = self.root_dir / \"components\"\n        self.results = {\n            \"timestamp\": time.time(),\n            \"validations\": {},\n            \"summary\": {},\n            \"errors\": []\n        }\n"
      },
      {
        "file": "validate-integration.py",
        "line": 25,
        "type": "empty_function",
        "content": "\"summary\": {},",
        "context": "        self.results = {\n            \"timestamp\": time.time(),\n            \"validations\": {},\n            \"summary\": {},\n            \"errors\": []\n        }\n        \n"
      },
      {
        "file": "validate-integration.py",
        "line": 329,
        "type": "empty_function",
        "content": "\"validations\": {},",
        "context": "        result = {\n            \"phase\": phase_num,\n            \"components\": phase_components,\n            \"validations\": {},\n            \"status\": \"unknown\"\n        }\n        \n"
      },
      {
        "file": "validate-integration.py",
        "line": 390,
        "type": "empty_function",
        "content": "\"build_status\": validations.get(\"build\", {}).get(\"status\", \"unknown\"),",
        "context": "        summary = {\n            \"total_phases\": 5,\n            \"phases_valid\": 0,\n            \"build_status\": validations.get(\"build\", {}).get(\"status\", \"unknown\"),\n            \"test_status\": validations.get(\"integration_tests\", {}).get(\"status\", \"unknown\"),\n            \"overall_status\": \"unknown\"\n        }\n"
      },
      {
        "file": "validate-integration.py",
        "line": 391,
        "type": "empty_function",
        "content": "\"test_status\": validations.get(\"integration_tests\", {}).get(\"status\", \"unknown\"),",
        "context": "            \"total_phases\": 5,\n            \"phases_valid\": 0,\n            \"build_status\": validations.get(\"build\", {}).get(\"status\", \"unknown\"),\n            \"test_status\": validations.get(\"integration_tests\", {}).get(\"status\", \"unknown\"),\n            \"overall_status\": \"unknown\"\n        }\n        \n"
      },
      {
        "file": "validate-integration.py",
        "line": 398,
        "type": "empty_function",
        "content": "if validations.get(phase_key, {}).get(\"status\") == \"valid\":",
        "context": "        # Count valid phases\n        for phase_num in range(1, 6):\n            phase_key = f\"phase_{phase_num}\"\n            if validations.get(phase_key, {}).get(\"status\") == \"valid\":\n                summary[\"phases_valid\"] += 1\n        \n        # Determine overall status\n"
      },
      {
        "file": "validate-integration.py",
        "line": 402,
        "type": "empty_function",
        "content": "structure_valid = validations.get(\"directory_structure\", {}).get(\"status\") == \"valid\"",
        "context": "                summary[\"phases_valid\"] += 1\n        \n        # Determine overall status\n        structure_valid = validations.get(\"directory_structure\", {}).get(\"status\") == \"valid\"\n        all_phases_valid = summary[\"phases_valid\"] == summary[\"total_phases\"]\n        build_ok = summary[\"build_status\"] in [\"build_successful\", \"cmake_successful\"]\n        \n"
      },
      {
        "file": "validate-integration.py",
        "line": 441,
        "type": "empty_function",
        "content": "phase_data = self.results[\"validations\"].get(phase_key, {})",
        "context": "        print(\"\\nPhase Details:\")\n        for phase_num in range(1, 6):\n            phase_key = f\"phase_{phase_num}\"\n            phase_data = self.results[\"validations\"].get(phase_key, {})\n            status = phase_data.get(\"status\", \"unknown\")\n            components = phase_data.get(\"components\", [])\n            print(f\"  Phase {phase_num}: {status.upper()} - {', '.join(components)}\")\n"
      },
      {
        "file": "verify_implementations.py",
        "line": 51,
        "type": "empty_function",
        "content": "self.verification_results: Dict[str, bool] = {}",
        "context": "    def __init__(self, repo_path: str):\n        self.repo_path = Path(repo_path)\n        self.todo_items: List[TodoItem] = []\n        self.verification_results: Dict[str, bool] = {}\n        \n    def scan_repository(self) -> List[TodoItem]:\n        \"\"\"Scan repository for all TODO/FIXME items\"\"\"\n"
      },
      {
        "file": "verify_implementations.py",
        "line": 345,
        "type": "empty_function",
        "content": "category_stats = {}",
        "context": "\"\"\"\n        \n        # Category statistics\n        category_stats = {}\n        for detail in results['verification_details']:\n            category = detail['item'].category.value\n            if category not in category_stats:\n"
      },
      {
        "file": "verify_implementations.py",
        "line": 361,
        "type": "empty_function",
        "content": "priority_stats = {}",
        "context": "        report += \"\\n## Priority Breakdown\\n\"\n        \n        # Priority statistics  \n        priority_stats = {}\n        for detail in results['verification_details']:\n            priority = detail['item'].priority.value\n            if priority not in priority_stats:\n"
      },
      {
        "file": "verify_implementations.py",
        "line": 391,
        "type": "empty_function",
        "content": "quality_stats = {}",
        "context": "        \n        report += \"\\n## Implementation Quality Assessment\\n\"\n        \n        quality_stats = {}\n        for detail in results['verification_details']:\n            if detail.get('is_implemented', False):\n                quality = detail.get('implementation_quality', 'Unknown')\n"
      },
      {
        "file": "scan_placeholders.py",
        "line": 90,
        "type": "empty_function",
        "content": "'by_type': {},",
        "context": "        'high_priority': len(categorized['high']),\n        'medium_priority': len(categorized['medium']),\n        'low_priority': len(categorized['low']),\n        'by_type': {},\n        'categorized': categorized\n    }\n    \n"
      },
      {
        "file": "GGML/Tensor/ann_rules.h",
        "line": 73,
        "type": "empty_function",
        "content": "NeuralTensor() : data(nullptr), shape(nullptr), ndim(0), total_size(0) {}",
        "context": "    size_t ndim;          // Number of dimensions\n    size_t total_size;    // Total elements\n    \n    NeuralTensor() : data(nullptr), shape(nullptr), ndim(0), total_size(0) {}\n    \n    NeuralTensor(size_t dims[], size_t num_dims) : ndim(num_dims) {\n        shape = new size_t[ndim];\n"
      },
      {
        "file": "GGML/Tensor/ann_rules.h",
        "line": 434,
        "type": "empty_function",
        "content": "AttentionAllocation() : sti(ATTENTION_DEFAULT_STI), lti(0.0f), urgency(0.0f), allocations(0) {}",
        "context": "    float urgency;       // Processing urgency metric\n    size_t allocations;  // Number of attention allocations\n    \n    AttentionAllocation() : sti(ATTENTION_DEFAULT_STI), lti(0.0f), urgency(0.0f), allocations(0) {}\n    \n    // Update attention based on neural activity\n    void update(float activity_level) {\n"
      },
      {
        "file": "GGML/Tensor/fold_rules.h",
        "line": 41,
        "type": "empty_function",
        "content": "Tensor() : data(nullptr), shape(nullptr), ndim(0), total_size(0) {}",
        "context": "    size_t ndim;          // Number of dimensions\n    size_t total_size;    // Total number of elements\n    \n    Tensor() : data(nullptr), shape(nullptr), ndim(0), total_size(0) {}\n    \n    Tensor(size_t dims[], size_t num_dims) : ndim(num_dims) {\n        shape = new size_t[ndim];\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/AgenticCatalogManager.h",
        "line": 50,
        "type": "empty_function",
        "content": "CatalogEntry() : access_count(0), quality_score(0.0) {}",
        "context": "    std::vector<std::string> tags;\n    std::unordered_map<std::string, std::string> custom_attributes;\n    \n    CatalogEntry() : access_count(0), quality_score(0.0) {}\n    \n    void update_access_info() {\n        access_count++;\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/AgenticCatalogManager.h",
        "line": 120,
        "type": "empty_function",
        "content": "average_quality_score(0.0) {}",
        "context": "        prototype_kernels(0), experimental_kernels(0),\n        average_degrees_of_freedom(0.0), average_complexity_score(0.0),\n        max_degrees_of_freedom(0), min_degrees_of_freedom(0),\n        average_quality_score(0.0) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/AgenticKernelSpec.h",
        "line": 89,
        "type": "empty_function",
        "content": "is_tunable(tunable), affects_degrees_of_freedom(affects_dof) {}",
        "context": "                       bool affects_dof = true)\n        : name(param_name), description(param_desc), data_type(type),\n          range(param_range), default_value(default_val), \n          is_tunable(tunable), affects_degrees_of_freedom(affects_dof) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/KernelDegreeAnalyzer.h",
        "line": 52,
        "type": "empty_function",
        "content": "complexity_weight(weight), description(desc) {}",
        "context": "                   double weight = 1.0,\n                   const std::string& desc = \"\")\n        : name(dof_name), type(dof_type), dimension(dim),\n          complexity_weight(weight), description(desc) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/KernelDegreeAnalyzer.h",
        "line": 78,
        "type": "empty_function",
        "content": "complexity_score(0.0), adaptability_index(0.0), computational_cost_estimate(0.0) {}",
        "context": "    DegreesOfFreedomAnalysis() : total_degrees_of_freedom(0),\n        parameter_space_dof(0), discrete_choice_dof(0), structural_dof(0),\n        temporal_dof(0), compositional_dof(0), emergent_dof(0),\n        complexity_score(0.0), adaptability_index(0.0), computational_cost_estimate(0.0) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/PrimeFactorizationShapeDeriver.h",
        "line": 32,
        "type": "empty_function",
        "content": "PrimeFactorization(size_t num = 0) : original_number(num) {}",
        "context": "    std::vector<size_t> prime_factors;\n    std::unordered_map<size_t, size_t> factor_counts;\n    \n    PrimeFactorization(size_t num = 0) : original_number(num) {}\n    \n    size_t get_factor_count(size_t prime) const {\n        auto it = factor_counts.find(prime);\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/PrimeFactorizationShapeDeriver.h",
        "line": 87,
        "type": "empty_function",
        "content": "computational_efficiency(0.0), cognitive_alignment(0.0), symmetry_score(0.0) {}",
        "context": "    std::string analysis_timestamp;\n    \n    TensorShapeDerivation() : total_elements(0), memory_efficiency(0.0),\n        computational_efficiency(0.0), cognitive_alignment(0.0), symmetry_score(0.0) {}\n    \n    bool is_valid() const { \n        return !optimal_shape.empty() && total_elements > 0; \n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/SerializationEngine.h",
        "line": 56,
        "type": "empty_function",
        "content": "validate_on_deserialize(true) {}",
        "context": "        : format(fmt), pretty_print(true), include_metadata(true),\n          include_analysis_data(true), include_derivation_data(true),\n          compress_output(false), validate_on_serialize(true),\n          validate_on_deserialize(true) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/SerializationEngine.h",
        "line": 75,
        "type": "empty_function",
        "content": "serialization_time_ms(0.0), compression_ratio(1.0) {}",
        "context": "    double compression_ratio;\n    \n    SerializationResult() : success(false), data_size(0), \n        serialization_time_ms(0.0), compression_ratio(1.0) {}\n    \n    bool has_warnings() const { return !warnings.empty(); }\n    bool has_errors() const { return !errors.empty(); }\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/SerializationEngine.h",
        "line": 95,
        "type": "empty_function",
        "content": "checksum_verified(false) {}",
        "context": "    bool checksum_verified;\n    \n    DeserializationResult() : success(false), deserialization_time_ms(0.0),\n        checksum_verified(false) {}\n    \n    bool has_warnings() const { return !warnings.empty(); }\n    bool has_errors() const { return !errors.empty(); }\n"
      },
      {
        "file": "agentic-kernels-catalog/include/opencog/agentic/SerializationEngine.h",
        "line": 118,
        "type": "empty_function",
        "content": "precision_preserved(false), numeric_precision_loss(0.0) {}",
        "context": "    \n    RoundTripValidationResult() : passed(false), fidelity_score(0.0),\n        metadata_preserved(false), structure_preserved(false),\n        precision_preserved(false), numeric_precision_loss(0.0) {}\n};\n\n/**\n"
      },
      {
        "file": "agentic-kernels-catalog/tests/test_kernel_spec.cpp",
        "line": 60,
        "type": "empty_function",
        "content": "kernel.add_parameter(BehavioralParameter(\"bool_param\", \"Bool param\", \"bool\", {}, 0));",
        "context": "    \n    // Add parameters with known DOF contributions\n    kernel.add_parameter(BehavioralParameter(\"float_param\", \"Float param\", \"float\", {0.0, 1.0}, 0.5));\n    kernel.add_parameter(BehavioralParameter(\"bool_param\", \"Bool param\", \"bool\", {}, 0));\n    kernel.add_parameter(BehavioralParameter(\"int_param\", \"Int param\", \"int\", {1, 10}, 5));\n    \n    size_t dof = kernel.calculate_degrees_of_freedom();\n"
      },
      {
        "file": "atomspace-restful/opencog/events/AtomSpacePublisherModule.h",
        "line": 68,
        "type": "empty_function",
        "content": "lambda_task(const F& f) : my_func(f) {}",
        "context": "        return NULL;\n    }\npublic:\n    lambda_task(const F& f) : my_func(f) {}\n};\n\ntemplate<typename F>\n"
      },
      {
        "file": "atomspace-restful/opencog/python/web/api/apighost.py",
        "line": 28,
        "type": "empty_function",
        "content": "action = \"(test-ghost \\\"{}\\\")\".format(query)",
        "context": "        if 'query' in data:\n            query = data['query']\n            print(query)\n            action = \"(test-ghost \\\"{}\\\")\".format(query)\n            scheme_eval(self.atomspace, action)\n            response = scheme_eval(self.atomspace, '(get-result)')\n            print(response)\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 159,
        "type": "empty_function",
        "content": "{}",
        "context": "\tpublic:\n\t\tMonoStorageNode(Type t, const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n\t\tMonoStorageNode(const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 162,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t{}\n\t\tMonoStorageNode(const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n\n\t\tvoid setAtomSpace(AtomSpace* as)\n\t\t{\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 192,
        "type": "empty_function",
        "content": "{}",
        "context": "\tpublic:\n\t\tRocksStorageNode(Type t, const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n\t\tRocksStorageNode(const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 195,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t{}\n\t\tRocksStorageNode(const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n\n\t\tvoid setAtomSpace(AtomSpace* as)\n\t\t{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 61,
        "type": "empty_function",
        "content": "Implicator(as, cvp), _store(sto), _ras(as) {}",
        "context": "\tpublic:\n\t\tBackingImplicator(BackingStore* sto, AtomSpace* as,\n\t\t                  ContainerValuePtr& cvp) :\n\t\t\tImplicator(as, cvp), _store(sto), _ras(as) {}\n\t\tvirtual ~BackingImplicator() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&, Type);\n\t\tvirtual Handle get_link(const Handle&, Type, HandleSeq&&);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 62,
        "type": "empty_function",
        "content": "virtual ~BackingImplicator() {}",
        "context": "\t\tBackingImplicator(BackingStore* sto, AtomSpace* as,\n\t\t                  ContainerValuePtr& cvp) :\n\t\t\tImplicator(as, cvp), _store(sto), _ras(as) {}\n\t\tvirtual ~BackingImplicator() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&, Type);\n\t\tvirtual Handle get_link(const Handle&, Type, HandleSeq&&);\n};\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 74,
        "type": "empty_function",
        "content": "SatisfyingSet(as, cvp), _store(sto) {}",
        "context": "\tpublic:\n\t\tBackingSatisfyingSet(BackingStore* sto, AtomSpace* as,\n\t\t                     ContainerValuePtr& cvp) :\n\t\t\tSatisfyingSet(as, cvp), _store(sto) {}\n\t\tvirtual ~BackingSatisfyingSet() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&, Type);\n\t\tvirtual Handle get_link(const Handle&, Type, HandleSeq&&);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 75,
        "type": "empty_function",
        "content": "virtual ~BackingSatisfyingSet() {}",
        "context": "\t\tBackingSatisfyingSet(BackingStore* sto, AtomSpace* as,\n\t\t                     ContainerValuePtr& cvp) :\n\t\t\tSatisfyingSet(as, cvp), _store(sto) {}\n\t\tvirtual ~BackingSatisfyingSet() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&, Type);\n\t\tvirtual Handle get_link(const Handle&, Type, HandleSeq&&);\n};\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 87,
        "type": "empty_function",
        "content": ": _store(sto), _as(as) {}",
        "context": "\t\tAtomSpace* _as;\n\tpublic:\n\t\tBackingJoinCallback(BackingStore* sto, AtomSpace* as)\n\t\t\t: _store(sto), _as(as) {}\n\t\tvirtual ~BackingJoinCallback() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&);\n};\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingQuery.cc",
        "line": 88,
        "type": "empty_function",
        "content": "virtual ~BackingJoinCallback() {}",
        "context": "\tpublic:\n\t\tBackingJoinCallback(BackingStore* sto, AtomSpace* as)\n\t\t\t: _store(sto), _as(as) {}\n\t\tvirtual ~BackingJoinCallback() {}\n\t\tvirtual IncomingSet get_incoming_set(const Handle&);\n};\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingStore.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual ~BackingStore() {}",
        "context": "\tfriend class BackingSatisfyingSet;\n\tfriend class BackingJoinCallback;\n\tpublic:\n\t\tvirtual ~BackingStore() {}\n\n\t\t/**\n\t\t * Fetch all the Values attached to the indicated Atom,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/BackingStore.h",
        "line": 170,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t */\n\t\tvirtual void postRemoveAtom(AtomSpace* as, const Handle& h,\n\t\t                            bool recursive, bool extracted)\n\t\t{}\n\n\t\t/**\n\t\t * Store the value located at `key` on `atom` to the remote\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 178,
        "type": "empty_function",
        "content": "static const size_t versn = std::hash<std::string>{}(\"version\");",
        "context": "\t// Fast dispatch. There should be zero hash collisions\n\t// here. If there are, we are in trouble. (Well, if there\n\t// are collisions, just prepend a dot?)\n\tstatic const size_t versn = std::hash<std::string>{}(\"version\");\n\tstatic const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");\n\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 179,
        "type": "empty_function",
        "content": "static const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");",
        "context": "\t// here. If there are, we are in trouble. (Well, if there\n\t// are collisions, just prepend a dot?)\n\tstatic const size_t versn = std::hash<std::string>{}(\"version\");\n\tstatic const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");\n\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 180,
        "type": "empty_function",
        "content": "static const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");",
        "context": "\t// are collisions, just prepend a dot?)\n\tstatic const size_t versn = std::hash<std::string>{}(\"version\");\n\tstatic const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");\n\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 181,
        "type": "empty_function",
        "content": "static const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");",
        "context": "\tstatic const size_t versn = std::hash<std::string>{}(\"version\");\n\tstatic const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");\n\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 182,
        "type": "empty_function",
        "content": "static const size_t haven = std::hash<std::string>{}(\"haveNode\");",
        "context": "\tstatic const size_t gtatm = std::hash<std::string>{}(\"getAtoms\");\n\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 183,
        "type": "empty_function",
        "content": "static const size_t havel = std::hash<std::string>{}(\"haveLink\");",
        "context": "\tstatic const size_t gtsub = std::hash<std::string>{}(\"getSubTypes\");\n\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 184,
        "type": "empty_function",
        "content": "static const size_t havea = std::hash<std::string>{}(\"haveAtom\");",
        "context": "\tstatic const size_t gtsup = std::hash<std::string>{}(\"getSuperTypes\");\n\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 185,
        "type": "empty_function",
        "content": "static const size_t makea = std::hash<std::string>{}(\"makeAtom\");",
        "context": "\tstatic const size_t haven = std::hash<std::string>{}(\"haveNode\");\n\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 186,
        "type": "empty_function",
        "content": "static const size_t loada = std::hash<std::string>{}(\"loadAtoms\");",
        "context": "\tstatic const size_t havel = std::hash<std::string>{}(\"haveLink\");\n\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 187,
        "type": "empty_function",
        "content": "static const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");",
        "context": "\tstatic const size_t havea = std::hash<std::string>{}(\"haveAtom\");\n\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 188,
        "type": "empty_function",
        "content": "static const size_t gettv = std::hash<std::string>{}(\"getTV\");",
        "context": "\tstatic const size_t makea = std::hash<std::string>{}(\"makeAtom\");\n\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 189,
        "type": "empty_function",
        "content": "static const size_t settv = std::hash<std::string>{}(\"setTV\");",
        "context": "\tstatic const size_t loada = std::hash<std::string>{}(\"loadAtoms\");\n\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n\tstatic const size_t execu = std::hash<std::string>{}(\"execute\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 190,
        "type": "empty_function",
        "content": "static const size_t gtval = std::hash<std::string>{}(\"getValues\");",
        "context": "\tstatic const size_t gtinc = std::hash<std::string>{}(\"getIncoming\");\n\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n\tstatic const size_t execu = std::hash<std::string>{}(\"execute\");\n\tstatic const size_t extra = std::hash<std::string>{}(\"extract\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 191,
        "type": "empty_function",
        "content": "static const size_t stval = std::hash<std::string>{}(\"setValue\");",
        "context": "\tstatic const size_t gettv = std::hash<std::string>{}(\"getTV\");\n\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n\tstatic const size_t execu = std::hash<std::string>{}(\"execute\");\n\tstatic const size_t extra = std::hash<std::string>{}(\"extract\");\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 192,
        "type": "empty_function",
        "content": "static const size_t execu = std::hash<std::string>{}(\"execute\");",
        "context": "\tstatic const size_t settv = std::hash<std::string>{}(\"setTV\");\n\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n\tstatic const size_t execu = std::hash<std::string>{}(\"execute\");\n\tstatic const size_t extra = std::hash<std::string>{}(\"extract\");\n\n\t// Ignore comments, blank lines\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 193,
        "type": "empty_function",
        "content": "static const size_t extra = std::hash<std::string>{}(\"extract\");",
        "context": "\tstatic const size_t gtval = std::hash<std::string>{}(\"getValues\");\n\tstatic const size_t stval = std::hash<std::string>{}(\"setValue\");\n\tstatic const size_t execu = std::hash<std::string>{}(\"execute\");\n\tstatic const size_t extra = std::hash<std::string>{}(\"extract\");\n\n\t// Ignore comments, blank lines\n\tsize_t cpos = cmd.find_first_not_of(\" \\n\\t\");\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 230,
        "type": "empty_function",
        "content": "act = std::hash<std::string>{}(cmd.substr(cpos, epos-cpos));",
        "context": "\t\tif (std::string::npos == epos) return reterr(cmd);\n\t\tpos = epos + 1;\n\n\t\tact = std::hash<std::string>{}(cmd.substr(cpos, epos-cpos));\n\t\tepos = cmd.size();\n\t}\n\telse\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 247,
        "type": "empty_function",
        "content": "act = std::hash<std::string>{}(tool_name);",
        "context": "\n\t\t// Extract the tool name\n\t\tstd::string tool_name = cmd.substr(cpos, tool_end-cpos);\n\t\tact = std::hash<std::string>{}(tool_name);\n\n\t\t// OK, so now pos and tool_end bracket the tool name.\n\t\t// Advance cpos past the params.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/JSCommands.cc",
        "line": 280,
        "type": "empty_function",
        "content": "// AtomSpace.version({})",
        "context": "\t// -----------------------------------------------\n\t// Get version\n\t// AtomSpace.version()\n\t// AtomSpace.version({})\n\tif (versn == act)\n\t{\n\t\tRETURN(ATOMSPACE_VERSION_STRING);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/McpPlugAtomSpace.cc",
        "line": 50,
        "type": "empty_function",
        "content": "\"{\\\"type\\\": \\\"object\\\", \\\"properties\\\": {}, \\\"required\\\": []}\");",
        "context": "\n\t// version\n\tadd_tool(json, \"version\", \"Get the AtomSpace version string\",\n\t\t\"{\\\"type\\\": \\\"object\\\", \\\"properties\\\": {}, \\\"required\\\": []}\");\n\n\t// getSubTypes\n\tadd_tool(json, \"getSubTypes\", \"Get all subtypes of a given atom type\",\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/json/McpPlugAtomSpace.h",
        "line": 44,
        "type": "empty_function",
        "content": "McpPlugAtomSpace(AtomSpace* as) : _as(as) {}",
        "context": "\tAtomSpace* _as;\n\npublic:\n\tMcpPlugAtomSpace(AtomSpace* as) : _as(as) {}\n\tvirtual ~McpPlugAtomSpace() = default;\n\n\t/**\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 44,
        "type": "empty_function",
        "content": "virtual void open(void) {}",
        "context": "\tvirtual ~DynamicDataProxy();\n\n\t// ----------------------------------------------------------------\n\tvirtual void open(void) {}\n\tvirtual void close(void) {}\n\tvirtual bool connected(void) { return true; }\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 45,
        "type": "empty_function",
        "content": "virtual void close(void) {}",
        "context": "\n\t// ----------------------------------------------------------------\n\tvirtual void open(void) {}\n\tvirtual void close(void) {}\n\tvirtual bool connected(void) { return true; }\n\nprotected:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 53,
        "type": "empty_function",
        "content": "virtual void fetchIncomingSet(AtomSpace*, const Handle&) {}",
        "context": "\t// BackingStore virtuals.\n\n\tvirtual void getAtom(const Handle&);\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 54,
        "type": "empty_function",
        "content": "virtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}",
        "context": "\n\tvirtual void getAtom(const Handle&);\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 56,
        "type": "empty_function",
        "content": "virtual void storeAtom(const Handle&, bool synchronous = false) {}",
        "context": "\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 57,
        "type": "empty_function",
        "content": "virtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}",
        "context": "\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 58,
        "type": "empty_function",
        "content": "virtual void storeValue(const Handle& atom, const Handle& key) {}",
        "context": "\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 60,
        "type": "empty_function",
        "content": "const ValuePtr& delta) {}",
        "context": "\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 63,
        "type": "empty_function",
        "content": "virtual void loadType(AtomSpace*, Type) {}",
        "context": "\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 64,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 65,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n\npublic:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/DynamicDataProxy.h",
        "line": 66,
        "type": "empty_function",
        "content": "virtual void barrier(AtomSpace* = nullptr) {}",
        "context": "\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n\npublic:\n\tstatic Handle factory(const Handle&);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 42,
        "type": "empty_function",
        "content": "virtual void open(void) {}",
        "context": "\n\t// ----------------------------------------------------------------\n\t// StorageNode virtuals  are all no-ops.\n\tvirtual void open(void) {}\n\tvirtual void close(void) {}\n\tvirtual bool connected(void) { return  true; }\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 43,
        "type": "empty_function",
        "content": "virtual void close(void) {}",
        "context": "\t// ----------------------------------------------------------------\n\t// StorageNode virtuals  are all no-ops.\n\tvirtual void open(void) {}\n\tvirtual void close(void) {}\n\tvirtual bool connected(void) { return  true; }\n\nprotected:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 50,
        "type": "empty_function",
        "content": "virtual void getAtom(const Handle&) {}",
        "context": "\t// ----------------------------------------------------------------\n\t// BackingStore virtuals.\n\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 51,
        "type": "empty_function",
        "content": "virtual void fetchIncomingSet(AtomSpace*, const Handle&) {}",
        "context": "\t// BackingStore virtuals.\n\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 52,
        "type": "empty_function",
        "content": "virtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}",
        "context": "\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 53,
        "type": "empty_function",
        "content": "virtual void storeAtom(const Handle&, bool synchronous = false) {}",
        "context": "\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 54,
        "type": "empty_function",
        "content": "virtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}",
        "context": "\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 55,
        "type": "empty_function",
        "content": "virtual void storeValue(const Handle& atom, const Handle& key) {}",
        "context": "\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 57,
        "type": "empty_function",
        "content": "const ValuePtr& delta) {}",
        "context": "\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 58,
        "type": "empty_function",
        "content": "virtual void loadValue(const Handle& atom, const Handle& key) {}",
        "context": "\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual void loadType(AtomSpace*, Type) {}",
        "context": "\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 61,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 62,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/NullProxy.h",
        "line": 64,
        "type": "empty_function",
        "content": "virtual void barrier(AtomSpace* = nullptr) {}",
        "context": "\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\n\tvirtual void barrier(AtomSpace* = nullptr) {}\n\npublic:\n\tstatic Handle factory(const Handle&);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.h",
        "line": 64,
        "type": "empty_function",
        "content": "virtual void create(void) {} // stop-gap. FIXME",
        "context": "\t// implementations. Some of these are stop-gap, and will need to be\n\t// updated at some later date. XXX FIXME.\n\n\tvirtual void create(void) {} // stop-gap. FIXME\n\tvirtual void destroy(void);  //stop-gap. FIXME\n\tvirtual void erase(void);    // stop-gap. FIXME\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual void storeAtom(const Handle&, bool synchronous = false) {}",
        "context": "\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&);\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type);\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}",
        "context": "\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type);\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 61,
        "type": "empty_function",
        "content": "virtual void storeValue(const Handle& atom, const Handle& key) {}",
        "context": "\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 63,
        "type": "empty_function",
        "content": "const ValuePtr& delta) {}",
        "context": "\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 67,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadThruProxy.h",
        "line": 68,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\npublic:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadWriteProxy.h",
        "line": 69,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ReadWriteProxy.h",
        "line": 70,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\n\tvirtual std::string monitor(void);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 58,
        "type": "empty_function",
        "content": "virtual void storeAtom(const Handle&, bool synchronous = false) {}",
        "context": "\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&);\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type);\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}",
        "context": "\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type);\n\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual void storeValue(const Handle& atom, const Handle& key) {}",
        "context": "\n\tvirtual void storeAtom(const Handle&, bool synchronous = false) {}\n\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 62,
        "type": "empty_function",
        "content": "const ValuePtr& delta) {}",
        "context": "\tvirtual void removeAtom(AtomSpace*, const Handle&, bool recursive) {}\n\tvirtual void storeValue(const Handle& atom, const Handle& key) {}\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta) {}\n\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 66,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key);\n\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/SequentialReadProxy.h",
        "line": 67,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type);\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\npublic:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 55,
        "type": "empty_function",
        "content": "virtual void getAtom(const Handle&) {}",
        "context": "\t// ----------------------------------------------------------------\n\t// BackingStore virtuals.\n\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 56,
        "type": "empty_function",
        "content": "virtual void fetchIncomingSet(AtomSpace*, const Handle&) {}",
        "context": "\t// BackingStore virtuals.\n\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false);\n\tvirtual void preRemoveAtom(AtomSpace*, const Handle&, bool recursive);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 57,
        "type": "empty_function",
        "content": "virtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}",
        "context": "\n\tvirtual void getAtom(const Handle&) {}\n\tvirtual void fetchIncomingSet(AtomSpace*, const Handle&) {}\n\tvirtual void fetchIncomingByType(AtomSpace*, const Handle&, Type) {}\n\tvirtual void storeAtom(const Handle&, bool synchronous = false);\n\tvirtual void preRemoveAtom(AtomSpace*, const Handle&, bool recursive);\n\tvirtual void postRemoveAtom(AtomSpace*, const Handle&,\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 65,
        "type": "empty_function",
        "content": "virtual void loadValue(const Handle& atom, const Handle& key) {}",
        "context": "\tvirtual void storeValue(const Handle& atom, const Handle& key);\n\tvirtual void updateValue(const Handle& atom, const Handle& key,\n\t                         const ValuePtr& delta);\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 67,
        "type": "empty_function",
        "content": "virtual void loadType(AtomSpace*, Type) {}",
        "context": "\t                         const ValuePtr& delta);\n\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 68,
        "type": "empty_function",
        "content": "virtual void loadAtomSpace(AtomSpace*) {}",
        "context": "\tvirtual void loadValue(const Handle& atom, const Handle& key) {}\n\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteThruProxy.h",
        "line": 69,
        "type": "empty_function",
        "content": "virtual void storeAtomSpace(const AtomSpace*) {}",
        "context": "\n\tvirtual void loadType(AtomSpace*, Type) {}\n\tvirtual void loadAtomSpace(AtomSpace*) {}\n\tvirtual void storeAtomSpace(const AtomSpace*) {}\n\tvirtual void barrier(AtomSpace* = nullptr);\n\npublic:\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 56,
        "type": "empty_function",
        "content": "Commands::Commands(void) : _multi_space(false) {}",
        "context": "/// is guaranteed to send only these commands, and no others.\n//\n\nCommands::Commands(void) : _multi_space(false) {}\nCommands::~Commands() {}\n\n/// Search for optional AtomSpace argument in `cmd` at `pos`.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 57,
        "type": "empty_function",
        "content": "Commands::~Commands() {}",
        "context": "//\n\nCommands::Commands(void) : _multi_space(false) {}\nCommands::~Commands() {}\n\n/// Search for optional AtomSpace argument in `cmd` at `pos`.\n/// If none is found, then return `as`\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Dispatcher.cc",
        "line": 52,
        "type": "empty_function",
        "content": "static const size_t HSH = std::hash<std::string>{}(STR); \\",
        "context": "\t// Optimized dispatch using direct method pointers\n\t// This avoids the overhead of std::bind and std::function\n#define REGISTER_HANDLER(HSH,STR,CB) \\\n   static const size_t HSH = std::hash<std::string>{}(STR); \\\n   _handler_map[HSH] = std::make_unique<CommandHandlerImpl<Commands>>(&_default, &Commands::CB);\n\n\tREGISTER_HANDLER(space, \"cog-atomspace)\",         cog_atomspace);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Dispatcher.cc",
        "line": 88,
        "type": "empty_function",
        "content": "size_t idhash = std::hash<std::string>{}(idstr);",
        "context": "\nvoid Dispatcher::install_handler(const std::string& idstr, Meth handler)\n{\n\tsize_t idhash = std::hash<std::string>{}(idstr);\n\t_dispatch_map.insert_or_assign(idhash, handler);\n}\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Dispatcher.cc",
        "line": 115,
        "type": "empty_function",
        "content": "size_t action = std::hash<std::string>{}(cmd.substr(pos, epos-pos));",
        "context": "\t\t\tcmd.c_str());\n\n\t// Look up the method to call, based on the hash of the command string.\n\tsize_t action = std::hash<std::string>{}(cmd.substr(pos, epos-pos));\n\t\n\t// First try the optimized handler map\n\tconst auto& handler = _handler_map.find(action);\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Dispatcher.h",
        "line": 44,
        "type": "empty_function",
        "content": "virtual ~CommandHandler() {}",
        "context": "class CommandHandler\n{\npublic:\n\tvirtual ~CommandHandler() {}\n\tvirtual std::string execute(const std::string& args) = 0;\n};\n\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Dispatcher.h",
        "line": 58,
        "type": "empty_function",
        "content": ": _target(target), _method(method) {}",
        "context": "\t\npublic:\n\tCommandHandlerImpl(T* target, std::string (T::*method)(const std::string&))\n\t\t: _target(target), _method(method) {}\n\t\n\tstd::string execute(const std::string& args) override\n\t{\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/tlb/TLB.h",
        "line": 41,
        "type": "empty_function",
        "content": "virtual ~uuid_pool() {}",
        "context": "class uuid_pool\n{\npublic:\n    virtual ~uuid_pool() {}\n\n    virtual UUID get_uuid(void) = 0;\n};\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/tlb/TLB.h",
        "line": 53,
        "type": "empty_function",
        "content": "local_uuid_pool(void) : _brk_uuid(1) {}",
        "context": "    // Thread-safe atomic\n    std::atomic<UUID> _brk_uuid;\npublic:\n    local_uuid_pool(void) : _brk_uuid(1) {}\n\n    UUID get_uuid(void)\n    {\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/tlb/UuidSCM.cc",
        "line": 72,
        "type": "empty_function",
        "content": "UuidSCM::UuidSCM() : ModuleWrap(\"opencog uuid\") {}",
        "context": "\n} /*end of namespace opencog*/\n\nUuidSCM::UuidSCM() : ModuleWrap(\"opencog uuid\") {}\n\n/// This is called while (opencog uuid) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/examples/c++-guile/ExampleSCM.cc",
        "line": 36,
        "type": "empty_function",
        "content": "{}",
        "context": "// ModuleWrap takes the string name of the guile module.\nExampleSCM::ExampleSCM(void) :\n\tModuleWrap(\"opencog example\")\n{}\n\n/// This is called while (opencog example) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/examples/c++-guile/PrimitiveExample.cc",
        "line": 23,
        "type": "empty_function",
        "content": "MyTestClass(AtomSpacePtr as, int id) : _as(as), _id(id) {}",
        "context": "\t\tint _id;  // some value in the instance\n\tpublic:\n\n\t\tMyTestClass(AtomSpacePtr as, int id) : _as(as), _id(id) {}\n\n\t\t// An example method -- accepts a handle, and wraps it\n\t\t// with a ListLink.\n"
      },
      {
        "file": "atomspace/opencog/atoms/atom_types/NameServer.cc",
        "line": 174,
        "type": "empty_function",
        "content": "_hash[type]                  = std::hash<std::string>{}(name);",
        "context": "    name2CodeMap[name]           = type;\n    _code2NameMap[type]          = &(name2CodeMap.find(name)->first);\n    _mod[type]                   = _tmod;\n    _hash[type]                  = std::hash<std::string>{}(name);\n\n    Type maxd = 1;\n    setParentRecursively(parent, type, maxd);\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Atom.cc",
        "line": 509,
        "type": "empty_function",
        "content": "void Atom::install() {}",
        "context": "    bucket->second.insert(GET_PTR(neu));\n}\n\nvoid Atom::install() {}\nvoid Atom::remove() {}\n\nbool Atom::isIncomingSetEmpty(const AtomSpace* as) const\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Atom.cc",
        "line": 510,
        "type": "empty_function",
        "content": "void Atom::remove() {}",
        "context": "}\n\nvoid Atom::install() {}\nvoid Atom::remove() {}\n\nbool Atom::isIncomingSetEmpty(const AtomSpace* as) const\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Atom.h",
        "line": 63,
        "type": "empty_function",
        "content": "_hash = std::hash<T*>{}(sp.get());",
        "context": "\t\tstd::weak_ptr<T>(sp)\n\t{\n\t\tif (!sp) return;\n\t\t_hash = std::hash<T*>{}(sp.get());\n\t}\n\n\tstd::size_t get_hash() const noexcept { return _hash; }\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Atom.h",
        "line": 265,
        "type": "empty_function",
        "content": "{}",
        "context": "        _use_iset(false),\n        _content_hash(Handle::INVALID_HASH),\n        _atom_space(nullptr)\n    {}\n\n    Atom& operator=(const Atom& other) // copy assignment operator\n        { return *this; }\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/ClassServer.cc",
        "line": 44,
        "type": "empty_function",
        "content": "{}",
        "context": "\nClassServer::ClassServer(const NameServer & nameServer):\n\t_nameServer(nameServer)\n{}\n\n/// ClassServer::splice -- install a factory for an atom type.\n///\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Handle.h",
        "line": 79,
        "type": "empty_function",
        "content": "explicit Handle(const AtomPtr& atom) : AtomPtr(atom) {}",
        "context": "    static const Handle UNDEFINED;\n\n    // Copy constructor\n    explicit Handle(const AtomPtr& atom) : AtomPtr(atom) {}\n\n    // Move constructor\n    explicit Handle(AtomPtr&& atom) : AtomPtr(atom) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Handle.h",
        "line": 82,
        "type": "empty_function",
        "content": "explicit Handle(AtomPtr&& atom) : AtomPtr(atom) {}",
        "context": "    explicit Handle(const AtomPtr& atom) : AtomPtr(atom) {}\n\n    // Move constructor\n    explicit Handle(AtomPtr&& atom) : AtomPtr(atom) {}\n\n    explicit Handle() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Handle.h",
        "line": 84,
        "type": "empty_function",
        "content": "explicit Handle() {}",
        "context": "    // Move constructor\n    explicit Handle(AtomPtr&& atom) : AtomPtr(atom) {}\n\n    explicit Handle() {}\n\n    ~Handle() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Handle.h",
        "line": 86,
        "type": "empty_function",
        "content": "~Handle() {}",
        "context": "\n    explicit Handle() {}\n\n    ~Handle() {}\n\n    ContentHash value(void) const;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Valuation.h",
        "line": 53,
        "type": "empty_function",
        "content": ": Value(VALUATION), _key(k), _atom(a), _value(v) {}",
        "context": "\npublic:\n\tValuation(const Handle& k, const Handle& a, const ValuePtr& v)\n\t\t: Value(VALUATION), _key(k), _atom(a), _value(v) {}\n\n\tvirtual ~Valuation() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/base/Valuation.h",
        "line": 55,
        "type": "empty_function",
        "content": "virtual ~Valuation() {}",
        "context": "\tValuation(const Handle& k, const Handle& a, const ValuePtr& v)\n\t\t: Value(VALUATION), _key(k), _atom(a), _value(v) {}\n\n\tvirtual ~Valuation() {}\n\n\tconst Handle& key() { return _key; }\n\tconst Handle& atom() { return _atom; }\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Context.cc",
        "line": 39,
        "type": "empty_function",
        "content": ": quotation(q), shadow(s), store_scope_variables(i), scope_variables(v) {}",
        "context": "Context::Context(const Quotation& q,\n                 const HandleSet& s,\n                 bool i, const VariablesStack& v)\n\t: quotation(q), shadow(s), store_scope_variables(i), scope_variables(v) {}\n\nContext::Context(bool s) : store_scope_variables(s) {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Context.cc",
        "line": 41,
        "type": "empty_function",
        "content": "Context::Context(bool s) : store_scope_variables(s) {}",
        "context": "                 bool i, const VariablesStack& v)\n\t: quotation(q), shadow(s), store_scope_variables(i), scope_variables(v) {}\n\nContext::Context(bool s) : store_scope_variables(s) {}\n\nvoid Context::update(const Handle& h)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FindUtils.cc",
        "line": 54,
        "type": "empty_function",
        "content": "{}",
        "context": "FindAtoms::FindAtoms(const Handle& atom)\n\t: _target_types(),\n\t  _target_atoms({atom})\n{}\n\nFindAtoms::FindAtoms(const HandleSet& selection)\n\t: _target_types(),\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FindUtils.cc",
        "line": 59,
        "type": "empty_function",
        "content": "{}",
        "context": "FindAtoms::FindAtoms(const HandleSet& selection)\n\t: _target_types(),\n\t  _target_atoms(selection)\n{}\n\nvoid FindAtoms::search_set(const Handle& h)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FindUtils.cc",
        "line": 409,
        "type": "empty_function",
        "content": "return {};",
        "context": "\tif ((t == VARIABLE_NODE or t == GLOB_NODE) and quotation.is_unquoted())\n\t\treturn {h};\n\tif (h->is_node())\n\t\treturn {};\n\n\t// Recursive cases\n\tOC_ASSERT(h->is_link());\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FindUtils.cc",
        "line": 441,
        "type": "empty_function",
        "content": "return {};",
        "context": "{\n\t// Base cases\n\tif (!h)\n\t\treturn {};\n\tif (h->is_node())\n\t\treturn {h};\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FindUtils.cc",
        "line": 456,
        "type": "empty_function",
        "content": "return {};",
        "context": "\t}\n\n\t// Please the compiler\n\treturn {};\n}\n\nbool is_closed(const Handle& h, Quotation quotation)\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FreeLink.h",
        "line": 51,
        "type": "empty_function",
        "content": "virtual ~FreeLink() {}",
        "context": "\tFreeLink(const HandleSeq&&, Type=FREE_LINK);\n\tFreeLink(const FreeLink&) = delete;\n\tFreeLink& operator=(const FreeLink&) = delete;\n\tvirtual ~FreeLink() {}\n\n\tconst FreeVariables& get_vars() const\n\t{ return  _vars; }\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FreeVariables.cc",
        "line": 162,
        "type": "empty_function",
        "content": "return HandlePathsMap{{h, {{}}}};",
        "context": "{\n\t// Base cases\n\tif (is_variable(h))\n\t\treturn HandlePathsMap{{h, {{}}}};\n\tif (h->is_node())\n\t\treturn HandlePathsMap{};\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FreeVariables.cc",
        "line": 164,
        "type": "empty_function",
        "content": "return HandlePathsMap{};",
        "context": "\tif (is_variable(h))\n\t\treturn HandlePathsMap{{h, {{}}}};\n\tif (h->is_node())\n\t\treturn HandlePathsMap{};\n\n\t// Recursive case\n\treturn variables_paths(h->get_type(), h->getOutgoingSet());\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FreeVariables.cc",
        "line": 195,
        "type": "empty_function",
        "content": "return {};",
        "context": "\tif (ctx.is_free_variable(body))\n\t\treturn {body};\n\tif (body->is_node())\n\t\treturn {};\n\n\t// Recursive cases\n\tOC_ASSERT(body->is_link());\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FreeVariables.h",
        "line": 67,
        "type": "empty_function",
        "content": "FreeVariables() {}",
        "context": "\tIndexMap index;\n\n\t// CTor, mostly convenient for unit tests\n\tFreeVariables() {}\n\tFreeVariables(const std::initializer_list<Handle>& variables);\n\n\t// Construct index. FreeVariables::varseq must be previously\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/FunctionLink.h",
        "line": 75,
        "type": "empty_function",
        "content": "virtual ~FunctionLink() {}",
        "context": "\n\tFunctionLink(const FunctionLink&) = delete;\n\tFunctionLink& operator=(const FunctionLink&) = delete;\n\tvirtual ~FunctionLink() {}\n\n\tvirtual bool is_executable(void) const { return true; }\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/NumberNode.h",
        "line": 49,
        "type": "empty_function",
        "content": "char buf[buf_size]{};",
        "context": "\tstatic std::string double_to_string(double x)\n\t{\n\t\tconst size_t buf_size = 30;\n\t\tchar buf[buf_size]{};\n\t\tstd::to_chars_result result = std::to_chars(buf, buf + buf_size,\n\t\t\tx, std::chars_format::general, 18);\n\t\tif (result.ec != std::errc())\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/PutLink.cc",
        "line": 495,
        "type": "empty_function",
        "content": "catch (const TypeCheckException& ex) {}",
        "context": "\t\t\t{\n\t\t\t\tbset.emplace_back(reddy(subs, oset));\n\t\t\t}\n\t\t\tcatch (const TypeCheckException& ex) {}\n\t\t}\n\t\treturn createLink(std::move(bset), SET_LINK);\n\t}\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/PutLink.cc",
        "line": 552,
        "type": "empty_function",
        "content": "catch (const TypeCheckException& ex) {}",
        "context": "\t\t{\n\t\t\tbset.emplace_back(reddy(subs, oset));\n\t\t}\n\t\tcatch (const TypeCheckException& ex) {}\n\t}\n\treturn createLink(std::move(bset), SET_LINK);\n}\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/PutLink.h",
        "line": 88,
        "type": "empty_function",
        "content": "virtual ~PutLink() {}",
        "context": "\tPutLink(const HandleSeq&&, Type=PUT_LINK);\n\tPutLink(const PutLink&) = delete;\n\tPutLink& operator=(const PutLink&) = delete;\n\tvirtual ~PutLink() {}\n\n\t// PutLink arguments may be the second or the third outgoing-set elt.\n\tHandle get_arguments() { return _arguments; }\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Quotation.cc",
        "line": 33,
        "type": "empty_function",
        "content": ": _quotation_level(ql), _local_quote(lq) {}",
        "context": "namespace opencog {\n\nQuotation::Quotation(int ql, bool lq)\n\t: _quotation_level(ql), _local_quote(lq) {}\n\nint Quotation::level() const\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 275,
        "type": "empty_function",
        "content": "vardecl = HandleCast(createVariableList(HandleSeq{}));",
        "context": "\t\t// vardecl it means that some quotations are missing. Rather\n\t\t// than adding them we set vardecl to an empty VariableList.\n\t\tif (not vardecl and not get_free_variables(nbody).empty())\n\t\t\tvardecl = HandleCast(createVariableList(HandleSeq{}));\n\t}\n\n\tif (vardecl)\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/ScopeLink.cc",
        "line": 457,
        "type": "empty_function",
        "content": "} catch (const NestingException& ex) {}",
        "context": "\tAtom& a = (Atom&) ac; // cast away constness, for smart ptr.\n\ttry {\n\t\treturn is_equal(a.get_handle(), true);\n\t} catch (const NestingException& ex) {}\n\treturn false;\n}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/TypeNode.h",
        "line": 82,
        "type": "empty_function",
        "content": "{}",
        "context": "\tTypeNode(Type t)\n\t\t: Node(TYPE_NODE, std::string(nameserver().getTypeName(t))),\n\t\t  _kind(t)\n\t{}\n\n\tTypeNode(TypeNode&) = delete;\n\tTypeNode& operator=(const TypeNode&) = delete;\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/VariableList.cc",
        "line": 46,
        "type": "empty_function",
        "content": "HandleSeq({})",
        "context": "\t: Link(\n\t\tnot vardecl ?\n\t\t// If vardecl is undefined then construct an empty variable list\n\t\tHandleSeq({})\n\t\t:\n\t\t// Otherwise vardecl is either a VariableList, or a naked or\n\t\t// typed variable.\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/VariableSet.cc",
        "line": 51,
        "type": "empty_function",
        "content": "HandleSeq({})",
        "context": "\t: UnorderedLink(\n\t\tnot vardecl ?\n\t\t// If vardecl is undefined then construct an empty variable set\n\t\tHandleSeq({})\n\t\t:\n\t\t// Otherwise vardecl is either a VariableSet, or a naked or\n\t\t// typed variable.\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/GroundedProcedureNode.h",
        "line": 42,
        "type": "empty_function",
        "content": ": Node(t, std::move(s)) {}",
        "context": "{\npublic:\n\tGroundedProcedureNode(Type t, const std::string s)\n\t\t: Node(t, std::move(s)) {}\n\tGroundedProcedureNode(const GroundedProcedureNode&) = delete;\n\tGroundedProcedureNode& operator=(const GroundedProcedureNode&) = delete;\n\tvirtual ~GroundedProcedureNode() {};\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/GroundedProcedureNode.h",
        "line": 45,
        "type": "empty_function",
        "content": "virtual ~GroundedProcedureNode() {};",
        "context": "\t\t: Node(t, std::move(s)) {}\n\tGroundedProcedureNode(const GroundedProcedureNode&) = delete;\n\tGroundedProcedureNode& operator=(const GroundedProcedureNode&) = delete;\n\tvirtual ~GroundedProcedureNode() {};\n\n\tvirtual ValuePtr execute_args(AtomSpace*, const ValuePtr&, bool silent=false) = 0;\n};\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 37,
        "type": "empty_function",
        "content": "{}",
        "context": "using namespace opencog;\n\nInstantiator::Instantiator(AtomSpace* as) : _as(as)\n{}\n\nInstantiator::Instantiator(const AtomSpacePtr& asp) : _as(asp.get())\n{}\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 40,
        "type": "empty_function",
        "content": "{}",
        "context": "{}\n\nInstantiator::Instantiator(const AtomSpacePtr& asp) : _as(asp.get())\n{}\n\n/// Perform beta-reduction on the expression `expr`, using the `vmap`\n/// to fish out values for variables.  The map holds pairs: the first\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.h",
        "line": 62,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t\t_consume_quotations(true),\n\t\t\t_needless_quotation(true),\n\t\t\t_halt(false)\n\t\t{}\n\t\tconst GroundingMap& _varmap;\n\n\t\t/**\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 150,
        "type": "empty_function",
        "content": "return createLinkValue(_out_type, ValueSeq({}));",
        "context": "\t{\n\t\tif (_out_is_link)\n\t\t\treturn createLink(_out_type);\n\t\treturn createLinkValue(_out_type, ValueSeq({}));\n\t}\n\n\tif (vp->is_atom())\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/ValueShimLink.h",
        "line": 49,
        "type": "empty_function",
        "content": "ValueShimLink(const ValuePtr& v) : Link(VALUE_SHIM_LINK), val(v) {}",
        "context": "public:\n\tValueShimLink(Type=VALUE_SHIM_LINK);\n\tValueShimLink(const HandleSeq&, Type=VALUE_SHIM_LINK);\n\tValueShimLink(const ValuePtr& v) : Link(VALUE_SHIM_LINK), val(v) {}\n\n\tValueShimLink(const ValueShimLink&) = delete;\n\tValueShimLink& operator=(const ValueShimLink&) = delete;\n"
      },
      {
        "file": "atomspace/opencog/atoms/grounded/Runner.h",
        "line": 40,
        "type": "empty_function",
        "content": "Runner(void) {}",
        "context": "class Runner\n{\npublic:\n\tRunner(void) {}\n\tRunner(const Runner&) = delete;\n\tRunner& operator=(const Runner&) = delete;\n\tvirtual ~Runner() {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/grounded/Runner.h",
        "line": 43,
        "type": "empty_function",
        "content": "virtual ~Runner() {}",
        "context": "\tRunner(void) {}\n\tRunner(const Runner&) = delete;\n\tRunner& operator=(const Runner&) = delete;\n\tvirtual ~Runner() {}\n\n\tvirtual ValuePtr evaluate(AtomSpace*, const ValuePtr&, bool=false) = 0;\n\tvirtual ValuePtr execute(AtomSpace*, const ValuePtr&, bool=false) = 0;\n"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.h",
        "line": 39,
        "type": "empty_function",
        "content": "virtual ~JoinCallback() {}",
        "context": "class JoinCallback\n{\npublic:\n\tvirtual ~JoinCallback() {}\n\n\t/// Callback to get the IncomgingSet of the given Handle.\n\tvirtual IncomingSet get_incoming_set(const Handle&) = 0;\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/BindLink.cc",
        "line": 50,
        "type": "empty_function",
        "content": "{}",
        "context": "                   const Handle& body,\n                   const Handle& rewrite)\n\t: BindLink(HandleSeq{vardecl, body, rewrite})\n{}\n\nBindLink::BindLink(const Handle& body, const Handle& rewrite)\n\t: BindLink(HandleSeq{body, rewrite})\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/BindLink.cc",
        "line": 54,
        "type": "empty_function",
        "content": "{}",
        "context": "\nBindLink::BindLink(const Handle& body, const Handle& rewrite)\n\t: BindLink(HandleSeq{body, rewrite})\n{}\n\nBindLink::BindLink(const HandleSeq&& hseq, Type t)\n\t: QueryLink(std::move(hseq), t)\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/Pattern.h",
        "line": 76,
        "type": "empty_function",
        "content": "Pattern() : group_min_size(0), group_max_size(-1), have_evaluatables(false) {}",
        "context": "\ttypedef std::pair<Handle, PatternTermPtr> AtomInClausePair;\n\ttypedef std::map<AtomInClausePair, PatternTermSeq> ConnectTermMap;\n\n\tPattern() : group_min_size(0), group_max_size(-1), have_evaluatables(false) {}\n\n\t// -------------------------------------------\n\t/// The current set of clauses (beta redex context) being grounded.\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternTerm.cc",
        "line": 44,
        "type": "empty_function",
        "content": "{}",
        "context": "\t  _has_choice(false),\n\t  _is_always(false),\n\t  _is_grouping(false)\n{}\n\nPatternTerm::PatternTerm(const PatternTermPtr& parent, const Handle& h)\n\t: _handle(h), _quote(Handle::UNDEFINED), _parent(parent),\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/QueryLink.cc",
        "line": 68,
        "type": "empty_function",
        "content": "{}",
        "context": "                   const Handle& body,\n                   const Handle& rewrite)\n\t: QueryLink(HandleSeq{vardecl, body, rewrite})\n{}\n\nQueryLink::QueryLink(const Handle& body, const Handle& rewrite)\n\t: QueryLink(HandleSeq{body, rewrite})\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/QueryLink.cc",
        "line": 72,
        "type": "empty_function",
        "content": "{}",
        "context": "\nQueryLink::QueryLink(const Handle& body, const Handle& rewrite)\n\t: QueryLink(HandleSeq{body, rewrite})\n{}\n\nQueryLink::QueryLink(const HandleSeq&& hseq, Type t)\n\t: PatternLink(std::move(hseq), t)\n"
      },
      {
        "file": "atomspace/opencog/atoms/rule/RuleLink.cc",
        "line": 59,
        "type": "empty_function",
        "content": "{}",
        "context": "                   const Handle& body,\n                   const Handle& rewrite)\n\t: RuleLink(HandleSeq{vardecl, body, rewrite})\n{}\n\nRuleLink::RuleLink(const Handle& body, const Handle& rewrite)\n\t: RuleLink(HandleSeq{body, rewrite})\n"
      },
      {
        "file": "atomspace/opencog/atoms/rule/RuleLink.cc",
        "line": 63,
        "type": "empty_function",
        "content": "{}",
        "context": "\nRuleLink::RuleLink(const Handle& body, const Handle& rewrite)\n\t: RuleLink(HandleSeq{body, rewrite})\n{}\n\nRuleLink::RuleLink(const HandleSeq&& hseq, Type t)\n\t: PrenexLink(std::move(hseq), t)\n"
      },
      {
        "file": "atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc",
        "line": 60,
        "type": "empty_function",
        "content": "{}",
        "context": "}\n\nFormulaTruthValue::~FormulaTruthValue()\n{}\n\nvoid FormulaTruthValue::init(void)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/truthvalue/TruthValue.h",
        "line": 81,
        "type": "empty_function",
        "content": ": tv_formula(tvf), tv_type(tvt) {}",
        "context": "\n\tMergeCtrl(TVFormula tvf=TVFormula::PLN_BOOK_REVISION,\n\t          TVType tvt=TVType::OLDER)\n\t\t: tv_formula(tvf), tv_type(tvt) {}\n};\n\nclass TruthValue;\n"
      },
      {
        "file": "atomspace/opencog/atoms/truthvalue/TruthValue.h",
        "line": 102,
        "type": "empty_function",
        "content": "TruthValue(Type t) : FloatValue(t) {}",
        "context": "\t}\n\nprotected:\n\tTruthValue(Type t) : FloatValue(t) {}\n\n\t// Merge helper method\n\tTruthValuePtr higher_confidence_merge(const TruthValuePtr&) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/truthvalue/TruthValue.h",
        "line": 110,
        "type": "empty_function",
        "content": "virtual ~TruthValue() {}",
        "context": "\tstatic bool nearly_equal(double, double);\n\npublic:\n\tvirtual ~TruthValue() {}\n\n\tvirtual bool operator==(const Value&) const = 0;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/BoolValue.h",
        "line": 46,
        "type": "empty_function",
        "content": "virtual void update() const {}",
        "context": "protected:\n\tmutable std::vector<bool> _value;\n\n\tvirtual void update() const {}\n\n\tBoolValue(Type t) : Value(t) {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/BoolValue.h",
        "line": 48,
        "type": "empty_function",
        "content": "BoolValue(Type t) : Value(t) {}",
        "context": "\n\tvirtual void update() const {}\n\n\tBoolValue(Type t) : Value(t) {}\n\npublic:\n\tBoolValue(bool v) : Value(BOOL_VALUE) { _value.push_back(v); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/BoolValue.h",
        "line": 53,
        "type": "empty_function",
        "content": ": Value(BOOL_VALUE), _value(v) {}",
        "context": "public:\n\tBoolValue(bool v) : Value(BOOL_VALUE) { _value.push_back(v); }\n\tBoolValue(const std::vector<bool>& v)\n\t\t: Value(BOOL_VALUE), _value(v) {}\n\tBoolValue(unsigned long);\n\tBoolValue(Type t, const std::vector<bool>& v) : Value(t), _value(v) {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/BoolValue.h",
        "line": 55,
        "type": "empty_function",
        "content": "BoolValue(Type t, const std::vector<bool>& v) : Value(t), _value(v) {}",
        "context": "\tBoolValue(const std::vector<bool>& v)\n\t\t: Value(BOOL_VALUE), _value(v) {}\n\tBoolValue(unsigned long);\n\tBoolValue(Type t, const std::vector<bool>& v) : Value(t), _value(v) {}\n\n\tvirtual ~BoolValue() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/BoolValue.h",
        "line": 57,
        "type": "empty_function",
        "content": "virtual ~BoolValue() {}",
        "context": "\tBoolValue(unsigned long);\n\tBoolValue(Type t, const std::vector<bool>& v) : Value(t), _value(v) {}\n\n\tvirtual ~BoolValue() {}\n\n\tconst std::vector<bool>& value() const { update(); return _value; }\n\tsize_t size() const { return _value.size(); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ContainerValue.h",
        "line": 58,
        "type": "empty_function",
        "content": "ContainerValue(Type t) : LinkStreamValue(t) {}",
        "context": "\t: public LinkStreamValue\n{\nprotected:\n\tContainerValue(Type t) : LinkStreamValue(t) {}\n\npublic:\n\tContainerValue(void) : LinkStreamValue(CONTAINER_VALUE) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ContainerValue.h",
        "line": 61,
        "type": "empty_function",
        "content": "ContainerValue(void) : LinkStreamValue(CONTAINER_VALUE) {}",
        "context": "\tContainerValue(Type t) : LinkStreamValue(t) {}\n\npublic:\n\tContainerValue(void) : LinkStreamValue(CONTAINER_VALUE) {}\n\tvirtual ~ContainerValue() {}\n\tvirtual void open(void) = 0;\n\tvirtual void close(void) = 0;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ContainerValue.h",
        "line": 62,
        "type": "empty_function",
        "content": "virtual ~ContainerValue() {}",
        "context": "\npublic:\n\tContainerValue(void) : LinkStreamValue(CONTAINER_VALUE) {}\n\tvirtual ~ContainerValue() {}\n\tvirtual void open(void) = 0;\n\tvirtual void close(void) = 0;\n\tvirtual bool is_closed(void) const = 0;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 48,
        "type": "empty_function",
        "content": "virtual void update() const {}",
        "context": "protected:\n\tmutable std::vector<double> _value;\n\n\tvirtual void update() const {}\n\n\tFloatValue(Type t) : Value(t) {}\npublic:\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 50,
        "type": "empty_function",
        "content": "FloatValue(Type t) : Value(t) {}",
        "context": "\n\tvirtual void update() const {}\n\n\tFloatValue(Type t) : Value(t) {}\npublic:\n\tFloatValue(Type t, const std::vector<double>& v) : Value(t), _value(v) {}\n\tFloatValue(double v) : Value(FLOAT_VALUE) { _value.push_back(v); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 52,
        "type": "empty_function",
        "content": "FloatValue(Type t, const std::vector<double>& v) : Value(t), _value(v) {}",
        "context": "\n\tFloatValue(Type t) : Value(t) {}\npublic:\n\tFloatValue(Type t, const std::vector<double>& v) : Value(t), _value(v) {}\n\tFloatValue(double v) : Value(FLOAT_VALUE) { _value.push_back(v); }\n\tFloatValue(const std::vector<double>& v)\n\t\t: Value(FLOAT_VALUE), _value(v) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 55,
        "type": "empty_function",
        "content": ": Value(FLOAT_VALUE), _value(v) {}",
        "context": "\tFloatValue(Type t, const std::vector<double>& v) : Value(t), _value(v) {}\n\tFloatValue(double v) : Value(FLOAT_VALUE) { _value.push_back(v); }\n\tFloatValue(const std::vector<double>& v)\n\t\t: Value(FLOAT_VALUE), _value(v) {}\n\tFloatValue(std::vector<double>&& v)\n\t\t: Value(FLOAT_VALUE), _value(std::move(v)) {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 57,
        "type": "empty_function",
        "content": ": Value(FLOAT_VALUE), _value(std::move(v)) {}",
        "context": "\tFloatValue(const std::vector<double>& v)\n\t\t: Value(FLOAT_VALUE), _value(v) {}\n\tFloatValue(std::vector<double>&& v)\n\t\t: Value(FLOAT_VALUE), _value(std::move(v)) {}\n\n\tvirtual ~FloatValue() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FloatValue.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual ~FloatValue() {}",
        "context": "\tFloatValue(std::vector<double>&& v)\n\t\t: Value(FLOAT_VALUE), _value(std::move(v)) {}\n\n\tvirtual ~FloatValue() {}\n\n\tconst std::vector<double>& value() const { update(); return _value; }\n\tsize_t size() const { return _value.size(); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FormulaStream.h",
        "line": 47,
        "type": "empty_function",
        "content": "FormulaStream(Type t) : StreamValue(t) {}",
        "context": "\t: public StreamValue\n{\nprotected:\n\tFormulaStream(Type t) : StreamValue(t) {}\n\n\tvoid init(void);\n\tvirtual void update() const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FormulaStream.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual ~FormulaStream() {}",
        "context": "\tFormulaStream(const Handle&);\n\tFormulaStream(const HandleSeq&&);\n\tFormulaStream(const ValueSeq&);\n\tvirtual ~FormulaStream() {}\n\n\t/** Returns a string representation of the value.  */\n\tvirtual std::string to_string(const std::string& indent = \"\") const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FutureStream.h",
        "line": 45,
        "type": "empty_function",
        "content": "FutureStream(Type t) : LinkStreamValue(t) {}",
        "context": "\t: public LinkStreamValue\n{\nprotected:\n\tFutureStream(Type t) : LinkStreamValue(t) {}\n\n\tvoid init(void);\n\tvirtual void update() const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/FutureStream.h",
        "line": 56,
        "type": "empty_function",
        "content": "virtual ~FutureStream() {}",
        "context": "\tFutureStream(const Handle&);\n\tFutureStream(const HandleSeq&&);\n\tFutureStream(const ValueSeq&);\n\tvirtual ~FutureStream() {}\n\n\t/** Returns a string representation of the value.  */\n\tvirtual std::string to_string(const std::string& indent = \"\") const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkStreamValue.h",
        "line": 44,
        "type": "empty_function",
        "content": "LinkStreamValue(Type t) : LinkValue(t) {}",
        "context": "\t: public LinkValue\n{\nprotected:\n\tLinkStreamValue(Type t) : LinkValue(t) {}\n\npublic:\n\tvirtual ~LinkStreamValue() {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkStreamValue.h",
        "line": 47,
        "type": "empty_function",
        "content": "virtual ~LinkStreamValue() {}",
        "context": "\tLinkStreamValue(Type t) : LinkValue(t) {}\n\npublic:\n\tvirtual ~LinkStreamValue() {}\n\n\t/** Returns true if two atoms are equal.  */\n\tvirtual bool operator==(const Value&) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 49,
        "type": "empty_function",
        "content": "virtual void update() const {}",
        "context": "\nprotected:\n\tmutable std::vector<ValuePtr> _value;\n\tvirtual void update() const {}\n\n\tLinkValue(Type t) : Value(t) {}\npublic:\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 51,
        "type": "empty_function",
        "content": "LinkValue(Type t) : Value(t) {}",
        "context": "\tmutable std::vector<ValuePtr> _value;\n\tvirtual void update() const {}\n\n\tLinkValue(Type t) : Value(t) {}\npublic:\n\tLinkValue(void)\n\t\t: Value(LINK_VALUE) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 54,
        "type": "empty_function",
        "content": ": Value(LINK_VALUE) {}",
        "context": "\tLinkValue(Type t) : Value(t) {}\npublic:\n\tLinkValue(void)\n\t\t: Value(LINK_VALUE) {}\n\n\tLinkValue(const ValuePtr& vp)\n\t\t: Value(LINK_VALUE) { _value.push_back(vp); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 60,
        "type": "empty_function",
        "content": ": Value(LINK_VALUE), _value(vlist) {}",
        "context": "\t\t: Value(LINK_VALUE) { _value.push_back(vp); }\n\n\tLinkValue(const ValueSeq& vlist)\n\t\t: Value(LINK_VALUE), _value(vlist) {}\n\n\tLinkValue(ValueSeq&& vlist)\n\t\t: Value(LINK_VALUE), _value(std::move(vlist)) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 63,
        "type": "empty_function",
        "content": ": Value(LINK_VALUE), _value(std::move(vlist)) {}",
        "context": "\t\t: Value(LINK_VALUE), _value(vlist) {}\n\n\tLinkValue(ValueSeq&& vlist)\n\t\t: Value(LINK_VALUE), _value(std::move(vlist)) {}\n\n\tLinkValue(Type t, const ValueSeq& vlist)\n\t\t: Value(t), _value(vlist) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 66,
        "type": "empty_function",
        "content": ": Value(t), _value(vlist) {}",
        "context": "\t\t: Value(LINK_VALUE), _value(std::move(vlist)) {}\n\n\tLinkValue(Type t, const ValueSeq& vlist)\n\t\t: Value(t), _value(vlist) {}\n\n\tLinkValue(Type t, ValueSeq&& vlist)\n\t\t: Value(t), _value(std::move(vlist)) {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 69,
        "type": "empty_function",
        "content": ": Value(t), _value(std::move(vlist)) {}",
        "context": "\t\t: Value(t), _value(vlist) {}\n\n\tLinkValue(Type t, ValueSeq&& vlist)\n\t\t: Value(t), _value(std::move(vlist)) {}\n\n\tLinkValue(Type t, const ValueSet& vset)\n\t\t: Value(t)\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/LinkValue.h",
        "line": 95,
        "type": "empty_function",
        "content": "virtual ~LinkValue() {}",
        "context": "\t\t: Value(LINK_VALUE)\n\t{ for (const Handle& h: hset) _value.emplace_back(h); }\n\n\tvirtual ~LinkValue() {}\n\n\tconst ValueSeq& value() const { update(); return _value; }\n\tHandleSeq to_handle_seq(void) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/QueueValue.cc",
        "line": 77,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t}\n\t}\n\tcatch (typename conq::Canceled& e)\n\t{}\n\n\t// If we are here, the queue closed up. Reopen it\n\t// just long enough to drain any remaining values.\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/QueueValue.h",
        "line": 46,
        "type": "empty_function",
        "content": "QueueValue(Type t) : ContainerValue(t) {}",
        "context": "\t: public ContainerValue, protected concurrent_queue<ValuePtr>\n{\nprotected:\n\tQueueValue(Type t) : ContainerValue(t) {}\n\tvirtual void update() const;\n\npublic:\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/QueueValue.h",
        "line": 50,
        "type": "empty_function",
        "content": "QueueValue(void) : ContainerValue(QUEUE_VALUE) {}",
        "context": "\tvirtual void update() const;\n\npublic:\n\tQueueValue(void) : ContainerValue(QUEUE_VALUE) {}\n\tQueueValue(const ValueSeq&);\n\tvirtual ~QueueValue() {}\n\tvirtual void open(void);\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/QueueValue.h",
        "line": 52,
        "type": "empty_function",
        "content": "virtual ~QueueValue() {}",
        "context": "public:\n\tQueueValue(void) : ContainerValue(QUEUE_VALUE) {}\n\tQueueValue(const ValueSeq&);\n\tvirtual ~QueueValue() {}\n\tvirtual void open(void);\n\tvirtual void close(void);\n\tvirtual bool is_closed(void) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/RandomStream.h",
        "line": 42,
        "type": "empty_function",
        "content": "RandomStream(Type t) : StreamValue(t) {}",
        "context": "\t: public StreamValue\n{\nprotected:\n\tRandomStream(Type t) : StreamValue(t) {}\n\tint _len;\n\n\tvirtual void update() const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/RandomStream.h",
        "line": 50,
        "type": "empty_function",
        "content": "virtual ~RandomStream() {}",
        "context": "public:\n\t// int is the desired size of the vector.\n\tRandomStream(int=1);\n\tvirtual ~RandomStream() {}\n\n\t/** Returns a string representation of the value.  */\n\tvirtual std::string to_string(const std::string& indent = \"\") const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StreamValue.h",
        "line": 53,
        "type": "empty_function",
        "content": "StreamValue(Type t) : FloatValue(t) {}",
        "context": "\t: public FloatValue\n{\nprotected:\n\tStreamValue(Type t) : FloatValue(t) {}\n\tStreamValue(Type t, const std::vector<double>& v) : FloatValue(t, v) {}\n\npublic:\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StreamValue.h",
        "line": 54,
        "type": "empty_function",
        "content": "StreamValue(Type t, const std::vector<double>& v) : FloatValue(t, v) {}",
        "context": "{\nprotected:\n\tStreamValue(Type t) : FloatValue(t) {}\n\tStreamValue(Type t, const std::vector<double>& v) : FloatValue(t, v) {}\n\npublic:\n\tvirtual ~StreamValue() {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StreamValue.h",
        "line": 57,
        "type": "empty_function",
        "content": "virtual ~StreamValue() {}",
        "context": "\tStreamValue(Type t, const std::vector<double>& v) : FloatValue(t, v) {}\n\npublic:\n\tvirtual ~StreamValue() {}\n\n\t/** Returns true if two atoms are equal.  */\n\tvirtual bool operator==(const Value&) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StringValue.h",
        "line": 53,
        "type": "empty_function",
        "content": ": Value(STRING_VALUE), _value(v) {}",
        "context": "\tStringValue(const std::string& v)\n\t\t: Value(STRING_VALUE) { _value.push_back(v); }\n\tStringValue(const std::vector<std::string>& v)\n\t\t: Value(STRING_VALUE), _value(v) {}\n\tStringValue(Type t, const std::vector<std::string>& v)\n\t\t: Value(t), _value(v) {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StringValue.h",
        "line": 55,
        "type": "empty_function",
        "content": ": Value(t), _value(v) {}",
        "context": "\tStringValue(const std::vector<std::string>& v)\n\t\t: Value(STRING_VALUE), _value(v) {}\n\tStringValue(Type t, const std::vector<std::string>& v)\n\t\t: Value(t), _value(v) {}\n\n\tvirtual ~StringValue() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/StringValue.h",
        "line": 57,
        "type": "empty_function",
        "content": "virtual ~StringValue() {}",
        "context": "\tStringValue(Type t, const std::vector<std::string>& v)\n\t\t: Value(t), _value(v) {}\n\n\tvirtual ~StringValue() {}\n\n\tconst std::vector<std::string>& value() const { return _value; }\n\tsize_t size() const {return _value.size(); }\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/UnisetValue.cc",
        "line": 77,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t}\n\t}\n\tcatch (typename conset::Canceled& e)\n\t{}\n\n\t// If we are here, the queue closed up. Reopen it\n\t// just long enough to drain any remaining values.\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/UnisetValue.h",
        "line": 48,
        "type": "empty_function",
        "content": "UnisetValue(Type t) : ContainerValue(t) {}",
        "context": "\t: public ContainerValue, protected concurrent_set<ValuePtr>\n{\nprotected:\n\tUnisetValue(Type t) : ContainerValue(t) {}\n\tvirtual void update() const;\n\npublic:\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/UnisetValue.h",
        "line": 52,
        "type": "empty_function",
        "content": "UnisetValue(void) : ContainerValue(UNISET_VALUE) {}",
        "context": "\tvirtual void update() const;\n\npublic:\n\tUnisetValue(void) : ContainerValue(UNISET_VALUE) {}\n\tUnisetValue(const ValueSeq&);\n\tvirtual ~UnisetValue() {}\n\tvirtual void open(void);\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/UnisetValue.h",
        "line": 54,
        "type": "empty_function",
        "content": "virtual ~UnisetValue() {}",
        "context": "public:\n\tUnisetValue(void) : ContainerValue(UNISET_VALUE) {}\n\tUnisetValue(const ValueSeq&);\n\tvirtual ~UnisetValue() {}\n\tvirtual void open(void);\n\tvirtual void close(void);\n\tvirtual bool is_closed(void) const;\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/Value.h",
        "line": 56,
        "type": "empty_function",
        "content": "Value(Type t) : _type(t) {}",
        "context": "\tType _type;\n\npublic:\n\tValue(Type t) : _type(t) {}\n\n\tvirtual ~Value() {}\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/Value.h",
        "line": 58,
        "type": "empty_function",
        "content": "virtual ~Value() {}",
        "context": "public:\n\tValue(Type t) : _type(t) {}\n\n\tvirtual ~Value() {}\n\n\tinline Type get_type() const { return _type; }\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ValueFactory.h",
        "line": 27,
        "type": "empty_function",
        "content": "ValueServer() {}",
        "context": "{\n    friend ValueServer& valueserver();\nprivate:\n    ValueServer() {}\n\n    struct ProtoFactory\n    {\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ValueFactory.h",
        "line": 89,
        "type": "empty_function",
        "content": "catch(...) {}",
        "context": "        {\n            fptr = fax.at(vtype);\n        }\n        catch(...) {}\n\n        if (nullptr == fptr)\n        {\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/ValueFactory.h",
        "line": 120,
        "type": "empty_function",
        "content": "catch(...) {}",
        "context": "                    }\n                }\n            }\n            catch(...) {}\n        }\n\n        if (fptr)\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/VoidValue.h",
        "line": 42,
        "type": "empty_function",
        "content": "VoidValue() : Value(VOID_VALUE) {}",
        "context": "class VoidValue : public Value\n{\nprivate:\n\tVoidValue() : Value(VOID_VALUE) {}\n\npublic:\n\tvirtual ~VoidValue() {}\n"
      },
      {
        "file": "atomspace/opencog/atoms/value/VoidValue.h",
        "line": 45,
        "type": "empty_function",
        "content": "virtual ~VoidValue() {}",
        "context": "\tVoidValue() : Value(VOID_VALUE) {}\n\npublic:\n\tvirtual ~VoidValue() {}\n\n\tstatic const ValuePtr INSTANCE;\n\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.h",
        "line": 286,
        "type": "empty_function",
        "content": "return add_link(t, HandleSeq{});",
        "context": "\n    inline Handle add_link(Type t)\n    {\n        return add_link(t, HandleSeq{});\n    }\n\n    inline Handle add_link(Type t, Handle h)\n"
      },
      {
        "file": "atomspace/opencog/atomspace/Permissions.h",
        "line": 79,
        "type": "empty_function",
        "content": ": _name(name), _type(type) {}",
        "context": "    \npublic:\n    Principal(const std::string& name, const std::string& type = \"user\")\n        : _name(name), _type(type) {}\n    \n    const std::string& getName() const { return _name; }\n    const std::string& getType() const { return _type; }\n"
      },
      {
        "file": "atomspace/opencog/atomspace/Permissions.h",
        "line": 108,
        "type": "empty_function",
        "content": ": _principal(principal) {}",
        "context": "    \npublic:\n    PermissionContext(const Principal& principal)\n        : _principal(principal) {}\n    \n    void addRole(const Principal& role) { _roles.insert(role); }\n    void removeRole(const Principal& role) { _roles.erase(role); }\n"
      },
      {
        "file": "atomspace/opencog/atomspace/Permissions.h",
        "line": 152,
        "type": "empty_function",
        "content": "PermissionManager() {}",
        "context": "    static std::shared_ptr<PermissionManager> _instance;\n    static std::mutex _instance_mutex;\n    \n    PermissionManager() {}\n    \npublic:\n    static std::shared_ptr<PermissionManager> getInstance()\n"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 47,
        "type": "empty_function",
        "content": ": _callback(std::forward<Callback>(callback)) {}",
        "context": "\t\tCallback _callback;\n\tpublic:\n\t\texplicit scope_exit(Callback&& callback)\n\t\t\t: _callback(std::forward<Callback>(callback)) {}\n\n\t\t~scope_exit() { _callback(); }\n};\n"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 300,
        "type": "empty_function",
        "content": "struct stat finfo = {};",
        "context": "    // Add default OpenCog module directories to the Python interpreter's path.\n    for (int i = 0; config_paths[i] != NULL; ++i)\n    {\n        struct stat finfo = {};\n        stat(config_paths[i], &finfo);\n\n        if (S_ISDIR(finfo.st_mode))\n"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 1502,
        "type": "empty_function",
        "content": "logger().warn(\"[PythonEval] Interrupt failed: {}\", e.what());",
        "context": "        \n    } catch (const std::exception& e) {\n        _result += \"PythonEval: interrupt failed - \" + std::string(e.what()) + \"\\n\";\n        logger().warn(\"[PythonEval] Interrupt failed: {}\", e.what());\n    }\n}\n\n"
      },
      {
        "file": "atomspace/opencog/eval/GenericEval.h",
        "line": 51,
        "type": "empty_function",
        "content": "_caught_error(false) {}",
        "context": "\t\tGenericEval(void) :\n\t\t\t_input_line(\"\"),\n\t\t\t_pending_input(false),\n\t\t\t_caught_error(false) {}\n\t\tvirtual ~GenericEval() {}\n\n\t\t/**\n"
      },
      {
        "file": "atomspace/opencog/eval/GenericEval.h",
        "line": 52,
        "type": "empty_function",
        "content": "virtual ~GenericEval() {}",
        "context": "\t\t\t_input_line(\"\"),\n\t\t\t_pending_input(false),\n\t\t\t_caught_error(false) {}\n\t\tvirtual ~GenericEval() {}\n\n\t\t/**\n\t\t * Return true if the expression was incomplete, and more is expected\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeEval.cc",
        "line": 1165,
        "type": "empty_function",
        "content": "catch (const concurrent_stack<SchemeEval*>::Canceled&) {}",
        "context": "\ttry {\n\t\tpool.push(ev);\n\t}\n\tcatch (const concurrent_stack<SchemeEval*>::Canceled&) {}\n}\n\n/// Return evaluator, for this thread and atomspace combination.\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeModule.cc",
        "line": 159,
        "type": "empty_function",
        "content": "{}",
        "context": "\nModuleWrap::ModuleWrap(const char* m) :\n\t_modname(m)\n{}\n\nvoid ModuleWrap::module_init(void)\n{\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.cc",
        "line": 67,
        "type": "empty_function",
        "content": "PrimitiveEnviron::~PrimitiveEnviron() {}",
        "context": "\tscm_c_export(\"opencog-extension\", NULL);\n}\n\nPrimitiveEnviron::~PrimitiveEnviron() {}\n\nvoid PrimitiveEnviron::do_register(const char * module,\n                                   const char *name,\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 93,
        "type": "empty_function",
        "content": "{}",
        "context": "\tSchemeArgConverters(const char * module, const char* name) :\n\t\tscheme_module(module),\n\t\tscheme_name(name)\n\t{}\n\n\tSCM scm_to(SCM args, size_t idx, SCM) const\n\t{\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 208,
        "type": "empty_function",
        "content": "return conv_call_function(args, std::index_sequence_for<Args...>{});",
        "context": "\t{\n\t\t// Call the function over the scm arguments. The index sequence\n\t\t// is used to access the argument types.\n\t\treturn conv_call_function(args, std::index_sequence_for<Args...>{});\n\t}\n};\n\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 262,
        "type": "empty_function",
        "content": "return conv_call_method(args, std::index_sequence_for<Args...>{});",
        "context": "\t{\n\t\t// Call the method over the scm arguments. The index sequence\n\t\t// is used to access the argument types.\n\t\treturn conv_call_method(args, std::index_sequence_for<Args...>{});\n\t}\n};\n\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 354,
        "type": "empty_function",
        "content": ": super(module, name, func, xport) {}",
        "context": "public:\n\tSchemeFunction(const char* module, const char* name,\n\t                R (*func)(Args...), bool xport)\n\t\t: super(module, name, func, xport) {}\n\nprotected:\n\tvirtual SCM invoke (SCM args)\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 373,
        "type": "empty_function",
        "content": ": super(module, name, func, xport) {}",
        "context": "public:\n\tSchemeFunction(const char* module, const char* name,\n\t               void (*func)(Args...), bool xport)\n\t\t: super(module, name, func, xport) {}\n\nprotected:\n\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 395,
        "type": "empty_function",
        "content": ": super(module, name, cb, data, xport) {}",
        "context": "public:\n\tSchemePrimitive(const char* module, const char* name,\n\t                R (C::*cb)(Args...), C *data, bool xport)\n\t\t: super(module, name, cb, data, xport) {}\n\nprotected:\n\tvirtual SCM invoke (SCM args)\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemePrimitive.h",
        "line": 414,
        "type": "empty_function",
        "content": ": super(module, name, cb, data, xport) {}",
        "context": "public:\n\tSchemePrimitive(const char* module, const char* name,\n\t                void (C::*cb)(Args...), C *data, bool xport)\n\t\t: super(module, name, cb, data, xport) {}\n\nprotected:\n\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 80,
        "type": "empty_function",
        "content": "{}",
        "context": "\nExecSCM::ExecSCM(void) :\n\tModuleWrap(\"opencog exec\")\n{}\n\n/// This is called while (opencog exec) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/LoggerSCM.cc",
        "line": 290,
        "type": "empty_function",
        "content": "LoggerSCM::LoggerSCM() : ModuleWrap(\"opencog logger\") {}",
        "context": "\n} /*end of namespace opencog*/\n\nLoggerSCM::LoggerSCM() : ModuleWrap(\"opencog logger\") {}\n\n/// This is called while (opencog logger) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/RandGenSCM.cc",
        "line": 69,
        "type": "empty_function",
        "content": "RandGenSCM::RandGenSCM() : ModuleWrap(\"opencog randgen\") {}",
        "context": "\t\n} /*end of namespace opencog*/\n\nRandGenSCM::RandGenSCM() : ModuleWrap(\"opencog randgen\") {}\n\n/// This is called while (opencog randgen) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/TypeUtilsSCM.cc",
        "line": 67,
        "type": "empty_function",
        "content": "{}",
        "context": "\nTypeUtilsSCM::TypeUtilsSCM(void) :\n\tModuleWrap(\"opencog type-utils\")\n{}\n\n/// This is called while (opencog type-utils) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "atomspace/opencog/query/ContinuationMixin.cc",
        "line": 46,
        "type": "empty_function",
        "content": "ContinuationException(void) {}",
        "context": "class ContinuationException : public SilentException\n{\npublic:\n    ContinuationException(void) {}\n};\n\nclass RewindException : public SilentException\n"
      },
      {
        "file": "atomspace/opencog/query/ContinuationMixin.cc",
        "line": 52,
        "type": "empty_function",
        "content": "RewindException(void) {}",
        "context": "class RewindException : public SilentException\n{\npublic:\n    RewindException(void) {}\n};\n\n/* ======================================================== */\n"
      },
      {
        "file": "atomspace/opencog/query/ContinuationMixin.cc",
        "line": 104,
        "type": "empty_function",
        "content": "catch (const ContinuationException& ex) {}",
        "context": "\t\t{\n\t\t\treturn SatisfyMixin::satisfy(lform);\n\t\t}\n\t\tcatch (const ContinuationException& ex) {}\n\n\t\t// Temporary safety mechanism. I suspect that most users do not\n\t\t// intend to write infinite loops (e.g. REPL loops) so assume\n"
      },
      {
        "file": "atomspace/opencog/query/ContinuationMixin.cc",
        "line": 151,
        "type": "empty_function",
        "content": "catch (const RewindException& ex) {}",
        "context": "\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tcatch (const RewindException& ex) {}\n\n\t\tDO_LOG({LAZY_LOG_FINE\n\t\t\t<< \"***************************************\";})\n"
      },
      {
        "file": "atomspace/opencog/query/ContinuationMixin.h",
        "line": 50,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\tContinuationMixin(AtomSpace* as) :\n\t\t\tTermMatchMixin(as), InitiateSearchMixin(as),\n\t\t\t_continuation(nullptr)\n\t\t{}\n\n\t\tvirtual void set_pattern(const Variables& vars,\n\t\t                         const Pattern& pat)\n"
      },
      {
        "file": "atomspace/opencog/query/Implicator.h",
        "line": 44,
        "type": "empty_function",
        "content": "TermMatchMixin(asp) {}",
        "context": "\t\tImplicator(AtomSpace* asp, ContainerValuePtr& cvp) :\n\t\t\tInitiateSearchMixin(asp),\n\t\t\tRewriteMixin(asp, cvp),\n\t\t\tTermMatchMixin(asp) {}\n\n\t\t\tvirtual void set_pattern(const Variables& vars,\n\t\t\t                         const Pattern& pat)\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchCallback.h",
        "line": 43,
        "type": "empty_function",
        "content": "virtual ~PatternMatchCallback() {};",
        "context": "class PatternMatchCallback\n{\n\tpublic:\n\t\tvirtual ~PatternMatchCallback() {};\n\n\t\t/**\n\t\t * Called when a node in the template pattern\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchCallback.h",
        "line": 146,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t */\n\t\tvirtual void post_link_mismatch(const Handle& patt_link,\n\t\t                                const Handle& grnd_link)\n\t\t{}\n\n\t\t/**\n\t\t * Called when the template pattern and the candidate grounding\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchCallback.h",
        "line": 384,
        "type": "empty_function",
        "content": "virtual void push(void) {}",
        "context": "\t\t * grounded. This gives the callee the opportunity to save\n\t\t * state onto a stack, if needed.\n\t\t */\n\t\tvirtual void push(void) {}\n\n\t\t/**\n\t\t * Called prior to starting a back-track, retreating from the\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchCallback.h",
        "line": 392,
        "type": "empty_function",
        "content": "virtual void pop(void) {}",
        "context": "\t\t * gives the callee the opportunity to maintain state with a\n\t\t * stack, if needed.\n\t\t */\n\t\tvirtual void pop(void) {}\n\n\t\t/**\n\t\t * Called before search initiation, to indicate the pattern\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 106,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, const PatternTermPtr&, bool) {}",
        "context": "\tLAZY_LOG_FINE << msg;\n}\n#else\nstatic inline void logmsg(const char*, const PatternTermPtr&, bool) {}\nstatic inline void logmsg(const char*, const PatternTermPtr&) {}\nstatic inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 107,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, const PatternTermPtr&) {}",
        "context": "}\n#else\nstatic inline void logmsg(const char*, const PatternTermPtr&, bool) {}\nstatic inline void logmsg(const char*, const PatternTermPtr&) {}\nstatic inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 108,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, const Handle&) {}",
        "context": "#else\nstatic inline void logmsg(const char*, const PatternTermPtr&, bool) {}\nstatic inline void logmsg(const char*, const PatternTermPtr&) {}\nstatic inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\nstatic inline void logmsg(const char*, size_t) {}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 109,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, const HandleSeq&) {}",
        "context": "static inline void logmsg(const char*, const PatternTermPtr&, bool) {}\nstatic inline void logmsg(const char*, const PatternTermPtr&) {}\nstatic inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\nstatic inline void logmsg(const char*, size_t) {}\nstatic inline void logmsg(const char*) {}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 110,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, int, int) {}",
        "context": "static inline void logmsg(const char*, const PatternTermPtr&) {}\nstatic inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\nstatic inline void logmsg(const char*, size_t) {}\nstatic inline void logmsg(const char*) {}\n#endif\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 111,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*, size_t) {}",
        "context": "static inline void logmsg(const char*, const Handle&) {}\nstatic inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\nstatic inline void logmsg(const char*, size_t) {}\nstatic inline void logmsg(const char*) {}\n#endif\n\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 112,
        "type": "empty_function",
        "content": "static inline void logmsg(const char*) {}",
        "context": "static inline void logmsg(const char*, const HandleSeq&) {}\nstatic inline void logmsg(const char*, int, int) {}\nstatic inline void logmsg(const char*, size_t) {}\nstatic inline void logmsg(const char*) {}\n#endif\n\n\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 3430,
        "type": "empty_function",
        "content": "const GroundingMap &clauses) {}",
        "context": "#else\n\nvoid PatternMatchEngine::log_solution(const GroundingMap &vars,\n                                      const GroundingMap &clauses) {}\n\nvoid PatternMatchEngine::log_term(const HandleSet &vars,\n                                  const HandleSeq &clauses) {}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 3433,
        "type": "empty_function",
        "content": "const HandleSeq &clauses) {}",
        "context": "                                      const GroundingMap &clauses) {}\n\nvoid PatternMatchEngine::log_term(const HandleSet &vars,\n                                  const HandleSeq &clauses) {}\n#endif\n\n/* ===================== END OF FILE ===================== */\n"
      },
      {
        "file": "atomspace/opencog/query/Recognizer.h",
        "line": 69,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\tRecognizer(AtomSpace* as) :\n\t\t    TermMatchMixin(as),\n\t\t    _cnt(0)\n\t\t{}\n\n\t\tvirtual bool node_match(const Handle&, const Handle&);\n\t\tvirtual bool link_match(const PatternTermPtr&, const Handle&);\n"
      },
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 82,
        "type": "empty_function",
        "content": "catch (...) {}",
        "context": "\t\t\tif (_var_marginals.end() != it)\n\t\t\t\t(*it).second->add(gvp);\n\t\t}\n\t\tcatch (...) {}\n\t}\n}\n\n"
      },
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 150,
        "type": "empty_function",
        "content": "} catch (const SilentException& ex) {}",
        "context": "\t\t\t}\n\t\t\tinsert_result(createLinkValue(vs));\n\t\t}\n\t} catch (const SilentException& ex) {}\n\n\t// If we found as many as we want, then stop looking for more.\n\treturn (_num_results >= max_results);\n"
      },
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 199,
        "type": "empty_function",
        "content": "} catch (const SilentException& ex) {}",
        "context": "\n\t\t\tgrp.insert(v);\n\t\t}\n\t} catch (const SilentException& ex) {}\n\n\treturn false;\n}\n"
      },
      {
        "file": "atomspace/opencog/query/Satisfier.h",
        "line": 56,
        "type": "empty_function",
        "content": "_result(false) {}",
        "context": "\tpublic:\n\t\tSatisfier(AtomSpace* as) :\n\t\t\tContinuationMixin(as),\n\t\t\t_result(false) {}\n\n\t\tDECLARE_PE_MUTEX;\n\t\tHandleSeq _varseq;\n"
      },
      {
        "file": "atomspace/opencog/query/Satisfier.h",
        "line": 116,
        "type": "empty_function",
        "content": "_num_results(0), max_results(SIZE_MAX) {}",
        "context": "\t\tSatisfyingSet(AtomSpace* as, const ContainerValuePtr& cvp) :\n\t\t\tContinuationMixin(as),\n\t\t\t_as(as), _result_queue(cvp),\n\t\t\t_num_results(0), max_results(SIZE_MAX) {}\n\n\t\tsize_t max_results;\n\n"
      },
      {
        "file": "atomspace/opencog/query/SatisfyMixin.cc",
        "line": 48,
        "type": "empty_function",
        "content": "PMCGroundings(PatternMatchCallback& cb) : _cb(cb) {}",
        "context": "\t\tPatternMatchCallback& _cb;\n\n\tpublic:\n\t\tPMCGroundings(PatternMatchCallback& cb) : _cb(cb) {}\n\n\t\t// Pass all the calls straight through, except one.\n\t\tbool node_match(const Handle& node1, const Handle& node2) {\n"
      },
      {
        "file": "atomspace/tests/cython/atomspace/test_exception.py",
        "line": 230,
        "type": "empty_function",
        "content": "return {}",
        "context": "\ndef ret_nil(*args):\n    print(args)\n    return {}\n\ndef ret_lst(*args):\n    print(args)\n"
      },
      {
        "file": "attention/opencog/attention/AttentionValue.h",
        "line": 35,
        "type": "empty_function",
        "content": "confidence(conf), spreading_factor(spread), decay_rate(decay) {}",
        "context": "    ECANAttentionTensor(double sti = 0.5, double lti = 0.5, double urg = 0.5,\n                       double conf = 0.5, double spread = 0.5, double decay = 0.95)\n        : short_term_importance(sti), long_term_importance(lti), urgency(urg),\n          confidence(conf), spreading_factor(spread), decay_rate(decay) {}\n          \n    // Convert to vector for tensor operations\n    std::array<double, 6> to_array() const {\n"
      },
      {
        "file": "attention/opencog/attention/ECANAgent.h",
        "line": 39,
        "type": "empty_function",
        "content": "timestamp(std::chrono::steady_clock::now()), request_type(type) {}",
        "context": "    \n    AttentionRequest(Handle h, double prio, double amount, const std::string& type)\n        : atom(h), priority(prio), requested_amount(amount), \n          timestamp(std::chrono::steady_clock::now()), request_type(type) {}\n          \n    bool operator<(const AttentionRequest& other) const {\n        return priority < other.priority; // For priority queue (max-heap)\n"
      },
      {
        "file": "autonomous-agency/scripts/validate-bootstrap.py",
        "line": 188,
        "type": "empty_function",
        "content": "results = {}",
        "context": "    print_header(\"AUTONOMOUS AGENCY BOOTSTRAP VALIDATION REPORT\")\n    \n    # Run all validations\n    results = {}\n    results[\"file_structure\"] = validate_file_structure()\n    results[\"configuration\"] = validate_configuration()\n    results[\"code_structure\"] = validate_code_structure()\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 25,
        "type": "empty_function",
        "content": "self.atoms = {}",
        "context": "class MockAtomSpace:\n    \"\"\"Mock AtomSpace for development purposes\"\"\"\n    def __init__(self):\n        self.atoms = {}\n        self.links = {}\n        self.next_id = 1\n    \n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 26,
        "type": "empty_function",
        "content": "self.links = {}",
        "context": "    \"\"\"Mock AtomSpace for development purposes\"\"\"\n    def __init__(self):\n        self.atoms = {}\n        self.links = {}\n        self.next_id = 1\n    \n    def add_node(self, node_type: str, name: str) -> str:\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 91,
        "type": "empty_function",
        "content": "self.shards = {}",
        "context": "        self.total_states = num_shards * self.links_per_shard * self.truth_dimensions  # 110\n        \n        # Initialize distributed shards\n        self.shards = {}\n        for i in range(num_shards):\n            self.shards[i] = DistributedShard(\n                shard_id=i,\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 152,
        "type": "empty_function",
        "content": "\"shard_results\": {},",
        "context": "        \"\"\"\n        results = {\n            \"total_matches\": 0,\n            \"shard_results\": {},\n            \"execution_time\": 0,\n            \"pattern_matches\": []\n        }\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 161,
        "type": "empty_function",
        "content": "futures = {}",
        "context": "        \n        # Execute queries in parallel across shards\n        with ThreadPoolExecutor(max_workers=self.num_shards) as executor:\n            futures = {}\n            \n            for query in queries:\n                # Determine target shards\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 195,
        "type": "empty_function",
        "content": "variables = {}",
        "context": "        \"\"\"\n        nodes = []\n        edges = []\n        variables = {}\n        \n        # Extract nodes\n        for node_spec in pattern_spec.get(\"nodes\", []):\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 258,
        "type": "empty_function",
        "content": "arguments = {}",
        "context": "    \n    def _extract_arguments(self, field_text: str) -> Dict[str, Any]:\n        \"\"\"Extract arguments from GraphQL field\"\"\"\n        arguments = {}\n        \n        # Find arguments in parentheses\n        arg_match = re.search(r'\\(([^)]+)\\)', field_text)\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 298,
        "type": "empty_function",
        "content": "args = field.get(\"arguments\", {})",
        "context": "        queries = []\n        \n        # Extract search parameters\n        args = field.get(\"arguments\", {})\n        pattern_type = args.get(\"pattern\", \"concept\")\n        target_name = args.get(\"target\", \"unknown\")\n        \n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 328,
        "type": "empty_function",
        "content": "args = field.get(\"arguments\", {})",
        "context": "        \"\"\"Convert GraphQL pattern match to AtomSpace queries\"\"\"\n        queries = []\n        \n        args = field.get(\"arguments\", {})\n        variables = args.get(\"variables\", [])\n        \n        # Create pattern with variables\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 357,
        "type": "empty_function",
        "content": "args = field.get(\"arguments\", {})",
        "context": "        \"\"\"Convert GraphQL query execution to AtomSpace patterns\"\"\"\n        queries = []\n        \n        args = field.get(\"arguments\", {})\n        query_type = args.get(\"type\", \"search\")\n        \n        if query_type == \"search\":\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 461,
        "type": "empty_function",
        "content": "\"shard_details\": {}",
        "context": "            \"links_per_shard\": self.links_per_shard,\n            \"truth_dimensions\": self.truth_dimensions,\n            \"total_states\": self.total_states,\n            \"shard_details\": {}\n        }\n        \n        for shard_id, shard in self.shards.items():\n"
      },
      {
        "file": "cognitive-das/atomspace_bridge.py",
        "line": 483,
        "type": "empty_function",
        "content": "\"coordinate_mapping\": {},",
        "context": "        validation = {\n            \"total_expected\": 110,\n            \"states_found\": 0,\n            \"coordinate_mapping\": {},\n            \"validation_passed\": False\n        }\n        \n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 102,
        "type": "empty_function",
        "content": "self.patterns = {}",
        "context": "        self.total_states = num_shards * links_per_shard * truth_dimensions\n        \n        # Pattern matching state\n        self.patterns = {}\n        self.atoms = {}\n        self.links = {}\n        self.match_cache = {}\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 103,
        "type": "empty_function",
        "content": "self.atoms = {}",
        "context": "        \n        # Pattern matching state\n        self.patterns = {}\n        self.atoms = {}\n        self.links = {}\n        self.match_cache = {}\n        \n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 104,
        "type": "empty_function",
        "content": "self.links = {}",
        "context": "        # Pattern matching state\n        self.patterns = {}\n        self.atoms = {}\n        self.links = {}\n        self.match_cache = {}\n        \n        # Performance tracking\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 105,
        "type": "empty_function",
        "content": "self.match_cache = {}",
        "context": "        self.patterns = {}\n        self.atoms = {}\n        self.links = {}\n        self.match_cache = {}\n        \n        # Performance tracking\n        self.match_statistics = {\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 255,
        "type": "empty_function",
        "content": "candidates = {}",
        "context": "        Returns:\n            Dict[str, List[str]]: Variable name to candidate atom IDs\n        \"\"\"\n        candidates = {}\n        \n        for var_name, var_type in template.variables.items():\n            candidates[var_name] = []\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 287,
        "type": "empty_function",
        "content": "return [{}]",
        "context": "            List[Dict[str, str]]: List of binding combinations\n        \"\"\"\n        if not variables:\n            return [{}]\n        \n        # Get variable names and their candidates\n        var_names = list(variables.keys())\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 589,
        "type": "empty_function",
        "content": "distribution = {}",
        "context": "    \n    def _analyze_shard_distribution(self) -> Dict[str, Any]:\n        \"\"\"Analyze distribution of atoms and links across shards\"\"\"\n        distribution = {}\n        \n        for shard_id in range(self.num_shards):\n            shard_atoms = sum(1 for atom in self.atoms.values() if atom.shard_id == shard_id)\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 71,
        "type": "empty_function",
        "content": "self.shard_queues = {}",
        "context": "        self.total_states = num_shards * links_per_shard * truth_dimensions  # 110\n        \n        # Shard management\n        self.shard_queues = {}\n        self.shard_workers = {}\n        self.shard_metrics = {}\n        self.shard_locks = {}\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 72,
        "type": "empty_function",
        "content": "self.shard_workers = {}",
        "context": "        \n        # Shard management\n        self.shard_queues = {}\n        self.shard_workers = {}\n        self.shard_metrics = {}\n        self.shard_locks = {}\n        \n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 73,
        "type": "empty_function",
        "content": "self.shard_metrics = {}",
        "context": "        # Shard management\n        self.shard_queues = {}\n        self.shard_workers = {}\n        self.shard_metrics = {}\n        self.shard_locks = {}\n        \n        # Results tracking\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 74,
        "type": "empty_function",
        "content": "self.shard_locks = {}",
        "context": "        self.shard_queues = {}\n        self.shard_workers = {}\n        self.shard_metrics = {}\n        self.shard_locks = {}\n        \n        # Results tracking\n        self.results_cache = {}\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 77,
        "type": "empty_function",
        "content": "self.results_cache = {}",
        "context": "        self.shard_locks = {}\n        \n        # Results tracking\n        self.results_cache = {}\n        self.active_tasks = {}\n        \n        # Configuration\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 78,
        "type": "empty_function",
        "content": "self.active_tasks = {}",
        "context": "        \n        # Results tracking\n        self.results_cache = {}\n        self.active_tasks = {}\n        \n        # Configuration\n        self.max_workers_per_shard = 2\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 271,
        "type": "empty_function",
        "content": "task = self.active_tasks.get(task_id, {}).get(\"task\")",
        "context": "        for task_id in task_ids:\n            if task_id not in [r.task_id for r in results]:\n                # Create timeout result\n                task = self.active_tasks.get(task_id, {}).get(\"task\")\n                timeout_result = ShardResult(\n                    task_id=task_id,\n                    shard_id=task.shard_id if task else -1,\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 299,
        "type": "empty_function",
        "content": "\"matches_by_shard\": {},",
        "context": "            \"successful_tasks\": sum(1 for r in results if r.success),\n            \"failed_tasks\": sum(1 for r in results if not r.success),\n            \"total_matches\": sum(len(r.matches) for r in results),\n            \"matches_by_shard\": {},\n            \"execution_times\": [r.execution_time for r in results],\n            \"average_execution_time\": 0.0,\n            \"shard_utilization\": {},\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 302,
        "type": "empty_function",
        "content": "\"shard_utilization\": {},",
        "context": "            \"matches_by_shard\": {},\n            \"execution_times\": [r.execution_time for r in results],\n            \"average_execution_time\": 0.0,\n            \"shard_utilization\": {},\n            \"truth_values_summary\": {},\n            \"error_summary\": {}\n        }\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 303,
        "type": "empty_function",
        "content": "\"truth_values_summary\": {},",
        "context": "            \"execution_times\": [r.execution_time for r in results],\n            \"average_execution_time\": 0.0,\n            \"shard_utilization\": {},\n            \"truth_values_summary\": {},\n            \"error_summary\": {}\n        }\n        \n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 304,
        "type": "empty_function",
        "content": "\"error_summary\": {}",
        "context": "            \"average_execution_time\": 0.0,\n            \"shard_utilization\": {},\n            \"truth_values_summary\": {},\n            \"error_summary\": {}\n        }\n        \n        # Calculate average execution time\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 580,
        "type": "empty_function",
        "content": "\"shard_metrics\": {},",
        "context": "        \"\"\"\n        report = {\n            \"global_metrics\": self.global_metrics.copy(),\n            \"shard_metrics\": {},\n            \"system_summary\": {\n                \"total_shards\": self.num_shards,\n                \"links_per_shard\": self.links_per_shard,\n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 589,
        "type": "empty_function",
        "content": "\"load_distribution\": {},",
        "context": "                \"active_tasks\": len([t for t in self.active_tasks.values() if not t[\"completed\"]]),\n                \"cached_results\": len(self.results_cache)\n            },\n            \"load_distribution\": {},\n            \"performance_summary\": {}\n        }\n        \n"
      },
      {
        "file": "cognitive-das/shard_manager.py",
        "line": 590,
        "type": "empty_function",
        "content": "\"performance_summary\": {}",
        "context": "                \"cached_results\": len(self.results_cache)\n            },\n            \"load_distribution\": {},\n            \"performance_summary\": {}\n        }\n        \n        # Collect shard metrics\n"
      },
      {
        "file": "cognitive-das/test_phase_beta.py",
        "line": 29,
        "type": "empty_function",
        "content": "self.test_results = {}",
        "context": "        self.executor = DistributedShardExecutor(num_shards=11, links_per_shard=5, truth_dimensions=2)\n        self.matcher = HypergraphPatternMatcher(num_shards=11, links_per_shard=5, truth_dimensions=2)\n        \n        self.test_results = {}\n    \n    def test_110_states_validation(self):\n        \"\"\"Test that we can access all 110 states in 11\u00d75\u00d72 tensor\"\"\"\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 66,
        "type": "empty_function",
        "content": "self.layer_weights = {}",
        "context": "        self.message_passes = 7\n        \n        # Initialize layer-specific weight matrices\n        self.layer_weights = {}\n        self.attention_weights = {}\n        \n        for layer in range(self.num_layers):\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 67,
        "type": "empty_function",
        "content": "self.attention_weights = {}",
        "context": "        \n        # Initialize layer-specific weight matrices\n        self.layer_weights = {}\n        self.attention_weights = {}\n        \n        for layer in range(self.num_layers):\n            self.layer_weights[layer] = np.random.randn(embedding_dim, embedding_dim) * 0.1\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 115,
        "type": "empty_function",
        "content": "node_messages = {}",
        "context": "            NeuralGraph: Graph with updated embeddings for this layer\n        \"\"\"\n        # Collect messages for all nodes in parallel\n        node_messages = {}\n        \n        # Use ThreadPoolExecutor for parallel message computation\n        with ThreadPoolExecutor(max_workers=7) as executor:\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 119,
        "type": "empty_function",
        "content": "futures = {}",
        "context": "        \n        # Use ThreadPoolExecutor for parallel message computation\n        with ThreadPoolExecutor(max_workers=7) as executor:\n            futures = {}\n            \n            for node_id, node in graph.nodes.items():\n                future = executor.submit(\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 358,
        "type": "empty_function",
        "content": "new_nodes = {}",
        "context": "    \n    def _deep_copy_graph(self, graph: NeuralGraph) -> NeuralGraph:\n        \"\"\"Create a deep copy of the neural graph\"\"\"\n        new_nodes = {}\n        new_edges = {}\n        \n        # Copy nodes\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 359,
        "type": "empty_function",
        "content": "new_edges = {}",
        "context": "    def _deep_copy_graph(self, graph: NeuralGraph) -> NeuralGraph:\n        \"\"\"Create a deep copy of the neural graph\"\"\"\n        new_nodes = {}\n        new_edges = {}\n        \n        # Copy nodes\n        for node_id, node in graph.nodes.items():\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 397,
        "type": "empty_function",
        "content": "nodes = {}",
        "context": "        Returns:\n            NeuralGraph: Test graph with 343 nodes\n        \"\"\"\n        nodes = {}\n        edges = {}\n        \n        # Create nodes for each position in 7\u00d77\u00d77 tensor\n"
      },
      {
        "file": "cognitive-gnn/message_passing.py",
        "line": 398,
        "type": "empty_function",
        "content": "edges = {}",
        "context": "            NeuralGraph: Test graph with 343 nodes\n        \"\"\"\n        nodes = {}\n        edges = {}\n        \n        # Create nodes for each position in 7\u00d77\u00d77 tensor\n        node_count = 0\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 40,
        "type": "empty_function",
        "content": "self.arguments = {}",
        "context": "    \n    def __post_init__(self):\n        if self.arguments is None:\n            self.arguments = {}\n        if self.directives is None:\n            self.directives = []\n        if self.selections is None:\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 56,
        "type": "empty_function",
        "content": "self.variables = {}",
        "context": "    \n    def __post_init__(self):\n        if self.variables is None:\n            self.variables = {}\n\n@dataclass\nclass NeuralGraphStructure:\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 183,
        "type": "empty_function",
        "content": "variables = {}",
        "context": "    \n    def _extract_variables(self, query_string: str) -> Dict[str, Any]:\n        \"\"\"Extract variables from GraphQL query\"\"\"\n        variables = {}\n        \n        # Find variable declarations\n        var_match = re.search(r'\\(([^)]+)\\)', query_string)\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 326,
        "type": "empty_function",
        "content": "arguments = {}",
        "context": "    \n    def _parse_arguments(self, field_string: str) -> Dict[str, Any]:\n        \"\"\"Parse arguments from field string\"\"\"\n        arguments = {}\n        \n        # Find arguments in parentheses\n        arg_match = re.search(r'\\(([^)]+)\\)', field_string)\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 417,
        "type": "empty_function",
        "content": "directive_args = {}",
        "context": "        \n        for match in directive_matches:\n            directive_name = match.group(1)\n            directive_args = {}\n            \n            if match.group(2):\n                arg_string = match.group(2)\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 610,
        "type": "empty_function",
        "content": "coord_attention = {}",
        "context": "        attention_matrix = np.zeros((7, 7))\n        \n        # Aggregate attention scores by x,y coordinates\n        coord_attention = {}\n        for node in nodes:\n            x, y, z = node[\"coordinates\"]\n            key = (x, y)\n"
      },
      {
        "file": "cognitive-gnn/schema_generator.py",
        "line": 37,
        "type": "empty_function",
        "content": "self.schema_cache = {}",
        "context": "    def __init__(self):\n        self.config = NeuralGraphQLConfig()\n        self.attention_weights = np.random.randn(7, 7, 7)\n        self.schema_cache = {}\n        \n    def generate_schema(self) -> str:\n        \"\"\"\n"
      },
      {
        "file": "cognitive-gnn/test_phase_alpha.py",
        "line": 30,
        "type": "empty_function",
        "content": "self.test_results = {}",
        "context": "        self.message_engine = MessagePassingEngine(embedding_dim=64)\n        self.query_parser = GraphQLQueryParser()\n        \n        self.test_results = {}\n    \n    def test_343_states_enumeration(self):\n        \"\"\"Test that we can enumerate all 343 states in 7\u00d77\u00d77 tensor\"\"\"\n"
      },
      {
        "file": "cognitive-membrane-sync/cognitive_membrane_cli.py",
        "line": 160,
        "type": "empty_function",
        "content": "print(f\"Organizations: {len(bridge.membrane_config.get('organizations', {}))}\")",
        "context": "                print(\"\ud83d\udcca Cognitive Membrane Status\")\n                print(\"=\" * 30)\n                print(f\"Enterprise: {bridge.membrane_config.get('enterprise_id', 'None')}\")\n                print(f\"Organizations: {len(bridge.membrane_config.get('organizations', {}))}\")\n                \n                total_repos = sum(len(org.get('repositories', {})) \n                                for org in bridge.membrane_config.get('organizations', {}).values())\n"
      },
      {
        "file": "cognitive-membrane-sync/cognitive_membrane_cli.py",
        "line": 162,
        "type": "empty_function",
        "content": "total_repos = sum(len(org.get('repositories', {}))",
        "context": "                print(f\"Enterprise: {bridge.membrane_config.get('enterprise_id', 'None')}\")\n                print(f\"Organizations: {len(bridge.membrane_config.get('organizations', {}))}\")\n                \n                total_repos = sum(len(org.get('repositories', {})) \n                                for org in bridge.membrane_config.get('organizations', {}).values())\n                print(f\"Repositories: {total_repos}\")\n                print(f\"Tensor mappings: {len(bridge.tensor_mappings)}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/cognitive_membrane_cli.py",
        "line": 163,
        "type": "empty_function",
        "content": "for org in bridge.membrane_config.get('organizations', {}).values())",
        "context": "                print(f\"Organizations: {len(bridge.membrane_config.get('organizations', {}))}\")\n                \n                total_repos = sum(len(org.get('repositories', {})) \n                                for org in bridge.membrane_config.get('organizations', {}).values())\n                print(f\"Repositories: {total_repos}\")\n                print(f\"Tensor mappings: {len(bridge.tensor_mappings)}\")\n                \n"
      },
      {
        "file": "cognitive-membrane-sync/cognitive_membrane_cli.py",
        "line": 171,
        "type": "empty_function",
        "content": "for repo_id in org_data.get('repositories', {}):",
        "context": "                    print(\"\\nOrganizations:\")\n                    for org_id, org_data in bridge.membrane_config['organizations'].items():\n                        print(f\"  \u2022 {org_id} ({org_data.get('membrane_type', 'unknown')})\")\n                        for repo_id in org_data.get('repositories', {}):\n                            print(f\"    - {repo_id}\")\n            else:\n                print(\"\u274c No membrane configuration loaded\")\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 161,
        "type": "empty_function",
        "content": "print(f\"   \ud83e\udde0 Primitives: {len(grammar_info.get('cognitive_primitives', {}))}\")",
        "context": "    print(f\"   \ud83d\udcdd Version: {grammar_info['version']}\")\n    print(f\"   \ud83c\udf0c Enterprise: {grammar_info['enterprise']}\")\n    print(f\"   \ud83d\udd52 Generated: {grammar_info['generation_timestamp']}\")\n    print(f\"   \ud83e\udde0 Primitives: {len(grammar_info.get('cognitive_primitives', {}))}\")\n    print(f\"   \u2699\ufe0f  Optimization Method: {grammar_info['tensor_optimization']['method']}\")\n    print(f\"   \ud83d\udd27 GGML Compatible: {grammar_info['ggml_compatibility']['version']}\")\n    \n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 179,
        "type": "empty_function",
        "content": "total_repos = sum(len(org.get('repositories', {})) for org in config.get('organizations', {}).values())",
        "context": "    \n    print_step(\"7.2\", \"Analyze Final Configuration\")\n    config = bridge.membrane_config\n    total_repos = sum(len(org.get('repositories', {})) for org in config.get('organizations', {}).values())\n    total_complexity = sum(\n        sum(repo.get('complexity_score', 0) for repo in org.get('repositories', {}).values())\n        for org in config.get('organizations', {}).values()\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 181,
        "type": "empty_function",
        "content": "sum(repo.get('complexity_score', 0) for repo in org.get('repositories', {}).values())",
        "context": "    config = bridge.membrane_config\n    total_repos = sum(len(org.get('repositories', {})) for org in config.get('organizations', {}).values())\n    total_complexity = sum(\n        sum(repo.get('complexity_score', 0) for repo in org.get('repositories', {}).values())\n        for org in config.get('organizations', {}).values()\n    )\n    \n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 182,
        "type": "empty_function",
        "content": "for org in config.get('organizations', {}).values()",
        "context": "    total_repos = sum(len(org.get('repositories', {})) for org in config.get('organizations', {}).values())\n    total_complexity = sum(\n        sum(repo.get('complexity_score', 0) for repo in org.get('repositories', {}).values())\n        for org in config.get('organizations', {}).values()\n    )\n    \n    print(f\"   \ud83c\udf0c Enterprise: {config['enterprise_id']}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 186,
        "type": "empty_function",
        "content": "print(f\"   \ud83c\udfe2 Organizations: {len(config.get('organizations', {}))}\")",
        "context": "    )\n    \n    print(f\"   \ud83c\udf0c Enterprise: {config['enterprise_id']}\")\n    print(f\"   \ud83c\udfe2 Organizations: {len(config.get('organizations', {}))}\")\n    print(f\"   \ud83d\udcc2 Total Repositories: {total_repos}\")\n    print(f\"   \ud83d\udcca Total Complexity: {total_complexity:.2f}\")\n    print(f\"   \ud83d\uddfa\ufe0f  Tensor Mappings: {len(bridge.tensor_mappings)}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 199,
        "type": "empty_function",
        "content": "for org_id, org_data in config.get('organizations', {}).items():",
        "context": "    \n    print_section(\"Phase 8: Organizational Topology Summary\")\n    \n    for org_id, org_data in config.get('organizations', {}).items():\n        print(f\"\\n\ud83c\udfe2 {org_id}:\")\n        print(f\"   Type: {org_data['membrane_type']}\")\n        print(f\"   Prime: {org_data['prime_factor']}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 204,
        "type": "empty_function",
        "content": "print(f\"   Repositories: {len(org_data.get('repositories', {}))}\")",
        "context": "        print(f\"   Type: {org_data['membrane_type']}\")\n        print(f\"   Prime: {org_data['prime_factor']}\")\n        print(f\"   Shape: {org_data['tensor_shape']}\")\n        print(f\"   Repositories: {len(org_data.get('repositories', {}))}\")\n        \n        for repo_id, repo_data in org_data.get('repositories', {}).items():\n            print(f\"     \ud83d\udcc2 {repo_id}: complexity={repo_data['complexity_score']:.2f}, \"\n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 206,
        "type": "empty_function",
        "content": "for repo_id, repo_data in org_data.get('repositories', {}).items():",
        "context": "        print(f\"   Shape: {org_data['tensor_shape']}\")\n        print(f\"   Repositories: {len(org_data.get('repositories', {}))}\")\n        \n        for repo_id, repo_data in org_data.get('repositories', {}).items():\n            print(f\"     \ud83d\udcc2 {repo_id}: complexity={repo_data['complexity_score']:.2f}, \"\n                  f\"patterns={len(repo_data['cognitive_patterns'])}\")\n    \n"
      },
      {
        "file": "cognitive-membrane-sync/demonstrate_framework.py",
        "line": 215,
        "type": "empty_function",
        "content": "print(f\"   \ud83c\udfe2 Organizational membranes: {len(config.get('organizations', {}))}\")",
        "context": "    print(\"\u2705 Multi-Scale Synchronization Framework demonstration completed successfully!\")\n    print(\"\\n\ud83d\udcc8 Summary Statistics:\")\n    print(f\"   \ud83c\udf0c Enterprise membranes: 1\")\n    print(f\"   \ud83c\udfe2 Organizational membranes: {len(config.get('organizations', {}))}\")\n    print(f\"   \ud83d\udcc2 Repository membranes: {total_repos}\")\n    print(f\"   \ud83d\udd04 Total synchronizations: {sync_result['membranes_synchronized']}\")\n    print(f\"   \ud83d\udcca Total cognitive complexity: {total_complexity:.2f}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 30,
        "type": "empty_function",
        "content": "self.membrane_config = {}",
        "context": "    def __init__(self, workspace_path: str = \"/workspaces/cosmos\"):\n        self.workspace_path = Path(workspace_path)\n        self.scheme_module_path = Path(__file__).parent.parent / \"distributed-cognition\" / \"scheme\"\n        self.membrane_config = {}\n        self.tensor_mappings = {}\n        \n    def initialize_membrane_topology(self, enterprise_id: str, tensor_dimensions: List[int]) -> Dict[str, Any]:\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 31,
        "type": "empty_function",
        "content": "self.tensor_mappings = {}",
        "context": "        self.workspace_path = Path(workspace_path)\n        self.scheme_module_path = Path(__file__).parent.parent / \"distributed-cognition\" / \"scheme\"\n        self.membrane_config = {}\n        self.tensor_mappings = {}\n        \n    def initialize_membrane_topology(self, enterprise_id: str, tensor_dimensions: List[int]) -> Dict[str, Any]:\n        \"\"\"Initialize the cognitive membrane topology\"\"\"\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 42,
        "type": "empty_function",
        "content": "'organizations': {},",
        "context": "            'enterprise_id': enterprise_id,\n            'tensor_dimensions': tensor_dimensions,\n            'timestamp': datetime.utcnow().isoformat(),\n            'organizations': {},\n            'repositories': {},\n            'membrane_hierarchy': {},\n            'synchronization_status': 'initialized'\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 43,
        "type": "empty_function",
        "content": "'repositories': {},",
        "context": "            'tensor_dimensions': tensor_dimensions,\n            'timestamp': datetime.utcnow().isoformat(),\n            'organizations': {},\n            'repositories': {},\n            'membrane_hierarchy': {},\n            'synchronization_status': 'initialized'\n        }\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 44,
        "type": "empty_function",
        "content": "'membrane_hierarchy': {},",
        "context": "            'timestamp': datetime.utcnow().isoformat(),\n            'organizations': {},\n            'repositories': {},\n            'membrane_hierarchy': {},\n            'synchronization_status': 'initialized'\n        }\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 64,
        "type": "empty_function",
        "content": "'repositories': {},",
        "context": "            'prime_factor': prime_factor,\n            'tensor_shape': tensor_shape,\n            'permeability': 'bidirectional',\n            'repositories': {},\n            'created_at': datetime.utcnow().isoformat()\n        }\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 70,
        "type": "empty_function",
        "content": "self.membrane_config['organizations'] = {}",
        "context": "        \n        # Add to enterprise configuration\n        if 'organizations' not in self.membrane_config:\n            self.membrane_config['organizations'] = {}\n        \n        self.membrane_config['organizations'][org_id] = org_membrane\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 160,
        "type": "empty_function",
        "content": "return {}",
        "context": "        \n        membrane_data = self._get_membrane_data(membrane_id)\n        if not membrane_data:\n            return {}\n        \n        hypergraph_embedding = {\n            'node_id': membrane_id,\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 281,
        "type": "empty_function",
        "content": "self.membrane_config = state_data.get('membrane_config', {})",
        "context": "            with open(input_file) as f:\n                state_data = json.load(f)\n            \n            self.membrane_config = state_data.get('membrane_config', {})\n            self.tensor_mappings = state_data.get('tensor_mappings', {})\n            \n            logger.info(f\"\ud83d\udce5 Loaded membrane state from {input_file}\")\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 282,
        "type": "empty_function",
        "content": "self.tensor_mappings = state_data.get('tensor_mappings', {})",
        "context": "                state_data = json.load(f)\n            \n            self.membrane_config = state_data.get('membrane_config', {})\n            self.tensor_mappings = state_data.get('tensor_mappings', {})\n            \n            logger.info(f\"\ud83d\udce5 Loaded membrane state from {input_file}\")\n            return True\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 376,
        "type": "empty_function",
        "content": "for org_data in self.membrane_config.get('organizations', {}).values():",
        "context": "            return self.membrane_config['organizations'][membrane_id]\n        \n        # Check if it's a repository\n        for org_data in self.membrane_config.get('organizations', {}).values():\n            if 'repositories' in org_data and membrane_id in org_data['repositories']:\n                return org_data['repositories'][membrane_id]\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 423,
        "type": "empty_function",
        "content": "for org_data in self.membrane_config.get('organizations', {}).values():",
        "context": "        total_complexity = 0\n        total_repos = 0\n        \n        for org_data in self.membrane_config.get('organizations', {}).values():\n            for repo_data in org_data.get('repositories', {}).values():\n                total_complexity += repo_data.get('complexity_score', 1.0)\n                total_repos += 1\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 424,
        "type": "empty_function",
        "content": "for repo_data in org_data.get('repositories', {}).values():",
        "context": "        total_repos = 0\n        \n        for org_data in self.membrane_config.get('organizations', {}).values():\n            for repo_data in org_data.get('repositories', {}).values():\n                total_complexity += repo_data.get('complexity_score', 1.0)\n                total_repos += 1\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 428,
        "type": "empty_function",
        "content": "enterprise_tensor_shape = [7, len(self.membrane_config.get('organizations', {})), total_repos, int(total_complexity), total_repos * 10]",
        "context": "                total_complexity += repo_data.get('complexity_score', 1.0)\n                total_repos += 1\n        \n        enterprise_tensor_shape = [7, len(self.membrane_config.get('organizations', {})), total_repos, int(total_complexity), total_repos * 10]\n        \n        self.tensor_mappings[enterprise_id] = {\n            'enterprise_tensor_shape': enterprise_tensor_shape,\n"
      },
      {
        "file": "cognitive-patterns/include/AdaptivePatternRecognitionFusionEngine.h",
        "line": 62,
        "type": "empty_function",
        "content": "cognitive_load_estimate(0.0) {}",
        "context": "    PatternRecognitionResult() \n        : strategy_used(RecognitionStrategy::ADAPTIVE_SELECT),\n          processing_time_ms(0.0), accuracy_estimate(0.0),\n          cognitive_load_estimate(0.0) {}\n};\n\n/**\n"
      },
      {
        "file": "cognitive-patterns/include/AdaptivePatternRecognitionFusionEngine.h",
        "line": 77,
        "type": "empty_function",
        "content": "attention_contributions(0.0) {}",
        "context": "    \n    CrossModalResult() \n        : symbolic_contributions(0.0), neural_contributions(0.0),\n          attention_contributions(0.0) {}\n};\n\n/**\n"
      },
      {
        "file": "cognitive-patterns/include/AdaptivePatternRecognitionFusionEngine.h",
        "line": 93,
        "type": "empty_function",
        "content": "usage_count(0), success_rate(0.5), last_used(std::chrono::system_clock::now()) {}",
        "context": "    \n    StrategyPerformance(RecognitionStrategy s = RecognitionStrategy::ADAPTIVE_SELECT)\n        : strategy(s), average_accuracy(0.5), average_processing_time_ms(100.0),\n          usage_count(0), success_rate(0.5), last_used(std::chrono::system_clock::now()) {}\n};\n\n/**\n"
      },
      {
        "file": "cognitive-patterns/include/AdaptivePatternRecognitionFusionEngine.h",
        "line": 110,
        "type": "empty_function",
        "content": "strategy_switch_penalty(0.05), enable_emergent_learning(true) {}",
        "context": "    AdaptiveConfig()\n        : adaptation_rate(0.1), cognitive_load_threshold(0.8),\n          accuracy_threshold(0.7), performance_history_size(100),\n          strategy_switch_penalty(0.05), enable_emergent_learning(true) {}\n};\n\n/**\n"
      },
      {
        "file": "cognitive-visualization/include/CognitiveVisualizer.h",
        "line": 68,
        "type": "empty_function",
        "content": "const std::map<std::string, std::vector<double>>& agent_states = {});",
        "context": "    void update_cognitive_visualization(\n        const std::map<std::string, std::vector<double>>& hypergraph_nodes,\n        const std::map<std::string, std::vector<std::pair<std::string, double>>>& hypergraph_edges,\n        const std::map<std::string, std::vector<double>>& agent_states = {});\n\n    /**\n     * Render adaptive attention overlays\n"
      },
      {
        "file": "cognitive-visualization/include/RealTimeIntrospector.h",
        "line": 198,
        "type": "empty_function",
        "content": "const std::vector<std::string>& focus_areas = {});",
        "context": "     * @return Map of insights and recommendations\n     */\n    std::map<std::string, std::string> perform_deep_introspection(\n        const std::vector<std::string>& focus_areas = {});\n\n    /**\n     * Generate adaptive monitoring recommendations\n"
      },
      {
        "file": "cognitive-visualization/include/RealTimeIntrospector.h",
        "line": 263,
        "type": "empty_function",
        "content": "const std::map<std::string, double>& safety_limits = {});",
        "context": "     * @param safety_limits Safety constraints for self-modification\n     */\n    void enable_meta_cognitive_adaptation(bool enable = true,\n                                        const std::map<std::string, double>& safety_limits = {});\n\nprivate:\n    /**\n"
      },
      {
        "file": "cognitive-visualization/src/HypergraphRenderer.cc",
        "line": 114,
        "type": "empty_function",
        "content": "std::string pattern_id = \"pattern_\" + std::to_string(std::hash<std::string>{}(pattern_query));",
        "context": "{\n    std::cout << \"\ud83d\udd0d Updating pattern match visualization: \" << pattern_query << std::endl;\n    \n    std::string pattern_id = \"pattern_\" + std::to_string(std::hash<std::string>{}(pattern_query));\n    \n    PatternMatchState state;\n    state.pattern_id = pattern_id;\n"
      },
      {
        "file": "cognitive-visualization/src/HypergraphRenderer.cc",
        "line": 258,
        "type": "empty_function",
        "content": "return \"{}\";",
        "context": "{\n    auto traversal_it = active_traversals_.find(traversal_id);\n    if (traversal_it == active_traversals_.end()) {\n        return \"{}\";\n    }\n    \n    const TraversalState& state = traversal_it->second;\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/Proxy.h",
        "line": 37,
        "type": "empty_function",
        "content": "Proxy(CogServer& cs) : Module(cs) {};",
        "context": "class Proxy : public Module\n{\n\tpublic:\n\t\tProxy(CogServer& cs) : Module(cs) {};\n\t\tvirtual ~Proxy() {};\n\n\t\tvirtual void setup(SexprEval*) = 0;\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/Proxy.h",
        "line": 38,
        "type": "empty_function",
        "content": "virtual ~Proxy() {};",
        "context": "{\n\tpublic:\n\t\tProxy(CogServer& cs) : Module(cs) {};\n\t\tvirtual ~Proxy() {};\n\n\t\tvirtual void setup(SexprEval*) = 0;\n};\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/ReadThruProxy.cc",
        "line": 36,
        "type": "empty_function",
        "content": "ReadThruProxy::ReadThruProxy(CogServer& cs) : Proxy(cs) {}",
        "context": "\nDECLARE_MODULE(ReadThruProxy);\n\nReadThruProxy::ReadThruProxy(CogServer& cs) : Proxy(cs) {}\n\nvoid ReadThruProxy::init(void) {}\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/ReadThruProxy.cc",
        "line": 38,
        "type": "empty_function",
        "content": "void ReadThruProxy::init(void) {}",
        "context": "\nReadThruProxy::ReadThruProxy(CogServer& cs) : Proxy(cs) {}\n\nvoid ReadThruProxy::init(void) {}\n\nReadThruProxy::~ReadThruProxy() {}\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/ReadThruProxy.cc",
        "line": 40,
        "type": "empty_function",
        "content": "ReadThruProxy::~ReadThruProxy() {}",
        "context": "\nvoid ReadThruProxy::init(void) {}\n\nReadThruProxy::~ReadThruProxy() {}\n\nbool ReadThruProxy::config(const char* cfg)\n{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/ReadThruProxy.cc",
        "line": 68,
        "type": "empty_function",
        "content": "ReadThru::~ReadThru() {}",
        "context": "\thave_value_cb = true;\n}\n\nReadThru::~ReadThru() {}\n\nvoid ReadThru::setup(SexprEval* sev)\n{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/ThruCommands.cc",
        "line": 41,
        "type": "empty_function",
        "content": "ThruCommands::~ThruCommands() {}",
        "context": "{\n}\n\nThruCommands::~ThruCommands() {}\n\nvoid ThruCommands::init(const AtomSpacePtr& asp)\n{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/WriteThruProxy.cc",
        "line": 37,
        "type": "empty_function",
        "content": "WriteThruProxy::WriteThruProxy(CogServer& cs) : Proxy(cs) {}",
        "context": "\nDECLARE_MODULE(WriteThruProxy);\n\nWriteThruProxy::WriteThruProxy(CogServer& cs) : Proxy(cs) {}\n\nvoid WriteThruProxy::init(void) {}\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/WriteThruProxy.cc",
        "line": 39,
        "type": "empty_function",
        "content": "void WriteThruProxy::init(void) {}",
        "context": "\nWriteThruProxy::WriteThruProxy(CogServer& cs) : Proxy(cs) {}\n\nvoid WriteThruProxy::init(void) {}\n\nWriteThruProxy::~WriteThruProxy() {}\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/WriteThruProxy.cc",
        "line": 41,
        "type": "empty_function",
        "content": "WriteThruProxy::~WriteThruProxy() {}",
        "context": "\nvoid WriteThruProxy::init(void) {}\n\nWriteThruProxy::~WriteThruProxy() {}\n\nbool WriteThruProxy::config(const char* cfg)\n{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/attic/proxy/WriteThruProxy.cc",
        "line": 68,
        "type": "empty_function",
        "content": "WriteThru::~WriteThru() {}",
        "context": "\thave_update_value_cb = true;\n}\n\nWriteThru::~WriteThru() {}\n\nvoid WriteThru::setup(SexprEval* sev)\n{\n"
      },
      {
        "file": "cogserver/opencog/cogserver/modules/commands/ModuleManagement.h",
        "line": 21,
        "type": "empty_function",
        "content": "REQUESTNAME(CogServer& cs) : Request(cs) {};                      \\",
        "context": "                                                                      \\\nclass REQUESTNAME : public Request {                                  \\\npublic:                                                               \\\n    REQUESTNAME(CogServer& cs) : Request(cs) {};                      \\\n    virtual ~REQUESTNAME() {};                                        \\\n    static const RequestClassInfo& info(void);                        \\\n    virtual bool execute(void);                                       \\\n"
      },
      {
        "file": "cogserver/opencog/cogserver/modules/commands/ModuleManagement.h",
        "line": 22,
        "type": "empty_function",
        "content": "virtual ~REQUESTNAME() {};                                        \\",
        "context": "class REQUESTNAME : public Request {                                  \\\npublic:                                                               \\\n    REQUESTNAME(CogServer& cs) : Request(cs) {};                      \\\n    virtual ~REQUESTNAME() {};                                        \\\n    static const RequestClassInfo& info(void);                        \\\n    virtual bool execute(void);                                       \\\n    virtual bool isShell(void) { return info().is_shell; }            \\\n"
      },
      {
        "file": "cogserver/opencog/cogserver/modules/commands/ShutdownRequest.cc",
        "line": 17,
        "type": "empty_function",
        "content": "ShutdownRequest::ShutdownRequest(CogServer& cs) : Request(cs) {}",
        "context": "\nusing namespace opencog;\n\nShutdownRequest::ShutdownRequest(CogServer& cs) : Request(cs) {}\nShutdownRequest::~ShutdownRequest() {}\n\nconst RequestClassInfo&\n"
      },
      {
        "file": "cogserver/opencog/cogserver/modules/commands/ShutdownRequest.cc",
        "line": 18,
        "type": "empty_function",
        "content": "ShutdownRequest::~ShutdownRequest() {}",
        "context": "using namespace opencog;\n\nShutdownRequest::ShutdownRequest(CogServer& cs) : Request(cs) {}\nShutdownRequest::~ShutdownRequest() {}\n\nconst RequestClassInfo&\nShutdownRequest::info(void)\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 46,
        "type": "empty_function",
        "content": "ClassInfo() {};",
        "context": "{\n    std::string id;\n\n    ClassInfo() {};\n    ClassInfo(const char* s) : id(s) {};\n    ClassInfo(const std::string& s) : id(s) {};\n};\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 47,
        "type": "empty_function",
        "content": "ClassInfo(const char* s) : id(s) {};",
        "context": "    std::string id;\n\n    ClassInfo() {};\n    ClassInfo(const char* s) : id(s) {};\n    ClassInfo(const std::string& s) : id(s) {};\n};\n \n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 48,
        "type": "empty_function",
        "content": "ClassInfo(const std::string& s) : id(s) {};",
        "context": "\n    ClassInfo() {};\n    ClassInfo(const char* s) : id(s) {};\n    ClassInfo(const std::string& s) : id(s) {};\n};\n \n/** Defines an abstract factory template, following Alexandrescu's pattern from\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 57,
        "type": "empty_function",
        "content": "explicit AbstractFactory() {};",
        "context": "class AbstractFactory\n{\npublic:\n    explicit AbstractFactory() {};\n    virtual ~AbstractFactory() {}\n    virtual _BaseType* create(CogServer&) const = 0;\n    virtual const ClassInfo& info() const = 0;\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 58,
        "type": "empty_function",
        "content": "virtual ~AbstractFactory() {}",
        "context": "{\npublic:\n    explicit AbstractFactory() {};\n    virtual ~AbstractFactory() {}\n    virtual _BaseType* create(CogServer&) const = 0;\n    virtual const ClassInfo& info() const = 0;\n}; \n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 69,
        "type": "empty_function",
        "content": "explicit Factory() : AbstractFactory<_BaseType>() {}",
        "context": "class Factory : public AbstractFactory<_BaseType>\n{\npublic:\n    explicit Factory() : AbstractFactory<_BaseType>() {}\n    virtual ~Factory() {}\n    virtual _BaseType* create(CogServer& cs) const { return new _Type(cs); }\n    virtual const ClassInfo& info() const { return _Type::info(); }\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Factory.h",
        "line": 70,
        "type": "empty_function",
        "content": "virtual ~Factory() {}",
        "context": "{\npublic:\n    explicit Factory() : AbstractFactory<_BaseType>() {}\n    virtual ~Factory() {}\n    virtual _BaseType* create(CogServer& cs) const { return new _Type(cs); }\n    virtual const ClassInfo& info() const { return _Type::info(); }\n}; \n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Module.h",
        "line": 125,
        "type": "empty_function",
        "content": "Module(CogServer& cs) : _cogserver(cs) {}",
        "context": "    typedef void        UnloadFunction(Module*);\n    typedef bool        ConfigFunction(Module*, const char*);\n\n    Module(CogServer& cs) : _cogserver(cs) {}\n    virtual ~Module() {}\n    virtual void init() = 0;\n    virtual bool config(const char *) = 0;\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Module.h",
        "line": 126,
        "type": "empty_function",
        "content": "virtual ~Module() {}",
        "context": "    typedef bool        ConfigFunction(Module*, const char*);\n\n    Module(CogServer& cs) : _cogserver(cs) {}\n    virtual ~Module() {}\n    virtual void init() = 0;\n    virtual bool config(const char *) = 0;\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Request.h",
        "line": 136,
        "type": "empty_function",
        "content": "do_cmd##Request(CogServer& cs) : Request(cs) {};            \\",
        "context": "                                                 hidden);             \\\n              return _cci;                                            \\\n          }                                                           \\\n          do_cmd##Request(CogServer& cs) : Request(cs) {};            \\\n          virtual ~do_cmd##Request() {};                              \\\n          virtual bool execute(void) {                                \\\n              logger().debug(\"[ %s Request] execute\", cmd_str);       \\\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/Request.h",
        "line": 137,
        "type": "empty_function",
        "content": "virtual ~do_cmd##Request() {};                              \\",
        "context": "              return _cci;                                            \\\n          }                                                           \\\n          do_cmd##Request(CogServer& cs) : Request(cs) {};            \\\n          virtual ~do_cmd##Request() {};                              \\\n          virtual bool execute(void) {                                \\\n              logger().debug(\"[ %s Request] execute\", cmd_str);       \\\n                                                                      \\\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/RequestClassInfo.h",
        "line": 39,
        "type": "empty_function",
        "content": "RequestClassInfo() : is_shell(false), hidden(false) {};",
        "context": "    /** Whether default shell should be hidden from help */\n    bool hidden;\n\n    RequestClassInfo() : is_shell(false), hidden(false) {};\n    RequestClassInfo(const char* i, const char *d, const char* h,\n            bool s = false, bool hide = false)\n        : ClassInfo(i), description(d), help(h), is_shell(s), hidden(hide) {};\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/RequestClassInfo.h",
        "line": 42,
        "type": "empty_function",
        "content": ": ClassInfo(i), description(d), help(h), is_shell(s), hidden(hide) {};",
        "context": "    RequestClassInfo() : is_shell(false), hidden(false) {};\n    RequestClassInfo(const char* i, const char *d, const char* h,\n            bool s = false, bool hide = false)\n        : ClassInfo(i), description(d), help(h), is_shell(s), hidden(hide) {};\n    RequestClassInfo(const std::string& i, \n                     const std::string& d,\n                     const std::string& h, \n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/RequestClassInfo.h",
        "line": 48,
        "type": "empty_function",
        "content": ": ClassInfo(i), description(d), help(h), is_shell(s), hidden(hide) {};",
        "context": "                     const std::string& h, \n                     bool s = false,\n                     bool hide = false)\n        : ClassInfo(i), description(d), help(h), is_shell(s), hidden(hide) {};\n};\n\n\n"
      },
      {
        "file": "cogserver/opencog/cogserver/shell/ShellModule.h",
        "line": 30,
        "type": "empty_function",
        "content": "shelloutRequest(CogServer& cs) : Request(cs) {};      \\",
        "context": "        {                                                             \\\n            public:                                                   \\\n                static const RequestClassInfo& info(void);            \\\n                shelloutRequest(CogServer& cs) : Request(cs) {};      \\\n                virtual ~shelloutRequest() {};                        \\\n                virtual bool execute(void);                           \\\n                virtual bool isShell(void) { return true; }           \\\n"
      },
      {
        "file": "cogserver/opencog/cogserver/shell/ShellModule.h",
        "line": 31,
        "type": "empty_function",
        "content": "virtual ~shelloutRequest() {};                        \\",
        "context": "            public:                                                   \\\n                static const RequestClassInfo& info(void);            \\\n                shelloutRequest(CogServer& cs) : Request(cs) {};      \\\n                virtual ~shelloutRequest() {};                        \\\n                virtual bool execute(void);                           \\\n                virtual bool isShell(void) { return true; }           \\\n        };                                                            \\\n"
      },
      {
        "file": "cogserver/opencog/network/GenericShell.cc",
        "line": 84,
        "type": "empty_function",
        "content": "{}",
        "context": "    _eval_done(true),\n    _evaluator(nullptr),\n    _name(\"gnrc\")\n{}\n\nGenericShell::~GenericShell()\n{\n"
      },
      {
        "file": "cogserver/opencog/network/GenericShell.cc",
        "line": 92,
        "type": "empty_function",
        "content": "catch (const std::exception& ex) {}",
        "context": "\n\t// It can happen that we already cancelled (e.g. control-D)\n\ttry { evalque.cancel(); }\n\tcatch (const std::exception& ex) {}\n\n\tif (evalthr)\n\t{\n"
      },
      {
        "file": "cogutil/opencog/util/Counter.h",
        "line": 65,
        "type": "empty_function",
        "content": "Counter() {}",
        "context": "\ttypedef std::map<T, CT, CMP> super;\n\ttypedef typename super::value_type value_type;\n\n\tCounter() {}\n\n\ttemplate<typename IT>\n\tCounter(IT from, IT to) : Counter()\n"
      },
      {
        "file": "cogutil/opencog/util/KLD.h",
        "line": 86,
        "type": "empty_function",
        "content": "KLDS() : margin(1.0) {}",
        "context": "     * set_q_pdf) to fill P and Q before computing KL(P||Q) via\n     * operator()\n     */\n    KLDS() : margin(1.0) {}\n\n    /**\n     * @param p sorted sequence of values representing the distribution of P\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 218,
        "type": "empty_function",
        "content": "Base(const Base& b) : logger(b.logger), lvl(b.lvl) {}",
        "context": "    class Base\n    {\n    public:\n        Base(const Base& b) : logger(b.logger), lvl(b.lvl) {}\n        template<typename T> std::stringstream& operator<<(const T& v)\n        {\n            ss << v;\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 231,
        "type": "empty_function",
        "content": "Base(Logger& l, Level v) : logger(l), lvl(v) {}",
        "context": "        }\n    protected:\n        friend class Logger;\n        Base(Logger& l, Level v) : logger(l), lvl(v) {}\n    private:\n        Logger& logger;\n        std::stringstream ss;\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 246,
        "type": "empty_function",
        "content": "Error(Logger& l) : Base(l, ERROR) {}",
        "context": "        Base operator()() { return *this; }\n    protected:\n        friend class Logger;\n        Error(Logger& l) : Base(l, ERROR) {}\n    };\n    Error error;\n\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 258,
        "type": "empty_function",
        "content": "Warn(Logger& l) : Base(l, WARN) {}",
        "context": "        Base operator()() { return *this; }\n    protected:\n        friend class Logger;\n        Warn(Logger& l) : Base(l, WARN) {}\n    };\n    Warn warn;\n\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 270,
        "type": "empty_function",
        "content": "Info(Logger& l) : Base(l, INFO) {}",
        "context": "        Base operator()() { return *this; }\n    protected:\n        friend class Logger;\n        Info(Logger& l) : Base(l, INFO) {}\n    };\n    Info info;\n\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 282,
        "type": "empty_function",
        "content": "Debug(Logger& l) : Base(l, DEBUG) {}",
        "context": "        Base operator()() { return *this; }\n    protected:\n        friend class Logger;\n        Debug(Logger& l) : Base(l, DEBUG) {}\n    };\n    Debug debug;\n\n"
      },
      {
        "file": "cogutil/opencog/util/Logger.h",
        "line": 294,
        "type": "empty_function",
        "content": "Fine(Logger& l) : Base(l, FINE) {}",
        "context": "        Base operator()() { return *this; }\n    protected:\n        friend class Logger;\n        Fine(Logger& l) : Base(l, FINE) {}\n    };\n\n    Fine fine;\n"
      },
      {
        "file": "cogutil/opencog/util/RandGen.h",
        "line": 54,
        "type": "empty_function",
        "content": "virtual ~RandGen() {}",
        "context": "\npublic:\n\n    virtual ~RandGen() {}\n\n    //! random int between 0 and max rand number.\n    virtual int randint() = 0;\n"
      },
      {
        "file": "cogutil/opencog/util/ThreadSafeKLDS.h",
        "line": 29,
        "type": "empty_function",
        "content": "ThreadSafeKLDS(const SortedSeq& p) : _klds(p) {}",
        "context": "    ThreadSafeKLDS() = default;\n    \n    template<typename SortedSeq>\n    ThreadSafeKLDS(const SortedSeq& p) : _klds(p) {}\n    \n    ThreadSafeKLDS(const typename KLDS<FloatT>::pdf_t& p_pdf, FloatT p_s = -1) \n        : _klds(p_pdf, p_s) {}\n"
      },
      {
        "file": "cogutil/opencog/util/ThreadSafeKLDS.h",
        "line": 32,
        "type": "empty_function",
        "content": ": _klds(p_pdf, p_s) {}",
        "context": "    ThreadSafeKLDS(const SortedSeq& p) : _klds(p) {}\n    \n    ThreadSafeKLDS(const typename KLDS<FloatT>::pdf_t& p_pdf, FloatT p_s = -1) \n        : _klds(p_pdf, p_s) {}\n\n    // Thread-safe wrapper methods\n    void set_p_pdf(const typename KLDS<FloatT>::pdf_t& p_counter, FloatT p_s = -1) {\n"
      },
      {
        "file": "cogutil/opencog/util/algorithm.h",
        "line": 344,
        "type": "empty_function",
        "content": "return {{}};",
        "context": "\t}\n\n\t// Base case\n\treturn {{}};\n}\n\n/**\n"
      },
      {
        "file": "cogutil/opencog/util/based_variant.h",
        "line": 54,
        "type": "empty_function",
        "content": "based_variant(const T& v) : Variant(v) { }",
        "context": "template<typename Variant, typename Base>\nstruct based_variant : public Variant {\n    template<typename T>\n    based_variant(const T& v) : Variant(v) { }\n    based_variant() { }\n\n    Base* operator->() {\n"
      },
      {
        "file": "cogutil/opencog/util/based_variant.h",
        "line": 55,
        "type": "empty_function",
        "content": "based_variant() { }",
        "context": "struct based_variant : public Variant {\n    template<typename T>\n    based_variant(const T& v) : Variant(v) { }\n    based_variant() { }\n\n    Base* operator->() {\n        return boost::apply_visitor(detail::based_variant_visitor<Base>(), *this);\n"
      },
      {
        "file": "cogutil/opencog/util/concurrent_queue.h",
        "line": 78,
        "type": "empty_function",
        "content": "{}",
        "context": "public:\n    concurrent_queue(void)\n        : the_queue(), the_mutex(), the_cond(), is_canceled(false)\n    {}\n    ~concurrent_queue()\n    { if (not is_canceled) cancel(); }\n\n"
      },
      {
        "file": "cogutil/opencog/util/concurrent_set.h",
        "line": 91,
        "type": "empty_function",
        "content": "{}",
        "context": "public:\n    concurrent_set(void)\n        : the_set(), the_mutex(), the_cond(), is_canceled(false)\n    {}\n    ~concurrent_set()\n    { if (not is_canceled) cancel(); }\n\n"
      },
      {
        "file": "cogutil/opencog/util/concurrent_stack.h",
        "line": 78,
        "type": "empty_function",
        "content": "{}",
        "context": "public:\n    concurrent_stack(void)\n        : the_stack(), the_mutex(), the_cond(), is_canceled(false)\n    {}\n    ~concurrent_stack()\n    { if (not is_canceled) cancel(); }\n\n"
      },
      {
        "file": "cogutil/opencog/util/digraph.h",
        "line": 49,
        "type": "empty_function",
        "content": "digraph(size_type n) : _incoming(n), _outgoing(n) { }",
        "context": "    typedef std::set<value_type> value_set;\n\n    //! construct an empty digraph of size n\n    digraph(size_type n) : _incoming(n), _outgoing(n) { }\n\n    //! insert an arc outgoing from src to dst\n    void insert(value_type src, value_type dst) {\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.cc",
        "line": 86,
        "type": "empty_function",
        "content": "{}",
        "context": "\nStandardException::StandardException() :\n    message(nullptr)\n{}\n\n// Exceptions must have a copy constructor, as otherwise the\n// catcher will not be able to see the message! Ouch!\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 303,
        "type": "empty_function",
        "content": "SilentException(void) {}",
        "context": "     * Constructor\n     * Nothing to be logged; this simply breaks us out of inner loops.\n     */\n    SilentException(void) {}\n\n}; // SilentException\n\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 320,
        "type": "empty_function",
        "content": "DeleteException(void) {}",
        "context": "     * Constructor\n     * Nothing to be logged; this simply breaks us out of inner loops.\n     */\n    DeleteException(void) {}\n\n}; // DeleteException\n\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 338,
        "type": "empty_function",
        "content": "NestingException(void) {}",
        "context": "     * Constructor\n     * Nothing to be logged; this simply breaks us out of inner loops.\n     */\n    NestingException(void) {}\n\n}; // NestingException\n\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 355,
        "type": "empty_function",
        "content": "NotEvaluatableException(void) {}",
        "context": "     * Constructor\n     * Nothing to be logged; this simply breaks us out of inner loops.\n     */\n    NotEvaluatableException(void) {}\n\n}; // NotEvaluatableException\n\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 375,
        "type": "empty_function",
        "content": "NotFoundException(void) {}",
        "context": "     * macro.\n     * @param Exception message in printf standard format.\n     */\n    NotFoundException(void) {}\n    NotFoundException(const char*, const char*, ...);\n    NotFoundException(const char*, const char*, va_list);\n\n"
      },
      {
        "file": "cogutil/opencog/util/exceptions.h",
        "line": 394,
        "type": "empty_function",
        "content": "TypeCheckException(void) {}",
        "context": "     * Constructor\n     * Nothing to be logged; this simply breaks us out of inner loops.\n     */\n    TypeCheckException(void) {}\n\n}; // TypeCheckException\n\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 59,
        "type": "empty_function",
        "content": "tagged_item(const Item& i, const Tag& s) : super(i, s) { }",
        "context": "    typedef typename super::first_type first_type;\n    typedef typename super::second_type second_type;\n\n    tagged_item(const Item& i, const Tag& s) : super(i, s) { }\n    explicit tagged_item(const Item& i) : super(i, Tag()) { }\n    tagged_item() { }\n    template<class T1, class T2>\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 60,
        "type": "empty_function",
        "content": "explicit tagged_item(const Item& i) : super(i, Tag()) { }",
        "context": "    typedef typename super::second_type second_type;\n\n    tagged_item(const Item& i, const Tag& s) : super(i, s) { }\n    explicit tagged_item(const Item& i) : super(i, Tag()) { }\n    tagged_item() { }\n    template<class T1, class T2>\n    tagged_item(const std::pair<T1, T2>& p) : super(p) { }\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 61,
        "type": "empty_function",
        "content": "tagged_item() { }",
        "context": "\n    tagged_item(const Item& i, const Tag& s) : super(i, s) { }\n    explicit tagged_item(const Item& i) : super(i, Tag()) { }\n    tagged_item() { }\n    template<class T1, class T2>\n    tagged_item(const std::pair<T1, T2>& p) : super(p) { }\n\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 63,
        "type": "empty_function",
        "content": "tagged_item(const std::pair<T1, T2>& p) : super(p) { }",
        "context": "    explicit tagged_item(const Item& i) : super(i, Tag()) { }\n    tagged_item() { }\n    template<class T1, class T2>\n    tagged_item(const std::pair<T1, T2>& p) : super(p) { }\n\n    bool operator<(const tagged_item<Item, Tag>& r) const {\n        return this->second < r.second;\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 116,
        "type": "empty_function",
        "content": ": ti_t(boost::make_counting_iterator(n), gen) { }",
        "context": "\n\n    generator_iterator(int n, Generator gen)\n            : ti_t(boost::make_counting_iterator(n), gen) { }\n    generator_iterator(int n)\n            : ti_t(boost::make_counting_iterator(n)) { }\n\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 118,
        "type": "empty_function",
        "content": ": ti_t(boost::make_counting_iterator(n)) { }",
        "context": "    generator_iterator(int n, Generator gen)\n            : ti_t(boost::make_counting_iterator(n), gen) { }\n    generator_iterator(int n)\n            : ti_t(boost::make_counting_iterator(n)) { }\n\n    typename ti_t::reference dereference() const {\n        return ti_t::functor()();\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 140,
        "type": "empty_function",
        "content": "transform_output_iterator(It it, F f) : _it(it), _f(f) { }",
        "context": "struct transform_output_iterator :\n            boost::output_iterator_helper<transform_output_iterator<It, F> > {\n\n    transform_output_iterator(It it, F f) : _it(it), _f(f) { }\n\n    template<typename T>\n    transform_output_iterator& operator=(const T& t) {\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 164,
        "type": "empty_function",
        "content": "push_output_iterator(Container& c) : _c(c) { }",
        "context": "struct push_output_iterator :\n            boost::output_iterator_helper<push_output_iterator<Container> > {\npublic:\n    push_output_iterator(Container& c) : _c(c) { }\n\n    template<typename T>\n    push_output_iterator& operator=(const T& t) {\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 184,
        "type": "empty_function",
        "content": "insert_output_iterator(Container& c) : _c(c) { }",
        "context": "struct insert_output_iterator :\n            boost::output_iterator_helper<insert_output_iterator<Container> > {\npublic:\n    insert_output_iterator(Container& c) : _c(c) { }\n\n    template<typename T>\n    insert_output_iterator& operator=(const T& t) {\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 207,
        "type": "empty_function",
        "content": "const_function(const T& t) : _t(t) { }",
        "context": "//! 0-ary function that returns t\ntemplate<typename T>\nstruct const_function {\n    const_function(const T& t) : _t(t) { }\n    typedef T result_type;\n\n    T operator()() const {\n"
      },
      {
        "file": "cogutil/opencog/util/functional.h",
        "line": 247,
        "type": "empty_function",
        "content": "toFunc(const M& _m) : m(_m) {}",
        "context": "struct toFunc {\n    typedef typename M::argument_type argument_type;\n    typedef typename M::argument_type result_type;\n    toFunc(const M& _m) : m(_m) {}\n    typename M::argument_type operator()(const argument_type& x) const {\n        result_type tmp(x);\n        m(tmp);\n"
      },
      {
        "file": "cogutil/opencog/util/hashing.h",
        "line": 50,
        "type": "empty_function",
        "content": "deref_hash(const Hash& h = Hash()) : hash(h) {}",
        "context": "template < typename T,\ntypename Hash = boost::hash<T> >\nstruct deref_hash {\n    deref_hash(const Hash& h = Hash()) : hash(h) {}\n    size_t operator()(const T& t) const {\n        return hash(*t);\n    }\n"
      },
      {
        "file": "cogutil/opencog/util/hashing.h",
        "line": 60,
        "type": "empty_function",
        "content": "deref_equals(const Equals& e = Equals()) : equals(e) {}",
        "context": "template < typename T,\ntypename Equals = std::equal_to<T> >\nstruct deref_equals {\n    deref_equals(const Equals& e = Equals()) : equals(e) {}\n    bool operator()(const T& x, const T& y) const {\n        return equals(*x, *y);\n    }\n"
      },
      {
        "file": "cogutil/opencog/util/lazy_normal_selector.h",
        "line": 40,
        "type": "empty_function",
        "content": "lazy_selector(n), _mean(mean), _stddev(stddev), _rng(std::random_device{}()) {",
        "context": "//! around the given mean with the given standard deviation\nstruct lazy_normal_selector : public lazy_selector {\n    lazy_normal_selector(unsigned int n, unsigned int mean = 0, unsigned int stddev = 1) :\n        lazy_selector(n), _mean(mean), _stddev(stddev), _rng(std::random_device{}()) {\n        OC_ASSERT(mean < n, \"Mean must be less than n\");\n        OC_ASSERT(stddev > 0, \"Standard deviation must be positive\");\n    }\n"
      },
      {
        "file": "cogutil/opencog/util/lazy_random_selector.cc",
        "line": 30,
        "type": "empty_function",
        "content": ": lazy_selector(u), rng(_rng) {}",
        "context": "\nlazy_random_selector::lazy_random_selector(unsigned int u,\n                                           opencog::RandGen& _rng)\n    : lazy_selector(u), rng(_rng) {}\n\nlazy_random_selector::lazy_random_selector(unsigned int u, unsigned int l,\n                                           opencog::RandGen& _rng)\n"
      },
      {
        "file": "cogutil/opencog/util/lazy_random_selector.cc",
        "line": 34,
        "type": "empty_function",
        "content": ": lazy_selector(u, l), rng(_rng) {}",
        "context": "\nlazy_random_selector::lazy_random_selector(unsigned int u, unsigned int l,\n                                           opencog::RandGen& _rng)\n    : lazy_selector(u, l), rng(_rng) {}\n\nunsigned int lazy_random_selector::select()\n{\n"
      },
      {
        "file": "cogutil/opencog/util/lazy_selector.h",
        "line": 46,
        "type": "empty_function",
        "content": "virtual ~lazy_selector() {}",
        "context": "{\t\npublic:\n    lazy_selector(unsigned int u, unsigned int l = 0);\n    virtual ~lazy_selector() {}\n    bool empty() const;\n\n    //! returns the number of elements < _n that can still be chosen\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 79,
        "type": "empty_function",
        "content": ": inf_cache_base(name), _n(n) {}",
        "context": "struct cache_base : public inf_cache_base\n{\n    cache_base(size_type n, const std::string& name)\n        : inf_cache_base(name), _n(n) {}\n\n    ~cache_base() {}\n\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 81,
        "type": "empty_function",
        "content": "~cache_base() {}",
        "context": "    cache_base(size_type n, const std::string& name)\n        : inf_cache_base(name), _n(n) {}\n\n    ~cache_base() {}\n\n    size_type max_size() const { return _n; }\n\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 106,
        "type": "empty_function",
        "content": ": F(f), cache_base(n, name), _fu(f), _map(n+1) {}",
        "context": "    typedef typename map::iterator map_iter;\n\n    lru_cache(size_type n, const F& f=F(), const std::string name = \"lru_cache\")\n        : F(f), cache_base(n, name), _fu(f), _map(n+1) {}\n\n    inline bool full() const { return _map.size()==_n; }\n    inline bool empty() const { return _map.empty(); }\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 239,
        "type": "empty_function",
        "content": ": super(n, f, name) {}",
        "context": "\n    lru_cache_threaded(size_type n, const F& f=F(),\n                       const std::string name = \"lru_cache_threaded\")\n        : super(n, f, name) {}\n\n    inline bool full() const {\n        shared_lock lock(mutex);\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 366,
        "type": "empty_function",
        "content": ": F(f), cache_base(n, name), _fu(f), _map(n+1) {}",
        "context": "    typedef typename map::iterator map_iter;\n\n    prr_cache(size_type n, const F& f=F(), const std::string name = \"prr_cache\")\n        : F(f), cache_base(n, name), _fu(f), _map(n+1) {}\n\n    bool full() const { return _map.size() == _n; }\n    bool empty() const { return _map.empty(); }\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 441,
        "type": "empty_function",
        "content": ": super(n, f, name) {}",
        "context": "\n    prr_cache_threaded(size_type n, const F& f=F(),\n                       const std::string name = \"prr_cache_threaded\")\n        : super(n, f, name) {}\n\n    bool full() const\n    {\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 527,
        "type": "empty_function",
        "content": ": F(f), inf_cache_base(name) {}",
        "context": "    typedef std::unique_lock<cache_mutex> unique_lock;\n\n    inf_cache(const F& f=F(), const std::string name = \"inf_cache\")\n        : F(f), inf_cache_base(name) {}\n\n    result_type operator()(const argument_type& x) const {\n        // hit?\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 578,
        "type": "empty_function",
        "content": "_ulimit(ulimit), _ufrac(ufrac) {}",
        "context": "                   float ulimit = 0.90, float ufrac = 2)\n        : _cache(cache), _counter(0), _ncycles(ncycles),\n          _llimit(llimit), _lfact(lfact),\n          _ulimit(ulimit), _ufrac(ufrac) {}\n\n    result_type operator()(const argument_type& x) const {\n\n"
      },
      {
        "file": "cogutil/opencog/util/lru_cache.h",
        "line": 632,
        "type": "empty_function",
        "content": "lru_cache_arg_result(size_type n) : _n(n), _map(n+1) { }",
        "context": "    typedef typename map::iterator map_iter;\n    typedef typename map::size_type size_type;\n\n    lru_cache_arg_result(size_type n) : _n(n), _map(n+1) { }\n\n    inline bool full() const { return _map.size()==_n; }\n    inline bool empty() const { return _map.empty(); }\n"
      },
      {
        "file": "cogutil/opencog/util/platform.h",
        "line": 50,
        "type": "empty_function",
        "content": "struct timezone {};",
        "context": "\n#define M_PI 3.14159265358979323846\n\nstruct timezone {};\n\nint                round(float x);\nchar*              __strtok_r(char *s1, const char *s2, char **lasts);\n"
      },
      {
        "file": "cogutil/opencog/util/recent_val.h",
        "line": 45,
        "type": "empty_function",
        "content": "recent_val(ValueType x): val(x), recent((float)x), decay(0.5f) {}",
        "context": "    float decay;\n\n\t//! constructor with initial value\n    recent_val(ValueType x): val(x), recent((float)x), decay(0.5f) {}\n\t//! constructor with 0 as initial value\n    recent_val(): val(0), recent(0.0f), decay(0.5f) {}\n\t\n"
      },
      {
        "file": "cogutil/opencog/util/recent_val.h",
        "line": 47,
        "type": "empty_function",
        "content": "recent_val(): val(0), recent(0.0f), decay(0.5f) {}",
        "context": "\t//! constructor with initial value\n    recent_val(ValueType x): val(x), recent((float)x), decay(0.5f) {}\n\t//! constructor with 0 as initial value\n    recent_val(): val(0), recent(0.0f), decay(0.5f) {}\n\t\n\t//! update the current value and the decaying record\n    /**\n"
      },
      {
        "file": "cogutil/opencog/util/sigslot.h",
        "line": 63,
        "type": "empty_function",
        "content": "SigSlot() : _slot_id(0) {}",
        "context": "\t\tmutable int _slot_id;\n\n\tpublic:\n\t\tSigSlot() : _slot_id(0) {}\n\n\t\t// Connect using std::function.\n\t\tint connect(std::function<void(ARGS...)> const& fn)\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 561,
        "type": "empty_function",
        "content": "compare_nodes(StrictWeakOrdering comp) : comp_(comp) {};",
        "context": "    template<class StrictWeakOrdering>\n    class compare_nodes {\n    public:\n        compare_nodes(StrictWeakOrdering comp) : comp_(comp) {};\n\n        bool operator()(const tree_node *a, const tree_node *b) const\n        {\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 573,
        "type": "empty_function",
        "content": "compare_nodes_pre_it(StrictWeakOrdering comp) : comp_(comp) {};",
        "context": "    template<class StrictWeakOrdering>\n    class compare_nodes_pre_it {\n    public:\n        compare_nodes_pre_it(StrictWeakOrdering comp) : comp_(comp) {};\n\n        bool operator()(const tree_node *a, const tree_node *b) const\n        {\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 2864,
        "type": "empty_function",
        "content": ": iterator_base(),parent_(0) {  }",
        "context": "\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator()\n    : iterator_base(),parent_(0) {  }\n\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(tree_node *tn)\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 2868,
        "type": "empty_function",
        "content": ": iterator_base(tn),parent_(tn==0 ? 0 : tn->parent) { }",
        "context": "\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(tree_node *tn)\n    : iterator_base(tn),parent_(tn==0 ? 0 : tn->parent) { }\n\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const iterator_base& other)\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 2872,
        "type": "empty_function",
        "content": ": iterator_base(other.node),parent_(other.node==0 ? 0 : other.node->parent) { }",
        "context": "\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const iterator_base& other)\n    : iterator_base(other.node),parent_(other.node==0 ? 0 : other.node->parent) { }\n\ntemplate <class T, class tree_node_allocator>\ntree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const sibling_iterator& other)\n"
      },
      {
        "file": "cogutil/opencog/util/tree.h",
        "line": 3203,
        "type": "empty_function",
        "content": "lexicographic_subtree_order() {}",
        "context": "// This can be changed if it's important...\ntemplate<typename T, typename compare=std::less<T>>\nstruct lexicographic_subtree_order {\n    lexicographic_subtree_order() {}\n\n    template<typename iter>\n    bool operator()(const tree<T>& tr1, const iter& it2) const {\n"
      },
      {
        "file": "cogutil/opencog/util/zipf.h",
        "line": 90,
        "type": "empty_function",
        "content": "void reset() {}",
        "context": "\t\t\tif (-0.5 >= q)\n\t\t\t\tthrow std::runtime_error(\"Range error: Parameter q must be greater than -0.5!\");\n\t\t}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n"
      },
      {
        "file": "cogutil/opencog/util/zipf.h",
        "line": 232,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t\t_s(s),\n\t\t\t_q(q),\n\t\t\t_dist(_pdf.begin(), _pdf.end())\n\t\t{}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n"
      },
      {
        "file": "cogutil/opencog/util/zipf.h",
        "line": 233,
        "type": "empty_function",
        "content": "void reset() {}",
        "context": "\t\t\t_q(q),\n\t\t\t_dist(_pdf.begin(), _pdf.end())\n\t\t{}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n"
      },
      {
        "file": "cogutil/opencog/util/boost_ext/accumulators/statistics/geometric_mean.h",
        "line": 102,
        "type": "empty_function",
        "content": "extractor<tag::geometric_mean> const geometric_mean = {};",
        "context": "//\nnamespace extract\n{\n    extractor<tag::geometric_mean> const geometric_mean = {};\n\n    BOOST_ACCUMULATORS_IGNORE_GLOBAL(geometric_mean)\n}\n"
      },
      {
        "file": "cogutil/opencog/util/boost_ext/accumulators/statistics/geometric_mean_mirror.h",
        "line": 104,
        "type": "empty_function",
        "content": "extractor<tag::geometric_mean_mirror> const geometric_mean_mirror = {};",
        "context": "//\nnamespace extract\n{\n    extractor<tag::geometric_mean_mirror> const geometric_mean_mirror = {};\n\n    BOOST_ACCUMULATORS_IGNORE_GLOBAL(geometric_mean_mirror)\n}\n"
      },
      {
        "file": "cogutil/scripts/util/sort-log.py",
        "line": 129,
        "type": "empty_function",
        "content": "key2txt = {}",
        "context": "    #    - ln is the line number of the first line of the message\n    # \n    # 2. Map thread to its first line number\n    key2txt = {}\n    tln, dt, ln = None, None, None\n    line_num = 0\n    t2ln = {}\n"
      },
      {
        "file": "cogutil/scripts/util/sort-log.py",
        "line": 132,
        "type": "empty_function",
        "content": "t2ln = {}",
        "context": "    key2txt = {}\n    tln, dt, ln = None, None, None\n    line_num = 0\n    t2ln = {}\n    for l in open(args.logfile):\n        # Parse timestamp, thread and fill the key2txt entry\n        timestamp_m = timestamp_prog.match(l)\n"
      },
      {
        "file": "components/core/atomspace-restful/opencog/events/AtomSpacePublisherModule.h",
        "line": 68,
        "type": "empty_function",
        "content": "lambda_task(const F& f) : my_func(f) {}",
        "context": "        return NULL;\n    }\npublic:\n    lambda_task(const F& f) : my_func(f) {}\n};\n\ntemplate<typename F>\n"
      },
      {
        "file": "components/core/atomspace-restful/opencog/python/web/api/apighost.py",
        "line": 28,
        "type": "empty_function",
        "content": "action = \"(test-ghost \\\"{}\\\")\".format(query)",
        "context": "        if 'query' in data:\n            query = data['query']\n            print(query)\n            action = \"(test-ghost \\\"{}\\\")\".format(query)\n            scheme_eval(self.atomspace, action)\n            response = scheme_eval(self.atomspace, '(get-result)')\n            print(response)\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 147,
        "type": "empty_function",
        "content": "{}",
        "context": "\tpublic:\n\t\tMonoStorageNode(Type t, const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n\t\tMonoStorageNode(const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
        "line": 150,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t{}\n\t\tMonoStorageNode(const std::string&& uri) :\n\t\t\tMonoStorage(std::move(uri))\n\t\t{}\n\n\t\tvoid setAtomSpace(AtomSpace* as)\n\t\t{\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 180,
        "type": "empty_function",
        "content": "{}",
        "context": "\tpublic:\n\t\tRocksStorageNode(Type t, const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n\t\tRocksStorageNode(const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
        "line": 183,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t{}\n\t\tRocksStorageNode(const std::string&& uri) :\n\t\t\tRocksStorage(std::move(uri))\n\t\t{}\n\n\t\tvoid setAtomSpace(AtomSpace* as)\n\t\t{\n"
      },
      {
        "file": "components/integration/opencog/opencog/ghost/cs-parse.scm",
        "line": 259,
        "type": "empty_function",
        "content": "; LBRACE RBRACE = Braces {}",
        "context": "    ; NOTE\n    ; LSBRACKET RSBRACKET = Square Brackets []\n    ; LPAREN RPAREN = parentheses ()\n    ; LBRACE RBRACE = Braces {}\n    ; DQUOTE = Double quote \"\n    ; ID = Identifier or Marking\n    ; DICTKEY = Dictionary Keyword Sets\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot-old/question/WordRelQuery.cc",
        "line": 67,
        "type": "empty_function",
        "content": "static inline void prt(Atom *atom) {}",
        "context": "   printf (\"%s\\n\", str.c_str());\n}\n#else\nstatic inline void prt(Atom *atom) {}\n#endif\n#ifdef DEBUG\n   #define dbgprt(f, varargs...) printf(f, ##varargs)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/telegram_bot.py",
        "line": 49,
        "type": "empty_function",
        "content": "print (\"Ok, we got message {}\".format(update.message.text))",
        "context": "\ndef echo(bot, update):\n    \"\"\"Echo the user message.\"\"\"\n    print (\"Ok, we got message {}\".format(update.message.text))\n    reply = scheme_eval(atomspace, '(process-query \"{}\" \"{}\")'.format(update.message.from_user.first_name, update.message.text))\n    print (\"And now we have a reply {}\".format(reply))\n    reply_decoded = reply.decode(\"utf-8\")\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/telegram_bot.py",
        "line": 50,
        "type": "empty_function",
        "content": "reply = scheme_eval(atomspace, '(process-query \"{}\" \"{}\")'.format(update.message.from_user.first_name, update.message.text))",
        "context": "def echo(bot, update):\n    \"\"\"Echo the user message.\"\"\"\n    print (\"Ok, we got message {}\".format(update.message.text))\n    reply = scheme_eval(atomspace, '(process-query \"{}\" \"{}\")'.format(update.message.from_user.first_name, update.message.text))\n    print (\"And now we have a reply {}\".format(reply))\n    reply_decoded = reply.decode(\"utf-8\")\n    print (\"Decoding the reply: {}\".format(reply_decoded))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/telegram_bot.py",
        "line": 51,
        "type": "empty_function",
        "content": "print (\"And now we have a reply {}\".format(reply))",
        "context": "    \"\"\"Echo the user message.\"\"\"\n    print (\"Ok, we got message {}\".format(update.message.text))\n    reply = scheme_eval(atomspace, '(process-query \"{}\" \"{}\")'.format(update.message.from_user.first_name, update.message.text))\n    print (\"And now we have a reply {}\".format(reply))\n    reply_decoded = reply.decode(\"utf-8\")\n    print (\"Decoding the reply: {}\".format(reply_decoded))\n    bot.send_message(chat_id=update.message.chat_id, text=reply_decoded)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/chatbot/telegram_bot.py",
        "line": 53,
        "type": "empty_function",
        "content": "print (\"Decoding the reply: {}\".format(reply_decoded))",
        "context": "    reply = scheme_eval(atomspace, '(process-query \"{}\" \"{}\")'.format(update.message.from_user.first_name, update.message.text))\n    print (\"And now we have a reply {}\".format(reply))\n    reply_decoded = reply.decode(\"utf-8\")\n    print (\"Decoding the reply: {}\".format(reply_decoded))\n    bot.send_message(chat_id=update.message.chat_id, text=reply_decoded)\n\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatch.h",
        "line": 81,
        "type": "empty_function",
        "content": "virtual ~FuzzyMatch() {}",
        "context": "{\npublic:\n    RankedHandleSeq perform_search(const Handle&);\n    virtual ~FuzzyMatch() {}\n\nprotected:\n    virtual void start_search(const Handle&) = 0;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/irc/IRC.cc",
        "line": 54,
        "type": "empty_function",
        "content": "{}",
        "context": "    datain(nullptr),\n    chan_users(nullptr),\n    hooks(nullptr)\n{}\n\nIRC::~IRC()\n{\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/scm/oc/processing-utils.scm",
        "line": 249,
        "type": "empty_function",
        "content": "(let* ((cmd (string-append \"find \" path \" -type f -exec cat {} \\\\;\"))",
        "context": "  Example usage:\n      (parse-all nlp-parse \\\"/home/test/articles\\\")\n\"\n    (let* ((cmd (string-append \"find \" path \" -type f -exec cat {} \\\\;\"))\n           (port (open-input-pipe cmd))\n           (line (get-line port))\n           (cnt 0))\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/sentiment/basic_sentiment_analysis.py",
        "line": 61,
        "type": "empty_function",
        "content": "self.dictionary = {}",
        "context": "        files = [open(path, 'r') for path in dictionary_paths]\n        dictionaries = [yaml.safe_load(dict_file) for dict_file in files]\n        map(lambda x: x.close(), files)\n        self.dictionary = {}\n        self.max_key_size = 0\n        for curr_dict in dictionaries:\n            for key in curr_dict:\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd/SenseSimilarity.h",
        "line": 20,
        "type": "empty_function",
        "content": "SenseSimilarity(void) {};",
        "context": "class SenseSimilarity\n{\n\tpublic:\n\t\tSenseSimilarity(void) {};\n\t\tvirtual ~SenseSimilarity() {};\n\n\t\tvirtual SimpleTruthValuePtr similarity(const Handle&, const Handle&) = 0;\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/wsd/SenseSimilarity.h",
        "line": 21,
        "type": "empty_function",
        "content": "virtual ~SenseSimilarity() {};",
        "context": "{\n\tpublic:\n\t\tSenseSimilarity(void) {};\n\t\tvirtual ~SenseSimilarity() {};\n\n\t\tvirtual SimpleTruthValuePtr similarity(const Handle&, const Handle&) = 0;\n};\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 91,
        "type": "empty_function",
        "content": "_category_index[new_category] = {};",
        "context": "  // _psi_category is a null pointer; its never set.\n  // _as->add_link(INHERITANCE_LINK, new_category, _psi_category);\n  if(not(_category_index.count(new_category))) {\n    _category_index[new_category] = {};\n  }\n\n  return new_category;\n"
      },
      {
        "file": "components/language/learn/scm/attic/mst-parse/mst-parser.scm",
        "line": 107,
        "type": "empty_function",
        "content": "(define infix \"-\u2010\u2011\u2012\u2013\u2014\u2015\u2026()[]{}\")",
        "context": "\t; Hey, the long-dashes below all look alike, but are actually\n\t; different. Same for the short dashes. The first dash is the\n\t; ascii-dash 0x2d. The rest are UTF-8 multi-byte encodings.\n\t(define infix \"-\u2010\u2011\u2012\u2013\u2014\u2015\u2026()[]{}\")\n\t(define prefix-list (string->list prefix))\n\t(define suffix-list (string->list suffix))\n\t(define infix-list (string->list infix))\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictNode.cc",
        "line": 135,
        "type": "empty_function",
        "content": "void opencog_nlp_lgparse_init(void) {}",
        "context": "\t// Module initialization function for Guile FFI\n\t// Empty because initialization is handled by C++ constructors\n\t// and the LGDictNode factory registration\n\tvoid opencog_nlp_lgparse_init(void) {}\n};\n"
      },
      {
        "file": "components/learning/moses/examples/example-ant/ant_scoring.cc",
        "line": 32,
        "type": "empty_function",
        "content": ": _steps(steps) {}",
        "context": "////////////////////////\n\nAntFitnessFunction::AntFitnessFunction(int steps)\n    : _steps(steps) {}\n\nvoid AntFitnessFunction::turn_left(Direction& d) {\n    d = (Direction)(((int)d + 3) % 4);\n"
      },
      {
        "file": "components/learning/moses/examples/example-ant/ant_scoring.cc",
        "line": 167,
        "type": "empty_function",
        "content": ": AntFitnessFunction(steps), _noise(noise) {}",
        "context": "/////////////////////////\n\nAntFitnessEstimator::AntFitnessEstimator(int steps, int noise)\n    : AntFitnessFunction(steps), _noise(noise) {}\nscore_t AntFitnessEstimator::operator()(const combo_tree& tr) const\n{\n    int error = opencog::randGen().randint(_noise + 1) - _noise / 2;\n"
      },
      {
        "file": "components/learning/moses/examples/example-ant/ant_scoring.h",
        "line": 116,
        "type": "empty_function",
        "content": "ant_bscore() {}",
        "context": "\nstruct ant_bscore : public bscore_base\n{\n    ant_bscore() {}\n\n    behavioral_score operator()(const combo_tree& tr) const;\n\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/pole_balancing.h",
        "line": 11,
        "type": "empty_function",
        "content": "virtual ~CartPole() {}",
        "context": "class CartPole {\npublic:\n    CartPole(bool randomize,bool velocity);\n    virtual ~CartPole() {}\n    virtual void simplifyTask();  \n    virtual void nextTask();\n    virtual double evalNet(combo::ann *net);\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_functions.h",
        "line": 84,
        "type": "empty_function",
        "content": "n_max(const field_set& fs) : fields(fs) {}",
        "context": "// settings in the instance.\nstruct n_max\n{\n    n_max(const field_set& fs) : fields(fs) {}\n    int operator()(const instance& inst) const\n    {\n        return accumulate(fields.begin_disc(inst), fields.end_disc(inst), 0);\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_functions.h",
        "line": 96,
        "type": "empty_function",
        "content": "contin_max(const field_set& fs) : fields(fs) {}",
        "context": "// in the instance.\nstruct contin_max\n{\n    contin_max(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const\n    {\n        return accumulate(fields.begin_contin(inst), fields.end_contin(inst),\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_functions.h",
        "line": 144,
        "type": "empty_function",
        "content": "sphere(const field_set& fs) : fields(fs) {}",
        "context": "//\nstruct sphere\n{\n    sphere(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const {\n        contin_t res = 0;\n        for (field_set::const_contin_iterator it = fields.begin_contin(inst);\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_functions.h",
        "line": 168,
        "type": "empty_function",
        "content": "termmax(const field_set& fs) : fields(fs) {}",
        "context": "// adds them together.  The sum of all of these is the returned score.\nstruct termmax\n{\n    termmax(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const\n    {\n        contin_t res = 0;\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_iterators.h",
        "line": 75,
        "type": "empty_function",
        "content": "multiplex(unsigned int n) : arity(n) { }",
        "context": "// is the address of the string bit described by a1, ..., an.\nstruct multiplex  : public iterator_function<bool>\n{\n    multiplex(unsigned int n) : arity(n) { }\n    unsigned int arity;\n    // [from, to( corresponds to the sequence of inputs of the\n    // function, the result corresponds to its output\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_iterators.h",
        "line": 94,
        "type": "empty_function",
        "content": "majority(unsigned int n) : arity(n) { }",
        "context": "// majority(x1, ..., xn) = 0 iff n/2 or more arguments are false\nstruct majority : public iterator_function<bool>\n{\n    majority(unsigned int n) : arity(n) { }\n    unsigned int arity;\n    // [from, to( corresponds to the sequence of inputs of the\n    // function, the result corresponds to its output\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/scoring_iterators.h",
        "line": 112,
        "type": "empty_function",
        "content": "simple_symbolic_regression(int o = 4) : order(o) { }",
        "context": "// f(x)_0 = 0\nstruct simple_symbolic_regression : public iterator_function<contin_t>\n{\n    simple_symbolic_regression(int o = 4) : order(o) { }\n    int order;\n    template<typename It>\n    contin_t operator()(It from, It to) const {\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-bit.cc",
        "line": 89,
        "type": "empty_function",
        "content": "trap(int n, int len) : trapsz(n), rounds(len) {}",
        "context": "\nstruct trap\n{\n    trap(int n, int len) : trapsz(n), rounds(len) {}\n\n    int vee(int x) const\n    {\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/trap-uni.cc",
        "line": 83,
        "type": "empty_function",
        "content": "trap(const field_set& fs, int n) : fields(fs), max(n-1) {}",
        "context": "\nstruct trap\n{\n    trap(const field_set& fs, int n) : fields(fs), max(n-1) {}\n\n    int vee(int x) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/ant_combo_vocabulary/ant_action_symbol.cc",
        "line": 31,
        "type": "empty_function",
        "content": "ant_action_symbol::ant_action_symbol() { }",
        "context": "\nusing namespace ant_action_symbol_properties;\n\nant_action_symbol::ant_action_symbol() { }\n\nconst action_symbol_basic_description* ant_action_symbol::get_basic_description_array() const {\n  return asbd;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/ant_combo_vocabulary/ant_indefinite_object.cc",
        "line": 31,
        "type": "empty_function",
        "content": "ant_indefinite_object::ant_indefinite_object() { }",
        "context": "\nusing namespace ant_indefinite_object_properties;\n\nant_indefinite_object::ant_indefinite_object() { }\n\nconst indefinite_object_basic_description* ant_indefinite_object::get_basic_description_array() const {\n  return iobd;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/action_symbol.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~action_symbol_base() {}",
        "context": "//without additional properties\nclass action_symbol_base : public operator_base {\npublic:\n    virtual ~action_symbol_base() {}\n\n    static const action_symbol_base* get_instance(const std::string& name) {\n         return NULL;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/ann.h",
        "line": 38,
        "type": "empty_function",
        "content": "ann_type(unsigned int i, ann_id _id) : idx(i), id(_id) {}",
        "context": "\nclass ann_type {\npublic:\n    ann_type(unsigned int i, ann_id _id) : idx(i), id(_id) {}\n    unsigned int idx;\n    ann_id id;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/builtin_action.h",
        "line": 61,
        "type": "empty_function",
        "content": "virtual ~builtin_action_base() {}",
        "context": "\nclass builtin_action_base : public operator_base {\npublic:\n    virtual ~builtin_action_base() {}\n\n    static const builtin_action_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/convert_ann_combo.h",
        "line": 37,
        "type": "empty_function",
        "content": "tree_transform() {}",
        "context": " */\nstruct tree_transform {\n\n    tree_transform() {}\n\n    combo_tree encode_node(ann& the_ann, ann_node* node) const {\n        int tag = node->tag;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/indefinite_object.h",
        "line": 38,
        "type": "empty_function",
        "content": "virtual ~indefinite_object_base() {}",
        "context": "//without additional properties\nclass indefinite_object_base : public operator_base {\npublic:\n    virtual ~indefinite_object_base() {}\n\n    static const indefinite_object_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/operator_base.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~operator_base() {}",
        "context": "  //of builtin_action_base and perception_base\n  class operator_base {\n  public:\n    virtual ~operator_base() {}\n\n    //get_name\n    virtual const std::string& get_name() const = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/perception.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual ~perception_base() {}",
        "context": "\nclass perception_base : public operator_base {\npublic:\n    virtual ~perception_base() {}\n\n    static const perception_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/procedure_call.cc",
        "line": 48,
        "type": "empty_function",
        "content": "procedure_call_base::~procedure_call_base() {}",
        "context": "    }\n}\n\nprocedure_call_base::~procedure_call_base() {}\n\n//get_name\nconst std::string& procedure_call_base::get_name() const\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/similarity.cc",
        "line": 218,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t\tbcnt = bv.at(pr.first);\n\t\t}\n\t\tcatch (const std::out_of_range& oor)\n\t\t{}\n\n\t\tdist += fabs(acnt - bcnt);\n\t}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/simple_nn.h",
        "line": 67,
        "type": "empty_function",
        "content": "source(s), dest(d), weight(w) { }",
        "context": "{\npublic:\n    ann_connection(ann_node* s, ann_node* d, double w):\n            source(s), dest(d), weight(w) { }\n    ann_node* source;\n    ann_node* dest;\n    double weight;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/simple_nn.h",
        "line": 85,
        "type": "empty_function",
        "content": ": visited(false), memory_ptr(_ptr), activation(0.0), tag(_tag), nodetype(type) {}",
        "context": "{\npublic:\n    ann_node(ann_nodetype type, int _tag = 0, ann_node* _ptr=NULL)\n        : visited(false), memory_ptr(_ptr), activation(0.0), tag(_tag), nodetype(type) {}\n\n    bool visited; //used for constructing combotrees\n    int counter; //used for determining network depth\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/simple_nn.h",
        "line": 158,
        "type": "empty_function",
        "content": "ann() {}",
        "context": "    //a list of all the connections\n    std::vector<ann_connection*> connections;\n\n    ann() {}\n\n    ~ann() {\n        ann_node_it iter;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 821,
        "type": "empty_function",
        "content": "hsh ^= std::hash<opencog::combo::vertex>{}(v)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (const opencog::combo::vertex& v: tre)\n\t\t\t\thsh ^= std::hash<opencog::combo::vertex>{}(v)\n\t\t\t\t       + 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/crutil/exception.cc",
        "line": 29,
        "type": "empty_function",
        "content": ": _message(m) {}",
        "context": "namespace opencog { namespace combo {\n\nComboReductException::ComboReductException(std::string m)\n  : _message(m) {}\n\nstd::string ComboReductException::get_message() const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/crutil/exception.cc",
        "line": 37,
        "type": "empty_function",
        "content": ": ComboReductException(\"Overflow Exception\"), _vertex(v) {}",
        "context": "}\n\nOverflowException::OverflowException(vertex v)\n    : ComboReductException(\"Overflow Exception\"), _vertex(v) {}\n\nvertex OverflowException::get_vertex() const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/crutil/exception.cc",
        "line": 45,
        "type": "empty_function",
        "content": ": ComboReductException(m), _vertex(v) {}",
        "context": "}\n\nEvalException::EvalException(vertex v, std::string m)\n    : ComboReductException(m), _vertex(v) {}\n\nvertex EvalException::get_vertex() const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/crutil/exception.cc",
        "line": 53,
        "type": "empty_function",
        "content": ": ComboReductException(\"Type check Exception\"), _arg(arg) {}",
        "context": "}\n\nTypeCheckException::TypeCheckException(int arg)\n    : ComboReductException(\"Type check Exception\"), _arg(arg) {} \n\n}} // ~namespaces combo opencog\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 38,
        "type": "empty_function",
        "content": ": boolean_inputs(inputs) {}",
        "context": "/////////////////////////\n\nboolean_interpreter::boolean_interpreter(const std::vector<builtin>& inputs)\n    : boolean_inputs(inputs) {}\n\nbuiltin boolean_interpreter::operator()(const combo_tree& tr) const {\n    return boolean_eval(tr.begin());\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 109,
        "type": "empty_function",
        "content": ": contin_inputs(inputs) {}",
        "context": "////////////////////////\n\ncontin_interpreter::contin_interpreter(const std::vector<contin_t>& inputs)\n    : contin_inputs(inputs) {}\n\ncontin_t contin_interpreter::operator()(const combo_tree& tr) const {\n    return contin_eval(tr.begin());\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 231,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(false),\n    _use_contin_inputs(false),\n    _mixed_inputs(inputs)\n{}\n\nmixed_interpreter::mixed_interpreter(const std::vector<contin_t>& inputs) :\n    contin_interpreter(inputs),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 238,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(false),\n    _use_contin_inputs(true),\n    _mixed_inputs(empty_vertex_seq)\n{}\n\nmixed_interpreter::mixed_interpreter(const std::vector<builtin>& inputs) :\n    boolean_interpreter(inputs),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 245,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(true),\n    _use_contin_inputs(false),\n    _mixed_inputs(empty_vertex_seq)\n{}\n\nvertex mixed_interpreter::operator()(const combo_tree& tr) const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 60,
        "type": "empty_function",
        "content": "crule<reduce_action_if>::crule(\"reduce_action_if\") {}",
        "context": "//action_boolean_if(C A A) -> A\nstruct reduce_action_if : public crule<reduce_action_if> {\n    reduce_action_if() : \n          crule<reduce_action_if>::crule(\"reduce_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 67,
        "type": "empty_function",
        "content": "crule<reduce_action_action_if>::crule(\"reduce_action_action_if\") {}",
        "context": "//action_action_if(A B B) -> and_seq(exec_seq(A) B)\nstruct reduce_action_action_if : public crule<reduce_action_action_if> {\n    reduce_action_action_if() : \n        crule<reduce_action_action_if>::crule(\"reduce_action_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 76,
        "type": "empty_function",
        "content": "crule<reduce_const_cond_action_if>::crule(\"reduce_const_cond_action_if\") {}",
        "context": "//with T in {action, boolean, contin}\nstruct reduce_const_cond_action_if: public crule<reduce_const_cond_action_if> {\n    reduce_const_cond_action_if() :\n        crule<reduce_const_cond_action_if>::crule(\"reduce_const_cond_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 84,
        "type": "empty_function",
        "content": "crule<reduce_not_cond_action_boolean_if>::crule(\"reduce_not_cond_action_boolean_if\") {}",
        "context": "struct reduce_not_cond_action_boolean_if:\n        public crule<reduce_not_cond_action_boolean_if> {\n    reduce_not_cond_action_boolean_if() :\n        crule<reduce_not_cond_action_boolean_if>::crule(\"reduce_not_cond_action_boolean_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 96,
        "type": "empty_function",
        "content": "crule<reduce_const_action_seq>::crule(\"reduce_const_action_seq\") {}",
        "context": "//exec_seq(A action_success C) -> exec_seq(A B)\nstruct reduce_const_action_seq : public crule<reduce_const_action_seq> {\n    reduce_const_action_seq () :\n        crule<reduce_const_action_seq>::crule(\"reduce_const_action_seq\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 105,
        "type": "empty_function",
        "content": "crule<reduce_empty_arg_seq>::crule(\"reduce_empty_arg_seq\") {}",
        "context": "//exec_seq() -> action_success\nstruct reduce_empty_arg_seq : public crule<reduce_empty_arg_seq> {\n    reduce_empty_arg_seq () :\n        crule<reduce_empty_arg_seq>::crule(\"reduce_empty_arg_seq\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 112,
        "type": "empty_function",
        "content": "crule<reduce_double_action_not>::crule(\"reduce_double_action_not\") {}",
        "context": "//action_not(action_not(A)) -> A\nstruct reduce_double_action_not : public crule<reduce_double_action_not> {\n    reduce_double_action_not () :\n        crule<reduce_double_action_not>::crule(\"reduce_double_action_not\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 120,
        "type": "empty_function",
        "content": "crule<reduce_repeat_out_action_while>::crule(\"reduce_repeat_out_action_while\") {}",
        "context": "//and_seq(A B action_while(B)) -> and_seq(A action_while(B))\nstruct reduce_repeat_out_action_while : public crule<reduce_repeat_out_action_while> {\n    reduce_repeat_out_action_while () :\n        crule<reduce_repeat_out_action_while>::crule(\"reduce_repeat_out_action_while\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 127,
        "type": "empty_function",
        "content": "reduce_repeat_in_action_while() : crule<reduce_repeat_in_action_while>::crule(\"reduce_repeat_in_action_while\") {}",
        "context": "//action_while(and_seq(A A)) -> action_while(A)\nstruct reduce_repeat_in_action_while : public\n            crule<reduce_repeat_in_action_while> {\n    reduce_repeat_in_action_while() : crule<reduce_repeat_in_action_while>::crule(\"reduce_repeat_in_action_while\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 137,
        "type": "empty_function",
        "content": "reduce_action_boolean_if_sub_cond() : crule<reduce_action_boolean_if_sub_cond>::crule(\"reduce_action_boolean_if_sub_cond\") {}",
        "context": "//action_boolean_if condition\nstruct reduce_action_boolean_if_sub_cond : public\n            crule<reduce_action_boolean_if_sub_cond> {\n    reduce_action_boolean_if_sub_cond() : crule<reduce_action_boolean_if_sub_cond>::crule(\"reduce_action_boolean_if_sub_cond\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 147,
        "type": "empty_function",
        "content": "reduce_boolean_while_sub_cond() : crule<reduce_boolean_while_sub_cond>::crule(\"reduce_boolean_while_sub_cond\") {}",
        "context": "//C within boolean_while condition.\nstruct reduce_boolean_while_sub_cond : public\n            crule<reduce_boolean_while_sub_cond> {\n    reduce_boolean_while_sub_cond() : crule<reduce_boolean_while_sub_cond>::crule(\"reduce_boolean_while_sub_cond\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 158,
        "type": "empty_function",
        "content": "reduce_action_action_if_always_succeeds() : crule<reduce_action_action_if_always_succeeds>::crule(\"reduce_action_action_if_always_succeeds\") {}",
        "context": "//action_action_if(A B C) -> and_seq(A B) iff get_action_result(A)==true\nstruct reduce_action_action_if_always_succeeds :\n            public crule<reduce_action_action_if_always_succeeds> {\n    reduce_action_action_if_always_succeeds() : crule<reduce_action_action_if_always_succeeds>::crule(\"reduce_action_action_if_always_succeeds\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 171,
        "type": "empty_function",
        "content": "reduce_action_while_always_fails() : crule<reduce_action_while_always_fails>::crule(\"reduce_action_while_always_fails\") {}",
        "context": "//action_while(A) -> A iff get_action_result(A)==false\nstruct reduce_action_while_always_fails :\n            public crule<reduce_action_while_always_fails> {\n    reduce_action_while_always_fails() : crule<reduce_action_while_always_fails>::crule(\"reduce_action_while_always_fails\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 179,
        "type": "empty_function",
        "content": "reduce_boolean_while_depend_condition() : crule<reduce_boolean_while_depend_condition>::crule(\"reduce_boolean_while_depend_condition\") {}",
        "context": "//boolean_while(C A) -> A iff eval(C)==true and get_action_result(A)==false\nstruct reduce_boolean_while_depend_condition :\n            public crule<reduce_boolean_while_depend_condition> {\n    reduce_boolean_while_depend_condition() : crule<reduce_boolean_while_depend_condition>::crule(\"reduce_boolean_while_depend_condition\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 188,
        "type": "empty_function",
        "content": "reduce_sequential_and_always_fails() : crule<reduce_sequential_and_always_fails>::crule(\"reduce_sequential_and_always_fails\") {}",
        "context": "//and get_action_result(An)==false\nstruct reduce_sequential_and_always_fails :\n            public crule<reduce_sequential_and_always_fails> {\n    reduce_sequential_and_always_fails() : crule<reduce_sequential_and_always_fails>::crule(\"reduce_sequential_and_always_fails\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 197,
        "type": "empty_function",
        "content": "reduce_sequential_or_always_succeeds() : crule<reduce_sequential_or_always_succeeds>::crule(\"reduce_sequential_or_always_succeeds\") {}",
        "context": "//and get_action_result(An)==true\nstruct reduce_sequential_or_always_succeeds :\n            public crule<reduce_sequential_or_always_succeeds> {\n    reduce_sequential_or_always_succeeds() : crule<reduce_sequential_or_always_succeeds>::crule(\"reduce_sequential_or_always_succeeds\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 207,
        "type": "empty_function",
        "content": "reduce_idempotent() : crule<reduce_idempotent>::crule(\"reduce_idempotent\") {}",
        "context": "\n//reduce 2 consecutive actions to 1 action\nstruct reduce_idempotent : public crule<reduce_idempotent> {\n    reduce_idempotent() : crule<reduce_idempotent>::crule(\"reduce_idempotent\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 214,
        "type": "empty_function",
        "content": "reduce_opposite() : crule<reduce_opposite>::crule(\"reduce_opposite\") {}",
        "context": "//reduce 2 consecutive opposite actions A1 A2\n//that is A1 is the reversal of A2\nstruct reduce_opposite : public crule<reduce_opposite> {\n    reduce_opposite() : crule<reduce_opposite>::crule(\"reduce_opposite\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 223,
        "type": "empty_function",
        "content": "reduce_additive() : crule<reduce_additive>::crule(\"reduce_additive\") {}",
        "context": "//are denoted additive by is_additive(action,int i);\n//the argument that are not denoted additive must be equal\nstruct reduce_additive : public crule<reduce_additive> {\n    reduce_additive() : crule<reduce_additive>::crule(\"reduce_additive\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 231,
        "type": "empty_function",
        "content": "reduce_zero_neutral() : crule<reduce_zero_neutral>::crule(\"reduce_zero_neutral\") {}",
        "context": "//replace action by action_success if exists 0 in one of its argument\n//neutral\nstruct reduce_zero_neutral : public crule<reduce_zero_neutral> {\n    reduce_zero_neutral() : crule<reduce_zero_neutral>::crule(\"reduce_zero_neutral\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 244,
        "type": "empty_function",
        "content": "reduce_modular_argument() : crule<reduce_modular_argument>::crule(\"reduce_modular_argument\") {}",
        "context": "//action_with_modular_argument(m) -> action_with_modular_argument(reduced(m))\n//for example, dummy_modular_action(6.28,-20)-> dummy_modular_action(0,-10)\nstruct reduce_modular_argument : public crule<reduce_modular_argument> {\n    reduce_modular_argument() : crule<reduce_modular_argument>::crule(\"reduce_modular_argument\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/action_rules.h",
        "line": 262,
        "type": "empty_function",
        "content": "preconditions_check() : crule<preconditions_check>::crule(\"preconditions_check\") {}",
        "context": "// and_seq(or_seq(grab bark) drop bark)-> and_seq(or_seq(grab bark) drop bark)\n// and_seq(or_seq(bark bark) drop bark)-> and_seq(or_seq(bark bark) action_success bark)\nstruct preconditions_check : public crule<preconditions_check> {\n    preconditions_check() : crule<preconditions_check>::crule(\"preconditions_check\") {}\n    void operator() (combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/ann_rules.h",
        "line": 42,
        "type": "empty_function",
        "content": "ann_rule() : crule<ann_rule>::crule(\"ann_rule\") {}",
        "context": "//ann reduction rule\n// WARNING: this rule should only be used alone, not combined with meta_rules\nstruct ann_rule : public crule<ann_rule> {\n    ann_rule() : crule<ann_rule>::crule(\"ann_rule\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const\n    {\n        tree_transform trans;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 40,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(igop) {}",
        "context": "    const vertex_set &ignore_ops;\n    reduce_cond_arg(int effort, const vertex_set &igop)\n        : crule<reduce_cond_arg>::crule(\"reduce_cond_arg\"),\n          reduct_effort(effort), ignore_ops(igop) {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n}; \n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 51,
        "type": "empty_function",
        "content": ": crule<reduce_cond_else>::crule(\"reduce_cond_else\") {}",
        "context": "struct reduce_cond_else : public crule<reduce_cond_else> \n{\n    reduce_cond_else() \n        : crule<reduce_cond_else>::crule(\"reduce_cond_else\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 61,
        "type": "empty_function",
        "content": ": crule<reduce_cond_adjacent>::crule(\"reduce_cond_adjacent\") {}",
        "context": "struct reduce_cond_adjacent : public crule<reduce_cond_adjacent> \n{\n    reduce_cond_adjacent() \n        : crule<reduce_cond_adjacent>::crule(\"reduce_cond_adjacent\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 85,
        "type": "empty_function",
        "content": ": crule<reduce_cond_const>::crule(\"reduce_cond_const\") {}",
        "context": "struct reduce_cond_const : public crule<reduce_cond_const> \n{\n    reduce_cond_const() \n        : crule<reduce_cond_const>::crule(\"reduce_cond_const\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 33,
        "type": "empty_function",
        "content": "reduce_plus_zero() : crule<reduce_plus_zero>::crule(\"reduce_plus_zero\") {}",
        "context": "\n//x+0 -> x\nstruct reduce_plus_zero : public crule<reduce_plus_zero> {\n    reduce_plus_zero() : crule<reduce_plus_zero>::crule(\"reduce_plus_zero\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 40,
        "type": "empty_function",
        "content": "reduce_times_one_zero() : crule<reduce_times_one_zero>::crule(\"reduce_times_one_zero\") {}",
        "context": "//x*1 -> x\n//x*0 -> 0\nstruct reduce_times_one_zero : public crule<reduce_times_one_zero> {\n    reduce_times_one_zero() : crule<reduce_times_one_zero>::crule(\"reduce_times_one_zero\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "reduce_factorize_fraction() : crule<reduce_factorize_fraction>::crule(\"reduce_factorize_fraction\") {}",
        "context": "//1)is the one that shorten the most the expression\n//2)if not unique, the lowest one according to the index order\nstruct reduce_factorize_fraction : public crule<reduce_factorize_fraction> {\n    reduce_factorize_fraction() : crule<reduce_factorize_fraction>::crule(\"reduce_factorize_fraction\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 61,
        "type": "empty_function",
        "content": "reduce_factorize() : crule<reduce_factorize>::crule(\"reduce_factorize\") {}",
        "context": "//2)if not unique, the lowest one according to the index order\n//Note : if x is a numerator of div, it works too\nstruct reduce_factorize : public crule<reduce_factorize> {\n    reduce_factorize() : crule<reduce_factorize>::crule(\"reduce_factorize\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 86,
        "type": "empty_function",
        "content": "crule<reduce_distribute>::crule(\"reduce_distribute\"), _reduction(&r) {}",
        "context": "// complete\nstruct reduce_distribute : public crule<reduce_distribute> {\n    reduce_distribute(const rule& r) : \n        crule<reduce_distribute>::crule(\"reduce_distribute\"), _reduction(&r) {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 97,
        "type": "empty_function",
        "content": "reduce_invert_constant() : crule<reduce_invert_constant>::crule(\"reduce_invert_constant\") {}",
        "context": "//x/(c*y) -> 1/c *x/y\n//0/x -> 0\nstruct reduce_invert_constant : public crule<reduce_invert_constant> {\n    reduce_invert_constant() : crule<reduce_invert_constant>::crule(\"reduce_invert_constant\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 105,
        "type": "empty_function",
        "content": "reduce_fraction() : crule<reduce_fraction>::crule(\"reduce_fraction\") {}",
        "context": "//or more generally,\n//(prod x_i*prod y_j)/(prod x_i*prod z_k)-> prod y_j/prod z_k\nstruct reduce_fraction : public crule<reduce_fraction> {\n    reduce_fraction() : crule<reduce_fraction>::crule(\"reduce_fraction\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 114,
        "type": "empty_function",
        "content": "reduce_times_div() : crule<reduce_times_div>::crule(\"reduce_times_div\") {}",
        "context": "//x*(y/z) -> (x*y)/z,\n//more generally prod x_i * prod y_j/z_j -> (prod x_i * prod y_j)/(prod z_j)\nstruct reduce_times_div : public crule<reduce_times_div> {\n    reduce_times_div() : crule<reduce_times_div>::crule(\"reduce_times_div\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 121,
        "type": "empty_function",
        "content": "reduce_plus_times_one_child() : crule<reduce_plus_times_one_child>::crule(\"reduce_plus_times_one_child\") {}",
        "context": "//+(x) -> x\n//*(x) -> x\nstruct reduce_plus_times_one_child : public crule<reduce_plus_times_one_child> {\n    reduce_plus_times_one_child() : crule<reduce_plus_times_one_child>::crule(\"reduce_plus_times_one_child\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 131,
        "type": "empty_function",
        "content": "reduce_sum_log() : crule<reduce_sum_log>::crule(\"reduce_sum_log\") {}",
        "context": "//works only if at least one log(x_i) exists otherwise\n//there would be a conflict with the rule log(c/x) -> -log((1/c)*x)\nstruct reduce_sum_log : public crule<reduce_sum_log> {\n    reduce_sum_log() : crule<reduce_sum_log>::crule(\"reduce_sum_log\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 140,
        "type": "empty_function",
        "content": "reduce_log_div_times() : crule<reduce_log_div_times>::crule(\"reduce_log_div_times\") {}",
        "context": "//log(exp(x)*y) -> x+log(y)\n//or more generally log(prod exp(x_i)*prod y_j) -> sum x_i +log(prod y_j)\nstruct reduce_log_div_times : public crule<reduce_log_div_times> {\n    reduce_log_div_times() : crule<reduce_log_div_times>::crule(\"reduce_log_div_times\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 146,
        "type": "empty_function",
        "content": "reduce_exp_times() : crule<reduce_exp_times>::crule(\"reduce_exp_times\") {}",
        "context": "\n//prod exp(x_i) -> exp(sum x_i)\nstruct reduce_exp_times : public crule<reduce_exp_times> {\n    reduce_exp_times() : crule<reduce_exp_times>::crule(\"reduce_exp_times\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n   \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 152,
        "type": "empty_function",
        "content": "reduce_exp_div() : crule<reduce_exp_div>::crule(\"reduce_exp_div\") {}",
        "context": "   \n//x/exp(y) -> x*exp(-y)\nstruct reduce_exp_div : public crule<reduce_exp_div> {\n    reduce_exp_div() : crule<reduce_exp_div>::crule(\"reduce_exp_div\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 163,
        "type": "empty_function",
        "content": "reduce_exp_log() : crule<reduce_exp_log>::crule(\"reduce_exp_log\") {}",
        "context": "//exp(log(x)+y) -> x*exp(y)\n//or more generally, exp(sum log(x_i) + sum y_j) -> prod x_i * exp(sum y_j)\nstruct reduce_exp_log : public crule<reduce_exp_log> {\n    reduce_exp_log() : crule<reduce_exp_log>::crule(\"reduce_exp_log\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n#endif\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": "reduce_sin() : crule<reduce_sin>::crule(\"reduce_sin\") {}",
        "context": "//or more generally\n//sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\nstruct reduce_sin : public crule<reduce_sin> {\n    reduce_sin() : crule<reduce_sin>::crule(\"reduce_sin\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 184,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(igop) {}",
        "context": "    const vertex_set &ignore_ops;\n    reduce_impulse_arg(int effort, const vertex_set &igop)\n        : crule<reduce_impulse_arg>::crule(\"reduce_impulse_arg\"),\n          reduct_effort(effort), ignore_ops(igop) {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/fold_rules.h",
        "line": 16,
        "type": "empty_function",
        "content": "fold_unrolling() : crule<fold_unrolling>::crule(\"fold_unrolling\") {}",
        "context": "//    foldl(f v list(a b c)) = f(f(f(v a) b) c)\n//    foldr(f v list(a b c)) = f(a f(b f(c v)))\nstruct fold_unrolling : public crule<fold_unrolling> {\n    fold_unrolling() : crule<fold_unrolling>::crule(\"fold_unrolling\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/general_rules.h",
        "line": 37,
        "type": "empty_function",
        "content": "level() : crule<level>::crule(\"level\") {}",
        "context": "// Note that level is recursive that is f(a,f(b,f(c,d))) -> f(a,b,c,d)\nstruct level : public crule<level>\n{ \n    level() : crule<level>::crule(\"level\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/general_rules.h",
        "line": 46,
        "type": "empty_function",
        "content": "eval_constants() : crule<eval_constants>::crule(\"eval_constants\") {}",
        "context": "// op(op(const,const),var), e.g., +(2,x,1) => +(3,x)\nstruct eval_constants : public crule<eval_constants>\n{ \n    eval_constants() : crule<eval_constants>::crule(\"eval_constants\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/general_rules.h",
        "line": 54,
        "type": "empty_function",
        "content": ": crule<reorder_commutative>::crule(\"reorder_commutative\") {}",
        "context": "struct reorder_commutative : public crule<reorder_commutative>\n{\n    reorder_commutative()\n        : crule<reorder_commutative>::crule(\"reorder_commutative\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/general_rules.h",
        "line": 62,
        "type": "empty_function",
        "content": ": crule<remove_null_vertices>::crule(\"remove_null_vertices\") {}",
        "context": "struct remove_null_vertices : public crule<remove_null_vertices>\n{\n    remove_null_vertices()\n        : crule<remove_null_vertices>::crule(\"remove_null_vertices\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/general_rules.h",
        "line": 70,
        "type": "empty_function",
        "content": ": crule<remove_all_assumptions>::crule(\"remove_all_assumptions\") {}",
        "context": "struct remove_all_assumptions : public crule<remove_all_assumptions>\n{\n    remove_all_assumptions()\n        : crule<remove_all_assumptions>::crule(\"remove_all_assumptions\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_reduction.cc",
        "line": 90,
        "type": "empty_function",
        "content": "{}",
        "context": "\nlogical_reduction::logical_reduction(const logical_reduction& rhs) :\n    p_medium(rhs.p_medium->clone()), p_complexe(rhs.p_complexe->clone())\n{}\n\nlogical_reduction& logical_reduction::operator=(const logical_reduction& rhs)\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 667,
        "type": "stub_function",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 697,
        "type": "stub_function",
        "content": "// stubbed out for performance",
        "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 39,
        "type": "empty_function",
        "content": "insert_ands() : crule<insert_ands>::crule(\"insert_ands\") {}",
        "context": "/// This is important so that other normalizations can catch all cases.\nstruct insert_ands : public crule<insert_ands>\n{\n    insert_ands() : crule<insert_ands>::crule(\"insert_ands\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 48,
        "type": "empty_function",
        "content": ": crule<remove_unary_junctors>::crule(\"remove_unary_junctors\") {}",
        "context": "struct remove_unary_junctors : public crule<remove_unary_junctors>\n{\n    remove_unary_junctors()\n        : crule<remove_unary_junctors>::crule(\"remove_unary_junctors\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 64,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(ignore_ops_) {}",
        "context": "    simplify_predicates(int effort,\n                        const vertex_set& ignore_ops_)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n          reduct_effort(effort), ignore_ops(ignore_ops_) {}\n\n    simplify_predicates(const simplify_predicates& rhs)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 68,
        "type": "empty_function",
        "content": "reduct_effort(rhs.reduct_effort), ignore_ops(rhs.ignore_ops) {}",
        "context": "\n    simplify_predicates(const simplify_predicates& rhs)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n          reduct_effort(rhs.reduct_effort), ignore_ops(rhs.ignore_ops) {}\n\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 82,
        "type": "empty_function",
        "content": "remove_dangling_junctors() : crule<remove_dangling_junctors>::crule(\"remove_dangling_junctors\") {}",
        "context": "/// logical formulae exibit more diversity\nstruct remove_dangling_junctors : public crule<remove_dangling_junctors>\n{\n    remove_dangling_junctors() : crule<remove_dangling_junctors>::crule(\"remove_dangling_junctors\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 93,
        "type": "empty_function",
        "content": ": crule<eval_logical_identities>::crule(\"eval_logical_identities\") {}",
        "context": "struct eval_logical_identities : public crule<eval_logical_identities>\n{\n    eval_logical_identities()\n        : crule<eval_logical_identities>::crule(\"eval_logical_identities\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 100,
        "type": "empty_function",
        "content": "reduce_nots() : crule<reduce_nots>::crule(\"reduce_nots\") {}",
        "context": "// !!a->a,!(a&&b)->(!a||!b),!(a||b)->(!a&&!b),\nstruct reduce_nots : public crule<reduce_nots>\n{\n    reduce_nots() : crule<reduce_nots>::crule(\"reduce_nots\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 113,
        "type": "empty_function",
        "content": "_reduction(&r) { }",
        "context": "{\n    reduce_and_assumptions(const rule& r)\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n         _reduction(&r) { }\n\n    reduce_and_assumptions()\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 117,
        "type": "empty_function",
        "content": "_reduction(this) { }",
        "context": "\n    reduce_and_assumptions()\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n        _reduction(this) { }\n\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 131,
        "type": "empty_function",
        "content": "_reduction(&r) { }",
        "context": "{\n    reduce_or_assumptions(const rule& r)\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n         _reduction(&r) { }\n\n    reduce_or_assumptions()\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 135,
        "type": "empty_function",
        "content": "_reduction(this) { }",
        "context": "\n    reduce_or_assumptions()\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n         _reduction(this) { }\n\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 150,
        "type": "empty_function",
        "content": "reduce_ors() : crule<reduce_ors>::crule(\"reduce_ors\") {}",
        "context": "// Also, true||X -> true, false||X -> X\nstruct reduce_ors : public crule<reduce_ors>\n{\n    reduce_ors() : crule<reduce_ors>::crule(\"reduce_ors\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 161,
        "type": "empty_function",
        "content": "reduce_ands() : crule<reduce_ands>::crule(\"reduce_ands\") {}",
        "context": "// Also, true&&X -> X, false&&X -> false\nstruct reduce_ands : public crule<reduce_ands>\n{\n    reduce_ands() : crule<reduce_ands>::crule(\"reduce_ands\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": ": crule<subtree_to_enf>::crule(\"subtree_to_enf\") {}",
        "context": "struct subtree_to_enf : public crule<subtree_to_enf>\n{\n    subtree_to_enf()\n        : crule<subtree_to_enf>::crule(\"subtree_to_enf\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const\n    {\n        reduce_to_enf(tr, it);\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 242,
        "type": "empty_function",
        "content": "tree_eraser(combo_tree& t) : tr(t) { }",
        "context": "\n        struct tree_eraser\n        {\n            tree_eraser(combo_tree& t) : tr(t) { }\n            combo_tree& tr;\n            template<typename It>\n            void operator()(It it) { tr.erase(*it); }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 250,
        "type": "empty_function",
        "content": "subtree_set_eraser(subtree_set& s) : se(s) { }",
        "context": "\n        struct subtree_set_eraser\n        {\n            subtree_set_eraser(subtree_set& s) : se(s) { }\n            subtree_set& se;\n            template<typename It>\n            void operator()(It it) { se.erase(it); }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 258,
        "type": "empty_function",
        "content": "tree_inserter(combo_tree& t,sib_it i) : tr(t),it(i) { }",
        "context": "\n        struct tree_inserter\n        {\n            tree_inserter(combo_tree& t,sib_it i) : tr(t),it(i) { }\n            combo_tree& tr;\n            sib_it it;\n            template<typename It1,typename It2>\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 279,
        "type": "empty_function",
        "content": ": crule<reduce_remove_subtree_equal_tt>::crule(\"reduce_remove_subtree_equal_tt\") {}",
        "context": "    : public crule<reduce_remove_subtree_equal_tt>\n{\n    reduce_remove_subtree_equal_tt()\n        : crule<reduce_remove_subtree_equal_tt>::crule(\"reduce_remove_subtree_equal_tt\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 47,
        "type": "empty_function",
        "content": "cond(cond_) {}",
        "context": "struct when : public crule<when> {\n    when(const rule& r_, bool cond_, string name = \"when\")\n        : crule<when>::crule(name), r(r_.clone()),\n          cond(cond_) {}\n    when(const when& w)\n        : crule<when>::crule(w.get_name()),\n          r(w.r->clone()), cond(w.cond) { }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "r(w.r->clone()), cond(w.cond) { }",
        "context": "          cond(cond_) {}\n    when(const when& w)\n        : crule<when>::crule(w.get_name()),\n          r(w.r->clone()), cond(w.cond) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\nprotected:\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 64,
        "type": "empty_function",
        "content": "r(r_.clone()) {}",
        "context": "    explicit ignore_size_increase(const rule& r_,\n                                  string name = \"ignore_size_increase\")\n        : crule<ignore_size_increase>::crule(name),\n          r(r_.clone()) {}\n    ignore_size_increase(const ignore_size_increase& i)\n        : crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 66,
        "type": "empty_function",
        "content": ": crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "        : crule<ignore_size_increase>::crule(name),\n          r(r_.clone()) {}\n    ignore_size_increase(const ignore_size_increase& i)\n        : crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\nprotected:\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 81,
        "type": "empty_function",
        "content": "input(combo::id::unknown_type), output(combo::id::unknown_type) { }",
        "context": "{\n    explicit downwards(const rule& r_, string name = \"downwards\")\n        : crule<downwards>::crule(name), r(r_.clone()),\n          input(combo::id::unknown_type), output(combo::id::unknown_type) { }\n\n    downwards(const rule& r_, combo::type_node t, string name = \"downwards\")\n        : crule<downwards>::crule(name),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 85,
        "type": "empty_function",
        "content": "r(r_.clone()), input(t), output(t) { }",
        "context": "\n    downwards(const rule& r_, combo::type_node t, string name = \"downwards\")\n        : crule<downwards>::crule(name),\n          r(r_.clone()), input(t), output(t) { }\n\n    downwards(const rule& r_, combo::type_node input_, combo::type_node output_,\n              string name = \"downwards\")\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 90,
        "type": "empty_function",
        "content": "r(r_.clone()), input(input_), output(output_) { }",
        "context": "    downwards(const rule& r_, combo::type_node input_, combo::type_node output_,\n              string name = \"downwards\")\n        : crule<downwards>::crule(name),\n          r(r_.clone()), input(input_), output(output_) { }\n\n    downwards(const downwards& d)\n        : crule<downwards>::crule(d.get_name()),\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 94,
        "type": "empty_function",
        "content": "r(d.r->clone()), input(d.input), output(d.output) { }",
        "context": "\n    downwards(const downwards& d)\n        : crule<downwards>::crule(d.get_name()),\n          r(d.r->clone()), input(d.input), output(d.output) { }\n\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 109,
        "type": "empty_function",
        "content": ": crule<upwards>::crule(name), r(r_.clone()) {}",
        "context": "//points at gets visited last)\nstruct upwards : public crule<upwards> {\n    explicit upwards(const rule& r_, string name = \"upwards\")\n        : crule<upwards>::crule(name), r(r_.clone()) {}\n    upwards(const upwards& u)\n        : crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 111,
        "type": "empty_function",
        "content": ": crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}",
        "context": "    explicit upwards(const rule& r_, string name = \"upwards\")\n        : crule<upwards>::crule(name), r(r_.clone()) {}\n    upwards(const upwards& u)\n        : crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}\n\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 123,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(name) {}",
        "context": "//longer changes\nstruct iterative : public crule<iterative> {\n    iterative(string name = \"iterative\")\n        : crule<iterative>::crule(name) {}\n    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 125,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(name), r(r_.clone()) {}",
        "context": "    iterative(string name = \"iterative\")\n        : crule<iterative>::crule(name) {}\n    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n        : crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 127,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n        : crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\nprotected:\n    std::shared_ptr<const rule> r;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 137,
        "type": "empty_function",
        "content": ": crule<assum_iterative>::crule(name) {}",
        "context": "//if the assumption set changes assum_iterative keeps iterating\nstruct assum_iterative : public crule<assum_iterative> {\n    assum_iterative(string name = \"assum_iterative\")\n        : crule<assum_iterative>::crule(name) {}\n    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 139,
        "type": "empty_function",
        "content": "crule<assum_iterative>::crule(name), r(r_.clone()) {}",
        "context": "    assum_iterative(string name = \"assum_iterative\")\n        : crule<assum_iterative>::crule(name) {}\n    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n        : crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 141,
        "type": "empty_function",
        "content": ": crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n        : crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\nprotected:\n    std::shared_ptr<const rule> r;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 150,
        "type": "empty_function",
        "content": "//sequential() { }",
        "context": "//apply rules sequentially to a particular point-of-application\n//overloaded up to 50 arguments.\nstruct sequential : public crule<sequential> {\n    //sequential() { }\n    sequential(const sequential& rhs)\n        : crule<sequential>::crule(rhs.get_name()),\n          rules(rhs.rules.begin(), rhs.rules.end()) { }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 153,
        "type": "empty_function",
        "content": "rules(rhs.rules.begin(), rhs.rules.end()) { }",
        "context": "    //sequential() { }\n    sequential(const sequential& rhs)\n        : crule<sequential>::crule(rhs.get_name()),\n          rules(rhs.rules.begin(), rhs.rules.end()) { }\n\n#define OC_RULES_PUSH_BACK(z, n, name) rules.push_back(BOOST_PP_CAT(name, n).clone());\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 35,
        "type": "empty_function",
        "content": "reduce_gt_zero_times_const() : crule<reduce_gt_zero_times_const>::crule(\"reduce_gt_zero_times_const\") {}",
        "context": "//0<c*x -> 0<-1*x if c<0\n//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_times_const : public crule<reduce_gt_zero_times_const> {\n    reduce_gt_zero_times_const() : crule<reduce_gt_zero_times_const>::crule(\"reduce_gt_zero_times_const\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 42,
        "type": "empty_function",
        "content": "reduce_gt_zero_pair_power() : crule<reduce_gt_zero_pair_power>::crule(\"reduce_gt_zero_pair_power\") {}",
        "context": "//0<c*x*x -> false if c<0\n//or more generally 0<c*x^p_x*y^p_y*exp(... where p_x, p_y... are divisible by 2\nstruct reduce_gt_zero_pair_power : public crule<reduce_gt_zero_pair_power> {\n    reduce_gt_zero_pair_power() : crule<reduce_gt_zero_pair_power>::crule(\"reduce_gt_zero_pair_power\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 51,
        "type": "empty_function",
        "content": "reduce_gt_zero_const_div() : crule<reduce_gt_zero_const_div>::crule(\"reduce_gt_zero_const_div\") {}",
        "context": "//WARNING : this rule is deprecated, use reduce_gt_zero_div instead\nstruct reduce_gt_zero_const_div : public crule<reduce_gt_zero_const_div>\n{\n    reduce_gt_zero_const_div() : crule<reduce_gt_zero_const_div>::crule(\"reduce_gt_zero_const_div\") {}\n        void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 59,
        "type": "empty_function",
        "content": "reduce_gt_zero_log() : crule<reduce_gt_zero_log>::crule(\"reduce_gt_zero_log\") {}",
        "context": "// 0<log(x) -> 0<-1+x\nstruct reduce_gt_zero_log : public crule<reduce_gt_zero_log>\n{\n    reduce_gt_zero_log() : crule<reduce_gt_zero_log>::crule(\"reduce_gt_zero_log\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n#endif\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 67,
        "type": "empty_function",
        "content": "reduce_gt_zero_exp() : crule<reduce_gt_zero_exp>::crule(\"reduce_gt_zero_exp\") {}",
        "context": "// 0<exp(x) -> true\nstruct reduce_gt_zero_exp : public crule<reduce_gt_zero_exp>\n{\n    reduce_gt_zero_exp() : crule<reduce_gt_zero_exp>::crule(\"reduce_gt_zero_exp\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 75,
        "type": "empty_function",
        "content": "reduce_gt_zero_minus_exp() : crule<reduce_gt_zero_minus_exp>::crule(\"reduce_gt_zero_minus_exp\") {}",
        "context": "//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_minus_exp : public crule<reduce_gt_zero_minus_exp>\n{\n    reduce_gt_zero_minus_exp() : crule<reduce_gt_zero_minus_exp>::crule(\"reduce_gt_zero_minus_exp\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 82,
        "type": "empty_function",
        "content": "reduce_gt_zero_prod_exp() : crule<reduce_gt_zero_prod_exp>::crule(\"reduce_gt_zero_prod_exp\") {}",
        "context": "//0<y*exp(x) -> 0<y\n//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_prod_exp : public crule<reduce_gt_zero_prod_exp> {\n    reduce_gt_zero_prod_exp() : crule<reduce_gt_zero_prod_exp>::crule(\"reduce_gt_zero_prod_exp\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 90,
        "type": "empty_function",
        "content": "reduce_gt_zero_const_sum_sin() : crule<reduce_gt_zero_const_sum_sin>::crule(\"reduce_gt_zero_const_sum_sin\") {}",
        "context": "//0<c+sin(x) -> false if c<=1\n//WARNING : this rule is deprecated, use reduce_gt_zero_sum_sin instead\nstruct reduce_gt_zero_const_sum_sin : public crule<reduce_gt_zero_const_sum_sin> {\n    reduce_gt_zero_const_sum_sin() : crule<reduce_gt_zero_const_sum_sin>::crule(\"reduce_gt_zero_const_sum_sin\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 96,
        "type": "empty_function",
        "content": "reduce_gt_zero_impulse() : crule<reduce_gt_zero_impulse>::crule(\"reduce_gt_zero_impulse\") {}",
        "context": "\n// 0<impulse(x) -> x   (remember x is boolean)\nstruct reduce_gt_zero_impulse : public crule<reduce_gt_zero_impulse> {\n    reduce_gt_zero_impulse() : crule<reduce_gt_zero_impulse>::crule(\"reduce_gt_zero_impulse\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 102,
        "type": "empty_function",
        "content": "reduce_impulse_power() : crule<reduce_impulse_power>::crule(\"reduce_impulse_power\") {}",
        "context": "\n//prod impulse(x_i)^p_i -> prod impulse(x_i)\nstruct reduce_impulse_power : public crule<reduce_impulse_power> {\n    reduce_impulse_power() : crule<reduce_impulse_power>::crule(\"reduce_impulse_power\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 108,
        "type": "empty_function",
        "content": "reduce_impulse_prod() : crule<reduce_impulse_prod>::crule(\"reduce_impulse_prod\") {}",
        "context": "\n//prod impulse(x_i) * z -> impulse(and x_i) * z\nstruct reduce_impulse_prod : public crule<reduce_impulse_prod> {\n    reduce_impulse_prod() : crule<reduce_impulse_prod>::crule(\"reduce_impulse_prod\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 114,
        "type": "empty_function",
        "content": "reduce_impulse_sum() : crule<reduce_impulse_sum>::crule(\"reduce_impulse_sum\") {}",
        "context": "\n//0<(sum impulse(x_i)) -> or x_i\nstruct reduce_impulse_sum : public crule<reduce_impulse_sum> {\n    reduce_impulse_sum() : crule<reduce_impulse_sum>::crule(\"reduce_impulse_sum\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 121,
        "type": "empty_function",
        "content": "reduce_contin_if_to_impulse() : crule<reduce_contin_if_to_impulse>::crule(\"reduce_contin_if_to_impulse\") {}",
        "context": "//if(x 1 0) -> impulse(x)\n//if(x 0 1) -> impulse(NOT(x))\nstruct reduce_contin_if_to_impulse : public crule<reduce_contin_if_to_impulse> {\n    reduce_contin_if_to_impulse() : crule<reduce_contin_if_to_impulse>::crule(\"reduce_contin_if_to_impulse\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 130,
        "type": "empty_function",
        "content": "reduce_contin_if() : crule<reduce_contin_if>::crule(\"reduce_contin_if\") {}",
        "context": "//if(x if(x y z) w) -> if(x y w)\n//if(x y if(x z w)) -> if(x y w)\nstruct reduce_contin_if : public crule<reduce_contin_if> {\n    reduce_contin_if() : crule<reduce_contin_if>::crule(\"reduce_contin_if\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 136,
        "type": "empty_function",
        "content": "reduce_op_contin_if() : crule<reduce_op_contin_if>::crule(\"reduce_op_contin_if\") {}",
        "context": "\n//op(if(x y1 z1) if(x y2 z2)) -> if(x op(y1 y2) op(z1 z2))\nstruct reduce_op_contin_if : public crule<reduce_op_contin_if> {\n    reduce_op_contin_if() : crule<reduce_op_contin_if>::crule(\"reduce_op_contin_if\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 143,
        "type": "empty_function",
        "content": "reduce_contin_if_inner_op() : crule<reduce_contin_if_inner_op>::crule(\"reduce_contin_if_inner_op\") {}",
        "context": "//contin_if(x op(y z) op(y w)) -> op(y contin_if(x z w))\n//op in {+, *, /}. If op is / the order of argument is respected\nstruct reduce_contin_if_inner_op : public crule<reduce_contin_if_inner_op> {\n    reduce_contin_if_inner_op() : crule<reduce_contin_if_inner_op>::crule(\"reduce_contin_if_inner_op\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 151,
        "type": "empty_function",
        "content": "reduce_contin_if_substitute_cond() : crule<reduce_contin_if_substitute_cond>::crule(\"reduce_contin_if_substitute_cond\") {}",
        "context": "struct reduce_contin_if_substitute_cond\n    : public crule<reduce_contin_if_substitute_cond> \n{\n    reduce_contin_if_substitute_cond() : crule<reduce_contin_if_substitute_cond>::crule(\"reduce_contin_if_substitute_cond\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": "reduce_junction_gt_zero_sum_constant() : crule<reduce_junction_gt_zero_sum_constant>::crule(\"reduce_junction_gt_zero_sum_constant\") {}",
        "context": "struct reduce_junction_gt_zero_sum_constant\n    : public crule<reduce_junction_gt_zero_sum_constant> \n{\n    reduce_junction_gt_zero_sum_constant() : crule<reduce_junction_gt_zero_sum_constant>::crule(\"reduce_junction_gt_zero_sum_constant\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 181,
        "type": "empty_function",
        "content": "reduce_from_assumptions(const rule& r) : crule<reduce_from_assumptions>::crule(\"reduce_from_assumptions\"), _reduction(&r) { }",
        "context": "// rule given in argument is used by reduce_from_assumptions::implies\n// and can be fully recursive (I guess?).\nstruct reduce_from_assumptions : public crule<reduce_from_assumptions> {\n    reduce_from_assumptions(const rule& r) : crule<reduce_from_assumptions>::crule(\"reduce_from_assumptions\"), _reduction(&r) { }    \n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n    bool implies(const combo_tree& tr, combo_tree::iterator it1, combo_tree::iterator it2) const;\nprotected:\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 190,
        "type": "empty_function",
        "content": "reduce_contin_if_not(const rule& r) : crule<reduce_contin_if_not>::crule(\"reduce_contin_if_not\"), _reduction(&r) { }",
        "context": "\n//if(x y z) -> if(NOT(x) z y)  if |rule(NOT(x))|<|rule(x)|\nstruct reduce_contin_if_not : public crule<reduce_contin_if_not> {\n    reduce_contin_if_not(const rule& r) : crule<reduce_contin_if_not>::crule(\"reduce_contin_if_not\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 199,
        "type": "empty_function",
        "content": "reduce_gt_zero_sum(const rule& r) : crule<reduce_gt_zero_sum>::crule(\"reduce_gt_zero_sum\"), _reduction(&r) { }",
        "context": "//0<sum x_i -> true    if 0<x_i -> true forall i\n//0<sum x_i -> false   if 0<x_i -> false forall i\nstruct reduce_gt_zero_sum : public crule<reduce_gt_zero_sum> {\n    reduce_gt_zero_sum(const rule& r) : crule<reduce_gt_zero_sum>::crule(\"reduce_gt_zero_sum\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 212,
        "type": "empty_function",
        "content": "_complete_reduction(&r), _reduction_without_itself(&r) { }",
        "context": "struct reduce_gt_zero_prod : public crule<reduce_gt_zero_prod> {\n    reduce_gt_zero_prod(const rule& r)\n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r), _reduction_without_itself(&r) { }\n    reduce_gt_zero_prod(const rule& r1, const rule& r2) \n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r1), _reduction_without_itself(&r2) { }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 215,
        "type": "empty_function",
        "content": "_complete_reduction(&r1), _reduction_without_itself(&r2) { }",
        "context": "          _complete_reduction(&r), _reduction_without_itself(&r) { }\n    reduce_gt_zero_prod(const rule& r1, const rule& r2) \n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r1), _reduction_without_itself(&r2) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _complete_reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 228,
        "type": "empty_function",
        "content": "reduce_gt_zero_div(const rule& r) : crule<reduce_gt_zero_div>::crule(\"reduce_gt_zero_div\"), _reduction(&r) { }",
        "context": "//0<x/y -> 0<-1*x if 0<-1*y -> true\n//0<x/y -> false  if x==0, that is not(0<x) -> true and not(0<-x) -> true\nstruct reduce_gt_zero_div : public crule<reduce_gt_zero_div> {\n    reduce_gt_zero_div(const rule& r) : crule<reduce_gt_zero_div>::crule(\"reduce_gt_zero_div\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 237,
        "type": "empty_function",
        "content": "reduce_gt_zero_sum_sin(const rule& r) : crule<reduce_gt_zero_sum_sin>::crule(\"reduce_gt_zero_sum_sin\"), _reduction(&r) { }",
        "context": "//0<x+sin(y) -> true  if 0<x-1 -> true\n//0<x+sin(y) -> false if 0<x+1 -> false\nstruct reduce_gt_zero_sum_sin : public crule<reduce_gt_zero_sum_sin> {\n    reduce_gt_zero_sum_sin(const rule& r) : crule<reduce_gt_zero_sum_sin>::crule(\"reduce_gt_zero_sum_sin\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 246,
        "type": "empty_function",
        "content": "reduce_gt_zero_sin(const rule& r) : crule<reduce_gt_zero_sin>::crule(\"reduce_gt_zero_sin\"), _reduction(&r) { }",
        "context": "//0<sin(y) -> true  if 0<y -> true and 0<pi-y -> true\n//0<sin(y) -> false if 0<y -> false and 0<-(y+pi) ->false\nstruct reduce_gt_zero_sin : public crule<reduce_gt_zero_sin> {\n    reduce_gt_zero_sin(const rule& r) : crule<reduce_gt_zero_sin>::crule(\"reduce_gt_zero_sin\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 257,
        "type": "empty_function",
        "content": "reduce_gt_division_of_constants(const rule& r) : crule<reduce_gt_division_of_constants>::crule(\"reduce_gt_division_of_constants\"), _reduction(&r) { }",
        "context": "//0<c*x+d -> true  if c==0 -> true && 0<d -> true\n//0<c*x+d -> false if c==0 -> true && d<=0 -> true\nstruct reduce_gt_division_of_constants : public crule<reduce_gt_division_of_constants> {\n    reduce_gt_division_of_constants(const rule& r) : crule<reduce_gt_division_of_constants>::crule(\"reduce_gt_division_of_constants\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 268,
        "type": "empty_function",
        "content": "crule<reduce_inequality_from_assumptions>::crule(\"reduce_inequality_from_assumptions\") {}",
        "context": "//other inequalities present as assumptions\nstruct reduce_inequality_from_assumptions : public crule<reduce_inequality_from_assumptions> {\n    reduce_inequality_from_assumptions() :\n        crule<reduce_inequality_from_assumptions>::crule(\"reduce_inequality_from_assumptions\") {}\n    //double_matrix, a matrix of doubles\n    //used by reduce_inequality_from_assumptions\n    //each inner vector is a row, the outer vector is a list of rows\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 36,
        "type": "empty_function",
        "content": "reduce_ultrametric() : crule<reduce_ultrametric>::crule(\"reduce_ultrametric\") {}",
        "context": "//f(x, z) <= max{d(x, y), d(y, z)}\n//when encounting f(x, y) and f(y, z) and d is ultrametric\nstruct reduce_ultrametric : public crule<reduce_ultrametric> {\n    reduce_ultrametric() : crule<reduce_ultrametric>::crule(\"reduce_ultrametric\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n \n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 44,
        "type": "empty_function",
        "content": "reduce_transitive() : crule<reduce_transitive>::crule(\"reduce_transitive\") {}",
        "context": "//f(x, z)\n//when encounting f(x, y) and f(y, z)\nstruct reduce_transitive : public crule<reduce_transitive> {\n    reduce_transitive() : crule<reduce_transitive>::crule(\"reduce_transitive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "reduce_reflexive() : crule<reduce_reflexive>::crule(\"reduce_reflexive\") {}",
        "context": "\n//reduce f(x,x) -> true iff f is reflexive\nstruct reduce_reflexive : public crule<reduce_reflexive> {\n    reduce_reflexive() : crule<reduce_reflexive>::crule(\"reduce_reflexive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 56,
        "type": "empty_function",
        "content": "reduce_irreflexive() : crule<reduce_irreflexive>::crule(\"reduce_irreflexive\") {}",
        "context": "\n//reduce f(x,x) -> false iff f is irreflexive\nstruct reduce_irreflexive : public crule<reduce_irreflexive> {\n    reduce_irreflexive() : crule<reduce_irreflexive>::crule(\"reduce_irreflexive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 71,
        "type": "empty_function",
        "content": "reduce_symmetric() : crule<reduce_symmetric>::crule(\"reduce_symmetric\") {}",
        "context": "//reduce_symmetric can permit more reductions\n//than with associative reduction.\nstruct reduce_symmetric : public crule<reduce_symmetric> {\n    reduce_symmetric() : crule<reduce_symmetric>::crule(\"reduce_symmetric\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 78,
        "type": "empty_function",
        "content": "reduce_identity_of_indiscernibles() : crule<reduce_identity_of_indiscernibles>::crule(\"reduce_identity_of_indiscernibles\") {}",
        "context": "\n//reduce f(x,y) -> 0 iff f verifies the property of identity of indiscernibles\nstruct reduce_identity_of_indiscernibles : public crule<reduce_identity_of_indiscernibles> {\n    reduce_identity_of_indiscernibles() : crule<reduce_identity_of_indiscernibles>::crule(\"reduce_identity_of_indiscernibles\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/reduct.h",
        "line": 39,
        "type": "empty_function",
        "content": "rule(std::string _name) : name(_name) {}",
        "context": "{\n    typedef combo_tree argument_type;\n\n    rule(std::string _name) : name(_name) {}\n    virtual ~rule() {}\n    virtual void operator()(combo_tree&, combo_tree::iterator) const=0;\n    virtual rule* clone() const=0;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/reduct.h",
        "line": 40,
        "type": "empty_function",
        "content": "virtual ~rule() {}",
        "context": "    typedef combo_tree argument_type;\n\n    rule(std::string _name) : name(_name) {}\n    virtual ~rule() {}\n    virtual void operator()(combo_tree&, combo_tree::iterator) const=0;\n    virtual rule* clone() const=0;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/reduct.h",
        "line": 66,
        "type": "empty_function",
        "content": "crule(std::string _name) : rule(_name) {}",
        "context": "template<typename T>\nstruct crule : public rule\n{\n    crule(std::string _name) : rule(_name) {}\n    rule* clone() const { return new T(*((T*) this)); }\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 75,
        "type": "empty_function",
        "content": "ITable::ITable() {}",
        "context": "        \n// -------------------------------------------------------\n\nITable::ITable() {}\n\nITable::ITable(const vector<type_node>& ts, const vector<string>& il)\n    : types(ts), labels(il) {}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 78,
        "type": "empty_function",
        "content": ": types(ts), labels(il) {}",
        "context": "ITable::ITable() {}\n\nITable::ITable(const vector<type_node>& ts, const vector<string>& il)\n    : types(ts), labels(il) {}\n\nITable::ITable(const ITable::super& mat, const vector<string>& il)\n    : super(mat), labels(il) {}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 81,
        "type": "empty_function",
        "content": ": super(mat), labels(il) {}",
        "context": "    : types(ts), labels(il) {}\n\nITable::ITable(const ITable::super& mat, const vector<string>& il)\n    : super(mat), labels(il) {}\n\n/// Construct an ITable holding a single column, the column from the OTable.\nITable::ITable(const OTable& ot)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 316,
        "type": "empty_function",
        "content": ": label(ol), type(id::unknown_type) {}",
        "context": "////////////\n\nOTable::OTable(const string& ol)\n    : label(ol), type(id::unknown_type) {}\n\nOTable::OTable(const super& ot, const string& ol)\n    : super(ot), label(ol)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 461,
        "type": "empty_function",
        "content": ": label(tl) {}",
        "context": "////////////\n\nTTable::TTable(const string& tl)\n    : label(tl) {}\n\nTTable::TTable(const super& tt, const string& tl)\n    : super(tt), label(tl) {}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 464,
        "type": "empty_function",
        "content": ": super(tt), label(tl) {}",
        "context": "    : label(tl) {}\n\nTTable::TTable(const super& tt, const string& tl)\n    : super(tt), label(tl) {}\n\nvoid TTable::set_label(const string& tl)\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 488,
        "type": "empty_function",
        "content": "Table::Table() : target_pos(0), timestamp_pos(0) {}",
        "context": "// Table //\n///////////\n\nTable::Table() : target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const OTable& otable_, const ITable& itable_)\n    : itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 491,
        "type": "empty_function",
        "content": ": itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}",
        "context": "Table::Table() : target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const OTable& otable_, const ITable& itable_)\n    : itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const combo_tree& tr, int nsamples,\n             contin_t min_contin, contin_t max_contin) :\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 496,
        "type": "empty_function",
        "content": "otable(tr, itable), target_pos(0), timestamp_pos(0) {}",
        "context": "Table::Table(const combo_tree& tr, int nsamples,\n             contin_t min_contin, contin_t max_contin) :\n    itable(infer_type_tree(tr), nsamples, min_contin, max_contin),\n    otable(tr, itable), target_pos(0), timestamp_pos(0) {}\n\nvector<string> Table::get_labels() const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 638,
        "type": "empty_function",
        "content": ": olabel(_olabel) {}",
        "context": "////////////\n\nCTable::CTable(const std::string& _olabel)\n    : olabel(_olabel) {}\n\nCTable::CTable(const string_seq& labs, const type_tree& tt)\n    : tsig(tt), olabel(labs[0]), ilabels(labs)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.cc",
        "line": 649,
        "type": "empty_function",
        "content": "{}",
        "context": "CTable::CTable(const std::string& _olabel, const string_seq& _ilabels,\n               const type_tree& tt)\n    : tsig(tt), olabel(_olabel), ilabels(_ilabels)\n{}\n\n\nvoid CTable::remove_rows(const set<unsigned>& idxs)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 117,
        "type": "empty_function",
        "content": "push_back_visitor(const T& value) : _value(value) {}",
        "context": "template<typename T /* type being pushed */>\nstruct push_back_visitor : public boost::static_visitor<>\n{\n    push_back_visitor(const T& value) : _value(value) {}\n    void operator()(std::vector<T>& seq) const {\n        seq.push_back(_value);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 145,
        "type": "empty_function",
        "content": "init_at_visitor(size_t pos) : _pos(pos) {}",
        "context": " */\nstruct init_at_visitor : public boost::static_visitor<>\n{\n    init_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq>\n    void operator()(Seq& seq) const {\n        typedef typename Seq::value_type vt;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 157,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<typename T>\nstruct get_at_visitor : public boost::static_visitor<T>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    T operator()(const std::vector<T>& seq) const {\n        return seq[_pos];\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 177,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<>\nstruct get_at_visitor<vertex> : public boost::static_visitor<vertex>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    vertex operator()(const combo_tree_seq& seq) const {\n        return *seq[_pos].begin();\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 190,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<>\nstruct get_at_visitor<combo_tree> : public boost::static_visitor<combo_tree>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> combo_tree operator()(const Seq& seq) const {\n        return seq[_pos];\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 199,
        "type": "empty_function",
        "content": "erase_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "\nstruct erase_at_visitor : public boost::static_visitor<>\n{\n    erase_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> void operator()(Seq& seq) const {\n        seq.erase(seq.begin() + _pos);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 210,
        "type": "empty_function",
        "content": "insert_at_visitor(int pos, const T v) : _pos(pos), _v(v) {}",
        "context": "struct insert_at_visitor : public boost::static_visitor<>\n{\n    // if pos is negative then it inserts at the end\n    insert_at_visitor(int pos, const T v) : _pos(pos), _v(v) {}\n    void operator()(std::vector<T>& seq) const {\n        seq.insert(_pos >= 0 ? seq.begin() + _pos : seq.end(), _v);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 300,
        "type": "empty_function",
        "content": "get_type_tree_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "\nstruct get_type_tree_at_visitor : public boost::static_visitor<type_tree>\n{\n    get_type_tree_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> type_tree operator()(const Seq& seq) {\n        return get_type_tree(seq[_pos]);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 432,
        "type": "empty_function",
        "content": ": _variant(std::vector<T>(il)) {}",
        "context": "        // logger().debug(\"sizeof(vertex) = %u\", sizeof(vertex));\n    }\n    template<typename T> multi_type_seq(const std::initializer_list<T>& il)\n        : _variant(std::vector<T>(il)) {}\n    template<typename T> multi_type_seq(const T& v) : _variant(v) {}\n    template<typename T> void push_back(const T& e) {\n        boost::apply_visitor(push_back_visitor<T>(e), _variant);\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 433,
        "type": "empty_function",
        "content": "template<typename T> multi_type_seq(const T& v) : _variant(v) {}",
        "context": "    }\n    template<typename T> multi_type_seq(const std::initializer_list<T>& il)\n        : _variant(std::vector<T>(il)) {}\n    template<typename T> multi_type_seq(const T& v) : _variant(v) {}\n    template<typename T> void push_back(const T& e) {\n        boost::apply_visitor(push_back_visitor<T>(e), _variant);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 499,
        "type": "empty_function",
        "content": "seq_filtered_visitor(const F& filter) : _filter(filter) {}",
        "context": "template<typename F>\nstruct seq_filtered_visitor : public boost::static_visitor<multi_type_seq>\n{\n    seq_filtered_visitor(const F& filter) : _filter(filter) {}\n    template<typename Seq> multi_type_seq operator()(const Seq& seq) {\n        return seq_filtered(seq, _filter);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 536,
        "type": "empty_function",
        "content": ": value(v), timestamp(t) {}",
        "context": "{\n    TimedValue(const vertex v,\n               const TTable::value_type t = TTable::value_type())\n        : value(v), timestamp(t) {}\n    vertex value;\n    TTable::value_type timestamp;\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 989,
        "type": "empty_function",
        "content": "otable(func, itable), target_pos(0), timestamp_pos(0) {}",
        "context": "    Table(const Func& func, arity_t a, int nsamples=-1) :\n        itable(gen_signature(type_node_of<bool>(),\n                             type_node_of<bool>(), a)),\n        otable(func, itable), target_pos(0), timestamp_pos(0) {}\n\n    Table(const combo_tree& tr, int nsamples=-1,\n          contin_t min_contin=-1.0, contin_t max_contin=1.0);\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1519,
        "type": "empty_function",
        "content": "complete_truth_table() {}",
        "context": "public:\n    typedef bool_seq super;\n\n    complete_truth_table() {}\n    template<typename It>\n    complete_truth_table(It from, It to) : super(from, to) {}\n    template<typename T>\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table.h",
        "line": 1521,
        "type": "empty_function",
        "content": "complete_truth_table(It from, It to) : super(from, to) {}",
        "context": "\n    complete_truth_table() {}\n    template<typename It>\n    complete_truth_table(It from, It to) : super(from, to) {}\n    template<typename T>\n    complete_truth_table(const tree<T>& tr, arity_t arity)\n        : super(pow2(arity)), _arity(arity)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 476,
        "type": "empty_function",
        "content": ": from_tokens_visitor(types), _index(index), _fixed_arity(fixed_arity) {}",
        "context": "    from_sparse_tokens_visitor(const std::vector<type_node>& types,\n                               const std::map<const std::string, size_t>& index,\n                               size_t fixed_arity)\n        : from_tokens_visitor(types), _index(index), _fixed_arity(fixed_arity) {}\n    result_type operator()(const string_seq& seq) {\n        using std::transform;\n        using std::for_each;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 126,
        "type": "empty_function",
        "content": "equal_to_type_tree(const type_tree& tt) : _tt(tt) {}",
        "context": "private:\n    const type_tree& _tt;\npublic:\n    equal_to_type_tree(const type_tree& tt) : _tt(tt) {}\n    bool operator()(const type_tree& tt) {\n        return equal_type_tree(_tt, tt);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 179,
        "type": "empty_function",
        "content": "inherit_from_type_tree(const type_tree& tt) : _tt(tt) {}",
        "context": "private:\n    const type_tree& _tt;\npublic:\n    inherit_from_type_tree(const type_tree& tt) : _tt(tt) {}\n    bool operator()(const type_tree& tt) {\n        return inherit_type_tree(tt, _tt);\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/main/feature-selection.h",
        "line": 69,
        "type": "empty_function",
        "content": "{}",
        "context": "        hc_widen_search(true),\n        hc_fraction_of_nn(2.0),\n        mi_confi(50.0)\n    {}\n\n    std::string algorithm;\n    std::string scorer;\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/main/feature-selection.h",
        "line": 147,
        "type": "empty_function",
        "content": "_cache(n, sc) {}",
        "context": "struct iscorer_cache : public iscorer_base\n{\n    iscorer_cache(size_t n, const DBScorer& sc) :\n        _cache(n, sc) {}\n\n    composite_score operator()(const instance& x) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/main/feature-selection.h",
        "line": 238,
        "type": "empty_function",
        "content": "hsh ^= std::hash<opencog::arity_t>{}(ii)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (int ii: fs)\n\t\t\t\thsh ^= std::hash<opencog::arity_t>{}(ii)\n\t\t\t\t\t+ 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/fs_scorer_base.h",
        "line": 38,
        "type": "empty_function",
        "content": ": _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}",
        "context": "{\n    // ctor\n    fs_scorer_base(const CTable& ctable, double confi)\n        : _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}\n\n    // dtor\n    virtual ~fs_scorer_base() {};\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/fs_scorer_base.h",
        "line": 41,
        "type": "empty_function",
        "content": "virtual ~fs_scorer_base() {};",
        "context": "        : _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}\n\n    // dtor\n    virtual ~fs_scorer_base() {};\n\n    virtual double operator()(const FeatureSet& features) const = 0;\n\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/moses_matrix.h",
        "line": 61,
        "type": "empty_function",
        "content": "_positive(positive) {}",
        "context": "               bool positive = true)\n        : super(ctable, confi), _penalty(penalty),\n          _min_activation(min_activation), _max_activation(max_activation),\n          _positive(positive) {}\n\n    double operator()(const FeatureSet& fs) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/moses_optim.h",
        "line": 55,
        "type": "empty_function",
        "content": ": _fs_scorer(fs_scorer), _fields(fields) {}",
        "context": "struct deme_based_scorer : public iscorer_base\n{\n    deme_based_scorer(const FSScorer& fs_scorer, const field_set& fields)\n        : _fs_scorer(fs_scorer), _fields(fields) {}\n\n    /**\n     * The feature set is represented by an instance encoding a\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 51,
        "type": "empty_function",
        "content": ": _ctable(ctable) {}",
        "context": "    typedef FeatureSet argument_type;\n    typedef double result_type;\n    MutualInformation(const CTable& ctable)\n        : _ctable(ctable) {}\n\n    double operator()(const FeatureSet& features) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 86,
        "type": "empty_function",
        "content": ": _it(it), _ot(ot), _confi(confi) {}",
        "context": "{\n    MICScorer(const ITable& it, const OTable& ot,\n              double confi = 100)\n        : _it(it), _ot(ot), _confi(confi) {}\n\n    /**\n     * The feature set is represented by an eda::instance encoding a\n"
      },
      {
        "file": "components/learning/moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 114,
        "type": "empty_function",
        "content": ": super(ctable, confi) {}",
        "context": "\n    // ctor\n    MICScorerCTable(const CTable& ctable, double confi = 100)\n        : super(ctable, confi) {}\n\n    /**\n     * The feature set is represented by an eda::instance encoding a\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.h",
        "line": 48,
        "type": "empty_function",
        "content": "~deme_expander() {}",
        "context": "                  const deme_parameters& pa = deme_parameters(),\n                  const subsample_deme_filter_parameters& fp = subsample_deme_filter_parameters());\n\n    ~deme_expander() {}\n\n    /**\n     * Create demes\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_params.h",
        "line": 50,
        "type": "empty_function",
        "content": "{}",
        "context": "        actions(_actions),\n        fstor(_fstor),\n        linear_contin(true)\n        {}\n\n    // The max number of candidates considered to be added to the\n    // metapopulation, if negative then all candidates are considered.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/feature_selector.cc",
        "line": 53,
        "type": "empty_function",
        "content": ": params(festor_params), _ctable(ctable) {}",
        "context": "\nfeature_selector::feature_selector(const combo::CTable& ctable,\n                                   const feature_selector_parameters& festor_params)\n    : params(festor_params), _ctable(ctable) {}\n\nfeature_selector::feature_selector(const combo::Table& table,\n                                   const feature_selector_parameters& festor_params)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/feature_selector.cc",
        "line": 57,
        "type": "empty_function",
        "content": ": params(festor_params), _ctable(table.compressed()) {}",
        "context": "\nfeature_selector::feature_selector(const combo::Table& table,\n                                   const feature_selector_parameters& festor_params)\n    : params(festor_params), _ctable(table.compressed()) {}\n\n// Do some sanity checking and mangling on the parameters.\nvoid feature_selector::preprocess_params(const combo::combo_tree& xmplr)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/feature_selector.h",
        "line": 53,
        "type": "empty_function",
        "content": "{}",
        "context": "        diversity_pressure(0.0),\n        diversity_cap(0),\n        diversity_interaction(0)\n    {}\n\n    feature_selection_parameters fs_params;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/local_structure.h",
        "line": 131,
        "type": "empty_function",
        "content": "const local_structure_model&) const {}",
        "context": "\n    template<typename It>\n    void operator()(const field_set&, It, It,\n                    const local_structure_model&) const {}\n};\n\n/*\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/local_structure.h",
        "line": 142,
        "type": "empty_function",
        "content": "void operator()(const field_set&,It,It,local_structure_model&) const { }",
        "context": "\n  //scratch_model should go here\n  template<typename It>\n  void operator()(const field_set&,It,It,local_structure_model&) const { }\n  };*/\n\n/// Handles probability learning for local structure models in EDA.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/replacement.h",
        "line": 71,
        "type": "empty_function",
        "content": ": window_size(ws), _fields(&fs), rng(_rng) { }",
        "context": "struct rtr_replacement\n{\n    rtr_replacement(const field_set& fs, int ws, RandGen& _rng = randGen())\n        : window_size(ws), _fields(&fs), rng(_rng) { }\n\n    template<typename NewInst, typename Dst>\n    void operator()(NewInst from, NewInst to, Dst from_dst, Dst to_dst) const\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/termination.h",
        "line": 39,
        "type": "empty_function",
        "content": "terminate_if_gte(const ScoreT& b) : bound(b) { }",
        "context": "template<typename ScoreT>\nstruct terminate_if_gte\n{\n    terminate_if_gte(const ScoreT& b) : bound(b) { }\n\n    template<typename It>\n    bool operator()(It from,It to) const {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/termination.h",
        "line": 58,
        "type": "empty_function",
        "content": "bound(b), n_gen(n), at(-1) { }",
        "context": "struct terminate_if_gte_or_no_improv\n{\n    terminate_if_gte_or_no_improv(const ScoreT& b, int n) :\n            bound(b), n_gen(n), at(-1) { }\n\n    template<typename It>\n    bool operator()(It from,It to) const {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 87,
        "type": "empty_function",
        "content": "bool_problem_base(demo_params& dp) : _dparms(dp) {}",
        "context": "class bool_problem_base : public problem_base\n{\n    public:\n        bool_problem_base(demo_params& dp) : _dparms(dp) {}\n        virtual combo::arity_t get_arity(int) = 0;\n        virtual logical_bscore get_bscore(int) = 0;\n        virtual void run(option_base*);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 131,
        "type": "empty_function",
        "content": "pa_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class pa_problem : public bool_problem_base\n{\n    public:\n        pa_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"pa\"; }\n        virtual const std::string description() const {\n             return \"Learn parity function demo\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 152,
        "type": "empty_function",
        "content": "dj_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class dj_problem : public bool_problem_base\n{\n    public:\n        dj_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"dj\"; }\n        virtual const std::string description() const {\n             return \"Learn logicical disjunction demo\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 174,
        "type": "empty_function",
        "content": "majority_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class majority_problem : public bool_problem_base\n{\n    public:\n        majority_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"maj\"; }\n        virtual const std::string description() const {\n             return \"Majority problem demo\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 197,
        "type": "empty_function",
        "content": "mux_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class mux_problem : public bool_problem_base\n{\n    public:\n        mux_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"mux\"; }\n        virtual const std::string description() const {\n            return \"Multiplex problem demo\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 236,
        "type": "empty_function",
        "content": "polynomial_problem(demo_params& dp) : _dparms(dp) {}",
        "context": "class polynomial_problem : public problem_base\n{\n    public:\n        polynomial_problem(demo_params& dp) : _dparms(dp) {}\n        virtual const std::string name() const { return \"sr\"; }\n        virtual const std::string description() const {\n             return \"Simple regression of f_n(x) = sum_{k={1,n}} x^k\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 304,
        "type": "empty_function",
        "content": "combo_problem_base(demo_params& dp) : _dparms(dp) {}",
        "context": "class combo_problem_base : public problem_base\n{\n    public:\n        combo_problem_base(demo_params& dp) : _dparms(dp) {}\n        void check_args(problem_params&);\n    protected:\n        demo_params& _dparms;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 364,
        "type": "empty_function",
        "content": "combo_problem(demo_params& dp) : combo_problem_base(dp) {}",
        "context": "class combo_problem : public combo_problem_base\n{\n    public:\n        combo_problem(demo_params& dp) : combo_problem_base(dp) {}\n        virtual const std::string name() const { return \"cp\"; }\n        virtual const std::string description() const {\n             return \"Demo: Learn a given combo program\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/demo-problems.cc",
        "line": 454,
        "type": "empty_function",
        "content": "ann_combo_problem(demo_params& dp) : combo_problem_base(dp) {}",
        "context": "class ann_combo_problem : public combo_problem_base\n{\n    public:\n        ann_combo_problem(demo_params& dp) : combo_problem_base(dp) {}\n        virtual const std::string name() const { return \"ann-cp\"; }\n        virtual const std::string description() const {\n             return \"Demo: Learn a given combo program using ANN\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~option_base() {}",
        "context": "class option_base\n{\n    public:\n        virtual ~option_base() {}\n        virtual void add_options(boost::program_options::options_description&) = 0;\n        virtual void parse_options(boost::program_options::variables_map&) {};\n};\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem.h",
        "line": 38,
        "type": "empty_function",
        "content": "virtual void parse_options(boost::program_options::variables_map&) {};",
        "context": "    public:\n        virtual ~option_base() {}\n        virtual void add_options(boost::program_options::options_description&) = 0;\n        virtual void parse_options(boost::program_options::variables_map&) {};\n};\n\nclass option_manager\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem.h",
        "line": 55,
        "type": "empty_function",
        "content": "virtual ~problem_base() {}",
        "context": "class problem_base\n{\n    public:\n        virtual ~problem_base() {}\n        virtual const std::string name() const = 0;\n        virtual const std::string description() const = 0;\n        virtual void run(option_base*) = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 51,
        "type": "empty_function",
        "content": "table_problem_base(table_problem_params& tp) : _tpp(tp) {}",
        "context": "class table_problem_base : public problem_base\n{\npublic:\n    table_problem_base(table_problem_params& tp) : _tpp(tp) {}\n\nprotected:\n    table_problem_params& _tpp;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 90,
        "type": "empty_function",
        "content": ": table_problem_base(tp), _ippp(ip) {}",
        "context": "{\n    public:\n        ip_problem(table_problem_params& tp, ip_problem_params& ip)\n           : table_problem_base(tp), _ippp(ip) {}\n        virtual const std::string name() const { return \"ip\"; }\n        virtual const std::string description() const {\n             return \"Find interesting patterns\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 105,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        ann_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"ann-it\"; }\n        virtual const std::string description() const {\n             return \"ANN-based regression on input table\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 120,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        pre_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"pre\"; }\n        virtual const std::string description() const {\n             return \"Precision-Activation scoring\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 133,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        pre_conj_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"pre-conj\"; }\n        virtual const std::string description() const {\n             return \"Precision-Conjunction-Maximization\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 146,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        prerec_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"prerec\"; }\n        virtual const std::string description() const {\n             return \"Precision Maximization (holding recall constant)\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 159,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        recall_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"recall\"; }\n        virtual const std::string description() const {\n             return \"Recall Maximization (holding precision constant)\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 172,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        bep_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"bep\"; }\n        virtual const std::string description() const {\n             return \"Maximize Break-even Point\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 185,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        f_one_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"f_one\"; }\n        virtual const std::string description() const {\n             return \"Maximize F_1 score\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 198,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        it_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"it\"; }\n        virtual const std::string description() const {\n             return \"Maximize Accuracy\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 211,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        select_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"select\"; }\n        virtual const std::string description() const {\n             return \"Select range of rows\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.h",
        "line": 224,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        cluster_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"cluster\"; }\n        virtual const std::string description() const {\n             return \"Discover clustering function\"; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/ensemble_params.h",
        "line": 39,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\texpalpha(2.0),\n\t\tbias_scale(1.0),\n\t\tnum_to_promote(1)\n\t{}\n\n\tbool do_boosting;    // boosting is enabled ...\n\tbool experts;        // do \"ensemble-of-experts\" boosting.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapop_params.h",
        "line": 116,
        "type": "empty_function",
        "content": "n_tuples(UINT_MAX) {}",
        "context": "        contiguous_time(true),\n        n_subsample_demes(_n_subsample_demes),\n        n_top_candidates(_n_top_candidates),\n        n_tuples(UINT_MAX) {}\n\n    // Subsample by time\n    bool by_time;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapop_params.h",
        "line": 179,
        "type": "empty_function",
        "content": "{}",
        "context": "        diversity(_diversity),\n        merge_callback(NULL),\n        callback_user_data(NULL)\n        {}\n\n    // The max number of candidates considered to be added to the\n    // metapopulation, if negative then all candidates are considered.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 139,
        "type": "empty_function",
        "content": "~metapopulation() {}",
        "context": "                   const metapop_parameters& pa = metapop_parameters(),\n                   const subsample_deme_filter_parameters& subp = subsample_deme_filter_parameters());\n\n    ~metapopulation() {}\n\n    const scored_combo_tree_set& best_candidates() const;\n    const ensemble& get_ensemble() const { return _ensemble; }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 366,
        "type": "empty_function",
        "content": ": _dparams(dparams), misses(0), hits(0) {}",
        "context": "    {\n        // ctor\n        cached_dst(const diversity_parameters& dparams)\n            : _dparams(dparams), misses(0), hits(0) {}\n\n        // We use a std::set instead of a std::pair, little\n        // optimization to deal with the symmetry of the distance\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/moses_main.h",
        "line": 62,
        "type": "empty_function",
        "content": "metapop_printer() {}",
        "context": "/// Print metapopulation results to stdout, logfile, etc.\nstruct metapop_printer\n{\n    metapop_printer() {}\n    metapop_printer(long _result_count,\n                    bool _output_score,\n                    bool _output_cscore,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/moses_main.h",
        "line": 88,
        "type": "empty_function",
        "content": "is_mpi(_is_mpi) {}",
        "context": "        ilabels(_ilabels),\n        output_file(_output_file),\n        fmt(_fmt),\n        is_mpi(_is_mpi) {}\n\n    /**\n     * Print metapopulation summary.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/moses_params.h",
        "line": 53,
        "type": "empty_function",
        "content": "{}",
        "context": "        local(_local), mpi(false), force_feed(false), jobs(_jobs), vm(_vm),\n        max_evals(_max_evals), max_gens(_max_gens), max_score(_max_score),\n        max_time(INT_MAX), max_cnd_output(_max_cnd_output)\n    {}\n\n    // Distributed solver control.\n    bool local;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/moses_params.h",
        "line": 86,
        "type": "empty_function",
        "content": "{}",
        "context": "struct moses_statistics\n{\n    moses_statistics() : n_evals(0), n_expansions(0), elapsed_secs(0)\n    {}\n\n    // total number of scoring function evaluations\n    std::atomic<int> n_evals;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 354,
        "type": "empty_function",
        "content": "worker_node() : rank(-1) {}",
        "context": "\nstruct worker_node\n{\n   worker_node() : rank(-1) {}\n   int rank;\n};\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.cc",
        "line": 44,
        "type": "empty_function",
        "content": ": string(to_string(expansion)) {}",
        "context": "using namespace std;\n\ndemeID_t::demeID_t(unsigned expansion)\n    : string(to_string(expansion)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first)\n    : string(to_string(expansion) + \".\" + to_string(breadth_first)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.cc",
        "line": 46,
        "type": "empty_function",
        "content": ": string(to_string(expansion) + \".\" + to_string(breadth_first)) {}",
        "context": "demeID_t::demeID_t(unsigned expansion)\n    : string(to_string(expansion)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first)\n    : string(to_string(expansion) + \".\" + to_string(breadth_first)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n    : string(to_string(expansion) + \".\" +\n             to_string(breadth_first) + \".SS-\" +\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.cc",
        "line": 50,
        "type": "empty_function",
        "content": "to_string(ss_deme)) {}",
        "context": "demeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n    : string(to_string(expansion) + \".\" +\n             to_string(breadth_first) + \".SS-\" +\n             to_string(ss_deme)) {}\n\nbool scored_combo_tree::operator==(const scored_combo_tree& r) const {\n    return get_tree() == r.get_tree()\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.cc",
        "line": 118,
        "type": "empty_function",
        "content": "{}",
        "context": "    : score(very_worst_score), complexity(least_complexity),\n      complexity_penalty(0.0), uniformity_penalty(0.0),\n      penalized_score(very_worst_score)\n{}\n\ncomposite_score& composite_score::operator=(const composite_score &r)\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 214,
        "type": "empty_function",
        "content": "behavioral_score() {}",
        "context": "// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 215,
        "type": "empty_function",
        "content": "behavioral_score(size_t sz) : std::vector<score_t>(sz) {}",
        "context": "struct behavioral_score : public std::vector<score_t>\n{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 216,
        "type": "empty_function",
        "content": "behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}",
        "context": "{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 218,
        "type": "empty_function",
        "content": ": std::vector<score_t>(il) {}",
        "context": "    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n\n    std::vector<score_t> operator-=(const std::vector<score_t>& rhs)\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 267,
        "type": "empty_function",
        "content": "{}",
        "context": "                      composite_score cs = composite_score(),\n                      behavioral_score bs = behavioral_score())\n        : _tree(tr), _deme_id(id), _cscore(cs), _bscore(bs), _weight(1.0)\n    {}\n\nprivate:\n    combo::combo_tree _tree;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/hill-climbing.h",
        "line": 187,
        "type": "empty_function",
        "content": "{}",
        "context": "    hill_climbing(const optim_parameters& op = optim_parameters(),\n                  const hc_parameters& hc = hc_parameters())\n        : optimizer_base(op), hc_params(hc), _total_RAM_bytes(getTotalRAM())\n    {}\n\nprotected:\n    // log legend for graph stats\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/optimization.h",
        "line": 149,
        "type": "empty_function",
        "content": "{}",
        "context": "          , hiscore(0.0), hicount(0.0),\n          num_improved(0.0), count_improved(0.0)\n#endif\n    {}\n    unsigned nsteps;\n    demeID_t demeID;\n    unsigned total_steps;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/optimization.h",
        "line": 177,
        "type": "empty_function",
        "content": ": opt_params(op) {}",
        "context": "struct optimizer_base : optim_stats\n{\n    optimizer_base(const optim_parameters& op = optim_parameters())\n        : opt_params(op) {}\n\n    virtual void operator()(deme_t& deme,\n                            const iscorer_base& iscorer,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/optimization.h",
        "line": 184,
        "type": "empty_function",
        "content": "virtual ~optimizer_base() {}",
        "context": "                            unsigned max_evals,\n                            time_t max_time) = 0;\n\n    virtual ~optimizer_base() {}\n\n    optim_parameters opt_params;\n};\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 159,
        "type": "empty_function",
        "content": ": optimizer_base(op), _total_RAM_bytes(getTotalRAM()), ps_params(ps) {}",
        "context": "{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n                    const ps_parameters& ps = ps_parameters())\n        : optimizer_base(op), _total_RAM_bytes(getTotalRAM()), ps_params(ps) {}\n\nprotected:\n    // Variables:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 173,
        "type": "empty_function",
        "content": "best_personal(part_size, std::vector<double>(disc_size)) {}",
        "context": "        std::vector<std::vector<double>> temp, best_personal;\n        discrete_particles(unsigned part_size, unsigned disc_size) :\n            temp(part_size, std::vector<double>(disc_size)),\n            best_personal(part_size, std::vector<double>(disc_size)) {}\n    };\n\n    // Functions (Better explanation in declaration):\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/star-anneal.h",
        "line": 51,
        "type": "empty_function",
        "content": "max_new_instances(100) {}",
        "context": "        min_temp(0),\n        temp_step_size(0.5),\n        accept_prob_temp_intensity(0.5),\n        max_new_instances(100) {}\n\n    double init_temp;\n    double min_temp;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/star-anneal.h",
        "line": 91,
        "type": "empty_function",
        "content": ": optimizer_base(op), sa_params(sa) {}",
        "context": "\n    simulated_annealing(const optim_parameters& op = optim_parameters(),\n                        const sa_parameters& sa = sa_parameters())\n        : optimizer_base(op), sa_params(sa) {}\n\n    double accept_probability(energy_t energy_new, energy_t energy_old,\n                              double temperature)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/univariate.h",
        "line": 48,
        "type": "empty_function",
        "content": "{}",
        "context": "        replacement_ratio(0.5),//ratio of population size sampled and integrated\n\n        model_complexity(1)    //model parsimony term log(N)*model_complexity\n    {}\n\n    bool is_tournament_selection() {\n        return selection > 1;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/univariate.h",
        "line": 67,
        "type": "empty_function",
        "content": ": optimizer_base(op), eda_params(ep) {}",
        "context": "{\n    univariate_optimization(const optim_parameters& op = optim_parameters(),\n                            const eda_parameters& ep = eda_parameters())\n        : optimizer_base(op), eda_params(ep) {}\n\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 139,
        "type": "empty_function",
        "content": "field() { }",
        "context": "     */\n    struct field\n    {\n        field() { }\n        field(width_t w, size_t ma, size_t mi)\n                : width(w), major_offset(ma), minor_offset(mi) { }\n        width_t width;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 141,
        "type": "empty_function",
        "content": ": width(w), major_offset(ma), minor_offset(mi) { }",
        "context": "    {\n        field() { }\n        field(width_t w, size_t ma, size_t mi)\n                : width(w), major_offset(ma), minor_offset(mi) { }\n        width_t width;\n        size_t major_offset, minor_offset;\n    };\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 153,
        "type": "empty_function",
        "content": "disc_spec(multiplicity_t a) : multy(a) { }",
        "context": "     */\n    struct disc_spec\n    {\n        disc_spec(multiplicity_t a) : multy(a) { }\n        multiplicity_t multy;\n        bool operator<(const disc_spec& rhs) const { //sort descending by multy\n            return multy > rhs.multy;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 183,
        "type": "empty_function",
        "content": ": mean(m), step_size(ss), expansion(ex), depth(d) { }",
        "context": "    struct contin_spec\n    {\n        contin_spec(contin_t m, contin_t ss, contin_t ex, depth_t d)\n                : mean(m), step_size(ss), expansion(ex), depth(d) { }\n        contin_t mean, step_size, expansion;\n        depth_t depth;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 237,
        "type": "empty_function",
        "content": "_all_left(true), _all_right(true), _step_size(c.step_size) { }",
        "context": "    {\n        contin_stepper(const contin_spec& c_)\n                : c(c_), value(c.mean),\n                _all_left(true), _all_right(true), _step_size(c.step_size) { }\n        const contin_spec& c;\n        contin_t value;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 288,
        "type": "empty_function",
        "content": "branching(next_power_of_two(1 + t.max_branching(t.begin()))) { }",
        "context": "    {\n        term_spec(const term_tree& t)\n                : tr(&t), depth(t.max_depth(t.begin())),\n                branching(next_power_of_two(1 + t.max_branching(t.begin()))) { }\n        // @todo: could be a source of bug if such order is not total\n        // as it's gonna make problems with field_set(from, to)\n        bool operator<(const term_spec& rhs) const { //sort descending by size\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 848,
        "type": "empty_function",
        "content": ": _it(it), _mask(packed_t(1) << offset) { }",
        "context": "\n    protected:\n        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 849,
        "type": "empty_function",
        "content": "bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }",
        "context": "    protected:\n        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n        Iterator _it; // instance iterator\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 850,
        "type": "empty_function",
        "content": "bit_iterator_base() : _it(), _mask(0) { }",
        "context": "        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n        Iterator _it; // instance iterator\n        packed_t _mask; // mask over the packed_t pointed by _it,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 865,
        "type": "empty_function",
        "content": "reference(const Iterator* it, size_t idx) : _it(it), _idx(idx) { }",
        "context": "\n        struct reference\n        {\n            reference(const Iterator* it, size_t idx) : _it(it), _idx(idx) { }\n\n            operator Value() const {\n                return do_get();\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 930,
        "type": "empty_function",
        "content": "iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }",
        "context": "            return _idx;\n        }\n    protected:\n        iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }\n        iterator_base() : _fs(NULL), _idx(0) { }\n\n        const field_set* _fs;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 931,
        "type": "empty_function",
        "content": "iterator_base() : _fs(NULL), _idx(0) { }",
        "context": "        }\n    protected:\n        iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }\n        iterator_base() : _fs(NULL), _idx(0) { }\n\n        const field_set* _fs;\n        size_t _idx;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 946,
        "type": "empty_function",
        "content": ": _it(it), _mask(mask) {}",
        "context": "        struct reference\n        {\n            reference(instance::iterator it, packed_t mask)\n                : _it(it), _mask(mask) {}\n\n            operator bool() const {\n                return (*_it & _mask) != 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1006,
        "type": "empty_function",
        "content": "bit_iterator() { }",
        "context": "        }\n        friend class const_bit_iterator;\n\n        bit_iterator() { }\n    protected:\n        bit_iterator(instance::iterator it, width_t offset)\n            : bit_iterator_base<bit_iterator, instance::iterator>(it, offset)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1010,
        "type": "empty_function",
        "content": "{ }",
        "context": "    protected:\n        bit_iterator(instance::iterator it, width_t offset)\n            : bit_iterator_base<bit_iterator, instance::iterator>(it, offset)\n        { }\n    };\n\n    struct const_bit_iterator\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1022,
        "type": "empty_function",
        "content": "instance::const_iterator > (bi._mask, bi._it) { }",
        "context": "        }\n        const_bit_iterator(const bit_iterator& bi)\n            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (bi._mask, bi._it) { }\n\n        const_bit_iterator() { }\n    protected:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1024,
        "type": "empty_function",
        "content": "const_bit_iterator() { }",
        "context": "            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (bi._mask, bi._it) { }\n\n        const_bit_iterator() { }\n    protected:\n        const_bit_iterator(instance::const_iterator it, width_t offset)\n            : bit_iterator_base < const_bit_iterator,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1028,
        "type": "empty_function",
        "content": "instance::const_iterator > (it, offset) { }",
        "context": "    protected:\n        const_bit_iterator(instance::const_iterator it, width_t offset)\n            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (it, offset) { }\n    };\n\n    // --------------------------------------------------------\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1043,
        "type": "empty_function",
        "content": "disc_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        disc_iterator() : _inst(NULL) { }\n\n        // For convenience.\n        multiplicity_t multy() const\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1060,
        "type": "empty_function",
        "content": ": iterator_base<disc_iterator, disc_t>(fs, idx), _inst(&inst) { }",
        "context": "\n    protected:\n        disc_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<disc_iterator, disc_t>(fs, idx), _inst(&inst) { }\n        instance* _inst;\n    };\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1075,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_disc_iterator(const disc_iterator& bi) :\n            iterator_base<const_disc_iterator, disc_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_disc_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1077,
        "type": "empty_function",
        "content": "const_disc_iterator() : _inst(NULL) { }",
        "context": "            iterator_base<const_disc_iterator, disc_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_disc_iterator() : _inst(NULL) { }\n\n        // For convenience.\n        multiplicity_t multy() const\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1089,
        "type": "empty_function",
        "content": ": iterator_base<const_disc_iterator, disc_t>(fs, idx), _inst(&inst) { }",
        "context": "\n    protected:\n        const_disc_iterator(const field_set& fs, size_t idx, const instance& inst)\n            : iterator_base<const_disc_iterator, disc_t>(fs, idx), _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1105,
        "type": "empty_function",
        "content": "contin_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        contin_iterator() : _inst(NULL) { }\n\n    protected:\n        contin_iterator(const field_set& fs, size_t idx, instance& inst)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1110,
        "type": "empty_function",
        "content": "{ }",
        "context": "    protected:\n        contin_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<contin_iterator, contin_t>(fs, idx), _inst(&inst)\n        { }\n        instance* _inst;\n    };\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1126,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_contin_iterator(const contin_iterator& bi)\n            : iterator_base<const_contin_iterator, contin_t>(*bi._fs, bi._idx),\n              _inst(bi._inst) { }\n\n        const_contin_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1128,
        "type": "empty_function",
        "content": "const_contin_iterator() : _inst(NULL) { }",
        "context": "            : iterator_base<const_contin_iterator, contin_t>(*bi._fs, bi._idx),\n              _inst(bi._inst) { }\n\n        const_contin_iterator() : _inst(NULL) { }\n\n    protected:\n        const_contin_iterator(const field_set& fs, size_t idx,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1134,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "        const_contin_iterator(const field_set& fs, size_t idx,\n                              const instance& inst)\n            : iterator_base<const_contin_iterator, contin_t>(fs, idx),\n              _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1152,
        "type": "empty_function",
        "content": "term_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        term_iterator() : _inst(NULL) { }\n\n    protected:\n        term_iterator(const field_set& fs, size_t idx, instance& inst)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1157,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "    protected:\n        term_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<term_iterator, term_t>(fs, idx),\n              _inst(&inst) { }\n\n        instance* _inst;\n    };\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1174,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_term_iterator(const term_iterator& bi) :\n            iterator_base<const_term_iterator, term_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_term_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1176,
        "type": "empty_function",
        "content": "const_term_iterator() : _inst(NULL) { }",
        "context": "            iterator_base<const_term_iterator, term_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_term_iterator() : _inst(NULL) { }\n\n    protected:\n        const_term_iterator(const field_set& fs, size_t idx,\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/field_set.h",
        "line": 1182,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "        const_term_iterator(const field_set& fs, size_t idx,\n                            const instance& inst)\n            : iterator_base<const_term_iterator, term_t>(fs, idx),\n              _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance.h",
        "line": 58,
        "type": "empty_function",
        "content": "hsh ^= std::hash<unsigned long int>{}(bs)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (unsigned long int bs: nstc)\n\t\t\t\thsh ^= std::hash<unsigned long int>{}(bs)\n\t\t\t\t      + 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 40,
        "type": "empty_function",
        "content": "virtual ~iscorer_base() {}",
        "context": "    typedef instance argument_type;\n    typedef composite_score result_type;\n    virtual composite_score operator()(const instance&) const = 0;\n    virtual ~iscorer_base() {}\n};\n\n/**\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 52,
        "type": "empty_function",
        "content": ": fs(_fs), target_inst(_target_inst) {}",
        "context": "{\n    distance_based_scorer(const field_set& _fs,\n                          const instance& _target_inst)\n        : fs(_fs), target_inst(_target_inst) {}\n\n    composite_score operator()(const instance& inst) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 76,
        "type": "empty_function",
        "content": ": _cscorer(cs), _rep(rep), _reduce(reduce) {}",
        "context": "{\n    complexity_based_scorer(behave_cscore& cs,\n                            representation& rep, bool reduce)\n        : _cscorer(cs), _rep(rep), _reduce(reduce) {}\n\n    composite_score operator()(const instance& inst) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_set.h",
        "line": 76,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create a deme initialized with n null instances.\n    instance_set(unsigned int n, MAYBE_CONST field_set& fs)\n        : super(n, instance(fs.packed_width())), _fields(fs),\n          n_evals(0), n_best_evals(0) {}\n    // Create a deme initialized with n instances of inst.\n    instance_set(unsigned int n, const instance& inst, MAYBE_CONST field_set& fs)\n        : super(n, inst), _fields(fs),\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_set.h",
        "line": 80,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create a deme initialized with n instances of inst.\n    instance_set(unsigned int n, const instance& inst, MAYBE_CONST field_set& fs)\n        : super(n, inst), _fields(fs),\n          n_evals(0), n_best_evals(0) {}\n    // Create an empty deme.\n    instance_set(MAYBE_CONST field_set& fs, const demeID_t& id = demeID_t())\n        : _fields(fs), _id(id),\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_set.h",
        "line": 84,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create an empty deme.\n    instance_set(MAYBE_CONST field_set& fs, const demeID_t& id = demeID_t())\n        : _fields(fs), _id(id),\n          n_evals(0), n_best_evals(0) {}\n\n#ifdef GCC46_EMPLACE_BACK_WORKAROUND\n    instance_set<ScoreT>& operator=(const instance_set<ScoreT>& rhs) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.cc",
        "line": 39,
        "type": "empty_function",
        "content": "step_size, expansion, depth) { }",
        "context": "                         contin_t step_size, contin_t expansion,\n                         field_set::width_t depth)\n    : knob_base(tr, tgt), _spec(combo::get_contin(*tgt),\n                                step_size, expansion, depth) { }\n\nbool contin_knob::in_exemplar() const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.cc",
        "line": 46,
        "type": "empty_function",
        "content": "void contin_knob::clear_exemplar() { }",
        "context": "    return true;\n}\n\nvoid contin_knob::clear_exemplar() { }\n\nvoid contin_knob::turn(contin_t x)\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 61,
        "type": "empty_function",
        "content": ": _tr(tr), _loc(loc) {}",
        "context": "struct knob_base\n{\n    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 62,
        "type": "empty_function",
        "content": "knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}",
        "context": "{\n    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n    // Is the feature nonzero by default? i.e., is it present in the exemplar?\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 63,
        "type": "empty_function",
        "content": "virtual ~knob_base() { }",
        "context": "    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n    // Is the feature nonzero by default? i.e., is it present in the exemplar?\n    virtual bool in_exemplar() const = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 87,
        "type": "empty_function",
        "content": ": knob_base(tr, tgt) {}",
        "context": "struct disc_knob_base : public knob_base\n{\n    disc_knob_base(combo_tree& tr, combo_tree::iterator tgt)\n        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 89,
        "type": "empty_function",
        "content": ": knob_base(tr) {}",
        "context": "    disc_knob_base(combo_tree& tr, combo_tree::iterator tgt)\n        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n\n    virtual void turn(int) = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 90,
        "type": "empty_function",
        "content": "virtual ~disc_knob_base() {}",
        "context": "        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n\n    virtual void turn(int) = 0;\n    virtual void disallow(int) = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 175,
        "type": "empty_function",
        "content": ": disc_knob_base(tr, tgt), _default(0), _current(0) {}",
        "context": "struct discrete_knob : public disc_knob_base\n{\n    discrete_knob(combo_tree& tr, combo_tree::iterator tgt)\n        : disc_knob_base(tr, tgt), _default(0), _current(0) {}\n    discrete_knob(combo_tree& tr)\n        : disc_knob_base(tr), _default(0), _current(0) {}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/knobs.h",
        "line": 177,
        "type": "empty_function",
        "content": ": disc_knob_base(tr), _default(0), _current(0) {}",
        "context": "    discrete_knob(combo_tree& tr, combo_tree::iterator tgt)\n        : disc_knob_base(tr, tgt), _default(0), _current(0) {}\n    discrete_knob(combo_tree& tr)\n        : disc_knob_base(tr), _default(0), _current(0) {}\n\n    /// Do not allow setting to be set.\n    void disallow(int setting) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/scored_instance.h",
        "line": 38,
        "type": "empty_function",
        "content": "scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }",
        "context": "{\n    typedef tagged_item<instance, ScoreT> super;\n\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/scored_instance.h",
        "line": 39,
        "type": "empty_function",
        "content": "scored_instance(const instance& i) : super(i) { }",
        "context": "    typedef tagged_item<instance, ScoreT> super;\n\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/scored_instance.h",
        "line": 40,
        "type": "empty_function",
        "content": "scored_instance() { }",
        "context": "\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/scored_instance.h",
        "line": 42,
        "type": "empty_function",
        "content": "scored_instance(const std::pair<T1, T2>& p) : super(p) { }",
        "context": "    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n\n    bool operator<(const scored_instance& other) const\n    {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.h",
        "line": 451,
        "type": "empty_function",
        "content": "{}",
        "context": "{\n    enum_filter_bscore(const CTable& ctt)\n        : enum_table_bscore(ctt), punish(1.0)\n    {}\n\n    behavioral_score operator()(const combo_tree& tr) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.h",
        "line": 495,
        "type": "empty_function",
        "content": "{}",
        "context": "{\n    enum_graded_bscore(const CTable& ctt)\n        : enum_table_bscore(ctt), grading(0.9)\n    {}\n\n    behavioral_score operator()(const combo_tree&) const;\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 59,
        "type": "empty_function",
        "content": "bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};",
        "context": "/// A behavioral score is a vector of scores, one per sample of a dataset.\nstruct bscore_base\n{\n    bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};\n    virtual ~bscore_base() {};\n\n    /// Return the behavioral score for the combo_tree\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual ~bscore_base() {};",
        "context": "struct bscore_base\n{\n    bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};\n    virtual ~bscore_base() {};\n\n    /// Return the behavioral score for the combo_tree\n    virtual behavioral_score operator()(const combo_tree&) const = 0;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 170,
        "type": "empty_function",
        "content": "virtual void ignore_cols(const std::set<arity_t>&) const {}",
        "context": "    /// new index set is ignored.  Thus, calling this with the empty set\n    /// will have the effect of restoring all columns that were previously\n    /// ignored.\n    virtual void ignore_cols(const std::set<arity_t>&) const {}\n\n    /// In case one wants to evaluate the fitness on a subset of the\n    /// data, one can provide a set of row indexes to ignore.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 179,
        "type": "empty_function",
        "content": "virtual void ignore_rows(const std::set<unsigned>&) const {}",
        "context": "    /// previously ignored rows will be restored, before the\n    /// newly-specified rows are removed.  Thus, calling this with the\n    /// empty set has the effect of restoring all ignored rows.\n    virtual void ignore_rows(const std::set<unsigned>&) const {}\n\n    // Like ignore_rows but consider timestamps instead of indexes\n    virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.h",
        "line": 182,
        "type": "empty_function",
        "content": "virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}",
        "context": "    virtual void ignore_rows(const std::set<unsigned>&) const {}\n\n    // Like ignore_rows but consider timestamps instead of indexes\n    virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}\n\n    // Return the uncompressed size of the CTable\n    virtual unsigned get_ctable_usize() const {\n"
      },
      {
        "file": "components/learning/moses/scripts/parse_log.py",
        "line": 16,
        "type": "empty_function",
        "content": "header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)",
        "context": "    # Define the regex for header and content\n    timestamp_re = r'\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}:\\d{3}\\]'\n    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n"
      },
      {
        "file": "components/learning/moses/scripts/parse_log.py",
        "line": 17,
        "type": "empty_function",
        "content": "content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)",
        "context": "    timestamp_re = r'\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}:\\d{3}\\]'\n    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n"
      },
      {
        "file": "components/learning/moses/scripts/parse_log.py",
        "line": 18,
        "type": "empty_function",
        "content": "all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)",
        "context": "    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n    all_content_cre = re.compile(all_content_re)\n"
      },
      {
        "file": "components/learning/moses/scripts/parse_log.py",
        "line": 19,
        "type": "empty_function",
        "content": "all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)",
        "context": "    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n    all_content_cre = re.compile(all_content_re)\n\n"
      },
      {
        "file": "distributed-cognition/include/TensorHypergraphProtocol.h",
        "line": 60,
        "type": "empty_function",
        "content": "MessageBuffer(size_t max_size = 1000) : max_buffer_size_(max_size) {}",
        "context": "    std::mutex buffer_mutex_;\n    \npublic:\n    MessageBuffer(size_t max_size = 1000) : max_buffer_size_(max_size) {}\n    \n    void add_message(const TensorMessage& message);\n    std::vector<TensorMessage> flush_buffer();\n"
      },
      {
        "file": "distributed-cognition/src/DistributedAtomSpaceSync.cc",
        "line": 199,
        "type": "empty_function",
        "content": "//void DistributedAtomSpaceSync::unsubscribe_from_atom(const std::string& agent_id, const std::string& atom_id) {}",
        "context": "\n//<<<<<<< copilot/fix-17\n// Implementation of remaining synchronization methods\n//void DistributedAtomSpaceSync::unsubscribe_from_atom(const std::string& agent_id, const std::string& atom_id) {}\n//AtomSyncRecord DistributedAtomSpaceSync::resolve_conflict(const std::vector<AtomSyncRecord>& conflicting_records) { return AtomSyncRecord(); }\n//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}\n//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}\n"
      },
      {
        "file": "distributed-cognition/src/DistributedAtomSpaceSync.cc",
        "line": 201,
        "type": "empty_function",
        "content": "//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}",
        "context": "// Implementation of remaining synchronization methods\n//void DistributedAtomSpaceSync::unsubscribe_from_atom(const std::string& agent_id, const std::string& atom_id) {}\n//AtomSyncRecord DistributedAtomSpaceSync::resolve_conflict(const std::vector<AtomSyncRecord>& conflicting_records) { return AtomSyncRecord(); }\n//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}\n//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}\n//std::vector<std::string> DistributedAtomSpaceSync::get_pending_sync_atoms(const std::string& agent_id) { return {}; }\n//void DistributedAtomSpaceSync::mark_atom_synchronized(const std::string& agent_id, const std::string& atom_id) {}\n"
      },
      {
        "file": "distributed-cognition/src/DistributedAtomSpaceSync.cc",
        "line": 202,
        "type": "empty_function",
        "content": "//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}",
        "context": "//void DistributedAtomSpaceSync::unsubscribe_from_atom(const std::string& agent_id, const std::string& atom_id) {}\n//AtomSyncRecord DistributedAtomSpaceSync::resolve_conflict(const std::vector<AtomSyncRecord>& conflicting_records) { return AtomSyncRecord(); }\n//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}\n//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}\n//std::vector<std::string> DistributedAtomSpaceSync::get_pending_sync_atoms(const std::string& agent_id) { return {}; }\n//void DistributedAtomSpaceSync::mark_atom_synchronized(const std::string& agent_id, const std::string& atom_id) {}\n//bool DistributedAtomSpaceSync::is_atom_fully_synchronized(const std::string& atom_id) { return true; }\n"
      },
      {
        "file": "distributed-cognition/src/DistributedAtomSpaceSync.cc",
        "line": 203,
        "type": "empty_function",
        "content": "//std::vector<std::string> DistributedAtomSpaceSync::get_pending_sync_atoms(const std::string& agent_id) { return {}; }",
        "context": "//AtomSyncRecord DistributedAtomSpaceSync::resolve_conflict(const std::vector<AtomSyncRecord>& conflicting_records) { return AtomSyncRecord(); }\n//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}\n//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}\n//std::vector<std::string> DistributedAtomSpaceSync::get_pending_sync_atoms(const std::string& agent_id) { return {}; }\n//void DistributedAtomSpaceSync::mark_atom_synchronized(const std::string& agent_id, const std::string& atom_id) {}\n//bool DistributedAtomSpaceSync::is_atom_fully_synchronized(const std::string& atom_id) { return true; }\n//=======\n"
      },
      {
        "file": "distributed-cognition/src/DistributedAtomSpaceSync.cc",
        "line": 204,
        "type": "empty_function",
        "content": "//void DistributedAtomSpaceSync::mark_atom_synchronized(const std::string& agent_id, const std::string& atom_id) {}",
        "context": "//void DistributedAtomSpaceSync::set_custom_conflict_resolver(std::function<AtomSyncRecord(const std::vector<AtomSyncRecord>&)> resolver) {}\n//void DistributedAtomSpaceSync::update_agent_reliability(const std::string& agent_id, double new_score) {}\n//std::vector<std::string> DistributedAtomSpaceSync::get_pending_sync_atoms(const std::string& agent_id) { return {}; }\n//void DistributedAtomSpaceSync::mark_atom_synchronized(const std::string& agent_id, const std::string& atom_id) {}\n//bool DistributedAtomSpaceSync::is_atom_fully_synchronized(const std::string& atom_id) { return true; }\n//=======\n// Real implementations for straightforward methods\n"
      },
      {
        "file": "distributed-cognition/src/MultiAgentStressTest.cc",
        "line": 21,
        "type": "empty_function",
        "content": ", rng_(std::random_device{}())",
        "context": "    , communication_protocol_(std::make_unique<TensorHypergraphProtocol>())\n    , atomspace_sync_(std::make_unique<DistributedAtomSpaceSync>())\n    , test_running_(false)\n    , rng_(std::random_device{}())\n    , uniform_dist_(0.0, 1.0)\n{\n    std::cout << \"MultiAgentStressTest framework initialized\" << std::endl;\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 147,
        "type": "empty_function",
        "content": "self.agents = {}",
        "context": "    \n    def __init__(self, api_host: str = \"localhost\", api_port: int = 8080):\n        self.api_base_url = f\"http://{api_host}:{api_port}/api/v1\"\n        self.agents = {}\n    \n    def test_api_connectivity(self) -> bool:\n        \"\"\"Test API server connectivity\"\"\"\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 217,
        "type": "empty_function",
        "content": "return {}",
        "context": "                return response.json()\n        except:\n            pass\n        return {}\n    \n    def get_embodiment_tensor(self, agent_id: str) -> Dict:\n        \"\"\"Get embodiment tensor data\"\"\"\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 227,
        "type": "empty_function",
        "content": "return {}",
        "context": "                return response.json()\n        except:\n            pass\n        return {}\n\nclass WebSocketStreamDemo:\n    \"\"\"Demonstrates real-time WebSocket streaming\"\"\"\n"
      },
      {
        "file": "distributed-cognitive-mesh/demo_phase4.py",
        "line": 269,
        "type": "empty_function",
        "content": "\"filters\": {}",
        "context": "        subscription = {\n            \"type\": \"subscribe\",\n            \"message_types\": [\"cognitive_state_update\", \"embodiment_tensor_update\"],\n            \"filters\": {}\n        }\n        ws.send(json.dumps(subscription))\n    \n"
      },
      {
        "file": "documentation/hooks/EmergentPhenomenaObserver.h",
        "line": 85,
        "type": "empty_function",
        "content": "const std::map<std::string, std::string>& context = {},",
        "context": "    void observe_phenomenon(EventType type,\n                          const std::string& source_component,\n                          const std::string& description,\n                          const std::map<std::string, std::string>& context = {},\n                          const std::map<std::string, double>& metrics = {});\n\n    /**\n"
      },
      {
        "file": "documentation/hooks/EmergentPhenomenaObserver.h",
        "line": 86,
        "type": "empty_function",
        "content": "const std::map<std::string, double>& metrics = {});",
        "context": "                          const std::string& source_component,\n                          const std::string& description,\n                          const std::map<std::string, std::string>& context = {},\n                          const std::map<std::string, double>& metrics = {});\n\n    /**\n     * Observe pattern emergence from HypergraphPatternExtractor\n"
      },
      {
        "file": "documentation/hooks/EmergentPhenomenaObserver.h",
        "line": 130,
        "type": "empty_function",
        "content": "std::chrono::system_clock::time_point start_time = {},",
        "context": "     */\n    std::vector<ObservationEvent> get_observations(\n        EventType type = EventType::PATTERN_EMERGENCE,\n        std::chrono::system_clock::time_point start_time = {},\n        std::chrono::system_clock::time_point end_time = {}) const;\n\n    /**\n"
      },
      {
        "file": "documentation/hooks/EmergentPhenomenaObserver.h",
        "line": 131,
        "type": "empty_function",
        "content": "std::chrono::system_clock::time_point end_time = {}) const;",
        "context": "    std::vector<ObservationEvent> get_observations(\n        EventType type = EventType::PATTERN_EMERGENCE,\n        std::chrono::system_clock::time_point start_time = {},\n        std::chrono::system_clock::time_point end_time = {}) const;\n\n    /**\n     * Generate automatic documentation for significant observations\n"
      },
      {
        "file": "entelechy/introspector.py",
        "line": 46,
        "type": "empty_function",
        "content": "self.dimensional_insights = {}",
        "context": "        )\n        self.component_config = None\n        self.integration_data = None\n        self.dimensional_insights = {}\n        \n    def perform_deep_introspection(self) -> Dict:\n        \"\"\"\n"
      },
      {
        "file": "entelechy/introspector.py",
        "line": 202,
        "type": "empty_function",
        "content": "results = {}",
        "context": "            'integration': ['opencog']\n        }\n        \n        results = {}\n        for layer_name, components in layers.items():\n            present = [c for c in components if (self.repo_path / c).exists()]\n            results[layer_name] = {\n"
      },
      {
        "file": "entelechy/introspector.py",
        "line": 272,
        "type": "empty_function",
        "content": "phase_assessment = {}",
        "context": "            }\n        }\n        \n        phase_assessment = {}\n        for phase_id, phase_data in phases.items():\n            components = phase_data['components']\n            present_count = sum(1 for c in components if (self.repo_path / c).exists())\n"
      },
      {
        "file": "entelechy/optimizer.py",
        "line": 263,
        "type": "empty_function",
        "content": "dimension_improvements = {}",
        "context": "        avg_fitness_gain = total_fitness_gain / len(self.evolution_history)\n        \n        # Identify most improved dimension\n        dimension_improvements = {}\n        for record in self.evolution_history:\n            dim = record['dimension_improved']\n            dimension_improvements[dim] = dimension_improvements.get(dim, 0) + 1\n"
      },
      {
        "file": "evolutionary-optimization/src/EvolutionaryOptimizer.cc",
        "line": 62,
        "type": "empty_function",
        "content": "std::to_string(std::hash<std::string>{}(std::to_string(dis(gen))));",
        "context": "    offspring.fitness_score = 0.0;\n    offspring.generation = std::max(generation, other.generation) + 1;\n    offspring.genome_id = \"offspring_\" + std::to_string(offspring.generation) + \"_\" + \n                          std::to_string(std::hash<std::string>{}(std::to_string(dis(gen))));\n    \n    return offspring;\n}\n"
      },
      {
        "file": "evolutionary-optimization/src/EvolutionaryOptimizer.cc",
        "line": 320,
        "type": "empty_function",
        "content": "elite_ratio_(0.1), rng_(std::random_device{}()),",
        "context": "EvolutionaryOptimizer::EvolutionaryOptimizer(int population_size, int max_generations)\n    : population_size_(population_size), max_generations_(max_generations),\n      current_generation_(0), mutation_rate_(0.1), crossover_rate_(0.8),\n      elite_ratio_(0.1), rng_(std::random_device{}()),\n      uniform_dist_(0.0, 1.0), normal_dist_(0.0, 1.0),\n      adaptive_mutation_(true), adaptive_selection_(true)\n{\n"
      },
      {
        "file": "evolutionary-optimization/src/EvolutionaryOptimizer.cc",
        "line": 574,
        "type": "empty_function",
        "content": "return CognitiveGenome{}; // Return empty genome",
        "context": "\nCognitiveGenome EvolutionaryOptimizer::get_best_genome() const {\n    if (population_.empty()) {\n        return CognitiveGenome{}; // Return empty genome\n    }\n    \n    auto best_it = std::max_element(population_.begin(), population_.end(),\n"
      },
      {
        "file": "evolutionary-optimization/src/EvolutionaryOptimizer.cc",
        "line": 712,
        "type": "empty_function",
        "content": "genome.genome_id = \"random_\" + std::to_string(std::hash<std::string>{}(std::to_string(uniform_dist_(rng_))));",
        "context": "    \n    genome.fitness_score = 0.0;\n    genome.generation = 0;\n    genome.genome_id = \"random_\" + std::to_string(std::hash<std::string>{}(std::to_string(uniform_dist_(rng_))));\n    \n    return genome;\n}\n"
      },
      {
        "file": "ggml-tensor-kernel/test_cognitive_primitives.py",
        "line": 33,
        "type": "empty_function",
        "content": "self.test_results = {}",
        "context": "    \"\"\"Comprehensive test suite for cognitive primitive functionality\"\"\"\n    \n    def __init__(self):\n        self.test_results = {}\n        self.performance_metrics = {}\n        self.memory_metrics = {}\n        \n"
      },
      {
        "file": "ggml-tensor-kernel/test_cognitive_primitives.py",
        "line": 34,
        "type": "empty_function",
        "content": "self.performance_metrics = {}",
        "context": "    \n    def __init__(self):\n        self.test_results = {}\n        self.performance_metrics = {}\n        self.memory_metrics = {}\n        \n    def run_all_tests(self):\n"
      },
      {
        "file": "ggml-tensor-kernel/test_cognitive_primitives.py",
        "line": 35,
        "type": "empty_function",
        "content": "self.memory_metrics = {}",
        "context": "    def __init__(self):\n        self.test_results = {}\n        self.performance_metrics = {}\n        self.memory_metrics = {}\n        \n    def run_all_tests(self):\n        \"\"\"Run all cognitive primitive tests\"\"\"\n"
      },
      {
        "file": "ggml-tensor-kernel/include/TensorBenchmark.h",
        "line": 50,
        "type": "empty_function",
        "content": "inference_depth(1) {}",
        "context": "        gradient_flow(GradientFlow::BIDIRECTIONAL),\n        fusion_weight(0.5f),\n        computation_cost(1.0f),\n        inference_depth(1) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/TensorBenchmark.h",
        "line": 69,
        "type": "empty_function",
        "content": "cognitive_load_factor(1.0) {}",
        "context": "        memory_usage_bytes(0),\n        accuracy_score(0.0),\n        tensor_operations_count(0),\n        cognitive_load_factor(1.0) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 46,
        "type": "empty_function",
        "content": "StubLogger() : level_(LogLevel::INFO), prefix_(\"[STUB] \") {}",
        "context": "    std::string prefix_;\n    \npublic:\n    StubLogger() : level_(LogLevel::INFO), prefix_(\"[STUB] \") {}\n    \n    void debug(const char* fmt, ...) { }  // Silent in stub mode\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 48,
        "type": "empty_function",
        "content": "void debug(const char* fmt, ...) { }  // Silent in stub mode",
        "context": "public:\n    StubLogger() : level_(LogLevel::INFO), prefix_(\"[STUB] \") {}\n    \n    void debug(const char* fmt, ...) { }  // Silent in stub mode\n    \n    void info(const char* fmt, ...) {\n        printf(\"%sINFO: \", prefix_.c_str());\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 135,
        "type": "empty_function",
        "content": "Handle() : uuid_(0), atom_ptr_(nullptr) {}",
        "context": "    uint64_t uuid_;\n    AtomPtr atom_ptr_;\n    \n    Handle() : uuid_(0), atom_ptr_(nullptr) {}\n    Handle(uint64_t id) : uuid_(id), atom_ptr_(nullptr) {}\n    Handle(const AtomPtr& ptr);  // Defined after Atom class\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 136,
        "type": "empty_function",
        "content": "Handle(uint64_t id) : uuid_(id), atom_ptr_(nullptr) {}",
        "context": "    AtomPtr atom_ptr_;\n    \n    Handle() : uuid_(0), atom_ptr_(nullptr) {}\n    Handle(uint64_t id) : uuid_(id), atom_ptr_(nullptr) {}\n    Handle(const AtomPtr& ptr);  // Defined after Atom class\n    \n    static const Handle UNDEFINED;\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 220,
        "type": "empty_function",
        "content": ": mean_(mean), confidence_(confidence) {}",
        "context": "    \npublic:\n    TruthValue(float mean = 0.5f, float confidence = 0.5f) \n        : mean_(mean), confidence_(confidence) {}\n    \n    float get_mean() const { return mean_; }\n    float get_confidence() const { return confidence_; }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 255,
        "type": "empty_function",
        "content": "truth_value_(std::make_shared<TruthValue>()) {}",
        "context": "public:\n    Atom(uint32_t type, const std::string& name = \"\") \n        : type_(type), name_(name), uuid_(next_uuid_++), \n          truth_value_(std::make_shared<TruthValue>()) {}\n    \n    virtual ~Atom() {}\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 257,
        "type": "empty_function",
        "content": "virtual ~Atom() {}",
        "context": "        : type_(type), name_(name), uuid_(next_uuid_++), \n          truth_value_(std::make_shared<TruthValue>()) {}\n    \n    virtual ~Atom() {}\n    \n    uint32_t get_type() const { return type_; }\n    Type get_type_as_type() const { return type_; }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 304,
        "type": "empty_function",
        "content": ": Atom(type, name) {}",
        "context": "class Node : public Atom {\npublic:\n    Node(uint32_t type, const std::string& name) \n        : Atom(type, name) {}\n    \n    virtual ~Node() {}\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 306,
        "type": "empty_function",
        "content": "virtual ~Node() {}",
        "context": "    Node(uint32_t type, const std::string& name) \n        : Atom(type, name) {}\n    \n    virtual ~Node() {}\n    \n    bool is_node() const override { return true; }\n    bool is_link() const override { return false; }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 322,
        "type": "empty_function",
        "content": ": Atom(type), outgoing_(outgoing) {}",
        "context": "    \npublic:\n    Link(uint32_t type, const HandleSeq& outgoing = HandleSeq())\n        : Atom(type), outgoing_(outgoing) {}\n    \n    virtual ~Link() {}\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 324,
        "type": "empty_function",
        "content": "virtual ~Link() {}",
        "context": "    Link(uint32_t type, const HandleSeq& outgoing = HandleSeq())\n        : Atom(type), outgoing_(outgoing) {}\n    \n    virtual ~Link() {}\n    \n    const HandleSeq& getOutgoingSet() const override { return outgoing_; }\n    size_t get_arity() const { return outgoing_.size(); }\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 367,
        "type": "empty_function",
        "content": "AtomSpace() : next_uuid_(1) {}",
        "context": "    uint64_t next_uuid_;\n    \npublic:\n    AtomSpace() : next_uuid_(1) {}\n    \n    ~AtomSpace() {\n        atom_table_.clear();\n"
      },
      {
        "file": "ggml-tensor-kernel/include/atomspace_stub.h",
        "line": 554,
        "type": "empty_function",
        "content": "SchemeEval(AtomSpace* as) : atomspace_(as) {}",
        "context": "    AtomSpace* atomspace_;\n    \npublic:\n    SchemeEval(AtomSpace* as) : atomspace_(as) {}\n    \n    static SchemeEval* get_evaluator(AtomSpace* as) {\n        return new SchemeEval(as);\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/AtomSpaceTensorMapper.h",
        "line": 38,
        "type": "empty_function",
        "content": "feature_dimensions(features), encoding_type(type) {}",
        "context": "                      const std::vector<size_t>& features,\n                      const std::string& type = \"standard\")\n        : node_dimensions(nodes), edge_dimensions(edges), \n          feature_dimensions(features), encoding_type(type) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/AttentionAllocator.h",
        "line": 34,
        "type": "empty_function",
        "content": ": name(context_name), weights(attention_weights), decay_rate(decay) {}",
        "context": "    AttentionContext(const std::string& context_name, \n                    const std::vector<double>& attention_weights,\n                    double decay = 0.95)\n        : name(context_name), weights(attention_weights), decay_rate(decay) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/DistributedExecutor.h",
        "line": 37,
        "type": "empty_function",
        "content": "memory_capacity(memory_cap), is_available(true), current_load(0) {}",
        "context": "    ExecutionNode(const std::string& id, const std::string& addr, \n                 size_t compute_cap, size_t memory_cap)\n        : node_id(id), address(addr), compute_capacity(compute_cap), \n          memory_capacity(memory_cap), is_available(true), current_load(0) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/DistributedExecutor.h",
        "line": 52,
        "type": "empty_function",
        "content": ": shard_id(id), node_id(node), dimensions(dims), offset(off), tensor_data(nullptr) {}",
        "context": "    \n    TensorShard(const std::string& id, const std::string& node, \n               const std::vector<size_t>& dims, const std::vector<size_t>& off)\n        : shard_id(id), node_id(node), dimensions(dims), offset(off), tensor_data(nullptr) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/DistributedExecutor.h",
        "line": 67,
        "type": "empty_function",
        "content": ": task_id(id), operation_name(op), is_completed(false) {}",
        "context": "    std::atomic<bool> is_completed;\n    \n    DistributedTask(const std::string& id, const std::string& op)\n        : task_id(id), operation_name(op), is_completed(false) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/GrammarRegistry.h",
        "line": 38,
        "type": "empty_function",
        "content": ": name(func_name), description(desc), input_types(inputs), output_type(output) {}",
        "context": "                   const std::string& desc,\n                   const std::vector<std::string>& inputs,\n                   const std::string& output)\n        : name(func_name), description(desc), input_types(inputs), output_type(output) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/GrammarRegistry.h",
        "line": 52,
        "type": "empty_function",
        "content": ": name(kernel_name), module_origin(origin), kernel_weights(nullptr) {}",
        "context": "    std::unordered_map<std::string, std::string> configuration;\n    \n    AgenticKernel(const std::string& kernel_name, const std::string& origin)\n        : name(kernel_name), module_origin(origin), kernel_weights(nullptr) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/NeuralSymbolicBridge.h",
        "line": 38,
        "type": "empty_function",
        "content": ": name(rule_name), description(desc) {}",
        "context": "    \n    TransformationRule() = default;\n    TransformationRule(const std::string& rule_name, const std::string& desc)\n        : name(rule_name), description(desc) {}\n};\n\n/**\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/TensorKernel.h",
        "line": 45,
        "type": "empty_function",
        "content": ": module_name(name), dimensions(dims), description(desc) {}",
        "context": "    \n    TensorShape() = default;\n    TensorShape(const std::string& name, const std::vector<size_t>& dims, const std::string& desc = \"\")\n        : module_name(name), dimensions(dims), description(desc) {}\n    \n    size_t total_elements() const {\n        size_t total = 1;\n"
      },
      {
        "file": "ggml-tensor-kernel/include/opencog/tensor/TensorKernel.h",
        "line": 67,
        "type": "empty_function",
        "content": ": name(module_name), shape(tensor_shape), tensor(nullptr) {}",
        "context": "    std::function<ggml_tensor*(ggml_context*, const std::vector<ggml_tensor*>&)> operation;\n    \n    CognitiveModule(const std::string& module_name, const TensorShape& tensor_shape)\n        : name(module_name), shape(tensor_shape), tensor(nullptr) {}\n    \n    virtual ~CognitiveModule() = default;\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/src/AtomSpaceTensorMapper_minimal.cc",
        "line": 82,
        "type": "empty_function",
        "content": "const std::vector<Handle>& outgoing = {},",
        "context": "\n    // Comprehensive atom registration with full metadata\n    void register_atom_complete(const Handle& atom, uint32_t type, const std::string& name = \"\",\n                               const std::vector<Handle>& outgoing = {},\n                               float tv_strength = 1.0f, float tv_confidence = 1.0f) {\n        AtomSerializationData data;\n        data.atom_id = atom.uuid_;\n"
      },
      {
        "file": "ggml-tensor-kernel/src/AtomSpaceTensorMapper_minimal.cc",
        "line": 216,
        "type": "empty_function",
        "content": "features = generate_comprehensive_features(atom, NODE_TYPE, \"\", {}, 1.0f, 1.0f);",
        "context": "                features = it->second.features;\n            } else {\n                // Generate default features for unknown atoms\n                features = generate_comprehensive_features(atom, NODE_TYPE, \"\", {}, 1.0f, 1.0f);\n            }\n            \n            // Copy features to tensor\n"
      },
      {
        "file": "ggml-tensor-kernel/src/AttentionAllocator_minimal.cc",
        "line": 31,
        "type": "empty_function",
        "content": ": sti(s), lti(l), vlti(v), rent(r) {}",
        "context": "    \n    AttentionValue() = default;\n    AttentionValue(float s, float l, float v = 0.0f, float r = 0.0f) \n        : sti(s), lti(l), vlti(v), rent(r) {}\n    \n    float total_importance() const {\n        return sti + lti + vlti;\n"
      },
      {
        "file": "ggml-tensor-kernel/src/CognitivePrimitive.cc",
        "line": 222,
        "type": "empty_function",
        "content": "return {};",
        "context": "std::vector<size_t> CognitivePrimitiveTensor::get_shape() const\n{\n    if (!tensor_) {\n        return {};\n    }\n    \n    std::vector<size_t> shape;\n"
      },
      {
        "file": "ggml-tensor-kernel/src/GrammarRegistry.cc",
        "line": 31,
        "type": "empty_function",
        "content": "static GrammarFunction empty_function(\"\", \"\", {}, \"\");",
        "context": "        return it->second;\n    }\n    \n    static GrammarFunction empty_function(\"\", \"\", {}, \"\");\n    logger().warn(\"GrammarRegistry\") << \"Grammar function not found: \" << name;\n    return empty_function;\n}\n"
      },
      {
        "file": "ggml-tensor-kernel/src/NeuralSymbolicBridge.cc",
        "line": 200,
        "type": "empty_function",
        "content": "size_t atom_hash = std::hash<std::string>{}(candidate->to_string()) % context_size;",
        "context": "        \n        for (const Handle& candidate : related_atoms) {\n            // Create simple hash-based score\n            size_t atom_hash = std::hash<std::string>{}(candidate->to_string()) % context_size;\n            float score = std::abs(context_data[atom_hash]);\n            \n            if (score > best_score) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/NeuralSymbolicBridge.cc",
        "line": 261,
        "type": "empty_function",
        "content": "size_t hash_idx = std::hash<std::string>{}(candidate_str) % guidance_size;",
        "context": "        for (const Handle& candidate : candidates) {\n            // Simple neural guidance scoring\n            std::string candidate_str = candidate->to_string();\n            size_t hash_idx = std::hash<std::string>{}(candidate_str) % guidance_size;\n            float score = std::abs(guidance_data[hash_idx]);\n            \n            // Boost score for exact name matches\n"
      },
      {
        "file": "ggml-tensor-kernel/src/TensorKernelSCM.cc",
        "line": 18,
        "type": "empty_function",
        "content": "TensorKernelSCM() : ModuleWrap(\"opencog tensor-kernel\") {}",
        "context": "    static TensorKernel* kernel_instance;\n    \npublic:\n    TensorKernelSCM() : ModuleWrap(\"opencog tensor-kernel\") {}\n    \n    void init();\n    \n"
      },
      {
        "file": "ggml-tensor-kernel/src/TensorKernel_minimal.cc",
        "line": 30,
        "type": "empty_function",
        "content": ": module_name(name), dimensions(dims), description(desc) {}",
        "context": "    \n    TensorShape() = default;\n    TensorShape(const std::string& name, const std::vector<size_t>& dims, const std::string& desc = \"\")\n        : module_name(name), dimensions(dims), description(desc) {}\n    \n    size_t total_elements() const {\n        size_t total = 1;\n"
      },
      {
        "file": "ggml-tensor-kernel/src/TensorKernel_minimal.cc",
        "line": 52,
        "type": "empty_function",
        "content": ": atomspace_(as), context_(ctx) {}",
        "context": "\npublic:\n    AtomSpaceTensorMapper(AtomSpace* as, ggml_context* ctx) \n        : atomspace_(as), context_(ctx) {}\n\n    // Register an atom and get its index\n    size_t register_atom(const Handle& atom) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/TensorKernel_minimal.cc",
        "line": 221,
        "type": "empty_function",
        "content": ": atomspace_(as), context_(ctx) {}",
        "context": "\npublic:\n    AttentionAllocator(AtomSpace* as, ggml_context* ctx) \n        : atomspace_(as), context_(ctx) {}\n\n    // Initialize attention for a set of atoms\n    void initialize_attention(const HandleSet& atoms) {\n"
      },
      {
        "file": "ggml-tensor-kernel/src/TensorRegistry.cc",
        "line": 31,
        "type": "empty_function",
        "content": "static TensorShape empty_shape(\"\", {}, \"\");",
        "context": "        return it->second;\n    }\n    \n    static TensorShape empty_shape(\"\", {}, \"\");\n    logger().warn(\"TensorRegistry\") << \"Shape not found: \" << name;\n    return empty_shape;\n}\n"
      },
      {
        "file": "language-learning/pipeline/tstr.py",
        "line": 37,
        "type": "empty_function",
        "content": "re = {}",
        "context": "    with open(config_json) as f:\n        kwargs = json.load(f)\n\n    re = {}\n\n    if 'input_grammar' in kwargs:  # Test .dict file    # 90123\n        ig = module_path + kwargs['input_grammar']\n"
      },
      {
        "file": "language-learning/src/common/fileconfman.py",
        "line": 33,
        "type": "empty_function",
        "content": "return {}",
        "context": "            if cfg[\"component\"] == comp_name:\n                return cfg['parameters']\n\n        return {}\n\n    def save_config(self, config_name: str, comp_name: str) -> None:\n        \"\"\"\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 63,
        "type": "empty_function",
        "content": "return \"{}h {}m {}s {}ms\".format(hours, minutes, seconds, millis)",
        "context": "        minutes = int((stat.parse_time - hours * 3600) / 60)\n        seconds = int(stat.parse_time % 60)\n        millis  = int((stat.parse_time % 60 - seconds) * 1000)\n        return \"{}h {}m {}s {}ms\".format(hours, minutes, seconds, millis)\n\n    @staticmethod\n    def text(stat) -> str:\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 67,
        "type": "empty_function",
        "content": "return  \"Total sentences parsed in full:\\t\\t{}\\n\" \\",
        "context": "\n    @staticmethod\n    def text(stat) -> str:\n        return  \"Total sentences parsed in full:\\t\\t{}\\n\" \\\n                \"Total sentences not parsed at all:\\t{}\\n\" \\\n                \"Average sentence parse:\\t\\t\\t{}\\n\" \\\n                \"Total sentences:\\t\\t\\t{:2.2f}\\n\" \\\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 68,
        "type": "empty_function",
        "content": "\"Total sentences not parsed at all:\\t{}\\n\" \\",
        "context": "    @staticmethod\n    def text(stat) -> str:\n        return  \"Total sentences parsed in full:\\t\\t{}\\n\" \\\n                \"Total sentences not parsed at all:\\t{}\\n\" \\\n                \"Average sentence parse:\\t\\t\\t{}\\n\" \\\n                \"Total sentences:\\t\\t\\t{:2.2f}\\n\" \\\n                \"Skipped sentences:\\t\\t\\t{:2.2f}\\n\" \\\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 69,
        "type": "empty_function",
        "content": "\"Average sentence parse:\\t\\t\\t{}\\n\" \\",
        "context": "    def text(stat) -> str:\n        return  \"Total sentences parsed in full:\\t\\t{}\\n\" \\\n                \"Total sentences not parsed at all:\\t{}\\n\" \\\n                \"Average sentence parse:\\t\\t\\t{}\\n\" \\\n                \"Total sentences:\\t\\t\\t{:2.2f}\\n\" \\\n                \"Skipped sentences:\\t\\t\\t{:2.2f}\\n\" \\\n                \"Parse time:\\t\\t\\t\\t{}\\n\".format( stat.completely_parsed_str(stat),\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 72,
        "type": "empty_function",
        "content": "\"Parse time:\\t\\t\\t\\t{}\\n\".format( stat.completely_parsed_str(stat),",
        "context": "                \"Average sentence parse:\\t\\t\\t{}\\n\" \\\n                \"Total sentences:\\t\\t\\t{:2.2f}\\n\" \\\n                \"Skipped sentences:\\t\\t\\t{:2.2f}\\n\" \\\n                \"Parse time:\\t\\t\\t\\t{}\\n\".format( stat.completely_parsed_str(stat),\n                                                      stat.completely_unparsed_str(stat),\n                                                      stat.parseability_str(stat),\n                                                      stat.sentences,\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 182,
        "type": "empty_function",
        "content": "return  \"Parse quality:\\t{}\\n\\n\" \\",
        "context": "\n    @staticmethod\n    def text(stat) -> str:\n        return  \"Parse quality:\\t{}\\n\\n\" \\\n                \"Average total links:\\t{:2.2f}\\n\" \\\n                \"Average ignored links:\\t{:2.2f}\\n\" \\\n                \"Average missing links:\\t{:2.2f}\\n\" \\\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 187,
        "type": "empty_function",
        "content": "\"Recall:\\t\\t{}\\n\" \\",
        "context": "                \"Average ignored links:\\t{:2.2f}\\n\" \\\n                \"Average missing links:\\t{:2.2f}\\n\" \\\n                \"Average extra links:\\t{:2.2f}\\n\\n\" \\\n                \"Recall:\\t\\t{}\\n\" \\\n                \"Precision:\\t{}\\n\" \\\n                \"F1:\\t\\t{}\\n\\n\" \\\n                \"Total sentences:\\t{:2.2f}\\n\" \\\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 188,
        "type": "empty_function",
        "content": "\"Precision:\\t{}\\n\" \\",
        "context": "                \"Average missing links:\\t{:2.2f}\\n\" \\\n                \"Average extra links:\\t{:2.2f}\\n\\n\" \\\n                \"Recall:\\t\\t{}\\n\" \\\n                \"Precision:\\t{}\\n\" \\\n                \"F1:\\t\\t{}\\n\\n\" \\\n                \"Total sentences:\\t{:2.2f}\\n\" \\\n                \"Skipped sentences:\\t{:2.2f}\\n\".format(\n"
      },
      {
        "file": "language-learning/src/common/parsemetrics.py",
        "line": 189,
        "type": "empty_function",
        "content": "\"F1:\\t\\t{}\\n\\n\" \\",
        "context": "                \"Average extra links:\\t{:2.2f}\\n\\n\" \\\n                \"Recall:\\t\\t{}\\n\" \\\n                \"Precision:\\t{}\\n\" \\\n                \"F1:\\t\\t{}\\n\\n\" \\\n                \"Total sentences:\\t{:2.2f}\\n\" \\\n                \"Skipped sentences:\\t{:2.2f}\\n\".format(\n                                                        stat.parse_quality_str(stat),\n"
      },
      {
        "file": "language-learning/src/common/pearson_coeff.py",
        "line": 63,
        "type": "empty_function",
        "content": "#print(\"Pair missing in LG file: {}\".format(k))",
        "context": "    for k, value in dictio.items():\n        if value[0] == np.Inf:\n            pairs_missing_LG += 1\n            #print(\"Pair missing in LG file: {}\".format(k))\n            continue\n        LG_dist_data[0].append(value[0])\n        LG_dist_data[1].append(value[1])\n"
      },
      {
        "file": "language-learning/src/common/pearson_coeff.py",
        "line": 70,
        "type": "empty_function",
        "content": "print(\"Pairs missing in LG file: {}\".format(pairs_missing_LG))",
        "context": "        LG_no_dist_data[0].append(value[0])\n        LG_no_dist_data[1].append(value[2])\n\n    print(\"Pairs missing in LG file: {}\".format(pairs_missing_LG))\n    LG_dist_data, dist_missing = eliminate_Inf(LG_dist_data)\n    print(\"Pairs missing in dist file: {}\".format(dist_missing))\n    LG_no_dist_data, no_dist_missing = eliminate_Inf(LG_no_dist_data)\n"
      },
      {
        "file": "language-learning/src/common/pearson_coeff.py",
        "line": 72,
        "type": "empty_function",
        "content": "print(\"Pairs missing in dist file: {}\".format(dist_missing))",
        "context": "\n    print(\"Pairs missing in LG file: {}\".format(pairs_missing_LG))\n    LG_dist_data, dist_missing = eliminate_Inf(LG_dist_data)\n    print(\"Pairs missing in dist file: {}\".format(dist_missing))\n    LG_no_dist_data, no_dist_missing = eliminate_Inf(LG_no_dist_data)\n    print(\"Pairs missing in no-dist file: {}\".format(no_dist_missing))\n\n"
      },
      {
        "file": "language-learning/src/common/pearson_coeff.py",
        "line": 74,
        "type": "empty_function",
        "content": "print(\"Pairs missing in no-dist file: {}\".format(no_dist_missing))",
        "context": "    LG_dist_data, dist_missing = eliminate_Inf(LG_dist_data)\n    print(\"Pairs missing in dist file: {}\".format(dist_missing))\n    LG_no_dist_data, no_dist_missing = eliminate_Inf(LG_no_dist_data)\n    print(\"Pairs missing in no-dist file: {}\".format(no_dist_missing))\n\n    # calculate Pearson's coefficient for each pair\n    pearR_dist = np.corrcoef(LG_dist_data[0], LG_dist_data[1])[1,0]\n"
      },
      {
        "file": "language-learning/src/common/pearson_coeff.py",
        "line": 138,
        "type": "empty_function",
        "content": "word_pair_dict = {}",
        "context": "    LG_data = Load_File(LG_file)\n    dist_data = Load_File(dist_file)\n    no_dist_data = Load_File(no_dist_file)\n    word_pair_dict = {}\n    word_pair_dict = Increase_Dictionary(word_pair_dict, LG_data, 0)\n    word_pair_dict = Increase_Dictionary(word_pair_dict, dist_data, 1)\n    word_pair_dict = Increase_Dictionary(word_pair_dict, no_dist_data, 2)\n"
      },
      {
        "file": "language-learning/src/common/tokencount.py",
        "line": 103,
        "type": "empty_function",
        "content": "token_counts = {}",
        "context": "    logger = logging.getLogger(__name__ + \".load_token_counts\")\n\n    # Clear dictionary to avoid confusion.\n    token_counts = {}\n\n    with open(file_path, \"r\") as file:\n        lines = file.readlines()\n"
      },
      {
        "file": "language-learning/src/common/tokencount.py",
        "line": 130,
        "type": "empty_function",
        "content": "token_counts = {}",
        "context": "    :param options:         Option bit mask. The same value as used by parser.\n    :return:                Dictionary with token appearances.\n    \"\"\"\n    token_counts = {}\n\n    def on_file(file: str, args: list) -> None:\n        update_token_counts(file, token_counts, options)\n"
      },
      {
        "file": "language-learning/src/dash_board/textdashboard.py",
        "line": 181,
        "type": "empty_function",
        "content": "return {}",
        "context": "        return True\n\n    def run(self, **kwargs) -> dict:\n        return {}\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 30,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_INPUT_PARSES))",
        "context": "        ret_val = True\n\n        if kwargs.get(PARAM_INPUT_PARSES, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_INPUT_PARSES))\n            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_CATEGORIES, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 34,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_CATEGORIES))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_CATEGORIES, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_CATEGORIES))\n            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_GRAMMAR, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 38,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_GRAMMAR))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_GRAMMAR, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_GRAMMAR))\n            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_STATISTICS, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 42,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_STATISTICS))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_STATISTICS, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_STATISTICS))\n            ret_val = False\n\n        if kwargs.get(PARAM_TEMP_DIR, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/__init__.py",
        "line": 46,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_TEMP_DIR))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_TEMP_DIR, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_TEMP_DIR))\n            ret_val = False\n\n        return ret_val\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 76,
        "type": "empty_function",
        "content": "return {}, {'error': 'no_clusters_generated'}",
        "context": "        # Check if labels are not empty\n        if len(labels) == 0:\n            logger.error(\"No clusters generated - labels array is empty\")\n            return {}, {'error': 'no_clusters_generated'}\n        log.update(metrics)\n\n        # labels \u21d2 cdf (legacy, extracted from agglomerative_clustering:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 132,
        "type": "empty_function",
        "content": "cats = {}",
        "context": "    :param kwargs:  ['word_space', 'clustering']\n    :return:        cats: {'cluster': [], 'words': [[str]], ...]\n    \"\"\"\n    cats = {}\n    cats['cluster'] = ['A'] + clusters['cluster'].tolist()\n    cats['parent'] = [0 for x in cats['cluster']]\n    cats['words'] = [[]] + [set(x) for x in clusters['cluster_words'].tolist()]\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 103,
        "type": "empty_function",
        "content": "new_cats = {}",
        "context": "        if len(branchi) > 0:\n            ordnung.extend(branchi)\n\n    new_cats = {}\n    new_cats['parent'] = [ordnung.index(cats['parent'][i]) for i in ordnung]\n\n    n = sum(1 for i in new_cats['parent'] if i == 0)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/grammar_inducer.py",
        "line": 96,
        "type": "empty_function",
        "content": "disjuncts = {}",
        "context": "    for i in clusters:\n        for word in rules['words'][i]:\n            word_clusters[word] = i\n    disjuncts = {}\n\n    for cluster in clusters:\n        djs = []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/incremental_clustering.py",
        "line": 22,
        "type": "empty_function",
        "content": "dct = {}",
        "context": "\ndef dict2dict(d):                                                       # 90205\n    # d :: list of strings read from Link Grammar .dict file\n    dct = {}\n    for i in range(1, len(d) - 1):\n        if len(d[i]) == 0:\n            continue\n"
      },
      {
        "file": "language-learning/src/grammar_learner/incremental_clustering.py",
        "line": 125,
        "type": "empty_function",
        "content": "dct = {}",
        "context": "def dict2lists(kd, **kwargs):                                           # 90131\n    prefix = kwa('###', 'tag_prefix', **kwargs)\n    suffix = kwa('###', 'tag_suffix', **kwargs)\n    dct = {}\n    for i in range(1, len(kd) - 1):\n        if len(kd[i]) == 0: continue\n        if kd[i][0] == '%' and kd[i+1][-1] == ':':\n"
      },
      {
        "file": "language-learning/src/grammar_learner/incremental_clustering.py",
        "line": 159,
        "type": "empty_function",
        "content": "dct = {}",
        "context": "\n    prefix = kwa('###', 'tag_prefix', **kwargs)\n    suffix = kwa('###', 'tag_suffix', **kwargs)\n    dct = {}\n    for i in range(1, len(kd) - 1):\n        if len(kd[i]) == 0: continue\n        if kd[i][0] == '%' and kd[i+1][-1] == ':':\n"
      },
      {
        "file": "language-learning/src/grammar_learner/incremental_clustering.py",
        "line": 189,
        "type": "empty_function",
        "content": "log = {}",
        "context": "    corpus: str = kwargs['output_grammar']\n    cp: str\n\n    log = {}\n\n    if 'input_grammar' not in kwargs:\n        rulez, re01 = learn(**kwargs)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/incremental_clustering.py",
        "line": 287,
        "type": "empty_function",
        "content": "responses = {}  # Dictionary to store responses from each iteration",
        "context": "        kwargs['corpus_path'] = kwargs['reference_path']\n\n    table = [['Iteration', 'N clusters', 'PA', 'F1']]\n    responses = {}  # Dictionary to store responses from each iteration\n    np = 1000000\n\n    iterations = kwa(7, 'iterations', **kwargs)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/kmeans.py",
        "line": 54,
        "type": "empty_function",
        "content": "logger.debug('clustering/poc.py/number_of_clusters: vdf:\\n{}'.format(",
        "context": "    # if verbose == 'debug':\n    #     print('clustering/poc.py/number_of_clusters: vdf:\\n', \\\n    #         vdf.applymap(round2).sort_values(by=[1,2], ascending=[True,True]))\n    logger.debug('clustering/poc.py/number_of_clusters: vdf:\\n{}'.format(\n        vdf.applymap(round2).sort_values(by=[1,2], ascending=[True,True])))\n\n    # Check number of clusters <= word vector dimensionality\n"
      },
      {
        "file": "language-learning/src/grammar_learner/kmeans.py",
        "line": 70,
        "type": "empty_function",
        "content": "logger.info('number_of_clusters: max_clusters = {}'.format(max_clusters))",
        "context": "\n    # if verbose in ['max', 'debug']:\n    #     print('number_of_clusters: max_clusters =', max_clusters)\n    logger.info('number_of_clusters: max_clusters = {}'.format(max_clusters))\n\n    n_clusters = max_clusters   #80623: cure case max < range.min\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pparser.py",
        "line": 77,
        "type": "empty_function",
        "content": "links = {}",
        "context": "                                               + ('+' if z > 0 else '-')\n                                               for z in (l + r)])\n                    pairs.append([words[k], disjunct])\n        links = {}\n        words = {}\n        return words, links\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pparser.py",
        "line": 78,
        "type": "empty_function",
        "content": "words = {}",
        "context": "                                               for z in (l + r)])\n                    pairs.append([words[k], disjunct])\n        links = {}\n        words = {}\n        return words, links\n\n    for line in lines:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 24,
        "type": "empty_function",
        "content": "else: return '', {}",
        "context": "        for root, dirs, fls in os.walk(kwargs['input_path']):\n            for f in fls:\n                files.append(os.path.join(root, f))\n    else: return '', {}\n    # us: ull string ~ ull parses file as a string, lines delimited by '\\n'\n    us = ''\n    for file in files:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 81,
        "type": "empty_function",
        "content": ":return:        (links, re): DataFrame, {}",
        "context": "    \"\"\" parses input files, filters and re\n    :param files:   list of paths to input files\n    :param kwargs:  defined in kwa below\n    :return:        (links, re): DataFrame, {}\n    \"\"\"\n    parse_mode = kwa('lower', 'parse_mode', **kwargs)  # 'casefold' \u00bb default?\n    wsd_symbol = kwa('', 'wsd_symbol', **kwargs)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 136,
        "type": "empty_function",
        "content": "return {}, re",
        "context": "    # Empty filtered df with 'max_sentence_length', 'max_unparsed_words'\n    if len(links) < 1:\n        re.update({'filtering error': 'empty_filtered_dataset'})\n        return {}, re\n\n    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 11,
        "type": "empty_function",
        "content": "return HTML('<table><tr>{}</tr></table>'",
        "context": "\n\ndef html_table(tbl):\n    return HTML('<table><tr>{}</tr></table>'\n                .format('</tr><tr>'\n                        .join('<td>{}</td>'\n                              .format('</td><td>'\n"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 13,
        "type": "empty_function",
        "content": ".join('<td>{}</td>'",
        "context": "def html_table(tbl):\n    return HTML('<table><tr>{}</tr></table>'\n                .format('</tr><tr>'\n                        .join('<td>{}</td>'\n                              .format('</td><td>'\n                                      .join(str(_) for _ in row))\n                              for row in tbl)))\n"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 48,
        "type": "empty_function",
        "content": "clusters = {}",
        "context": "        lines = f.read().splitlines()\n    cats = [[y[0], int(y[1]), int(y[2]), y[4].split()]\n            for y in [x.split('\\t') for x in lines]]  # shorter: no similarities\n    clusters = {}\n    m = 0\n    for i, x in enumerate(cats):\n        if x[0] not in clusters:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/write_files.py",
        "line": 78,
        "type": "empty_function",
        "content": "# rules: [] or {}",
        "context": "\ndef save_link_grammar(rules, output_grammar, grammar_rules = 2,\n                      header = '', footer = ''):\n    # rules: [] or {}\n    # grammar_rules = kwargs['grammar_rules']: 1 \u21d2 connectors, 2+ \u21d2 disjuncts\n    if type(rules) is dict:\n        rules = rules2list(rules, grammar_rules)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/write_files.py",
        "line": 153,
        "type": "empty_function",
        "content": "clusters = {}",
        "context": "def save_category_tree(category_list, tree_file, verbose = 'none'):\n    logger = logging.getLogger(__name__ + \".save_category_tree\")\n    cats = category_list\n    clusters = {}\n    m = 0\n    for i, x in enumerate(cats):\n        if x[0] not in clusters: clusters[x[0]] = []\n"
      },
      {
        "file": "language-learning/src/grammar_tester/grammartester.py",
        "line": 82,
        "type": "empty_function",
        "content": "self._token_counts = {}",
        "context": "        self._total_dicts = 0\n        self._total_sentences = 0\n        self._progress = None\n        self._token_counts = {}\n        self._test_kwargs = None\n\n    @staticmethod\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lginprocparser.py",
        "line": 176,
        "type": "empty_function",
        "content": "\"Reference file '{}' does not match \"",
        "context": "                    string = \"\\n\".join([sent.text for sent in sentences])\n                    self._logger.debug(string)\n                    raise LGParseError(\"Number of sentences in corpus and reference files missmatch. \"\n                                       \"Reference file '{}' does not match \"\n                                       \"its corpus counterpart {} != {}.\".format(ref_path, len_ref, len_par))\n\n            # Parse linkages and make statistics estimation\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lginprocparser.py",
        "line": 177,
        "type": "empty_function",
        "content": "\"its corpus counterpart {} != {}.\".format(ref_path, len_ref, len_par))",
        "context": "                    self._logger.debug(string)\n                    raise LGParseError(\"Number of sentences in corpus and reference files missmatch. \"\n                                       \"Reference file '{}' does not match \"\n                                       \"its corpus counterpart {} != {}.\".format(ref_path, len_ref, len_par))\n\n            # Parse linkages and make statistics estimation\n            for sentence_count, sent in enumerate(sentences):\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lginprocparser.py",
        "line": 242,
        "type": "empty_function",
        "content": "self._logger.info(\"Link Grammar version: {}\\n\"",
        "context": "        :return:                Tuple (ParseMetrics, ParseQuality).\n        \"\"\"\n        if progress is None:\n            self._logger.info(\"Link Grammar version: {}\\n\"\n                  \"Link Grammar dictionaries: {}\".format(self._lg_version, self._lg_dict_path))\n\n        if not (options & BIT_EXISTING_DICT):\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lginprocparser.py",
        "line": 243,
        "type": "empty_function",
        "content": "\"Link Grammar dictionaries: {}\".format(self._lg_version, self._lg_dict_path))",
        "context": "        \"\"\"\n        if progress is None:\n            self._logger.info(\"Link Grammar version: {}\\n\"\n                  \"Link Grammar dictionaries: {}\".format(self._lg_version, self._lg_dict_path))\n\n        if not (options & BIT_EXISTING_DICT):\n            dict_ver = get_lg_dict_version(dict_path)\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lginprocparser.py",
        "line": 343,
        "type": "empty_function",
        "content": "\"Read: {}, Parsed: {}, File: {}\".format(sentence_count,",
        "context": "                    path_len = len(corpus_path)\n\n                    raise LGParseError(\"Number of sentences does not match. \"\n                          \"Read: {}, Parsed: {}, File: {}\".format(sentence_count,\n                                                                  ret_metrics.sentences + ret_metrics.skipped_sentences,\n                                                                  corpus_path if path_len < 31\n                                                                                else \"...\" + corpus_path[path_len-27:]))\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lgmisc.py",
        "line": 92,
        "type": "empty_function",
        "content": "raise FileNotFoundError(\"Grammar root path '{}' does not exist.\".format(grammar_path))",
        "context": "        raise FileNotFoundError(\"Dictionary file name is expected to have proper notation.\" + dict_file_path)\n\n    if not os.path.isdir(grammar_path):\n        raise FileNotFoundError(\"Grammar root path '{}' does not exist.\".format(grammar_path))\n\n    dict_path = grammar_path + \"/\" + dict_path if dict_path is not None else dict_file_path\n\n"
      },
      {
        "file": "language-learning/src/grammar_tester/lgpcommands.py",
        "line": 8,
        "type": "empty_function",
        "content": "verbosity = \"-verbosity={}\".format(verb)",
        "context": "def get_linkparser_command(options: int, dict_path: str, limit: int, timeout: int, verb: int=1, num_linkages: int=1) \\\n        -> List[str]:\n\n    verbosity = \"-verbosity={}\".format(verb)\n\n    # Make command option list depending on the output format specified.\n    if not (options & BIT_OUTPUT) or (options & BIT_OUTPUT_POSTSCRIPT):\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 116,
        "type": "empty_function",
        "content": "print(\"writing parses file to '{}'\".format(file_name))",
        "context": "    :param options:             Parse options bit mask.\n    :return:                    None.\n    \"\"\"\n    print(\"writing parses file to '{}'\".format(file_name))\n\n    with open(file_name, 'w') as fo:\n        for sent in sentence_parses:\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 302,
        "type": "empty_function",
        "content": "logger.info(\"{} {} {} {} {} {}\".format(test_set, ref_set, test_set & ref_set,",
        "context": "        pq.ignored = (len(test_parse[PARSE_LINK_SET]) - len(test_set))\n\n        logger.info(f\"{test_parse[0]}\")\n        logger.info(\"{} {} {} {} {} {}\".format(test_set, ref_set, test_set & ref_set,\n              ParseQuality.recall_str(pq), ParseQuality.precision_str(pq), ParseQuality.f1_str(pq)))\n\n        total_parse_quality += pq\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 468,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_TST_PATH))",
        "context": "        ret_val = True\n\n        if kwargs.get(PARAM_TST_PATH, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_TST_PATH))\n            ret_val = False\n\n        if kwargs.get(PARAM_REF_PATH, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 472,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_REF_PATH))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_REF_PATH, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_REF_PATH))\n            ret_val = False\n\n        if kwargs.get(PARAM_OUT_PATH, None) is None:\n"
      },
      {
        "file": "language-learning/src/grammar_tester/parsevaluate.py",
        "line": 476,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUT_PATH))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_OUT_PATH, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUT_PATH))\n            ret_val = False\n\n        return ret_val\n"
      },
      {
        "file": "language-learning/src/observer/lgobserver.py",
        "line": 38,
        "type": "empty_function",
        "content": "# print(\"{} {}\".format(linkage.tokens[link[0]], linkage.tokens[link[1]]))",
        "context": "\n        for link in linkage.links:\n            # if linkage.tokens[link[0]] == r\"###LEFT-WALL###\":  # and linkage.tokens[link[1]] == r\".\":\n                # print(\"{} {}\".format(linkage.tokens[link[0]], linkage.tokens[link[1]]))\n\n            self._pairs.add(linkage.tokens[link[0]], linkage.tokens[link[1]])\n\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 25,
        "type": "empty_function",
        "content": "print(\"writing parses file to '{}'\".format(filename))",
        "context": "    \"\"\"\n        Prints parses to file (for sequential and random eval methods)\n    \"\"\"\n    print(\"writing parses file to '{}'\".format(filename))\n    with open(filename, 'w') as fo:\n        for sent, parse in zip(sentences, parses):\n            fo.write(\" \".join(sent) + \"\\n\")\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 159,
        "type": "empty_function",
        "content": "print(\"Sentence: {}\".format(\" \".join(ref_sent)))",
        "context": "            sum_recall += true_pos / (true_pos + false_neg)  # add parse's recall\n\n        if verbose:\n            print(\"Sentence: {}\".format(\" \".join(ref_sent)))\n            print(\"Correct links: {}\".format(true_pos))\n            print(\"Missing links: {}\".format(false_neg))\n            print(\"Extra links: {}\".format(false_pos))\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 160,
        "type": "empty_function",
        "content": "print(\"Correct links: {}\".format(true_pos))",
        "context": "\n        if verbose:\n            print(\"Sentence: {}\".format(\" \".join(ref_sent)))\n            print(\"Correct links: {}\".format(true_pos))\n            print(\"Missing links: {}\".format(false_neg))\n            print(\"Extra links: {}\".format(false_pos))\n\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 161,
        "type": "empty_function",
        "content": "print(\"Missing links: {}\".format(false_neg))",
        "context": "        if verbose:\n            print(\"Sentence: {}\".format(\" \".join(ref_sent)))\n            print(\"Correct links: {}\".format(true_pos))\n            print(\"Missing links: {}\".format(false_neg))\n            print(\"Extra links: {}\".format(false_pos))\n\n        # print to file the processed parses\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 162,
        "type": "empty_function",
        "content": "print(\"Extra links: {}\".format(false_pos))",
        "context": "            print(\"Sentence: {}\".format(\" \".join(ref_sent)))\n            print(\"Correct links: {}\".format(true_pos))\n            print(\"Missing links: {}\".format(false_neg))\n            print(\"Extra links: {}\".format(false_pos))\n\n        # print to file the processed parses\n        if filter:\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 176,
        "type": "empty_function",
        "content": "print(\"A total of {} sentences filtered, {:.2%} of reference file\".format(filtered_sents, float(filtered_sents) / len(ref_parses)))",
        "context": "    print(\"\\nAvg Precision: {:.2%}\".format(precision))\n    print(\"Avg Recall: {:.2%}\".format(recall))\n    print(\"Avg Fscore: {:.2%}\\n\".format(2 * precision * recall / (precision + recall)))\n    print(\"A total of {} sentences filtered, {:.2%} of reference file\".format(filtered_sents, float(filtered_sents) / len(ref_parses)))\n    print(\"A total of {} parses evaluated, {:.2%} of reference file\".format(evaluated_parses, float(evaluated_parses) / len(ref_parses)))\n    print(\"{:.2f} ignored links per evaluated parse\".format(ignored_links / evaluated_parses))\n    if filter:\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 177,
        "type": "empty_function",
        "content": "print(\"A total of {} parses evaluated, {:.2%} of reference file\".format(evaluated_parses, float(evaluated_parses) / len(ref_parses)))",
        "context": "    print(\"Avg Recall: {:.2%}\".format(recall))\n    print(\"Avg Fscore: {:.2%}\\n\".format(2 * precision * recall / (precision + recall)))\n    print(\"A total of {} sentences filtered, {:.2%} of reference file\".format(filtered_sents, float(filtered_sents) / len(ref_parses)))\n    print(\"A total of {} parses evaluated, {:.2%} of reference file\".format(evaluated_parses, float(evaluated_parses) / len(ref_parses)))\n    print(\"{:.2f} ignored links per evaluated parse\".format(ignored_links / evaluated_parses))\n    if filter:\n        fa.close() # close output file if opened\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 220,
        "type": "empty_function",
        "content": "fake_words = [\"w{}\".format(x) for x in range(1, num_words + 1)]",
        "context": "        curr_sent.insert(0, \"###LEFT-WALL###\")\n        curr_parse = []\n        # subtitute words with numbers, to avoid token-splitting by LG \"any\"\n        fake_words = [\"w{}\".format(x) for x in range(1, num_words + 1)]\n        sent_string = \" \".join(fake_words)\n        sentence = Sentence(sent_string, any_dict, po)\n        linkages = sentence.parse()\n"
      },
      {
        "file": "language-learning/src/parse_evaluator/parse_evaluator.py",
        "line": 267,
        "type": "empty_function",
        "content": "ft.write(\"Sentence Differs:\\n{}\\nin tokens:{}<--->{}\\n\".format(\" \".join(ref_sent), sorted(list(set_ref - set_test)), sorted(list(set_test - set_ref))))",
        "context": "            if new_ref != new_test:\n                set_ref = set(new_ref)\n                set_test = set(new_test)\n                ft.write(\"Sentence Differs:\\n{}\\nin tokens:{}<--->{}\\n\".format(\" \".join(ref_sent), sorted(list(set_ref - set_test)), sorted(list(set_test - set_ref))))\n\ndef Evaluate_Alternative(ref_file, test_file, verbose, ignore_WALL, sequential, random_flag, filter_sentences, compare_tokenization, content, **kwargs):\n\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 41,
        "type": "empty_function",
        "content": "return {}",
        "context": "        return True\n\n    def run(self, **kwargs):\n        return {}\n\n    @staticmethod\n    def create(**kwargs):\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 67,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_INPUT_PATH))",
        "context": "        ret_val = True\n\n        if kwargs.get(PARAM_INPUT_PATH, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_INPUT_PATH))\n            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_PATH, None) is None:\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 71,
        "type": "empty_function",
        "content": "print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_PATH))",
        "context": "            ret_val = False\n\n        if kwargs.get(PARAM_OUTPUT_PATH, None) is None:\n            print(\"Error: parameter '{}' is not specified.\".format(PARAM_OUTPUT_PATH))\n            ret_val = False\n\n        return ret_val\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 94,
        "type": "empty_function",
        "content": "return {}",
        "context": "        # Run Token Counter\n        dump_token_counts(input_path, output_path, options)\n\n        return {}\n\n\n# Pipeline component dictionary having tuples of component class and prefix, used when automaticaly creating\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 128,
        "type": "empty_function",
        "content": "raise Exception(\"Error: '{}' is not a valid pipeline component name.\".format(name))",
        "context": "        return component\n\n    except KeyError:\n        raise Exception(\"Error: '{}' is not a valid pipeline component name.\".format(name))\n\n\ndef single_proc_exec(node: PipelineTreeNode2) -> None:\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 149,
        "type": "empty_function",
        "content": "result = {}",
        "context": "        os.makedirs(leaf)\n\n    parameters = node._parameters\n    result = {}\n\n    pre_exec = parameters.get(\"pre-exec-req\", None)\n\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 205,
        "type": "empty_function",
        "content": "raise Exception(\"Error: static component '{}' does not exist.\".format(name))",
        "context": "    inst = node.static_components.get(name, None)\n\n    if inst is None:\n        raise Exception(\"Error: static component '{}' does not exist.\".format(name))\n\n    return getattr(inst, meth)(**req)\n\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 254,
        "type": "empty_function",
        "content": "scopes = {\"THIS\": {**new_environment, **all_parameters}, \"PREV\": {}} if parent is None else \\",
        "context": "\n    new_environment = {**environment, **{\"RLEAF\": rleaf, \"LEAF\": leaf, \"CREATE_LEAF\": create_leaf}}\n\n    scopes = {\"THIS\": {**new_environment, **all_parameters}, \"PREV\": {}} if parent is None else \\\n             {\"THIS\": {**new_environment, **all_parameters}, \"PREV\": {**parent._environment, **parent._parameters}}\n\n    # Substitute derived path for LEAF, PREV and other variables\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 278,
        "type": "empty_function",
        "content": "comm = component_config.get(\"common-parameters\", {})",
        "context": "\n        name = component_config.get(\"component\", None)\n        type = component_config.get(\"type\", \"dynamic\")\n        comm = component_config.get(\"common-parameters\", {})\n        spec = component_config.get(\"specific-parameters\", None)\n\n        if name is None:\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 288,
        "type": "empty_function",
        "content": "params = subst_variables_in_dict(component_config.get(\"parameters\", {}), globals, first_char)",
        "context": "            raise Exception(\"No 'specific-parameters' section found in configuration.\")\n\n        if type == \"static\":\n            params = subst_variables_in_dict(component_config.get(\"parameters\", {}), globals, first_char)\n\n            inst_name = component_config.get(\"instance-name\", None)\n\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetree.py",
        "line": 400,
        "type": "empty_function",
        "content": "return \"{}h {}m {}s {}ms\".format(hours, minutes, seconds, millis)",
        "context": "    minutes = int((parse_time - hours * 3600) / 60)\n    seconds = int(parse_time % 60)\n    millis  = int((parse_time % 60 - seconds) * 1000)\n    return \"{}h {}m {}s {}ms\".format(hours, minutes, seconds, millis)\n\n\ndef run_tree() -> None:\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetreenode.py",
        "line": 36,
        "type": "empty_function",
        "content": "self._parameters: Dict[str, Any] = {} if parameters is None else parameters",
        "context": "\n        self.seq_no: int = seq_no\n        self._component_name: str = name\n        self._parameters: Dict[str, Any] = {} if parameters is None else parameters\n        self._environment: Dict[str, Any] = {} if environment is None else environment\n        self._siblings: List[PipelineTreeNode2] = []\n        self._parent: Union[None, PipelineTreeNode2] = parent\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetreenode.py",
        "line": 37,
        "type": "empty_function",
        "content": "self._environment: Dict[str, Any] = {} if environment is None else environment",
        "context": "        self.seq_no: int = seq_no\n        self._component_name: str = name\n        self._parameters: Dict[str, Any] = {} if parameters is None else parameters\n        self._environment: Dict[str, Any] = {} if environment is None else environment\n        self._siblings: List[PipelineTreeNode2] = []\n        self._parent: Union[None, PipelineTreeNode2] = parent\n\n"
      },
      {
        "file": "language-learning/src/pipeline/varhelper.py",
        "line": 87,
        "type": "empty_function",
        "content": "raise NameError(\"Variable '{}' is unknown within the scope.\".format(line))",
        "context": "            return key, value, cls\n\n        # Raise exception if not found in current scope\n        raise NameError(\"Variable '{}' is unknown within the scope.\".format(line))\n\n    key_len = len(key)\n\n"
      },
      {
        "file": "language-learning/src/pipeline/varhelper.py",
        "line": 101,
        "type": "empty_function",
        "content": "raise NameError(\"Variable '{}' is unknown within the scope '{}'.\".format(line[key_len + 1:], scope))",
        "context": "    key, value, cls = get_variable_value(line[key_len+1:], values)\n\n    if key is None:\n        raise NameError(\"Variable '{}' is unknown within the scope '{}'.\".format(line[key_len + 1:], scope))\n\n    return scope + \".\" + key, value, cls\n\n"
      },
      {
        "file": "language-learning/src/pre_cleaner/pre_cleaner.py",
        "line": 66,
        "type": "empty_function",
        "content": "kwargs = {}",
        "context": "\t\t\t\t\t\t\tsplit_sentences.pl, even if text is lowercased (they're added by default)\n\t\t]\n\t\"\"\"\n\tkwargs = {}\n\ttry:\n\t\topts, args = getopt.getopt(argv,\"hi:o:c:b:a:s:l:t:x:y:z:UjpndTHeS\",[\"idir=\",\n\t\t\t\"odir=\", \"chars_invalid=\", \"boundary_chars=\",\"tokenized_chars=\", \n"
      },
      {
        "file": "language-learning/src/pre_cleaner/pre_cleaner.py",
        "line": 134,
        "type": "empty_function",
        "content": "boundary_chars: str = u'\\' \" \\.', tokenized_chars: str = u\"[](){}<>,:;/\\$#&+=?!\u00a1\u00bf\",",
        "context": "\tExecute_Precleaner(inputdir, outputdir, **kwargs)\n\ndef Execute_Precleaner(inputdir: str, outputdir: str, invalid_chars: str = \"\",\n\t\t\t\t\t\tboundary_chars: str = u'\\' \" \\.', tokenized_chars: str = u\"[](){}<>,:;/\\$#&+=?!\u00a1\u00bf\",\n\t\t\t\t\t\tsuffix_list: str = \"\", max_tokens: int = 25, max_chars: int = 25, \n\t\t\t\t\t\tsentence_invalid_symbols: str = \"\",\tsentence_invalid_tokens: list = [],\n\t\t\t\t\t\ttoken_invalid_symbols: str = \"\", convert_lowercase: bool = True,\n"
      },
      {
        "file": "language-learning/src/pre_cleaner/pre_cleaner.py",
        "line": 147,
        "type": "empty_function",
        "content": "print(\"Processing: {}/{}\".format(inputdir, inputfile))",
        "context": "\torder to achieve desired cleanup\n\t'''\n\tfor inputfile in os.listdir(inputdir):\n\t\tprint(\"Processing: {}/{}\".format(inputdir, inputfile))\n\t\tsentences = Load_Files(inputdir + \"/\" + inputfile)\n\n\t\toutputfile = outputdir + \"/\" + inputfile\n"
      },
      {
        "file": "language-learning/src/text_parser/__init__.py",
        "line": 76,
        "type": "empty_function",
        "content": "#                 logger.error(\"Error: neither '{}' nor '{}' is specified.\".format(PARAM_DICT_PATH, PARAM_LANGUAGE))",
        "context": "#         if parser_type.startswith(\"link-grammar\"):\n#\n#             if kwargs.get(PARAM_DICT_PATH, None) is None and kwargs.get(PARAM_LANGUAGE, None) is None:\n#                 logger.error(\"Error: neither '{}' nor '{}' is specified.\".format(PARAM_DICT_PATH, PARAM_LANGUAGE))\n#                 ret_val = False\n#\n#         return ret_val\n"
      },
      {
        "file": "language-learning/src/web/api/lgrestparser.py",
        "line": 76,
        "type": "empty_function",
        "content": "link_list               = {}                # output dictionary",
        "context": "\n    def on_get(self, req, resp):\n        \"\"\" Handle HTTP GET request \"\"\"\n        link_list               = {}                # output dictionary\n        link_list['errors']     = []                # list of errors if any\n        link_list['linkages']   = []                # list of linkages in requested format\n\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 76,
        "type": "empty_function",
        "content": "senses_id = {}",
        "context": "    with open(filename, 'r') as f:\n        words = []\n        senses = []\n        senses_id = {}\n        sense_count = 0\n        for line in f.readlines():\n            for token in line.split():\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 89,
        "type": "empty_function",
        "content": "answers = {}",
        "context": "                if sense not in senses_id:\n                    senses_id[sense] = sense_count\n                    sense_count += 1\n        answers = {}\n        for w, s in zip(words, senses):\n            if w not in answers:\n                answers[w] = []\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 170,
        "type": "empty_function",
        "content": "predictions = {}",
        "context": "    if random_benchmark:\n        fscore = 0\n        for repeat in range(rand_repeats):\n            predictions = {}\n            for word in true_answers.keys():\n                num_senses = len(set(true_answers[word]))\n                predictions[word] = [randint(1, num_senses) for i in range(len(true_answers[word]))]\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 176,
        "type": "empty_function",
        "content": "print(\"\\nAverage fscore after {} random benchmarks: {}\\n\".format(rand_repeats, fscore / rand_repeats))",
        "context": "                predictions[word] = [randint(1, num_senses) for i in range(len(true_answers[word]))]\n            scores = compute_metrics(true_answers, predictions)\n            fscore += scores[2]\n        print(\"\\nAverage fscore after {} random benchmarks: {}\\n\".format(rand_repeats, fscore / rand_repeats))\n    # compare reference to test\n    else:\n        for test_file in os.listdir(test_dir):\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 180,
        "type": "empty_function",
        "content": "print(\"Evaluating: {}\".format(test_file))",
        "context": "    # compare reference to test\n    else:\n        for test_file in os.listdir(test_dir):\n            print(\"Evaluating: {}\".format(test_file))\n            eval_files.append(test_file)\n            predictions = read_answers(test_dir + \"/\" + test_file, separator)\n            ari, vscore, fscore, punished_fscore = compute_metrics(true_answers, predictions)\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 192,
        "type": "empty_function",
        "content": "print(\"Best ari: {} in files {}\\n\".format(max_ari, [eval_files[i] for i in ari_indexes]))",
        "context": "\n        max_ari = max(ari_list)\n        ari_indexes = [i for i, j in enumerate(ari_list) if j == max_ari]\n        print(\"Best ari: {} in files {}\\n\".format(max_ari, [eval_files[i] for i in ari_indexes]))\n        max_vscore = max(vscore_list)\n        vscore_indexes = [i for i, j in enumerate(vscore_list) if j == max_vscore]\n        print(\"Best vscore: {} in files {}\\n\".format(max_vscore, [eval_files[i] for i in vscore_indexes]))\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 195,
        "type": "empty_function",
        "content": "print(\"Best vscore: {} in files {}\\n\".format(max_vscore, [eval_files[i] for i in vscore_indexes]))",
        "context": "        print(\"Best ari: {} in files {}\\n\".format(max_ari, [eval_files[i] for i in ari_indexes]))\n        max_vscore = max(vscore_list)\n        vscore_indexes = [i for i, j in enumerate(vscore_list) if j == max_vscore]\n        print(\"Best vscore: {} in files {}\\n\".format(max_vscore, [eval_files[i] for i in vscore_indexes]))\n        max_fscore = max(fscore_list)\n        fscore_indexes = [i for i, j in enumerate(fscore_list) if j == max_fscore]\n        print(\"Best fscore: {} in files {}\\n\".format(max_fscore, [eval_files[i] for i in fscore_indexes]))\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 198,
        "type": "empty_function",
        "content": "print(\"Best fscore: {} in files {}\\n\".format(max_fscore, [eval_files[i] for i in fscore_indexes]))",
        "context": "        print(\"Best vscore: {} in files {}\\n\".format(max_vscore, [eval_files[i] for i in vscore_indexes]))\n        max_fscore = max(fscore_list)\n        fscore_indexes = [i for i, j in enumerate(fscore_list) if j == max_fscore]\n        print(\"Best fscore: {} in files {}\\n\".format(max_fscore, [eval_files[i] for i in fscore_indexes]))\n        max_wsd_score = max(wsd_score_list)\n        wsd_score_indexes = [i for i, j in enumerate(wsd_score_list) if j == max_wsd_score]\n        print(\"Best WSD score: {} in files {}\\n\".format(max_wsd_score, [eval_files[i] for i in wsd_score_indexes]))\n"
      },
      {
        "file": "language-learning/src/word_senser/evaluate_WSD.py",
        "line": 201,
        "type": "empty_function",
        "content": "print(\"Best WSD score: {} in files {}\\n\".format(max_wsd_score, [eval_files[i] for i in wsd_score_indexes]))",
        "context": "        print(\"Best fscore: {} in files {}\\n\".format(max_fscore, [eval_files[i] for i in fscore_indexes]))\n        max_wsd_score = max(wsd_score_list)\n        wsd_score_indexes = [i for i, j in enumerate(wsd_score_list) if j == max_wsd_score]\n        print(\"Best WSD score: {} in files {}\\n\".format(max_wsd_score, [eval_files[i] for i in wsd_score_indexes]))\n    \nif __name__ == '__main__':\n    main(sys.argv[1:])\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser.py",
        "line": 201,
        "type": "empty_function",
        "content": "self.assertEqual(num_sent, 12, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 12))",
        "context": "        \"\"\" Test postscript parsing for total number of parsed sentences \"\"\"\n        pr = LGInprocParser()\n        num_sent = len(pr._parse_batch_ps_output(lg_post_output, 0))\n        self.assertEqual(num_sent, 12, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 12))\n\n    # # @unittest.skip\n    # def test_parse_batch_ps_output_explosion(self):\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser.py",
        "line": 208,
        "type": "empty_function",
        "content": "#     self.assertEqual(num_sent, 4, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 4))",
        "context": "    #     \"\"\" Test for 'combinatorial explosion' \"\"\"\n    #     pr = LGInprocParser(verbosity=0)\n    #     num_sent = len(pr._parse_batch_ps_output(lg_post_explosion, 0))\n    #     self.assertEqual(num_sent, 4, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 4))\n\n    # @unittest.skip\n    def test_parse_batch_ps_output_sharp(self):\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser.py",
        "line": 216,
        "type": "empty_function",
        "content": "self.assertEqual(num_sent, 1, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 1))",
        "context": "        pr = LGInprocParser(verbosity=1)\n        sentences = pr._parse_batch_ps_output(sharp_sign_linkage, 0)\n        num_sent = len(sentences)\n        self.assertEqual(num_sent, 1, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 1))\n\n        print(sentences[0].text)\n        print(sentences[0].linkages)\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser.py",
        "line": 304,
        "type": "empty_function",
        "content": "token_counts, total_count = {}, 0",
        "context": "\n    # @unittest.skip\n    def test_min_word_count(self):\n        token_counts, total_count = {}, 0\n        corpus_file_path = \"tests/test-data/corpora/poc-turtle/poc-turtle-dot-separated.txt\"\n\n        options = BIT_EXISTING_DICT | BIT_NO_LWALL | BIT_NO_PERIOD | BIT_STRIP\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser2.py",
        "line": 113,
        "type": "empty_function",
        "content": "#     self.assertEqual(num_sent, 12, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 12))",
        "context": "    #     \"\"\" Test postscript parsing for total number of parsed sentences \"\"\"\n    #     pr = LGInprocParser2()\n    #     num_sent = len(pr._parse_batch_ps_output(lg_post_output, 0))\n    #     self.assertEqual(num_sent, 12, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 12))\n    #\n    # @unittest.skip\n    # def test_parse_batch_ps_output_explosion(self):\n"
      },
      {
        "file": "language-learning/tests/test_lginprocparser2.py",
        "line": 120,
        "type": "empty_function",
        "content": "#     self.assertEqual(num_sent, 4, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 4))",
        "context": "    #     \"\"\" Test for 'combinatorial explosion' \"\"\"\n    #     pr = LGInprocParser2(verbosity=0)\n    #     num_sent = len(pr._parse_batch_ps_output(lg_post_explosion, 0))\n    #     self.assertEqual(num_sent, 4, \"'parse_batch_ps_output()' returns '{}' instead of '{}'\".format(num_sent, 4))\n\n    # @unittest.skip\n    def test_parse_sent_count(self):\n"
      },
      {
        "file": "language-learning/tests/test_pipelinetree.py",
        "line": 82,
        "type": "empty_function",
        "content": "self.assertEqual({}, root._environment)",
        "context": "        self.assertEqual(\"grammar-learner\", root._component_name)\n        self.assertEqual({\"space\": \"cDRKc\"}, root._specific_parameters)\n        self.assertEqual({\"input_parses\": \"~/data/parses/poc-turtle\"}, root._common_parameters)\n        self.assertEqual({}, root._environment)\n\n    @unittest.skip\n    def test_add_siblings(self):\n"
      },
      {
        "file": "language-learning/tests/test_tokencount.py",
        "line": 17,
        "type": "empty_function",
        "content": "token_counts, total_counts = {}, 0",
        "context": "            os.mkdir(self.output_dir)\n\n    def test_get_token_counts(self):\n        token_counts, total_counts = {}, 0\n\n        options = BIT_EXISTING_DICT | BIT_NO_LWALL | BIT_NO_PERIOD | BIT_STRIP\n\n"
      },
      {
        "file": "learn/opencog/learn/UnsupervisedLearner.cc",
        "line": 359,
        "type": "empty_function",
        "content": "double consistency = 0.7 + 0.3 * (std::hash<std::string>{}(pattern->get_name()) % 100) / 100.0;",
        "context": "    double coverage = std::min(1.0, static_cast<double>(examples.size()) / 10.0);\n    \n    // Add some randomness to simulate more complex quality assessment\n    double consistency = 0.7 + 0.3 * (std::hash<std::string>{}(pattern->get_name()) % 100) / 100.0;\n    \n    return (coverage + consistency) / 2.0;\n}\n"
      },
      {
        "file": "lg-atomese/opencog/lg-atomese/LGParser.cc",
        "line": 156,
        "type": "empty_function",
        "content": "oss << \"parse_\" << sentence.substr(0, 20) << \"_\" << std::hash<std::string>{}(parse_info);",
        "context": "    }\n    \n    std::ostringstream oss;\n    oss << \"parse_\" << sentence.substr(0, 20) << \"_\" << std::hash<std::string>{}(parse_info);\n    \n    Handle parse_atom = atomspace_->add_node(CONCEPT_NODE, oss.str());\n    \n"
      },
      {
        "file": "lg-atomese/opencog/lg-atomese/LGParser.cc",
        "line": 174,
        "type": "empty_function",
        "content": "std::string(\"linkage_\") + std::to_string(std::hash<std::string>{}(linkage_info)));",
        "context": "    }\n    \n    Handle linkage_atom = atomspace_->add_node(CONCEPT_NODE, \n                                              std::string(\"linkage_\") + std::to_string(std::hash<std::string>{}(linkage_info)));\n    \n    // Add linkage information as value\n    StringValuePtr linkage_value = createStringValue({linkage_info});\n"
      },
      {
        "file": "lg-atomese/opencog/lg-atomese/LGParser.cc",
        "line": 336,
        "type": "empty_function",
        "content": "linkage_id << \"linkage_\" << linkage_num << \"_\" << std::hash<std::string>{}(linkage_info);",
        "context": "    \n    // Create unique linkage identifier\n    std::ostringstream linkage_id;\n    linkage_id << \"linkage_\" << linkage_num << \"_\" << std::hash<std::string>{}(linkage_info);\n    Handle linkage_atom = atomspace_->add_node(CONCEPT_NODE, linkage_id.str());\n    \n    // Create word atoms\n"
      },
      {
        "file": "meta-cognition/examples/meta_cognitive_demo.cc",
        "line": 36,
        "type": "empty_function",
        "content": ": name_(name), atomspace_(as), rng_(std::random_device{}()), dist_(0.0, 1.0)",
        "context": "    \npublic:\n    ECANCognitiveComponent(const std::string& name, AtomSpace* as)\n        : name_(name), atomspace_(as), rng_(std::random_device{}()), dist_(0.0, 1.0)\n    {\n        // Create attention bank\n        attention_bank_ = std::make_shared<AttentionBank>(as);\n"
      },
      {
        "file": "meta-cognition/src/CoreSelfAwareness.cc",
        "line": 704,
        "type": "empty_function",
        "content": "} catch (...) {}",
        "context": "        for (const auto& obs : self_observation_functions_) {\n            try {\n                avg_state += obs.second();\n            } catch (...) {}\n        }\n        avg_state /= self_observation_functions_.size();\n        patterns[\"average_component_activity\"] = avg_state;\n"
      },
      {
        "file": "moses/examples/example-ant/ant_scoring.cc",
        "line": 32,
        "type": "empty_function",
        "content": ": _steps(steps) {}",
        "context": "////////////////////////\n\nAntFitnessFunction::AntFitnessFunction(int steps)\n    : _steps(steps) {}\n\nvoid AntFitnessFunction::turn_left(Direction& d) {\n    d = (Direction)(((int)d + 3) % 4);\n"
      },
      {
        "file": "moses/examples/example-ant/ant_scoring.cc",
        "line": 167,
        "type": "empty_function",
        "content": ": AntFitnessFunction(steps), _noise(noise) {}",
        "context": "/////////////////////////\n\nAntFitnessEstimator::AntFitnessEstimator(int steps, int noise)\n    : AntFitnessFunction(steps), _noise(noise) {}\nscore_t AntFitnessEstimator::operator()(const combo_tree& tr) const\n{\n    int error = opencog::randGen().randint(_noise + 1) - _noise / 2;\n"
      },
      {
        "file": "moses/examples/example-ant/ant_scoring.h",
        "line": 116,
        "type": "empty_function",
        "content": "ant_bscore() {}",
        "context": "\nstruct ant_bscore : public bscore_base\n{\n    ant_bscore() {}\n\n    behavioral_score operator()(const combo_tree& tr) const;\n\n"
      },
      {
        "file": "moses/examples/example-progs/pole_balancing.h",
        "line": 11,
        "type": "empty_function",
        "content": "virtual ~CartPole() {}",
        "context": "class CartPole {\npublic:\n    CartPole(bool randomize,bool velocity);\n    virtual ~CartPole() {}\n    virtual void simplifyTask();  \n    virtual void nextTask();\n    virtual double evalNet(combo::ann *net);\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_functions.h",
        "line": 84,
        "type": "empty_function",
        "content": "n_max(const field_set& fs) : fields(fs) {}",
        "context": "// settings in the instance.\nstruct n_max\n{\n    n_max(const field_set& fs) : fields(fs) {}\n    int operator()(const instance& inst) const\n    {\n        return accumulate(fields.begin_disc(inst), fields.end_disc(inst), 0);\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_functions.h",
        "line": 96,
        "type": "empty_function",
        "content": "contin_max(const field_set& fs) : fields(fs) {}",
        "context": "// in the instance.\nstruct contin_max\n{\n    contin_max(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const\n    {\n        return accumulate(fields.begin_contin(inst), fields.end_contin(inst),\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_functions.h",
        "line": 144,
        "type": "empty_function",
        "content": "sphere(const field_set& fs) : fields(fs) {}",
        "context": "//\nstruct sphere\n{\n    sphere(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const {\n        contin_t res = 0;\n        for (field_set::const_contin_iterator it = fields.begin_contin(inst);\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_functions.h",
        "line": 168,
        "type": "empty_function",
        "content": "termmax(const field_set& fs) : fields(fs) {}",
        "context": "// adds them together.  The sum of all of these is the returned score.\nstruct termmax\n{\n    termmax(const field_set& fs) : fields(fs) {}\n    contin_t operator()(const instance& inst) const\n    {\n        contin_t res = 0;\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_iterators.h",
        "line": 75,
        "type": "empty_function",
        "content": "multiplex(unsigned int n) : arity(n) { }",
        "context": "// is the address of the string bit described by a1, ..., an.\nstruct multiplex  : public iterator_function<bool>\n{\n    multiplex(unsigned int n) : arity(n) { }\n    unsigned int arity;\n    // [from, to( corresponds to the sequence of inputs of the\n    // function, the result corresponds to its output\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_iterators.h",
        "line": 94,
        "type": "empty_function",
        "content": "majority(unsigned int n) : arity(n) { }",
        "context": "// majority(x1, ..., xn) = 0 iff n/2 or more arguments are false\nstruct majority : public iterator_function<bool>\n{\n    majority(unsigned int n) : arity(n) { }\n    unsigned int arity;\n    // [from, to( corresponds to the sequence of inputs of the\n    // function, the result corresponds to its output\n"
      },
      {
        "file": "moses/examples/example-progs/scoring_iterators.h",
        "line": 112,
        "type": "empty_function",
        "content": "simple_symbolic_regression(int o = 4) : order(o) { }",
        "context": "// f(x)_0 = 0\nstruct simple_symbolic_regression : public iterator_function<contin_t>\n{\n    simple_symbolic_regression(int o = 4) : order(o) { }\n    int order;\n    template<typename It>\n    contin_t operator()(It from, It to) const {\n"
      },
      {
        "file": "moses/examples/example-progs/trap-bit.cc",
        "line": 89,
        "type": "empty_function",
        "content": "trap(int n, int len) : trapsz(n), rounds(len) {}",
        "context": "\nstruct trap\n{\n    trap(int n, int len) : trapsz(n), rounds(len) {}\n\n    int vee(int x) const\n    {\n"
      },
      {
        "file": "moses/examples/example-progs/trap-uni.cc",
        "line": 83,
        "type": "empty_function",
        "content": "trap(const field_set& fs, int n) : fields(fs), max(n-1) {}",
        "context": "\nstruct trap\n{\n    trap(const field_set& fs, int n) : fields(fs), max(n-1) {}\n\n    int vee(int x) const\n    {\n"
      },
      {
        "file": "moses/moses/comboreduct/ant_combo_vocabulary/ant_action_symbol.cc",
        "line": 31,
        "type": "empty_function",
        "content": "ant_action_symbol::ant_action_symbol() { }",
        "context": "\nusing namespace ant_action_symbol_properties;\n\nant_action_symbol::ant_action_symbol() { }\n\nconst action_symbol_basic_description* ant_action_symbol::get_basic_description_array() const {\n  return asbd;\n"
      },
      {
        "file": "moses/moses/comboreduct/ant_combo_vocabulary/ant_indefinite_object.cc",
        "line": 31,
        "type": "empty_function",
        "content": "ant_indefinite_object::ant_indefinite_object() { }",
        "context": "\nusing namespace ant_indefinite_object_properties;\n\nant_indefinite_object::ant_indefinite_object() { }\n\nconst indefinite_object_basic_description* ant_indefinite_object::get_basic_description_array() const {\n  return iobd;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/action_symbol.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~action_symbol_base() {}",
        "context": "//without additional properties\nclass action_symbol_base : public operator_base {\npublic:\n    virtual ~action_symbol_base() {}\n\n    static const action_symbol_base* get_instance(const std::string& name) {\n         return NULL;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/ann.h",
        "line": 38,
        "type": "empty_function",
        "content": "ann_type(unsigned int i, ann_id _id) : idx(i), id(_id) {}",
        "context": "\nclass ann_type {\npublic:\n    ann_type(unsigned int i, ann_id _id) : idx(i), id(_id) {}\n    unsigned int idx;\n    ann_id id;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/builtin_action.h",
        "line": 61,
        "type": "empty_function",
        "content": "virtual ~builtin_action_base() {}",
        "context": "\nclass builtin_action_base : public operator_base {\npublic:\n    virtual ~builtin_action_base() {}\n\n    static const builtin_action_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/convert_ann_combo.h",
        "line": 37,
        "type": "empty_function",
        "content": "tree_transform() {}",
        "context": " */\nstruct tree_transform {\n\n    tree_transform() {}\n\n    combo_tree encode_node(ann& the_ann, ann_node* node) const {\n        int tag = node->tag;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/indefinite_object.h",
        "line": 38,
        "type": "empty_function",
        "content": "virtual ~indefinite_object_base() {}",
        "context": "//without additional properties\nclass indefinite_object_base : public operator_base {\npublic:\n    virtual ~indefinite_object_base() {}\n\n    static const indefinite_object_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/operator_base.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~operator_base() {}",
        "context": "  //of builtin_action_base and perception_base\n  class operator_base {\n  public:\n    virtual ~operator_base() {}\n\n    //get_name\n    virtual const std::string& get_name() const = 0;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/perception.h",
        "line": 59,
        "type": "empty_function",
        "content": "virtual ~perception_base() {}",
        "context": "\nclass perception_base : public operator_base {\npublic:\n    virtual ~perception_base() {}\n\n    static const perception_base* get_instance(const std::string& name) {\n        return NULL;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/procedure_call.cc",
        "line": 48,
        "type": "empty_function",
        "content": "procedure_call_base::~procedure_call_base() {}",
        "context": "    }\n}\n\nprocedure_call_base::~procedure_call_base() {}\n\n//get_name\nconst std::string& procedure_call_base::get_name() const\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/similarity.cc",
        "line": 218,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\t\tbcnt = bv.at(pr.first);\n\t\t}\n\t\tcatch (const std::out_of_range& oor)\n\t\t{}\n\n\t\tdist += fabs(acnt - bcnt);\n\t}\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/simple_nn.h",
        "line": 67,
        "type": "empty_function",
        "content": "source(s), dest(d), weight(w) { }",
        "context": "{\npublic:\n    ann_connection(ann_node* s, ann_node* d, double w):\n            source(s), dest(d), weight(w) { }\n    ann_node* source;\n    ann_node* dest;\n    double weight;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/simple_nn.h",
        "line": 85,
        "type": "empty_function",
        "content": ": visited(false), memory_ptr(_ptr), activation(0.0), tag(_tag), nodetype(type) {}",
        "context": "{\npublic:\n    ann_node(ann_nodetype type, int _tag = 0, ann_node* _ptr=NULL)\n        : visited(false), memory_ptr(_ptr), activation(0.0), tag(_tag), nodetype(type) {}\n\n    bool visited; //used for constructing combotrees\n    int counter; //used for determining network depth\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/simple_nn.h",
        "line": 158,
        "type": "empty_function",
        "content": "ann() {}",
        "context": "    //a list of all the connections\n    std::vector<ann_connection*> connections;\n\n    ann() {}\n\n    ~ann() {\n        ann_node_it iter;\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 821,
        "type": "empty_function",
        "content": "hsh ^= std::hash<opencog::combo::vertex>{}(v)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (const opencog::combo::vertex& v: tre)\n\t\t\t\thsh ^= std::hash<opencog::combo::vertex>{}(v)\n\t\t\t\t       + 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "moses/moses/comboreduct/crutil/exception.cc",
        "line": 29,
        "type": "empty_function",
        "content": ": _message(m) {}",
        "context": "namespace opencog { namespace combo {\n\nComboReductException::ComboReductException(std::string m)\n  : _message(m) {}\n\nstd::string ComboReductException::get_message() const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/crutil/exception.cc",
        "line": 37,
        "type": "empty_function",
        "content": ": ComboReductException(\"Overflow Exception\"), _vertex(v) {}",
        "context": "}\n\nOverflowException::OverflowException(vertex v)\n    : ComboReductException(\"Overflow Exception\"), _vertex(v) {}\n\nvertex OverflowException::get_vertex() const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/crutil/exception.cc",
        "line": 45,
        "type": "empty_function",
        "content": ": ComboReductException(m), _vertex(v) {}",
        "context": "}\n\nEvalException::EvalException(vertex v, std::string m)\n    : ComboReductException(m), _vertex(v) {}\n\nvertex EvalException::get_vertex() const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/crutil/exception.cc",
        "line": 53,
        "type": "empty_function",
        "content": ": ComboReductException(\"Type check Exception\"), _arg(arg) {}",
        "context": "}\n\nTypeCheckException::TypeCheckException(int arg)\n    : ComboReductException(\"Type check Exception\"), _arg(arg) {} \n\n}} // ~namespaces combo opencog\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 38,
        "type": "empty_function",
        "content": ": boolean_inputs(inputs) {}",
        "context": "/////////////////////////\n\nboolean_interpreter::boolean_interpreter(const std::vector<builtin>& inputs)\n    : boolean_inputs(inputs) {}\n\nbuiltin boolean_interpreter::operator()(const combo_tree& tr) const {\n    return boolean_eval(tr.begin());\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 109,
        "type": "empty_function",
        "content": ": contin_inputs(inputs) {}",
        "context": "////////////////////////\n\ncontin_interpreter::contin_interpreter(const std::vector<contin_t>& inputs)\n    : contin_inputs(inputs) {}\n\ncontin_t contin_interpreter::operator()(const combo_tree& tr) const {\n    return contin_eval(tr.begin());\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 231,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(false),\n    _use_contin_inputs(false),\n    _mixed_inputs(inputs)\n{}\n\nmixed_interpreter::mixed_interpreter(const std::vector<contin_t>& inputs) :\n    contin_interpreter(inputs),\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 238,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(false),\n    _use_contin_inputs(true),\n    _mixed_inputs(empty_vertex_seq)\n{}\n\nmixed_interpreter::mixed_interpreter(const std::vector<builtin>& inputs) :\n    boolean_interpreter(inputs),\n"
      },
      {
        "file": "moses/moses/comboreduct/interpreter/interpreter.cc",
        "line": 245,
        "type": "empty_function",
        "content": "{}",
        "context": "    _use_boolean_inputs(true),\n    _use_contin_inputs(false),\n    _mixed_inputs(empty_vertex_seq)\n{}\n\nvertex mixed_interpreter::operator()(const combo_tree& tr) const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 60,
        "type": "empty_function",
        "content": "crule<reduce_action_if>::crule(\"reduce_action_if\") {}",
        "context": "//action_boolean_if(C A A) -> A\nstruct reduce_action_if : public crule<reduce_action_if> {\n    reduce_action_if() : \n          crule<reduce_action_if>::crule(\"reduce_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 67,
        "type": "empty_function",
        "content": "crule<reduce_action_action_if>::crule(\"reduce_action_action_if\") {}",
        "context": "//action_action_if(A B B) -> and_seq(exec_seq(A) B)\nstruct reduce_action_action_if : public crule<reduce_action_action_if> {\n    reduce_action_action_if() : \n        crule<reduce_action_action_if>::crule(\"reduce_action_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 76,
        "type": "empty_function",
        "content": "crule<reduce_const_cond_action_if>::crule(\"reduce_const_cond_action_if\") {}",
        "context": "//with T in {action, boolean, contin}\nstruct reduce_const_cond_action_if: public crule<reduce_const_cond_action_if> {\n    reduce_const_cond_action_if() :\n        crule<reduce_const_cond_action_if>::crule(\"reduce_const_cond_action_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 84,
        "type": "empty_function",
        "content": "crule<reduce_not_cond_action_boolean_if>::crule(\"reduce_not_cond_action_boolean_if\") {}",
        "context": "struct reduce_not_cond_action_boolean_if:\n        public crule<reduce_not_cond_action_boolean_if> {\n    reduce_not_cond_action_boolean_if() :\n        crule<reduce_not_cond_action_boolean_if>::crule(\"reduce_not_cond_action_boolean_if\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 96,
        "type": "empty_function",
        "content": "crule<reduce_const_action_seq>::crule(\"reduce_const_action_seq\") {}",
        "context": "//exec_seq(A action_success C) -> exec_seq(A B)\nstruct reduce_const_action_seq : public crule<reduce_const_action_seq> {\n    reduce_const_action_seq () :\n        crule<reduce_const_action_seq>::crule(\"reduce_const_action_seq\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 105,
        "type": "empty_function",
        "content": "crule<reduce_empty_arg_seq>::crule(\"reduce_empty_arg_seq\") {}",
        "context": "//exec_seq() -> action_success\nstruct reduce_empty_arg_seq : public crule<reduce_empty_arg_seq> {\n    reduce_empty_arg_seq () :\n        crule<reduce_empty_arg_seq>::crule(\"reduce_empty_arg_seq\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 112,
        "type": "empty_function",
        "content": "crule<reduce_double_action_not>::crule(\"reduce_double_action_not\") {}",
        "context": "//action_not(action_not(A)) -> A\nstruct reduce_double_action_not : public crule<reduce_double_action_not> {\n    reduce_double_action_not () :\n        crule<reduce_double_action_not>::crule(\"reduce_double_action_not\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 120,
        "type": "empty_function",
        "content": "crule<reduce_repeat_out_action_while>::crule(\"reduce_repeat_out_action_while\") {}",
        "context": "//and_seq(A B action_while(B)) -> and_seq(A action_while(B))\nstruct reduce_repeat_out_action_while : public crule<reduce_repeat_out_action_while> {\n    reduce_repeat_out_action_while () :\n        crule<reduce_repeat_out_action_while>::crule(\"reduce_repeat_out_action_while\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 127,
        "type": "empty_function",
        "content": "reduce_repeat_in_action_while() : crule<reduce_repeat_in_action_while>::crule(\"reduce_repeat_in_action_while\") {}",
        "context": "//action_while(and_seq(A A)) -> action_while(A)\nstruct reduce_repeat_in_action_while : public\n            crule<reduce_repeat_in_action_while> {\n    reduce_repeat_in_action_while() : crule<reduce_repeat_in_action_while>::crule(\"reduce_repeat_in_action_while\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 137,
        "type": "empty_function",
        "content": "reduce_action_boolean_if_sub_cond() : crule<reduce_action_boolean_if_sub_cond>::crule(\"reduce_action_boolean_if_sub_cond\") {}",
        "context": "//action_boolean_if condition\nstruct reduce_action_boolean_if_sub_cond : public\n            crule<reduce_action_boolean_if_sub_cond> {\n    reduce_action_boolean_if_sub_cond() : crule<reduce_action_boolean_if_sub_cond>::crule(\"reduce_action_boolean_if_sub_cond\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 147,
        "type": "empty_function",
        "content": "reduce_boolean_while_sub_cond() : crule<reduce_boolean_while_sub_cond>::crule(\"reduce_boolean_while_sub_cond\") {}",
        "context": "//C within boolean_while condition.\nstruct reduce_boolean_while_sub_cond : public\n            crule<reduce_boolean_while_sub_cond> {\n    reduce_boolean_while_sub_cond() : crule<reduce_boolean_while_sub_cond>::crule(\"reduce_boolean_while_sub_cond\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 158,
        "type": "empty_function",
        "content": "reduce_action_action_if_always_succeeds() : crule<reduce_action_action_if_always_succeeds>::crule(\"reduce_action_action_if_always_succeeds\") {}",
        "context": "//action_action_if(A B C) -> and_seq(A B) iff get_action_result(A)==true\nstruct reduce_action_action_if_always_succeeds :\n            public crule<reduce_action_action_if_always_succeeds> {\n    reduce_action_action_if_always_succeeds() : crule<reduce_action_action_if_always_succeeds>::crule(\"reduce_action_action_if_always_succeeds\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 171,
        "type": "empty_function",
        "content": "reduce_action_while_always_fails() : crule<reduce_action_while_always_fails>::crule(\"reduce_action_while_always_fails\") {}",
        "context": "//action_while(A) -> A iff get_action_result(A)==false\nstruct reduce_action_while_always_fails :\n            public crule<reduce_action_while_always_fails> {\n    reduce_action_while_always_fails() : crule<reduce_action_while_always_fails>::crule(\"reduce_action_while_always_fails\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 179,
        "type": "empty_function",
        "content": "reduce_boolean_while_depend_condition() : crule<reduce_boolean_while_depend_condition>::crule(\"reduce_boolean_while_depend_condition\") {}",
        "context": "//boolean_while(C A) -> A iff eval(C)==true and get_action_result(A)==false\nstruct reduce_boolean_while_depend_condition :\n            public crule<reduce_boolean_while_depend_condition> {\n    reduce_boolean_while_depend_condition() : crule<reduce_boolean_while_depend_condition>::crule(\"reduce_boolean_while_depend_condition\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 188,
        "type": "empty_function",
        "content": "reduce_sequential_and_always_fails() : crule<reduce_sequential_and_always_fails>::crule(\"reduce_sequential_and_always_fails\") {}",
        "context": "//and get_action_result(An)==false\nstruct reduce_sequential_and_always_fails :\n            public crule<reduce_sequential_and_always_fails> {\n    reduce_sequential_and_always_fails() : crule<reduce_sequential_and_always_fails>::crule(\"reduce_sequential_and_always_fails\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 197,
        "type": "empty_function",
        "content": "reduce_sequential_or_always_succeeds() : crule<reduce_sequential_or_always_succeeds>::crule(\"reduce_sequential_or_always_succeeds\") {}",
        "context": "//and get_action_result(An)==true\nstruct reduce_sequential_or_always_succeeds :\n            public crule<reduce_sequential_or_always_succeeds> {\n    reduce_sequential_or_always_succeeds() : crule<reduce_sequential_or_always_succeeds>::crule(\"reduce_sequential_or_always_succeeds\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 207,
        "type": "empty_function",
        "content": "reduce_idempotent() : crule<reduce_idempotent>::crule(\"reduce_idempotent\") {}",
        "context": "\n//reduce 2 consecutive actions to 1 action\nstruct reduce_idempotent : public crule<reduce_idempotent> {\n    reduce_idempotent() : crule<reduce_idempotent>::crule(\"reduce_idempotent\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 214,
        "type": "empty_function",
        "content": "reduce_opposite() : crule<reduce_opposite>::crule(\"reduce_opposite\") {}",
        "context": "//reduce 2 consecutive opposite actions A1 A2\n//that is A1 is the reversal of A2\nstruct reduce_opposite : public crule<reduce_opposite> {\n    reduce_opposite() : crule<reduce_opposite>::crule(\"reduce_opposite\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 223,
        "type": "empty_function",
        "content": "reduce_additive() : crule<reduce_additive>::crule(\"reduce_additive\") {}",
        "context": "//are denoted additive by is_additive(action,int i);\n//the argument that are not denoted additive must be equal\nstruct reduce_additive : public crule<reduce_additive> {\n    reduce_additive() : crule<reduce_additive>::crule(\"reduce_additive\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 231,
        "type": "empty_function",
        "content": "reduce_zero_neutral() : crule<reduce_zero_neutral>::crule(\"reduce_zero_neutral\") {}",
        "context": "//replace action by action_success if exists 0 in one of its argument\n//neutral\nstruct reduce_zero_neutral : public crule<reduce_zero_neutral> {\n    reduce_zero_neutral() : crule<reduce_zero_neutral>::crule(\"reduce_zero_neutral\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 244,
        "type": "empty_function",
        "content": "reduce_modular_argument() : crule<reduce_modular_argument>::crule(\"reduce_modular_argument\") {}",
        "context": "//action_with_modular_argument(m) -> action_with_modular_argument(reduced(m))\n//for example, dummy_modular_action(6.28,-20)-> dummy_modular_action(0,-10)\nstruct reduce_modular_argument : public crule<reduce_modular_argument> {\n    reduce_modular_argument() : crule<reduce_modular_argument>::crule(\"reduce_modular_argument\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/action_rules.h",
        "line": 262,
        "type": "empty_function",
        "content": "preconditions_check() : crule<preconditions_check>::crule(\"preconditions_check\") {}",
        "context": "// and_seq(or_seq(grab bark) drop bark)-> and_seq(or_seq(grab bark) drop bark)\n// and_seq(or_seq(bark bark) drop bark)-> and_seq(or_seq(bark bark) action_success bark)\nstruct preconditions_check : public crule<preconditions_check> {\n    preconditions_check() : crule<preconditions_check>::crule(\"preconditions_check\") {}\n    void operator() (combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/ann_rules.h",
        "line": 42,
        "type": "empty_function",
        "content": "ann_rule() : crule<ann_rule>::crule(\"ann_rule\") {}",
        "context": "//ann reduction rule\n// WARNING: this rule should only be used alone, not combined with meta_rules\nstruct ann_rule : public crule<ann_rule> {\n    ann_rule() : crule<ann_rule>::crule(\"ann_rule\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const\n    {\n        tree_transform trans;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 40,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(igop) {}",
        "context": "    const vertex_set &ignore_ops;\n    reduce_cond_arg(int effort, const vertex_set &igop)\n        : crule<reduce_cond_arg>::crule(\"reduce_cond_arg\"),\n          reduct_effort(effort), ignore_ops(igop) {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n}; \n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 51,
        "type": "empty_function",
        "content": ": crule<reduce_cond_else>::crule(\"reduce_cond_else\") {}",
        "context": "struct reduce_cond_else : public crule<reduce_cond_else> \n{\n    reduce_cond_else() \n        : crule<reduce_cond_else>::crule(\"reduce_cond_else\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 61,
        "type": "empty_function",
        "content": ": crule<reduce_cond_adjacent>::crule(\"reduce_cond_adjacent\") {}",
        "context": "struct reduce_cond_adjacent : public crule<reduce_cond_adjacent> \n{\n    reduce_cond_adjacent() \n        : crule<reduce_cond_adjacent>::crule(\"reduce_cond_adjacent\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/branch_rules.h",
        "line": 85,
        "type": "empty_function",
        "content": ": crule<reduce_cond_const>::crule(\"reduce_cond_const\") {}",
        "context": "struct reduce_cond_const : public crule<reduce_cond_const> \n{\n    reduce_cond_const() \n        : crule<reduce_cond_const>::crule(\"reduce_cond_const\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 33,
        "type": "empty_function",
        "content": "reduce_plus_zero() : crule<reduce_plus_zero>::crule(\"reduce_plus_zero\") {}",
        "context": "\n//x+0 -> x\nstruct reduce_plus_zero : public crule<reduce_plus_zero> {\n    reduce_plus_zero() : crule<reduce_plus_zero>::crule(\"reduce_plus_zero\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 40,
        "type": "empty_function",
        "content": "reduce_times_one_zero() : crule<reduce_times_one_zero>::crule(\"reduce_times_one_zero\") {}",
        "context": "//x*1 -> x\n//x*0 -> 0\nstruct reduce_times_one_zero : public crule<reduce_times_one_zero> {\n    reduce_times_one_zero() : crule<reduce_times_one_zero>::crule(\"reduce_times_one_zero\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "reduce_factorize_fraction() : crule<reduce_factorize_fraction>::crule(\"reduce_factorize_fraction\") {}",
        "context": "//1)is the one that shorten the most the expression\n//2)if not unique, the lowest one according to the index order\nstruct reduce_factorize_fraction : public crule<reduce_factorize_fraction> {\n    reduce_factorize_fraction() : crule<reduce_factorize_fraction>::crule(\"reduce_factorize_fraction\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 61,
        "type": "empty_function",
        "content": "reduce_factorize() : crule<reduce_factorize>::crule(\"reduce_factorize\") {}",
        "context": "//2)if not unique, the lowest one according to the index order\n//Note : if x is a numerator of div, it works too\nstruct reduce_factorize : public crule<reduce_factorize> {\n    reduce_factorize() : crule<reduce_factorize>::crule(\"reduce_factorize\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 86,
        "type": "empty_function",
        "content": "crule<reduce_distribute>::crule(\"reduce_distribute\"), _reduction(&r) {}",
        "context": "// complete\nstruct reduce_distribute : public crule<reduce_distribute> {\n    reduce_distribute(const rule& r) : \n        crule<reduce_distribute>::crule(\"reduce_distribute\"), _reduction(&r) {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 97,
        "type": "empty_function",
        "content": "reduce_invert_constant() : crule<reduce_invert_constant>::crule(\"reduce_invert_constant\") {}",
        "context": "//x/(c*y) -> 1/c *x/y\n//0/x -> 0\nstruct reduce_invert_constant : public crule<reduce_invert_constant> {\n    reduce_invert_constant() : crule<reduce_invert_constant>::crule(\"reduce_invert_constant\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 105,
        "type": "empty_function",
        "content": "reduce_fraction() : crule<reduce_fraction>::crule(\"reduce_fraction\") {}",
        "context": "//or more generally,\n//(prod x_i*prod y_j)/(prod x_i*prod z_k)-> prod y_j/prod z_k\nstruct reduce_fraction : public crule<reduce_fraction> {\n    reduce_fraction() : crule<reduce_fraction>::crule(\"reduce_fraction\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 114,
        "type": "empty_function",
        "content": "reduce_times_div() : crule<reduce_times_div>::crule(\"reduce_times_div\") {}",
        "context": "//x*(y/z) -> (x*y)/z,\n//more generally prod x_i * prod y_j/z_j -> (prod x_i * prod y_j)/(prod z_j)\nstruct reduce_times_div : public crule<reduce_times_div> {\n    reduce_times_div() : crule<reduce_times_div>::crule(\"reduce_times_div\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 121,
        "type": "empty_function",
        "content": "reduce_plus_times_one_child() : crule<reduce_plus_times_one_child>::crule(\"reduce_plus_times_one_child\") {}",
        "context": "//+(x) -> x\n//*(x) -> x\nstruct reduce_plus_times_one_child : public crule<reduce_plus_times_one_child> {\n    reduce_plus_times_one_child() : crule<reduce_plus_times_one_child>::crule(\"reduce_plus_times_one_child\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 131,
        "type": "empty_function",
        "content": "reduce_sum_log() : crule<reduce_sum_log>::crule(\"reduce_sum_log\") {}",
        "context": "//works only if at least one log(x_i) exists otherwise\n//there would be a conflict with the rule log(c/x) -> -log((1/c)*x)\nstruct reduce_sum_log : public crule<reduce_sum_log> {\n    reduce_sum_log() : crule<reduce_sum_log>::crule(\"reduce_sum_log\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 140,
        "type": "empty_function",
        "content": "reduce_log_div_times() : crule<reduce_log_div_times>::crule(\"reduce_log_div_times\") {}",
        "context": "//log(exp(x)*y) -> x+log(y)\n//or more generally log(prod exp(x_i)*prod y_j) -> sum x_i +log(prod y_j)\nstruct reduce_log_div_times : public crule<reduce_log_div_times> {\n    reduce_log_div_times() : crule<reduce_log_div_times>::crule(\"reduce_log_div_times\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 146,
        "type": "empty_function",
        "content": "reduce_exp_times() : crule<reduce_exp_times>::crule(\"reduce_exp_times\") {}",
        "context": "\n//prod exp(x_i) -> exp(sum x_i)\nstruct reduce_exp_times : public crule<reduce_exp_times> {\n    reduce_exp_times() : crule<reduce_exp_times>::crule(\"reduce_exp_times\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n   \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 152,
        "type": "empty_function",
        "content": "reduce_exp_div() : crule<reduce_exp_div>::crule(\"reduce_exp_div\") {}",
        "context": "   \n//x/exp(y) -> x*exp(-y)\nstruct reduce_exp_div : public crule<reduce_exp_div> {\n    reduce_exp_div() : crule<reduce_exp_div>::crule(\"reduce_exp_div\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n  \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 163,
        "type": "empty_function",
        "content": "reduce_exp_log() : crule<reduce_exp_log>::crule(\"reduce_exp_log\") {}",
        "context": "//exp(log(x)+y) -> x*exp(y)\n//or more generally, exp(sum log(x_i) + sum y_j) -> prod x_i * exp(sum y_j)\nstruct reduce_exp_log : public crule<reduce_exp_log> {\n    reduce_exp_log() : crule<reduce_exp_log>::crule(\"reduce_exp_log\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n#endif\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": "reduce_sin() : crule<reduce_sin>::crule(\"reduce_sin\") {}",
        "context": "//or more generally\n//sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\nstruct reduce_sin : public crule<reduce_sin> {\n    reduce_sin() : crule<reduce_sin>::crule(\"reduce_sin\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.h",
        "line": 184,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(igop) {}",
        "context": "    const vertex_set &ignore_ops;\n    reduce_impulse_arg(int effort, const vertex_set &igop)\n        : crule<reduce_impulse_arg>::crule(\"reduce_impulse_arg\"),\n          reduct_effort(effort), ignore_ops(igop) {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/fold_rules.h",
        "line": 16,
        "type": "empty_function",
        "content": "fold_unrolling() : crule<fold_unrolling>::crule(\"fold_unrolling\") {}",
        "context": "//    foldl(f v list(a b c)) = f(f(f(v a) b) c)\n//    foldr(f v list(a b c)) = f(a f(b f(c v)))\nstruct fold_unrolling : public crule<fold_unrolling> {\n    fold_unrolling() : crule<fold_unrolling>::crule(\"fold_unrolling\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/general_rules.h",
        "line": 37,
        "type": "empty_function",
        "content": "level() : crule<level>::crule(\"level\") {}",
        "context": "// Note that level is recursive that is f(a,f(b,f(c,d))) -> f(a,b,c,d)\nstruct level : public crule<level>\n{ \n    level() : crule<level>::crule(\"level\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/general_rules.h",
        "line": 46,
        "type": "empty_function",
        "content": "eval_constants() : crule<eval_constants>::crule(\"eval_constants\") {}",
        "context": "// op(op(const,const),var), e.g., +(2,x,1) => +(3,x)\nstruct eval_constants : public crule<eval_constants>\n{ \n    eval_constants() : crule<eval_constants>::crule(\"eval_constants\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/general_rules.h",
        "line": 54,
        "type": "empty_function",
        "content": ": crule<reorder_commutative>::crule(\"reorder_commutative\") {}",
        "context": "struct reorder_commutative : public crule<reorder_commutative>\n{\n    reorder_commutative()\n        : crule<reorder_commutative>::crule(\"reorder_commutative\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/general_rules.h",
        "line": 62,
        "type": "empty_function",
        "content": ": crule<remove_null_vertices>::crule(\"remove_null_vertices\") {}",
        "context": "struct remove_null_vertices : public crule<remove_null_vertices>\n{\n    remove_null_vertices()\n        : crule<remove_null_vertices>::crule(\"remove_null_vertices\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/general_rules.h",
        "line": 70,
        "type": "empty_function",
        "content": ": crule<remove_all_assumptions>::crule(\"remove_all_assumptions\") {}",
        "context": "struct remove_all_assumptions : public crule<remove_all_assumptions>\n{\n    remove_all_assumptions()\n        : crule<remove_all_assumptions>::crule(\"remove_all_assumptions\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_reduction.cc",
        "line": 90,
        "type": "empty_function",
        "content": "{}",
        "context": "\nlogical_reduction::logical_reduction(const logical_reduction& rhs) :\n    p_medium(rhs.p_medium->clone()), p_complexe(rhs.p_complexe->clone())\n{}\n\nlogical_reduction& logical_reduction::operator=(const logical_reduction& rhs)\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 669,
        "type": "stub_function",
        "content": "// stub out, for performance.",
        "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
        "line": 699,
        "type": "stub_function",
        "content": "// stubbed out for performance",
        "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 39,
        "type": "empty_function",
        "content": "insert_ands() : crule<insert_ands>::crule(\"insert_ands\") {}",
        "context": "/// This is important so that other normalizations can catch all cases.\nstruct insert_ands : public crule<insert_ands>\n{\n    insert_ands() : crule<insert_ands>::crule(\"insert_ands\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 48,
        "type": "empty_function",
        "content": ": crule<remove_unary_junctors>::crule(\"remove_unary_junctors\") {}",
        "context": "struct remove_unary_junctors : public crule<remove_unary_junctors>\n{\n    remove_unary_junctors()\n        : crule<remove_unary_junctors>::crule(\"remove_unary_junctors\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 64,
        "type": "empty_function",
        "content": "reduct_effort(effort), ignore_ops(ignore_ops_) {}",
        "context": "    simplify_predicates(int effort,\n                        const vertex_set& ignore_ops_)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n          reduct_effort(effort), ignore_ops(ignore_ops_) {}\n\n    simplify_predicates(const simplify_predicates& rhs)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 68,
        "type": "empty_function",
        "content": "reduct_effort(rhs.reduct_effort), ignore_ops(rhs.ignore_ops) {}",
        "context": "\n    simplify_predicates(const simplify_predicates& rhs)\n        : crule<simplify_predicates>::crule(\"simplify_predicates\"),\n          reduct_effort(rhs.reduct_effort), ignore_ops(rhs.ignore_ops) {}\n\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 82,
        "type": "empty_function",
        "content": "remove_dangling_junctors() : crule<remove_dangling_junctors>::crule(\"remove_dangling_junctors\") {}",
        "context": "/// logical formulae exibit more diversity\nstruct remove_dangling_junctors : public crule<remove_dangling_junctors>\n{\n    remove_dangling_junctors() : crule<remove_dangling_junctors>::crule(\"remove_dangling_junctors\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 93,
        "type": "empty_function",
        "content": ": crule<eval_logical_identities>::crule(\"eval_logical_identities\") {}",
        "context": "struct eval_logical_identities : public crule<eval_logical_identities>\n{\n    eval_logical_identities()\n        : crule<eval_logical_identities>::crule(\"eval_logical_identities\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 100,
        "type": "empty_function",
        "content": "reduce_nots() : crule<reduce_nots>::crule(\"reduce_nots\") {}",
        "context": "// !!a->a,!(a&&b)->(!a||!b),!(a||b)->(!a&&!b),\nstruct reduce_nots : public crule<reduce_nots>\n{\n    reduce_nots() : crule<reduce_nots>::crule(\"reduce_nots\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 113,
        "type": "empty_function",
        "content": "_reduction(&r) { }",
        "context": "{\n    reduce_and_assumptions(const rule& r)\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n         _reduction(&r) { }\n\n    reduce_and_assumptions()\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 117,
        "type": "empty_function",
        "content": "_reduction(this) { }",
        "context": "\n    reduce_and_assumptions()\n        : crule<reduce_and_assumptions>::crule(\"reduce_and_assumptions\"),\n        _reduction(this) { }\n\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 131,
        "type": "empty_function",
        "content": "_reduction(&r) { }",
        "context": "{\n    reduce_or_assumptions(const rule& r)\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n         _reduction(&r) { }\n\n    reduce_or_assumptions()\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 135,
        "type": "empty_function",
        "content": "_reduction(this) { }",
        "context": "\n    reduce_or_assumptions()\n        : crule<reduce_or_assumptions>::crule(\"reduce_or_assumptions\"),\n         _reduction(this) { }\n\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 150,
        "type": "empty_function",
        "content": "reduce_ors() : crule<reduce_ors>::crule(\"reduce_ors\") {}",
        "context": "// Also, true||X -> true, false||X -> X\nstruct reduce_ors : public crule<reduce_ors>\n{\n    reduce_ors() : crule<reduce_ors>::crule(\"reduce_ors\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 161,
        "type": "empty_function",
        "content": "reduce_ands() : crule<reduce_ands>::crule(\"reduce_ands\") {}",
        "context": "// Also, true&&X -> X, false&&X -> false\nstruct reduce_ands : public crule<reduce_ands>\n{\n    reduce_ands() : crule<reduce_ands>::crule(\"reduce_ands\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": ": crule<subtree_to_enf>::crule(\"subtree_to_enf\") {}",
        "context": "struct subtree_to_enf : public crule<subtree_to_enf>\n{\n    subtree_to_enf()\n        : crule<subtree_to_enf>::crule(\"subtree_to_enf\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const\n    {\n        reduce_to_enf(tr, it);\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 242,
        "type": "empty_function",
        "content": "tree_eraser(combo_tree& t) : tr(t) { }",
        "context": "\n        struct tree_eraser\n        {\n            tree_eraser(combo_tree& t) : tr(t) { }\n            combo_tree& tr;\n            template<typename It>\n            void operator()(It it) { tr.erase(*it); }\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 250,
        "type": "empty_function",
        "content": "subtree_set_eraser(subtree_set& s) : se(s) { }",
        "context": "\n        struct subtree_set_eraser\n        {\n            subtree_set_eraser(subtree_set& s) : se(s) { }\n            subtree_set& se;\n            template<typename It>\n            void operator()(It it) { se.erase(it); }\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 258,
        "type": "empty_function",
        "content": "tree_inserter(combo_tree& t,sib_it i) : tr(t),it(i) { }",
        "context": "\n        struct tree_inserter\n        {\n            tree_inserter(combo_tree& t,sib_it i) : tr(t),it(i) { }\n            combo_tree& tr;\n            sib_it it;\n            template<typename It1,typename It2>\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/logical_rules.h",
        "line": 279,
        "type": "empty_function",
        "content": ": crule<reduce_remove_subtree_equal_tt>::crule(\"reduce_remove_subtree_equal_tt\") {}",
        "context": "    : public crule<reduce_remove_subtree_equal_tt>\n{\n    reduce_remove_subtree_equal_tt()\n        : crule<reduce_remove_subtree_equal_tt>::crule(\"reduce_remove_subtree_equal_tt\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 47,
        "type": "empty_function",
        "content": "cond(cond_) {}",
        "context": "struct when : public crule<when> {\n    when(const rule& r_, bool cond_, string name = \"when\")\n        : crule<when>::crule(name), r(r_.clone()),\n          cond(cond_) {}\n    when(const when& w)\n        : crule<when>::crule(w.get_name()),\n          r(w.r->clone()), cond(w.cond) { }\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "r(w.r->clone()), cond(w.cond) { }",
        "context": "          cond(cond_) {}\n    when(const when& w)\n        : crule<when>::crule(w.get_name()),\n          r(w.r->clone()), cond(w.cond) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\nprotected:\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 64,
        "type": "empty_function",
        "content": "r(r_.clone()) {}",
        "context": "    explicit ignore_size_increase(const rule& r_,\n                                  string name = \"ignore_size_increase\")\n        : crule<ignore_size_increase>::crule(name),\n          r(r_.clone()) {}\n    ignore_size_increase(const ignore_size_increase& i)\n        : crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 66,
        "type": "empty_function",
        "content": ": crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "        : crule<ignore_size_increase>::crule(name),\n          r(r_.clone()) {}\n    ignore_size_increase(const ignore_size_increase& i)\n        : crule<ignore_size_increase>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\nprotected:\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 81,
        "type": "empty_function",
        "content": "input(combo::id::unknown_type), output(combo::id::unknown_type) { }",
        "context": "{\n    explicit downwards(const rule& r_, string name = \"downwards\")\n        : crule<downwards>::crule(name), r(r_.clone()),\n          input(combo::id::unknown_type), output(combo::id::unknown_type) { }\n\n    downwards(const rule& r_, combo::type_node t, string name = \"downwards\")\n        : crule<downwards>::crule(name),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 85,
        "type": "empty_function",
        "content": "r(r_.clone()), input(t), output(t) { }",
        "context": "\n    downwards(const rule& r_, combo::type_node t, string name = \"downwards\")\n        : crule<downwards>::crule(name),\n          r(r_.clone()), input(t), output(t) { }\n\n    downwards(const rule& r_, combo::type_node input_, combo::type_node output_,\n              string name = \"downwards\")\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 90,
        "type": "empty_function",
        "content": "r(r_.clone()), input(input_), output(output_) { }",
        "context": "    downwards(const rule& r_, combo::type_node input_, combo::type_node output_,\n              string name = \"downwards\")\n        : crule<downwards>::crule(name),\n          r(r_.clone()), input(input_), output(output_) { }\n\n    downwards(const downwards& d)\n        : crule<downwards>::crule(d.get_name()),\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 94,
        "type": "empty_function",
        "content": "r(d.r->clone()), input(d.input), output(d.output) { }",
        "context": "\n    downwards(const downwards& d)\n        : crule<downwards>::crule(d.get_name()),\n          r(d.r->clone()), input(d.input), output(d.output) { }\n\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 109,
        "type": "empty_function",
        "content": ": crule<upwards>::crule(name), r(r_.clone()) {}",
        "context": "//points at gets visited last)\nstruct upwards : public crule<upwards> {\n    explicit upwards(const rule& r_, string name = \"upwards\")\n        : crule<upwards>::crule(name), r(r_.clone()) {}\n    upwards(const upwards& u)\n        : crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 111,
        "type": "empty_function",
        "content": ": crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}",
        "context": "    explicit upwards(const rule& r_, string name = \"upwards\")\n        : crule<upwards>::crule(name), r(r_.clone()) {}\n    upwards(const upwards& u)\n        : crule<upwards>::crule(u.get_name()), r(u.r->clone()) {}\n\n    void operator()(combo_tree&, combo_tree::iterator) const;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 123,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(name) {}",
        "context": "//longer changes\nstruct iterative : public crule<iterative> {\n    iterative(string name = \"iterative\")\n        : crule<iterative>::crule(name) {}\n    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 125,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(name), r(r_.clone()) {}",
        "context": "    iterative(string name = \"iterative\")\n        : crule<iterative>::crule(name) {}\n    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n        : crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 127,
        "type": "empty_function",
        "content": ": crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "    explicit iterative(const rule& r_, string name = \"iterative\")\n        : crule<iterative>::crule(name), r(r_.clone()) {}\n    iterative(const iterative& i)\n        : crule<iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\nprotected:\n    std::shared_ptr<const rule> r;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 137,
        "type": "empty_function",
        "content": ": crule<assum_iterative>::crule(name) {}",
        "context": "//if the assumption set changes assum_iterative keeps iterating\nstruct assum_iterative : public crule<assum_iterative> {\n    assum_iterative(string name = \"assum_iterative\")\n        : crule<assum_iterative>::crule(name) {}\n    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 139,
        "type": "empty_function",
        "content": "crule<assum_iterative>::crule(name), r(r_.clone()) {}",
        "context": "    assum_iterative(string name = \"assum_iterative\")\n        : crule<assum_iterative>::crule(name) {}\n    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n        : crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 141,
        "type": "empty_function",
        "content": ": crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }",
        "context": "    explicit assum_iterative(const rule& r_, string name = \"assum_iterative\") :\n        crule<assum_iterative>::crule(name), r(r_.clone()) {}\n    assum_iterative(const assum_iterative& i)\n        : crule<assum_iterative>::crule(i.get_name()), r(i.r->clone()) { }\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\nprotected:\n    std::shared_ptr<const rule> r;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 150,
        "type": "empty_function",
        "content": "//sequential() { }",
        "context": "//apply rules sequentially to a particular point-of-application\n//overloaded up to 50 arguments.\nstruct sequential : public crule<sequential> {\n    //sequential() { }\n    sequential(const sequential& rhs)\n        : crule<sequential>::crule(rhs.get_name()),\n          rules(rhs.rules.begin(), rhs.rules.end()) { }\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/meta_rules.h",
        "line": 153,
        "type": "empty_function",
        "content": "rules(rhs.rules.begin(), rhs.rules.end()) { }",
        "context": "    //sequential() { }\n    sequential(const sequential& rhs)\n        : crule<sequential>::crule(rhs.get_name()),\n          rules(rhs.rules.begin(), rhs.rules.end()) { }\n\n#define OC_RULES_PUSH_BACK(z, n, name) rules.push_back(BOOST_PP_CAT(name, n).clone());\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 35,
        "type": "empty_function",
        "content": "reduce_gt_zero_times_const() : crule<reduce_gt_zero_times_const>::crule(\"reduce_gt_zero_times_const\") {}",
        "context": "//0<c*x -> 0<-1*x if c<0\n//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_times_const : public crule<reduce_gt_zero_times_const> {\n    reduce_gt_zero_times_const() : crule<reduce_gt_zero_times_const>::crule(\"reduce_gt_zero_times_const\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 42,
        "type": "empty_function",
        "content": "reduce_gt_zero_pair_power() : crule<reduce_gt_zero_pair_power>::crule(\"reduce_gt_zero_pair_power\") {}",
        "context": "//0<c*x*x -> false if c<0\n//or more generally 0<c*x^p_x*y^p_y*exp(... where p_x, p_y... are divisible by 2\nstruct reduce_gt_zero_pair_power : public crule<reduce_gt_zero_pair_power> {\n    reduce_gt_zero_pair_power() : crule<reduce_gt_zero_pair_power>::crule(\"reduce_gt_zero_pair_power\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 51,
        "type": "empty_function",
        "content": "reduce_gt_zero_const_div() : crule<reduce_gt_zero_const_div>::crule(\"reduce_gt_zero_const_div\") {}",
        "context": "//WARNING : this rule is deprecated, use reduce_gt_zero_div instead\nstruct reduce_gt_zero_const_div : public crule<reduce_gt_zero_const_div>\n{\n    reduce_gt_zero_const_div() : crule<reduce_gt_zero_const_div>::crule(\"reduce_gt_zero_const_div\") {}\n        void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 59,
        "type": "empty_function",
        "content": "reduce_gt_zero_log() : crule<reduce_gt_zero_log>::crule(\"reduce_gt_zero_log\") {}",
        "context": "// 0<log(x) -> 0<-1+x\nstruct reduce_gt_zero_log : public crule<reduce_gt_zero_log>\n{\n    reduce_gt_zero_log() : crule<reduce_gt_zero_log>::crule(\"reduce_gt_zero_log\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n#endif\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 67,
        "type": "empty_function",
        "content": "reduce_gt_zero_exp() : crule<reduce_gt_zero_exp>::crule(\"reduce_gt_zero_exp\") {}",
        "context": "// 0<exp(x) -> true\nstruct reduce_gt_zero_exp : public crule<reduce_gt_zero_exp>\n{\n    reduce_gt_zero_exp() : crule<reduce_gt_zero_exp>::crule(\"reduce_gt_zero_exp\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 75,
        "type": "empty_function",
        "content": "reduce_gt_zero_minus_exp() : crule<reduce_gt_zero_minus_exp>::crule(\"reduce_gt_zero_minus_exp\") {}",
        "context": "//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_minus_exp : public crule<reduce_gt_zero_minus_exp>\n{\n    reduce_gt_zero_minus_exp() : crule<reduce_gt_zero_minus_exp>::crule(\"reduce_gt_zero_minus_exp\") {}\n    void operator()(combo_tree& tr, combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 82,
        "type": "empty_function",
        "content": "reduce_gt_zero_prod_exp() : crule<reduce_gt_zero_prod_exp>::crule(\"reduce_gt_zero_prod_exp\") {}",
        "context": "//0<y*exp(x) -> 0<y\n//WARNING : this rule is deprecated, use reduce_gt_zero_prod instead\nstruct reduce_gt_zero_prod_exp : public crule<reduce_gt_zero_prod_exp> {\n    reduce_gt_zero_prod_exp() : crule<reduce_gt_zero_prod_exp>::crule(\"reduce_gt_zero_prod_exp\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 90,
        "type": "empty_function",
        "content": "reduce_gt_zero_const_sum_sin() : crule<reduce_gt_zero_const_sum_sin>::crule(\"reduce_gt_zero_const_sum_sin\") {}",
        "context": "//0<c+sin(x) -> false if c<=1\n//WARNING : this rule is deprecated, use reduce_gt_zero_sum_sin instead\nstruct reduce_gt_zero_const_sum_sin : public crule<reduce_gt_zero_const_sum_sin> {\n    reduce_gt_zero_const_sum_sin() : crule<reduce_gt_zero_const_sum_sin>::crule(\"reduce_gt_zero_const_sum_sin\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 96,
        "type": "empty_function",
        "content": "reduce_gt_zero_impulse() : crule<reduce_gt_zero_impulse>::crule(\"reduce_gt_zero_impulse\") {}",
        "context": "\n// 0<impulse(x) -> x   (remember x is boolean)\nstruct reduce_gt_zero_impulse : public crule<reduce_gt_zero_impulse> {\n    reduce_gt_zero_impulse() : crule<reduce_gt_zero_impulse>::crule(\"reduce_gt_zero_impulse\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 102,
        "type": "empty_function",
        "content": "reduce_impulse_power() : crule<reduce_impulse_power>::crule(\"reduce_impulse_power\") {}",
        "context": "\n//prod impulse(x_i)^p_i -> prod impulse(x_i)\nstruct reduce_impulse_power : public crule<reduce_impulse_power> {\n    reduce_impulse_power() : crule<reduce_impulse_power>::crule(\"reduce_impulse_power\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 108,
        "type": "empty_function",
        "content": "reduce_impulse_prod() : crule<reduce_impulse_prod>::crule(\"reduce_impulse_prod\") {}",
        "context": "\n//prod impulse(x_i) * z -> impulse(and x_i) * z\nstruct reduce_impulse_prod : public crule<reduce_impulse_prod> {\n    reduce_impulse_prod() : crule<reduce_impulse_prod>::crule(\"reduce_impulse_prod\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 114,
        "type": "empty_function",
        "content": "reduce_impulse_sum() : crule<reduce_impulse_sum>::crule(\"reduce_impulse_sum\") {}",
        "context": "\n//0<(sum impulse(x_i)) -> or x_i\nstruct reduce_impulse_sum : public crule<reduce_impulse_sum> {\n    reduce_impulse_sum() : crule<reduce_impulse_sum>::crule(\"reduce_impulse_sum\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 121,
        "type": "empty_function",
        "content": "reduce_contin_if_to_impulse() : crule<reduce_contin_if_to_impulse>::crule(\"reduce_contin_if_to_impulse\") {}",
        "context": "//if(x 1 0) -> impulse(x)\n//if(x 0 1) -> impulse(NOT(x))\nstruct reduce_contin_if_to_impulse : public crule<reduce_contin_if_to_impulse> {\n    reduce_contin_if_to_impulse() : crule<reduce_contin_if_to_impulse>::crule(\"reduce_contin_if_to_impulse\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 130,
        "type": "empty_function",
        "content": "reduce_contin_if() : crule<reduce_contin_if>::crule(\"reduce_contin_if\") {}",
        "context": "//if(x if(x y z) w) -> if(x y w)\n//if(x y if(x z w)) -> if(x y w)\nstruct reduce_contin_if : public crule<reduce_contin_if> {\n    reduce_contin_if() : crule<reduce_contin_if>::crule(\"reduce_contin_if\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 136,
        "type": "empty_function",
        "content": "reduce_op_contin_if() : crule<reduce_op_contin_if>::crule(\"reduce_op_contin_if\") {}",
        "context": "\n//op(if(x y1 z1) if(x y2 z2)) -> if(x op(y1 y2) op(z1 z2))\nstruct reduce_op_contin_if : public crule<reduce_op_contin_if> {\n    reduce_op_contin_if() : crule<reduce_op_contin_if>::crule(\"reduce_op_contin_if\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 143,
        "type": "empty_function",
        "content": "reduce_contin_if_inner_op() : crule<reduce_contin_if_inner_op>::crule(\"reduce_contin_if_inner_op\") {}",
        "context": "//contin_if(x op(y z) op(y w)) -> op(y contin_if(x z w))\n//op in {+, *, /}. If op is / the order of argument is respected\nstruct reduce_contin_if_inner_op : public crule<reduce_contin_if_inner_op> {\n    reduce_contin_if_inner_op() : crule<reduce_contin_if_inner_op>::crule(\"reduce_contin_if_inner_op\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 151,
        "type": "empty_function",
        "content": "reduce_contin_if_substitute_cond() : crule<reduce_contin_if_substitute_cond>::crule(\"reduce_contin_if_substitute_cond\") {}",
        "context": "struct reduce_contin_if_substitute_cond\n    : public crule<reduce_contin_if_substitute_cond> \n{\n    reduce_contin_if_substitute_cond() : crule<reduce_contin_if_substitute_cond>::crule(\"reduce_contin_if_substitute_cond\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 172,
        "type": "empty_function",
        "content": "reduce_junction_gt_zero_sum_constant() : crule<reduce_junction_gt_zero_sum_constant>::crule(\"reduce_junction_gt_zero_sum_constant\") {}",
        "context": "struct reduce_junction_gt_zero_sum_constant\n    : public crule<reduce_junction_gt_zero_sum_constant> \n{\n    reduce_junction_gt_zero_sum_constant() : crule<reduce_junction_gt_zero_sum_constant>::crule(\"reduce_junction_gt_zero_sum_constant\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 181,
        "type": "empty_function",
        "content": "reduce_from_assumptions(const rule& r) : crule<reduce_from_assumptions>::crule(\"reduce_from_assumptions\"), _reduction(&r) { }",
        "context": "// rule given in argument is used by reduce_from_assumptions::implies\n// and can be fully recursive (I guess?).\nstruct reduce_from_assumptions : public crule<reduce_from_assumptions> {\n    reduce_from_assumptions(const rule& r) : crule<reduce_from_assumptions>::crule(\"reduce_from_assumptions\"), _reduction(&r) { }    \n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n    bool implies(const combo_tree& tr, combo_tree::iterator it1, combo_tree::iterator it2) const;\nprotected:\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 190,
        "type": "empty_function",
        "content": "reduce_contin_if_not(const rule& r) : crule<reduce_contin_if_not>::crule(\"reduce_contin_if_not\"), _reduction(&r) { }",
        "context": "\n//if(x y z) -> if(NOT(x) z y)  if |rule(NOT(x))|<|rule(x)|\nstruct reduce_contin_if_not : public crule<reduce_contin_if_not> {\n    reduce_contin_if_not(const rule& r) : crule<reduce_contin_if_not>::crule(\"reduce_contin_if_not\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 199,
        "type": "empty_function",
        "content": "reduce_gt_zero_sum(const rule& r) : crule<reduce_gt_zero_sum>::crule(\"reduce_gt_zero_sum\"), _reduction(&r) { }",
        "context": "//0<sum x_i -> true    if 0<x_i -> true forall i\n//0<sum x_i -> false   if 0<x_i -> false forall i\nstruct reduce_gt_zero_sum : public crule<reduce_gt_zero_sum> {\n    reduce_gt_zero_sum(const rule& r) : crule<reduce_gt_zero_sum>::crule(\"reduce_gt_zero_sum\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 212,
        "type": "empty_function",
        "content": "_complete_reduction(&r), _reduction_without_itself(&r) { }",
        "context": "struct reduce_gt_zero_prod : public crule<reduce_gt_zero_prod> {\n    reduce_gt_zero_prod(const rule& r)\n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r), _reduction_without_itself(&r) { }\n    reduce_gt_zero_prod(const rule& r1, const rule& r2) \n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r1), _reduction_without_itself(&r2) { }\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 215,
        "type": "empty_function",
        "content": "_complete_reduction(&r1), _reduction_without_itself(&r2) { }",
        "context": "          _complete_reduction(&r), _reduction_without_itself(&r) { }\n    reduce_gt_zero_prod(const rule& r1, const rule& r2) \n        : crule<reduce_gt_zero_prod>::crule(\"reduce_gt_zero_prod\"), \n          _complete_reduction(&r1), _reduction_without_itself(&r2) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _complete_reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 228,
        "type": "empty_function",
        "content": "reduce_gt_zero_div(const rule& r) : crule<reduce_gt_zero_div>::crule(\"reduce_gt_zero_div\"), _reduction(&r) { }",
        "context": "//0<x/y -> 0<-1*x if 0<-1*y -> true\n//0<x/y -> false  if x==0, that is not(0<x) -> true and not(0<-x) -> true\nstruct reduce_gt_zero_div : public crule<reduce_gt_zero_div> {\n    reduce_gt_zero_div(const rule& r) : crule<reduce_gt_zero_div>::crule(\"reduce_gt_zero_div\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 237,
        "type": "empty_function",
        "content": "reduce_gt_zero_sum_sin(const rule& r) : crule<reduce_gt_zero_sum_sin>::crule(\"reduce_gt_zero_sum_sin\"), _reduction(&r) { }",
        "context": "//0<x+sin(y) -> true  if 0<x-1 -> true\n//0<x+sin(y) -> false if 0<x+1 -> false\nstruct reduce_gt_zero_sum_sin : public crule<reduce_gt_zero_sum_sin> {\n    reduce_gt_zero_sum_sin(const rule& r) : crule<reduce_gt_zero_sum_sin>::crule(\"reduce_gt_zero_sum_sin\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 246,
        "type": "empty_function",
        "content": "reduce_gt_zero_sin(const rule& r) : crule<reduce_gt_zero_sin>::crule(\"reduce_gt_zero_sin\"), _reduction(&r) { }",
        "context": "//0<sin(y) -> true  if 0<y -> true and 0<pi-y -> true\n//0<sin(y) -> false if 0<y -> false and 0<-(y+pi) ->false\nstruct reduce_gt_zero_sin : public crule<reduce_gt_zero_sin> {\n    reduce_gt_zero_sin(const rule& r) : crule<reduce_gt_zero_sin>::crule(\"reduce_gt_zero_sin\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 257,
        "type": "empty_function",
        "content": "reduce_gt_division_of_constants(const rule& r) : crule<reduce_gt_division_of_constants>::crule(\"reduce_gt_division_of_constants\"), _reduction(&r) { }",
        "context": "//0<c*x+d -> true  if c==0 -> true && 0<d -> true\n//0<c*x+d -> false if c==0 -> true && d<=0 -> true\nstruct reduce_gt_division_of_constants : public crule<reduce_gt_division_of_constants> {\n    reduce_gt_division_of_constants(const rule& r) : crule<reduce_gt_division_of_constants>::crule(\"reduce_gt_division_of_constants\"), _reduction(&r) { }\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\nprotected:\n    const rule* _reduction;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.h",
        "line": 268,
        "type": "empty_function",
        "content": "crule<reduce_inequality_from_assumptions>::crule(\"reduce_inequality_from_assumptions\") {}",
        "context": "//other inequalities present as assumptions\nstruct reduce_inequality_from_assumptions : public crule<reduce_inequality_from_assumptions> {\n    reduce_inequality_from_assumptions() :\n        crule<reduce_inequality_from_assumptions>::crule(\"reduce_inequality_from_assumptions\") {}\n    //double_matrix, a matrix of doubles\n    //used by reduce_inequality_from_assumptions\n    //each inner vector is a row, the outer vector is a list of rows\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 36,
        "type": "empty_function",
        "content": "reduce_ultrametric() : crule<reduce_ultrametric>::crule(\"reduce_ultrametric\") {}",
        "context": "//f(x, z) <= max{d(x, y), d(y, z)}\n//when encounting f(x, y) and f(y, z) and d is ultrametric\nstruct reduce_ultrametric : public crule<reduce_ultrametric> {\n    reduce_ultrametric() : crule<reduce_ultrametric>::crule(\"reduce_ultrametric\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n \n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 44,
        "type": "empty_function",
        "content": "reduce_transitive() : crule<reduce_transitive>::crule(\"reduce_transitive\") {}",
        "context": "//f(x, z)\n//when encounting f(x, y) and f(y, z)\nstruct reduce_transitive : public crule<reduce_transitive> {\n    reduce_transitive() : crule<reduce_transitive>::crule(\"reduce_transitive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 50,
        "type": "empty_function",
        "content": "reduce_reflexive() : crule<reduce_reflexive>::crule(\"reduce_reflexive\") {}",
        "context": "\n//reduce f(x,x) -> true iff f is reflexive\nstruct reduce_reflexive : public crule<reduce_reflexive> {\n    reduce_reflexive() : crule<reduce_reflexive>::crule(\"reduce_reflexive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 56,
        "type": "empty_function",
        "content": "reduce_irreflexive() : crule<reduce_irreflexive>::crule(\"reduce_irreflexive\") {}",
        "context": "\n//reduce f(x,x) -> false iff f is irreflexive\nstruct reduce_irreflexive : public crule<reduce_irreflexive> {\n    reduce_irreflexive() : crule<reduce_irreflexive>::crule(\"reduce_irreflexive\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 71,
        "type": "empty_function",
        "content": "reduce_symmetric() : crule<reduce_symmetric>::crule(\"reduce_symmetric\") {}",
        "context": "//reduce_symmetric can permit more reductions\n//than with associative reduction.\nstruct reduce_symmetric : public crule<reduce_symmetric> {\n    reduce_symmetric() : crule<reduce_symmetric>::crule(\"reduce_symmetric\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/perception_rules.h",
        "line": 78,
        "type": "empty_function",
        "content": "reduce_identity_of_indiscernibles() : crule<reduce_identity_of_indiscernibles>::crule(\"reduce_identity_of_indiscernibles\") {}",
        "context": "\n//reduce f(x,y) -> 0 iff f verifies the property of identity of indiscernibles\nstruct reduce_identity_of_indiscernibles : public crule<reduce_identity_of_indiscernibles> {\n    reduce_identity_of_indiscernibles() : crule<reduce_identity_of_indiscernibles>::crule(\"reduce_identity_of_indiscernibles\") {}\n    void operator()(combo_tree& tr,combo_tree::iterator it) const;\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/reduct.h",
        "line": 39,
        "type": "empty_function",
        "content": "rule(std::string _name) : name(_name) {}",
        "context": "{\n    typedef combo_tree argument_type;\n\n    rule(std::string _name) : name(_name) {}\n    virtual ~rule() {}\n    virtual void operator()(combo_tree&, combo_tree::iterator) const=0;\n    virtual rule* clone() const=0;\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/reduct.h",
        "line": 40,
        "type": "empty_function",
        "content": "virtual ~rule() {}",
        "context": "    typedef combo_tree argument_type;\n\n    rule(std::string _name) : name(_name) {}\n    virtual ~rule() {}\n    virtual void operator()(combo_tree&, combo_tree::iterator) const=0;\n    virtual rule* clone() const=0;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/reduct.h",
        "line": 66,
        "type": "empty_function",
        "content": "crule(std::string _name) : rule(_name) {}",
        "context": "template<typename T>\nstruct crule : public rule\n{\n    crule(std::string _name) : rule(_name) {}\n    rule* clone() const { return new T(*((T*) this)); }\n};\n\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 75,
        "type": "empty_function",
        "content": "ITable::ITable() {}",
        "context": "        \n// -------------------------------------------------------\n\nITable::ITable() {}\n\nITable::ITable(const vector<type_node>& ts, const vector<string>& il)\n    : types(ts), labels(il) {}\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 78,
        "type": "empty_function",
        "content": ": types(ts), labels(il) {}",
        "context": "ITable::ITable() {}\n\nITable::ITable(const vector<type_node>& ts, const vector<string>& il)\n    : types(ts), labels(il) {}\n\nITable::ITable(const ITable::super& mat, const vector<string>& il)\n    : super(mat), labels(il) {}\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 81,
        "type": "empty_function",
        "content": ": super(mat), labels(il) {}",
        "context": "    : types(ts), labels(il) {}\n\nITable::ITable(const ITable::super& mat, const vector<string>& il)\n    : super(mat), labels(il) {}\n\n/// Construct an ITable holding a single column, the column from the OTable.\nITable::ITable(const OTable& ot)\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 327,
        "type": "empty_function",
        "content": ": label(ol), type(id::unknown_type) {}",
        "context": "////////////\n\nOTable::OTable(const string& ol)\n    : label(ol), type(id::unknown_type) {}\n\nOTable::OTable(const super& ot, const string& ol)\n    : super(ot), label(ol)\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 472,
        "type": "empty_function",
        "content": ": label(tl) {}",
        "context": "////////////\n\nTTable::TTable(const string& tl)\n    : label(tl) {}\n\nTTable::TTable(const super& tt, const string& tl)\n    : super(tt), label(tl) {}\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 475,
        "type": "empty_function",
        "content": ": super(tt), label(tl) {}",
        "context": "    : label(tl) {}\n\nTTable::TTable(const super& tt, const string& tl)\n    : super(tt), label(tl) {}\n\nvoid TTable::set_label(const string& tl)\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 499,
        "type": "empty_function",
        "content": "Table::Table() : target_pos(0), timestamp_pos(0) {}",
        "context": "// Table //\n///////////\n\nTable::Table() : target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const OTable& otable_, const ITable& itable_)\n    : itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 502,
        "type": "empty_function",
        "content": ": itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}",
        "context": "Table::Table() : target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const OTable& otable_, const ITable& itable_)\n    : itable(itable_), otable(otable_), target_pos(0), timestamp_pos(0) {}\n\nTable::Table(const combo_tree& tr, int nsamples,\n             contin_t min_contin, contin_t max_contin) :\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 507,
        "type": "empty_function",
        "content": "otable(tr, itable), target_pos(0), timestamp_pos(0) {}",
        "context": "Table::Table(const combo_tree& tr, int nsamples,\n             contin_t min_contin, contin_t max_contin) :\n    itable(infer_type_tree(tr), nsamples, min_contin, max_contin),\n    otable(tr, itable), target_pos(0), timestamp_pos(0) {}\n\nvector<string> Table::get_labels() const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 649,
        "type": "empty_function",
        "content": ": olabel(_olabel) {}",
        "context": "////////////\n\nCTable::CTable(const std::string& _olabel)\n    : olabel(_olabel) {}\n\nCTable::CTable(const string_seq& labs, const type_tree& tt)\n    : tsig(tt), olabel(labs[0]), ilabels(labs)\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.cc",
        "line": 660,
        "type": "empty_function",
        "content": "{}",
        "context": "CTable::CTable(const std::string& _olabel, const string_seq& _ilabels,\n               const type_tree& tt)\n    : tsig(tt), olabel(_olabel), ilabels(_ilabels)\n{}\n\n\nvoid CTable::remove_rows(const set<unsigned>& idxs)\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 117,
        "type": "empty_function",
        "content": "push_back_visitor(const T& value) : _value(value) {}",
        "context": "template<typename T /* type being pushed */>\nstruct push_back_visitor : public boost::static_visitor<>\n{\n    push_back_visitor(const T& value) : _value(value) {}\n    void operator()(std::vector<T>& seq) const {\n        seq.push_back(_value);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 145,
        "type": "empty_function",
        "content": "init_at_visitor(size_t pos) : _pos(pos) {}",
        "context": " */\nstruct init_at_visitor : public boost::static_visitor<>\n{\n    init_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq>\n    void operator()(Seq& seq) const {\n        typedef typename Seq::value_type vt;\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 157,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<typename T>\nstruct get_at_visitor : public boost::static_visitor<T>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    T operator()(const std::vector<T>& seq) const {\n        return seq[_pos];\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 177,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<>\nstruct get_at_visitor<vertex> : public boost::static_visitor<vertex>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    vertex operator()(const combo_tree_seq& seq) const {\n        return *seq[_pos].begin();\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 190,
        "type": "empty_function",
        "content": "get_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "template<>\nstruct get_at_visitor<combo_tree> : public boost::static_visitor<combo_tree>\n{\n    get_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> combo_tree operator()(const Seq& seq) const {\n        return seq[_pos];\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 199,
        "type": "empty_function",
        "content": "erase_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "\nstruct erase_at_visitor : public boost::static_visitor<>\n{\n    erase_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> void operator()(Seq& seq) const {\n        seq.erase(seq.begin() + _pos);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 210,
        "type": "empty_function",
        "content": "insert_at_visitor(int pos, const T v) : _pos(pos), _v(v) {}",
        "context": "struct insert_at_visitor : public boost::static_visitor<>\n{\n    // if pos is negative then it inserts at the end\n    insert_at_visitor(int pos, const T v) : _pos(pos), _v(v) {}\n    void operator()(std::vector<T>& seq) const {\n        seq.insert(_pos >= 0 ? seq.begin() + _pos : seq.end(), _v);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 300,
        "type": "empty_function",
        "content": "get_type_tree_at_visitor(size_t pos) : _pos(pos) {}",
        "context": "\nstruct get_type_tree_at_visitor : public boost::static_visitor<type_tree>\n{\n    get_type_tree_at_visitor(size_t pos) : _pos(pos) {}\n    template<typename Seq> type_tree operator()(const Seq& seq) {\n        return get_type_tree(seq[_pos]);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 432,
        "type": "empty_function",
        "content": ": _variant(std::vector<T>(il)) {}",
        "context": "        // logger().debug(\"sizeof(vertex) = %u\", sizeof(vertex));\n    }\n    template<typename T> multi_type_seq(const std::initializer_list<T>& il)\n        : _variant(std::vector<T>(il)) {}\n    template<typename T> multi_type_seq(const T& v) : _variant(v) {}\n    template<typename T> void push_back(const T& e) {\n        boost::apply_visitor(push_back_visitor<T>(e), _variant);\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 433,
        "type": "empty_function",
        "content": "template<typename T> multi_type_seq(const T& v) : _variant(v) {}",
        "context": "    }\n    template<typename T> multi_type_seq(const std::initializer_list<T>& il)\n        : _variant(std::vector<T>(il)) {}\n    template<typename T> multi_type_seq(const T& v) : _variant(v) {}\n    template<typename T> void push_back(const T& e) {\n        boost::apply_visitor(push_back_visitor<T>(e), _variant);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 499,
        "type": "empty_function",
        "content": "seq_filtered_visitor(const F& filter) : _filter(filter) {}",
        "context": "template<typename F>\nstruct seq_filtered_visitor : public boost::static_visitor<multi_type_seq>\n{\n    seq_filtered_visitor(const F& filter) : _filter(filter) {}\n    template<typename Seq> multi_type_seq operator()(const Seq& seq) {\n        return seq_filtered(seq, _filter);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 536,
        "type": "empty_function",
        "content": ": value(v), timestamp(t) {}",
        "context": "{\n    TimedValue(const vertex v,\n               const TTable::value_type t = TTable::value_type())\n        : value(v), timestamp(t) {}\n    vertex value;\n    TTable::value_type timestamp;\n\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 989,
        "type": "empty_function",
        "content": "otable(func, itable), target_pos(0), timestamp_pos(0) {}",
        "context": "    Table(const Func& func, arity_t a, int nsamples=-1) :\n        itable(gen_signature(type_node_of<bool>(),\n                             type_node_of<bool>(), a)),\n        otable(func, itable), target_pos(0), timestamp_pos(0) {}\n\n    Table(const combo_tree& tr, int nsamples=-1,\n          contin_t min_contin=-1.0, contin_t max_contin=1.0);\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1519,
        "type": "empty_function",
        "content": "complete_truth_table() {}",
        "context": "public:\n    typedef bool_seq super;\n\n    complete_truth_table() {}\n    template<typename It>\n    complete_truth_table(It from, It to) : super(from, to) {}\n    template<typename T>\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table.h",
        "line": 1521,
        "type": "empty_function",
        "content": "complete_truth_table(It from, It to) : super(from, to) {}",
        "context": "\n    complete_truth_table() {}\n    template<typename It>\n    complete_truth_table(It from, It to) : super(from, to) {}\n    template<typename T>\n    complete_truth_table(const tree<T>& tr, arity_t arity)\n        : super(pow2(arity)), _arity(arity)\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 455,
        "type": "empty_function",
        "content": ": from_tokens_visitor(types), _index(index), _fixed_arity(fixed_arity) {}",
        "context": "    from_sparse_tokens_visitor(const std::vector<type_node>& types,\n                               const std::map<const std::string, size_t>& index,\n                               size_t fixed_arity)\n        : from_tokens_visitor(types), _index(index), _fixed_arity(fixed_arity) {}\n    result_type operator()(const string_seq& seq) {\n        using std::transform;\n        using std::for_each;\n"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 126,
        "type": "empty_function",
        "content": "equal_to_type_tree(const type_tree& tt) : _tt(tt) {}",
        "context": "private:\n    const type_tree& _tt;\npublic:\n    equal_to_type_tree(const type_tree& tt) : _tt(tt) {}\n    bool operator()(const type_tree& tt) {\n        return equal_type_tree(_tt, tt);\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 179,
        "type": "empty_function",
        "content": "inherit_from_type_tree(const type_tree& tt) : _tt(tt) {}",
        "context": "private:\n    const type_tree& _tt;\npublic:\n    inherit_from_type_tree(const type_tree& tt) : _tt(tt) {}\n    bool operator()(const type_tree& tt) {\n        return inherit_type_tree(tt, _tt);\n    }\n"
      },
      {
        "file": "moses/moses/feature-selection/main/feature-selection.h",
        "line": 69,
        "type": "empty_function",
        "content": "{}",
        "context": "        hc_widen_search(true),\n        hc_fraction_of_nn(2.0),\n        mi_confi(50.0)\n    {}\n\n    std::string algorithm;\n    std::string scorer;\n"
      },
      {
        "file": "moses/moses/feature-selection/main/feature-selection.h",
        "line": 147,
        "type": "empty_function",
        "content": "_cache(n, sc) {}",
        "context": "struct iscorer_cache : public iscorer_base\n{\n    iscorer_cache(size_t n, const DBScorer& sc) :\n        _cache(n, sc) {}\n\n    composite_score operator()(const instance& x) const\n    {\n"
      },
      {
        "file": "moses/moses/feature-selection/main/feature-selection.h",
        "line": 238,
        "type": "empty_function",
        "content": "hsh ^= std::hash<opencog::arity_t>{}(ii)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (int ii: fs)\n\t\t\t\thsh ^= std::hash<opencog::arity_t>{}(ii)\n\t\t\t\t\t+ 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/fs_scorer_base.h",
        "line": 38,
        "type": "empty_function",
        "content": ": _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}",
        "context": "{\n    // ctor\n    fs_scorer_base(const CTable& ctable, double confi)\n        : _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}\n\n    // dtor\n    virtual ~fs_scorer_base() {};\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/fs_scorer_base.h",
        "line": 41,
        "type": "empty_function",
        "content": "virtual ~fs_scorer_base() {};",
        "context": "        : _ctable(ctable), _confi(confi), _usize(_ctable.uncompressed_size()) {}\n\n    // dtor\n    virtual ~fs_scorer_base() {};\n\n    virtual double operator()(const FeatureSet& features) const = 0;\n\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/moses_matrix.h",
        "line": 61,
        "type": "empty_function",
        "content": "_positive(positive) {}",
        "context": "               bool positive = true)\n        : super(ctable, confi), _penalty(penalty),\n          _min_activation(min_activation), _max_activation(max_activation),\n          _positive(positive) {}\n\n    double operator()(const FeatureSet& fs) const\n    {\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/moses_optim.h",
        "line": 55,
        "type": "empty_function",
        "content": ": _fs_scorer(fs_scorer), _fields(fields) {}",
        "context": "struct deme_based_scorer : public iscorer_base\n{\n    deme_based_scorer(const FSScorer& fs_scorer, const field_set& fields)\n        : _fs_scorer(fs_scorer), _fields(fields) {}\n\n    /**\n     * The feature set is represented by an instance encoding a\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 51,
        "type": "empty_function",
        "content": ": _ctable(ctable) {}",
        "context": "    typedef FeatureSet argument_type;\n    typedef double result_type;\n    MutualInformation(const CTable& ctable)\n        : _ctable(ctable) {}\n\n    double operator()(const FeatureSet& features) const\n    {\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 86,
        "type": "empty_function",
        "content": ": _it(it), _ot(ot), _confi(confi) {}",
        "context": "{\n    MICScorer(const ITable& it, const OTable& ot,\n              double confi = 100)\n        : _it(it), _ot(ot), _confi(confi) {}\n\n    /**\n     * The feature set is represented by an eda::instance encoding a\n"
      },
      {
        "file": "moses/moses/feature-selection/scorers/mutual_info.h",
        "line": 114,
        "type": "empty_function",
        "content": ": super(ctable, confi) {}",
        "context": "\n    // ctor\n    MICScorerCTable(const CTable& ctable, double confi = 100)\n        : super(ctable, confi) {}\n\n    /**\n     * The feature set is represented by an eda::instance encoding a\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.h",
        "line": 48,
        "type": "empty_function",
        "content": "~deme_expander() {}",
        "context": "                  const deme_parameters& pa = deme_parameters(),\n                  const subsample_deme_filter_parameters& fp = subsample_deme_filter_parameters());\n\n    ~deme_expander() {}\n\n    /**\n     * Create demes\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_params.h",
        "line": 50,
        "type": "empty_function",
        "content": "{}",
        "context": "        actions(_actions),\n        fstor(_fstor),\n        linear_contin(true)\n        {}\n\n    // The max number of candidates considered to be added to the\n    // metapopulation, if negative then all candidates are considered.\n"
      },
      {
        "file": "moses/moses/moses/deme/feature_selector.cc",
        "line": 53,
        "type": "empty_function",
        "content": ": params(festor_params), _ctable(ctable) {}",
        "context": "\nfeature_selector::feature_selector(const combo::CTable& ctable,\n                                   const feature_selector_parameters& festor_params)\n    : params(festor_params), _ctable(ctable) {}\n\nfeature_selector::feature_selector(const combo::Table& table,\n                                   const feature_selector_parameters& festor_params)\n"
      },
      {
        "file": "moses/moses/moses/deme/feature_selector.cc",
        "line": 57,
        "type": "empty_function",
        "content": ": params(festor_params), _ctable(table.compressed()) {}",
        "context": "\nfeature_selector::feature_selector(const combo::Table& table,\n                                   const feature_selector_parameters& festor_params)\n    : params(festor_params), _ctable(table.compressed()) {}\n\n// Do some sanity checking and mangling on the parameters.\nvoid feature_selector::preprocess_params(const combo::combo_tree& xmplr)\n"
      },
      {
        "file": "moses/moses/moses/deme/feature_selector.h",
        "line": 53,
        "type": "empty_function",
        "content": "{}",
        "context": "        diversity_pressure(0.0),\n        diversity_cap(0),\n        diversity_interaction(0)\n    {}\n\n    feature_selection_parameters fs_params;\n\n"
      },
      {
        "file": "moses/moses/moses/eda/local_structure.h",
        "line": 131,
        "type": "empty_function",
        "content": "const local_structure_model&) const {}",
        "context": "\n    template<typename It>\n    void operator()(const field_set&, It, It,\n                    const local_structure_model&) const {}\n};\n\n/*\n"
      },
      {
        "file": "moses/moses/moses/eda/local_structure.h",
        "line": 142,
        "type": "empty_function",
        "content": "void operator()(const field_set&,It,It,local_structure_model&) const { }",
        "context": "\n  //scratch_model should go here\n  template<typename It>\n  void operator()(const field_set&,It,It,local_structure_model&) const { }\n  };*/\n\n/// Handles probability learning for local structure models in EDA.\n"
      },
      {
        "file": "moses/moses/moses/eda/replacement.h",
        "line": 71,
        "type": "empty_function",
        "content": ": window_size(ws), _fields(&fs), rng(_rng) { }",
        "context": "struct rtr_replacement\n{\n    rtr_replacement(const field_set& fs, int ws, RandGen& _rng = randGen())\n        : window_size(ws), _fields(&fs), rng(_rng) { }\n\n    template<typename NewInst, typename Dst>\n    void operator()(NewInst from, NewInst to, Dst from_dst, Dst to_dst) const\n"
      },
      {
        "file": "moses/moses/moses/eda/termination.h",
        "line": 39,
        "type": "empty_function",
        "content": "terminate_if_gte(const ScoreT& b) : bound(b) { }",
        "context": "template<typename ScoreT>\nstruct terminate_if_gte\n{\n    terminate_if_gte(const ScoreT& b) : bound(b) { }\n\n    template<typename It>\n    bool operator()(It from,It to) const {\n"
      },
      {
        "file": "moses/moses/moses/eda/termination.h",
        "line": 58,
        "type": "empty_function",
        "content": "bound(b), n_gen(n), at(-1) { }",
        "context": "struct terminate_if_gte_or_no_improv\n{\n    terminate_if_gte_or_no_improv(const ScoreT& b, int n) :\n            bound(b), n_gen(n), at(-1) { }\n\n    template<typename It>\n    bool operator()(It from,It to) const {\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 87,
        "type": "empty_function",
        "content": "bool_problem_base(demo_params& dp) : _dparms(dp) {}",
        "context": "class bool_problem_base : public problem_base\n{\n    public:\n        bool_problem_base(demo_params& dp) : _dparms(dp) {}\n        virtual combo::arity_t get_arity(int) = 0;\n        virtual logical_bscore get_bscore(int) = 0;\n        virtual void run(option_base*);\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 131,
        "type": "empty_function",
        "content": "pa_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class pa_problem : public bool_problem_base\n{\n    public:\n        pa_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"pa\"; }\n        virtual const std::string description() const {\n             return \"Learn parity function demo\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 152,
        "type": "empty_function",
        "content": "dj_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class dj_problem : public bool_problem_base\n{\n    public:\n        dj_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"dj\"; }\n        virtual const std::string description() const {\n             return \"Learn logicical disjunction demo\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 174,
        "type": "empty_function",
        "content": "majority_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class majority_problem : public bool_problem_base\n{\n    public:\n        majority_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"maj\"; }\n        virtual const std::string description() const {\n             return \"Majority problem demo\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 197,
        "type": "empty_function",
        "content": "mux_problem(demo_params& dp) : bool_problem_base(dp) {}",
        "context": "class mux_problem : public bool_problem_base\n{\n    public:\n        mux_problem(demo_params& dp) : bool_problem_base(dp) {}\n        virtual const std::string name() const { return \"mux\"; }\n        virtual const std::string description() const {\n            return \"Multiplex problem demo\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 236,
        "type": "empty_function",
        "content": "polynomial_problem(demo_params& dp) : _dparms(dp) {}",
        "context": "class polynomial_problem : public problem_base\n{\n    public:\n        polynomial_problem(demo_params& dp) : _dparms(dp) {}\n        virtual const std::string name() const { return \"sr\"; }\n        virtual const std::string description() const {\n             return \"Simple regression of f_n(x) = sum_{k={1,n}} x^k\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 304,
        "type": "empty_function",
        "content": "combo_problem_base(demo_params& dp) : _dparms(dp) {}",
        "context": "class combo_problem_base : public problem_base\n{\n    public:\n        combo_problem_base(demo_params& dp) : _dparms(dp) {}\n        void check_args(problem_params&);\n    protected:\n        demo_params& _dparms;\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 364,
        "type": "empty_function",
        "content": "combo_problem(demo_params& dp) : combo_problem_base(dp) {}",
        "context": "class combo_problem : public combo_problem_base\n{\n    public:\n        combo_problem(demo_params& dp) : combo_problem_base(dp) {}\n        virtual const std::string name() const { return \"cp\"; }\n        virtual const std::string description() const {\n             return \"Demo: Learn a given combo program\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/demo-problems.cc",
        "line": 454,
        "type": "empty_function",
        "content": "ann_combo_problem(demo_params& dp) : combo_problem_base(dp) {}",
        "context": "class ann_combo_problem : public combo_problem_base\n{\n    public:\n        ann_combo_problem(demo_params& dp) : combo_problem_base(dp) {}\n        virtual const std::string name() const { return \"ann-cp\"; }\n        virtual const std::string description() const {\n             return \"Demo: Learn a given combo program using ANN\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/problem.h",
        "line": 36,
        "type": "empty_function",
        "content": "virtual ~option_base() {}",
        "context": "class option_base\n{\n    public:\n        virtual ~option_base() {}\n        virtual void add_options(boost::program_options::options_description&) = 0;\n        virtual void parse_options(boost::program_options::variables_map&) {};\n};\n"
      },
      {
        "file": "moses/moses/moses/main/problem.h",
        "line": 38,
        "type": "empty_function",
        "content": "virtual void parse_options(boost::program_options::variables_map&) {};",
        "context": "    public:\n        virtual ~option_base() {}\n        virtual void add_options(boost::program_options::options_description&) = 0;\n        virtual void parse_options(boost::program_options::variables_map&) {};\n};\n\nclass option_manager\n"
      },
      {
        "file": "moses/moses/moses/main/problem.h",
        "line": 55,
        "type": "empty_function",
        "content": "virtual ~problem_base() {}",
        "context": "class problem_base\n{\n    public:\n        virtual ~problem_base() {}\n        virtual const std::string name() const = 0;\n        virtual const std::string description() const = 0;\n        virtual void run(option_base*) = 0;\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 51,
        "type": "empty_function",
        "content": "table_problem_base(table_problem_params& tp) : _tpp(tp) {}",
        "context": "class table_problem_base : public problem_base\n{\npublic:\n    table_problem_base(table_problem_params& tp) : _tpp(tp) {}\n\nprotected:\n    table_problem_params& _tpp;\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 90,
        "type": "empty_function",
        "content": ": table_problem_base(tp), _ippp(ip) {}",
        "context": "{\n    public:\n        ip_problem(table_problem_params& tp, ip_problem_params& ip)\n           : table_problem_base(tp), _ippp(ip) {}\n        virtual const std::string name() const { return \"ip\"; }\n        virtual const std::string description() const {\n             return \"Find interesting patterns\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 105,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        ann_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"ann-it\"; }\n        virtual const std::string description() const {\n             return \"ANN-based regression on input table\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 120,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        pre_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"pre\"; }\n        virtual const std::string description() const {\n             return \"Precision-Activation scoring\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 133,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        pre_conj_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"pre-conj\"; }\n        virtual const std::string description() const {\n             return \"Precision-Conjunction-Maximization\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 146,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        prerec_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"prerec\"; }\n        virtual const std::string description() const {\n             return \"Precision Maximization (holding recall constant)\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 159,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        recall_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"recall\"; }\n        virtual const std::string description() const {\n             return \"Recall Maximization (holding precision constant)\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 172,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        bep_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"bep\"; }\n        virtual const std::string description() const {\n             return \"Maximize Break-even Point\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 185,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        f_one_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"f_one\"; }\n        virtual const std::string description() const {\n             return \"Maximize F_1 score\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 198,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        it_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"it\"; }\n        virtual const std::string description() const {\n             return \"Maximize Accuracy\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 211,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        select_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"select\"; }\n        virtual const std::string description() const {\n             return \"Select range of rows\"; }\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.h",
        "line": 224,
        "type": "empty_function",
        "content": ": table_problem_base(tp) {}",
        "context": "{\n    public:\n        cluster_table_problem(table_problem_params& tp)\n            : table_problem_base(tp) {}\n        virtual const std::string name() const { return \"cluster\"; }\n        virtual const std::string description() const {\n             return \"Discover clustering function\"; }\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/ensemble_params.h",
        "line": 39,
        "type": "empty_function",
        "content": "{}",
        "context": "\t\texpalpha(2.0),\n\t\tbias_scale(1.0),\n\t\tnum_to_promote(1)\n\t{}\n\n\tbool do_boosting;    // boosting is enabled ...\n\tbool experts;        // do \"ensemble-of-experts\" boosting.\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapop_params.h",
        "line": 116,
        "type": "empty_function",
        "content": "n_tuples(UINT_MAX) {}",
        "context": "        contiguous_time(true),\n        n_subsample_demes(_n_subsample_demes),\n        n_top_candidates(_n_top_candidates),\n        n_tuples(UINT_MAX) {}\n\n    // Subsample by time\n    bool by_time;\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapop_params.h",
        "line": 179,
        "type": "empty_function",
        "content": "{}",
        "context": "        diversity(_diversity),\n        merge_callback(NULL),\n        callback_user_data(NULL)\n        {}\n\n    // The max number of candidates considered to be added to the\n    // metapopulation, if negative then all candidates are considered.\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.h",
        "line": 139,
        "type": "empty_function",
        "content": "~metapopulation() {}",
        "context": "                   const metapop_parameters& pa = metapop_parameters(),\n                   const subsample_deme_filter_parameters& subp = subsample_deme_filter_parameters());\n\n    ~metapopulation() {}\n\n    const scored_combo_tree_set& best_candidates() const;\n    const ensemble& get_ensemble() const { return _ensemble; }\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.h",
        "line": 366,
        "type": "empty_function",
        "content": ": _dparams(dparams), misses(0), hits(0) {}",
        "context": "    {\n        // ctor\n        cached_dst(const diversity_parameters& dparams)\n            : _dparams(dparams), misses(0), hits(0) {}\n\n        // We use a std::set instead of a std::pair, little\n        // optimization to deal with the symmetry of the distance\n"
      },
      {
        "file": "moses/moses/moses/moses/moses_main.h",
        "line": 62,
        "type": "empty_function",
        "content": "metapop_printer() {}",
        "context": "/// Print metapopulation results to stdout, logfile, etc.\nstruct metapop_printer\n{\n    metapop_printer() {}\n    metapop_printer(long _result_count,\n                    bool _output_score,\n                    bool _output_cscore,\n"
      },
      {
        "file": "moses/moses/moses/moses/moses_main.h",
        "line": 88,
        "type": "empty_function",
        "content": "is_mpi(_is_mpi) {}",
        "context": "        ilabels(_ilabels),\n        output_file(_output_file),\n        fmt(_fmt),\n        is_mpi(_is_mpi) {}\n\n    /**\n     * Print metapopulation summary.\n"
      },
      {
        "file": "moses/moses/moses/moses/moses_params.h",
        "line": 53,
        "type": "empty_function",
        "content": "{}",
        "context": "        local(_local), mpi(false), force_feed(false), jobs(_jobs), vm(_vm),\n        max_evals(_max_evals), max_gens(_max_gens), max_score(_max_score),\n        max_time(INT_MAX), max_cnd_output(_max_cnd_output)\n    {}\n\n    // Distributed solver control.\n    bool local;\n"
      },
      {
        "file": "moses/moses/moses/moses/moses_params.h",
        "line": 86,
        "type": "empty_function",
        "content": "{}",
        "context": "struct moses_statistics\n{\n    moses_statistics() : n_evals(0), n_expansions(0), elapsed_secs(0)\n    {}\n\n    // total number of scoring function evaluations\n    std::atomic<int> n_evals;\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 359,
        "type": "empty_function",
        "content": "worker_node() : rank(-1) {}",
        "context": "\nstruct worker_node\n{\n   worker_node() : rank(-1) {}\n   int rank;\n};\n\n"
      },
      {
        "file": "moses/moses/moses/moses/types.cc",
        "line": 44,
        "type": "empty_function",
        "content": ": string(to_string(expansion)) {}",
        "context": "using namespace std;\n\ndemeID_t::demeID_t(unsigned expansion)\n    : string(to_string(expansion)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first)\n    : string(to_string(expansion) + \".\" + to_string(breadth_first)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n"
      },
      {
        "file": "moses/moses/moses/moses/types.cc",
        "line": 46,
        "type": "empty_function",
        "content": ": string(to_string(expansion) + \".\" + to_string(breadth_first)) {}",
        "context": "demeID_t::demeID_t(unsigned expansion)\n    : string(to_string(expansion)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first)\n    : string(to_string(expansion) + \".\" + to_string(breadth_first)) {}\ndemeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n    : string(to_string(expansion) + \".\" +\n             to_string(breadth_first) + \".SS-\" +\n"
      },
      {
        "file": "moses/moses/moses/moses/types.cc",
        "line": 50,
        "type": "empty_function",
        "content": "to_string(ss_deme)) {}",
        "context": "demeID_t::demeID_t(unsigned expansion, unsigned breadth_first, unsigned ss_deme)\n    : string(to_string(expansion) + \".\" +\n             to_string(breadth_first) + \".SS-\" +\n             to_string(ss_deme)) {}\n\nbool scored_combo_tree::operator==(const scored_combo_tree& r) const {\n    return get_tree() == r.get_tree()\n"
      },
      {
        "file": "moses/moses/moses/moses/types.cc",
        "line": 118,
        "type": "empty_function",
        "content": "{}",
        "context": "    : score(very_worst_score), complexity(least_complexity),\n      complexity_penalty(0.0), uniformity_penalty(0.0),\n      penalized_score(very_worst_score)\n{}\n\ncomposite_score& composite_score::operator=(const composite_score &r)\n{\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 214,
        "type": "empty_function",
        "content": "behavioral_score() {}",
        "context": "// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 215,
        "type": "empty_function",
        "content": "behavioral_score(size_t sz) : std::vector<score_t>(sz) {}",
        "context": "struct behavioral_score : public std::vector<score_t>\n{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 216,
        "type": "empty_function",
        "content": "behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}",
        "context": "{\n    behavioral_score() {}\n    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 218,
        "type": "empty_function",
        "content": ": std::vector<score_t>(il) {}",
        "context": "    behavioral_score(size_t sz) : std::vector<score_t>(sz) {}\n    behavioral_score(size_t sz, score_t val) : std::vector<score_t>(sz, val) {}\n    behavioral_score(std::initializer_list<score_t> il)\n        : std::vector<score_t>(il) {}\n\n    std::vector<score_t> operator-=(const std::vector<score_t>& rhs)\n    {\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 267,
        "type": "empty_function",
        "content": "{}",
        "context": "                      composite_score cs = composite_score(),\n                      behavioral_score bs = behavioral_score())\n        : _tree(tr), _deme_id(id), _cscore(cs), _bscore(bs), _weight(1.0)\n    {}\n\nprivate:\n    combo::combo_tree _tree;\n"
      },
      {
        "file": "moses/moses/moses/optimization/hill-climbing.h",
        "line": 187,
        "type": "empty_function",
        "content": "{}",
        "context": "    hill_climbing(const optim_parameters& op = optim_parameters(),\n                  const hc_parameters& hc = hc_parameters())\n        : optimizer_base(op), hc_params(hc), _total_RAM_bytes(getTotalRAM())\n    {}\n\nprotected:\n    // log legend for graph stats\n"
      },
      {
        "file": "moses/moses/moses/optimization/optimization.h",
        "line": 149,
        "type": "empty_function",
        "content": "{}",
        "context": "          , hiscore(0.0), hicount(0.0),\n          num_improved(0.0), count_improved(0.0)\n#endif\n    {}\n    unsigned nsteps;\n    demeID_t demeID;\n    unsigned total_steps;\n"
      },
      {
        "file": "moses/moses/moses/optimization/optimization.h",
        "line": 177,
        "type": "empty_function",
        "content": ": opt_params(op) {}",
        "context": "struct optimizer_base : optim_stats\n{\n    optimizer_base(const optim_parameters& op = optim_parameters())\n        : opt_params(op) {}\n\n    virtual void operator()(deme_t& deme,\n                            const iscorer_base& iscorer,\n"
      },
      {
        "file": "moses/moses/moses/optimization/optimization.h",
        "line": 184,
        "type": "empty_function",
        "content": "virtual ~optimizer_base() {}",
        "context": "                            unsigned max_evals,\n                            time_t max_time) = 0;\n\n    virtual ~optimizer_base() {}\n\n    optim_parameters opt_params;\n};\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 175,
        "type": "empty_function",
        "content": ": optimizer_base(op), _total_RAM_bytes(getTotalRAM()), ps_params(ps) {}",
        "context": "{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n                    const ps_parameters& ps = ps_parameters())\n        : optimizer_base(op), _total_RAM_bytes(getTotalRAM()), ps_params(ps) {}\n\nprotected:\n    // Variables:\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 189,
        "type": "empty_function",
        "content": "best_personal(part_size, std::vector<double>(disc_size)) {}",
        "context": "        std::vector<std::vector<double>> temp, best_personal;\n        discrete_particles(unsigned part_size, unsigned disc_size) :\n            temp(part_size, std::vector<double>(disc_size)),\n            best_personal(part_size, std::vector<double>(disc_size)) {}\n    };\n\n    // Functions (Better explanation in declaration):\n"
      },
      {
        "file": "moses/moses/moses/optimization/star-anneal.h",
        "line": 51,
        "type": "empty_function",
        "content": "max_new_instances(100) {}",
        "context": "        min_temp(0),\n        temp_step_size(0.5),\n        accept_prob_temp_intensity(0.5),\n        max_new_instances(100) {}\n\n    double init_temp;\n    double min_temp;\n"
      },
      {
        "file": "moses/moses/moses/optimization/star-anneal.h",
        "line": 91,
        "type": "empty_function",
        "content": ": optimizer_base(op), sa_params(sa) {}",
        "context": "\n    simulated_annealing(const optim_parameters& op = optim_parameters(),\n                        const sa_parameters& sa = sa_parameters())\n        : optimizer_base(op), sa_params(sa) {}\n\n    double accept_probability(energy_t energy_new, energy_t energy_old,\n                              double temperature)\n"
      },
      {
        "file": "moses/moses/moses/optimization/univariate.h",
        "line": 48,
        "type": "empty_function",
        "content": "{}",
        "context": "        replacement_ratio(0.5),//ratio of population size sampled and integrated\n\n        model_complexity(1)    //model parsimony term log(N)*model_complexity\n    {}\n\n    bool is_tournament_selection() {\n        return selection > 1;\n"
      },
      {
        "file": "moses/moses/moses/optimization/univariate.h",
        "line": 67,
        "type": "empty_function",
        "content": ": optimizer_base(op), eda_params(ep) {}",
        "context": "{\n    univariate_optimization(const optim_parameters& op = optim_parameters(),\n                            const eda_parameters& ep = eda_parameters())\n        : optimizer_base(op), eda_params(ep) {}\n\n    void operator()(deme_t& deme,\n                    const iscorer_base& iscorer,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 139,
        "type": "empty_function",
        "content": "field() { }",
        "context": "     */\n    struct field\n    {\n        field() { }\n        field(width_t w, size_t ma, size_t mi)\n                : width(w), major_offset(ma), minor_offset(mi) { }\n        width_t width;\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 141,
        "type": "empty_function",
        "content": ": width(w), major_offset(ma), minor_offset(mi) { }",
        "context": "    {\n        field() { }\n        field(width_t w, size_t ma, size_t mi)\n                : width(w), major_offset(ma), minor_offset(mi) { }\n        width_t width;\n        size_t major_offset, minor_offset;\n    };\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 153,
        "type": "empty_function",
        "content": "disc_spec(multiplicity_t a) : multy(a) { }",
        "context": "     */\n    struct disc_spec\n    {\n        disc_spec(multiplicity_t a) : multy(a) { }\n        multiplicity_t multy;\n        bool operator<(const disc_spec& rhs) const { //sort descending by multy\n            return multy > rhs.multy;\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 183,
        "type": "empty_function",
        "content": ": mean(m), step_size(ss), expansion(ex), depth(d) { }",
        "context": "    struct contin_spec\n    {\n        contin_spec(contin_t m, contin_t ss, contin_t ex, depth_t d)\n                : mean(m), step_size(ss), expansion(ex), depth(d) { }\n        contin_t mean, step_size, expansion;\n        depth_t depth;\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 237,
        "type": "empty_function",
        "content": "_all_left(true), _all_right(true), _step_size(c.step_size) { }",
        "context": "    {\n        contin_stepper(const contin_spec& c_)\n                : c(c_), value(c.mean),\n                _all_left(true), _all_right(true), _step_size(c.step_size) { }\n        const contin_spec& c;\n        contin_t value;\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 288,
        "type": "empty_function",
        "content": "branching(next_power_of_two(1 + t.max_branching(t.begin()))) { }",
        "context": "    {\n        term_spec(const term_tree& t)\n                : tr(&t), depth(t.max_depth(t.begin())),\n                branching(next_power_of_two(1 + t.max_branching(t.begin()))) { }\n        // @todo: could be a source of bug if such order is not total\n        // as it's gonna make problems with field_set(from, to)\n        bool operator<(const term_spec& rhs) const { //sort descending by size\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 852,
        "type": "empty_function",
        "content": ": _it(it), _mask(packed_t(1) << offset) { }",
        "context": "\n    protected:\n        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 853,
        "type": "empty_function",
        "content": "bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }",
        "context": "    protected:\n        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n        Iterator _it; // instance iterator\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 854,
        "type": "empty_function",
        "content": "bit_iterator_base() : _it(), _mask(0) { }",
        "context": "        bit_iterator_base(Iterator it, width_t offset)\n            : _it(it), _mask(packed_t(1) << offset) { }\n        bit_iterator_base(packed_t mask, Iterator it) : _it(it), _mask(mask) { }\n        bit_iterator_base() : _it(), _mask(0) { }\n\n        Iterator _it; // instance iterator\n        packed_t _mask; // mask over the packed_t pointed by _it,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 869,
        "type": "empty_function",
        "content": "reference(const Iterator* it, size_t idx) : _it(it), _idx(idx) { }",
        "context": "\n        struct reference\n        {\n            reference(const Iterator* it, size_t idx) : _it(it), _idx(idx) { }\n\n            operator Value() const {\n                return do_get();\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 934,
        "type": "empty_function",
        "content": "iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }",
        "context": "            return _idx;\n        }\n    protected:\n        iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }\n        iterator_base() : _fs(NULL), _idx(0) { }\n\n        const field_set* _fs;\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 935,
        "type": "empty_function",
        "content": "iterator_base() : _fs(NULL), _idx(0) { }",
        "context": "        }\n    protected:\n        iterator_base(const field_set& fs, size_t idx) : _fs(&fs), _idx(idx) { }\n        iterator_base() : _fs(NULL), _idx(0) { }\n\n        const field_set* _fs;\n        size_t _idx;\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 950,
        "type": "empty_function",
        "content": ": _it(it), _mask(mask) {}",
        "context": "        struct reference\n        {\n            reference(instance::iterator it, packed_t mask)\n                : _it(it), _mask(mask) {}\n\n            operator bool() const {\n                return (*_it & _mask) != 0;\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1010,
        "type": "empty_function",
        "content": "bit_iterator() { }",
        "context": "        }\n        friend class const_bit_iterator;\n\n        bit_iterator() { }\n    protected:\n        bit_iterator(instance::iterator it, width_t offset)\n            : bit_iterator_base<bit_iterator, instance::iterator>(it, offset)\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1014,
        "type": "empty_function",
        "content": "{ }",
        "context": "    protected:\n        bit_iterator(instance::iterator it, width_t offset)\n            : bit_iterator_base<bit_iterator, instance::iterator>(it, offset)\n        { }\n    };\n\n    struct const_bit_iterator\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1026,
        "type": "empty_function",
        "content": "instance::const_iterator > (bi._mask, bi._it) { }",
        "context": "        }\n        const_bit_iterator(const bit_iterator& bi)\n            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (bi._mask, bi._it) { }\n\n        const_bit_iterator() { }\n    protected:\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1028,
        "type": "empty_function",
        "content": "const_bit_iterator() { }",
        "context": "            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (bi._mask, bi._it) { }\n\n        const_bit_iterator() { }\n    protected:\n        const_bit_iterator(instance::const_iterator it, width_t offset)\n            : bit_iterator_base < const_bit_iterator,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1032,
        "type": "empty_function",
        "content": "instance::const_iterator > (it, offset) { }",
        "context": "    protected:\n        const_bit_iterator(instance::const_iterator it, width_t offset)\n            : bit_iterator_base < const_bit_iterator,\n                                  instance::const_iterator > (it, offset) { }\n    };\n\n    // --------------------------------------------------------\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1047,
        "type": "empty_function",
        "content": "disc_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        disc_iterator() : _inst(NULL) { }\n\n        // For convenience.\n        multiplicity_t multy() const\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1064,
        "type": "empty_function",
        "content": ": iterator_base<disc_iterator, disc_t>(fs, idx), _inst(&inst) { }",
        "context": "\n    protected:\n        disc_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<disc_iterator, disc_t>(fs, idx), _inst(&inst) { }\n        instance* _inst;\n    };\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1079,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_disc_iterator(const disc_iterator& bi) :\n            iterator_base<const_disc_iterator, disc_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_disc_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1081,
        "type": "empty_function",
        "content": "const_disc_iterator() : _inst(NULL) { }",
        "context": "            iterator_base<const_disc_iterator, disc_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_disc_iterator() : _inst(NULL) { }\n\n        // For convenience.\n        multiplicity_t multy() const\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1093,
        "type": "empty_function",
        "content": ": iterator_base<const_disc_iterator, disc_t>(fs, idx), _inst(&inst) { }",
        "context": "\n    protected:\n        const_disc_iterator(const field_set& fs, size_t idx, const instance& inst)\n            : iterator_base<const_disc_iterator, disc_t>(fs, idx), _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1109,
        "type": "empty_function",
        "content": "contin_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        contin_iterator() : _inst(NULL) { }\n\n    protected:\n        contin_iterator(const field_set& fs, size_t idx, instance& inst)\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1114,
        "type": "empty_function",
        "content": "{ }",
        "context": "    protected:\n        contin_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<contin_iterator, contin_t>(fs, idx), _inst(&inst)\n        { }\n        instance* _inst;\n    };\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1130,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_contin_iterator(const contin_iterator& bi)\n            : iterator_base<const_contin_iterator, contin_t>(*bi._fs, bi._idx),\n              _inst(bi._inst) { }\n\n        const_contin_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1132,
        "type": "empty_function",
        "content": "const_contin_iterator() : _inst(NULL) { }",
        "context": "            : iterator_base<const_contin_iterator, contin_t>(*bi._fs, bi._idx),\n              _inst(bi._inst) { }\n\n        const_contin_iterator() : _inst(NULL) { }\n\n    protected:\n        const_contin_iterator(const field_set& fs, size_t idx,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1138,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "        const_contin_iterator(const field_set& fs, size_t idx,\n                              const instance& inst)\n            : iterator_base<const_contin_iterator, contin_t>(fs, idx),\n              _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1156,
        "type": "empty_function",
        "content": "term_iterator() : _inst(NULL) { }",
        "context": "            return reference(this, _idx);\n        }\n\n        term_iterator() : _inst(NULL) { }\n\n    protected:\n        term_iterator(const field_set& fs, size_t idx, instance& inst)\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1161,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "    protected:\n        term_iterator(const field_set& fs, size_t idx, instance& inst)\n            : iterator_base<term_iterator, term_t>(fs, idx),\n              _inst(&inst) { }\n\n        instance* _inst;\n    };\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1178,
        "type": "empty_function",
        "content": "_inst(bi._inst) { }",
        "context": "\n        const_term_iterator(const term_iterator& bi) :\n            iterator_base<const_term_iterator, term_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_term_iterator() : _inst(NULL) { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1180,
        "type": "empty_function",
        "content": "const_term_iterator() : _inst(NULL) { }",
        "context": "            iterator_base<const_term_iterator, term_t>(*bi._fs, bi._idx),\n            _inst(bi._inst) { }\n\n        const_term_iterator() : _inst(NULL) { }\n\n    protected:\n        const_term_iterator(const field_set& fs, size_t idx,\n"
      },
      {
        "file": "moses/moses/moses/representation/field_set.h",
        "line": 1186,
        "type": "empty_function",
        "content": "_inst(&inst) { }",
        "context": "        const_term_iterator(const field_set& fs, size_t idx,\n                            const instance& inst)\n            : iterator_base<const_term_iterator, term_t>(fs, idx),\n              _inst(&inst) { }\n        const instance* _inst;\n    };\n\n"
      },
      {
        "file": "moses/moses/moses/representation/instance.h",
        "line": 58,
        "type": "empty_function",
        "content": "hsh ^= std::hash<unsigned long int>{}(bs)",
        "context": "\t\t{\n\t\t\tsize_t hsh = 0;\n\t\t\tfor (unsigned long int bs: nstc)\n\t\t\t\thsh ^= std::hash<unsigned long int>{}(bs)\n\t\t\t\t      + 0x9e3779b9 + (hsh << 6) + (hsh >> 2);\n\t\t\treturn hsh;\n\t\t}\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 40,
        "type": "empty_function",
        "content": "virtual ~iscorer_base() {}",
        "context": "    typedef instance argument_type;\n    typedef composite_score result_type;\n    virtual composite_score operator()(const instance&) const = 0;\n    virtual ~iscorer_base() {}\n};\n\n/**\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 52,
        "type": "empty_function",
        "content": ": fs(_fs), target_inst(_target_inst) {}",
        "context": "{\n    distance_based_scorer(const field_set& _fs,\n                          const instance& _target_inst)\n        : fs(_fs), target_inst(_target_inst) {}\n\n    composite_score operator()(const instance& inst) const\n    {\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 76,
        "type": "empty_function",
        "content": ": _cscorer(cs), _rep(rep), _reduce(reduce) {}",
        "context": "{\n    complexity_based_scorer(behave_cscore& cs,\n                            representation& rep, bool reduce)\n        : _cscorer(cs), _rep(rep), _reduce(reduce) {}\n\n    composite_score operator()(const instance& inst) const\n    {\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_set.h",
        "line": 76,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create a deme initialized with n null instances.\n    instance_set(unsigned int n, MAYBE_CONST field_set& fs)\n        : super(n, instance(fs.packed_width())), _fields(fs),\n          n_evals(0), n_best_evals(0) {}\n    // Create a deme initialized with n instances of inst.\n    instance_set(unsigned int n, const instance& inst, MAYBE_CONST field_set& fs)\n        : super(n, inst), _fields(fs),\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_set.h",
        "line": 80,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create a deme initialized with n instances of inst.\n    instance_set(unsigned int n, const instance& inst, MAYBE_CONST field_set& fs)\n        : super(n, inst), _fields(fs),\n          n_evals(0), n_best_evals(0) {}\n    // Create an empty deme.\n    instance_set(MAYBE_CONST field_set& fs, const demeID_t& id = demeID_t())\n        : _fields(fs), _id(id),\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_set.h",
        "line": 84,
        "type": "empty_function",
        "content": "n_evals(0), n_best_evals(0) {}",
        "context": "    // Create an empty deme.\n    instance_set(MAYBE_CONST field_set& fs, const demeID_t& id = demeID_t())\n        : _fields(fs), _id(id),\n          n_evals(0), n_best_evals(0) {}\n\n#ifdef GCC46_EMPLACE_BACK_WORKAROUND\n    instance_set<ScoreT>& operator=(const instance_set<ScoreT>& rhs) {\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.cc",
        "line": 39,
        "type": "empty_function",
        "content": "step_size, expansion, depth) { }",
        "context": "                         contin_t step_size, contin_t expansion,\n                         field_set::width_t depth)\n    : knob_base(tr, tgt), _spec(combo::get_contin(*tgt),\n                                step_size, expansion, depth) { }\n\nbool contin_knob::in_exemplar() const\n{\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.cc",
        "line": 46,
        "type": "empty_function",
        "content": "void contin_knob::clear_exemplar() { }",
        "context": "    return true;\n}\n\nvoid contin_knob::clear_exemplar() { }\n\nvoid contin_knob::turn(contin_t x)\n{\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 61,
        "type": "empty_function",
        "content": ": _tr(tr), _loc(loc) {}",
        "context": "struct knob_base\n{\n    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 62,
        "type": "empty_function",
        "content": "knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}",
        "context": "{\n    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n    // Is the feature nonzero by default? i.e., is it present in the exemplar?\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 63,
        "type": "empty_function",
        "content": "virtual ~knob_base() { }",
        "context": "    knob_base(combo_tree& tr, combo_tree::iterator loc)\n        : _tr(tr), _loc(loc) {}\n    knob_base(combo_tree& tr) : _tr(tr), _loc(tr.end()) {}\n    virtual ~knob_base() { }\n\n    // Is the feature nonzero by default? i.e., is it present in the exemplar?\n    virtual bool in_exemplar() const = 0;\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 87,
        "type": "empty_function",
        "content": ": knob_base(tr, tgt) {}",
        "context": "struct disc_knob_base : public knob_base\n{\n    disc_knob_base(combo_tree& tr, combo_tree::iterator tgt)\n        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 89,
        "type": "empty_function",
        "content": ": knob_base(tr) {}",
        "context": "    disc_knob_base(combo_tree& tr, combo_tree::iterator tgt)\n        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n\n    virtual void turn(int) = 0;\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 90,
        "type": "empty_function",
        "content": "virtual ~disc_knob_base() {}",
        "context": "        : knob_base(tr, tgt) {}\n    disc_knob_base(combo_tree& tr)\n        : knob_base(tr) {}\n    virtual ~disc_knob_base() {}\n\n    virtual void turn(int) = 0;\n    virtual void disallow(int) = 0;\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 175,
        "type": "empty_function",
        "content": ": disc_knob_base(tr, tgt), _default(0), _current(0) {}",
        "context": "struct discrete_knob : public disc_knob_base\n{\n    discrete_knob(combo_tree& tr, combo_tree::iterator tgt)\n        : disc_knob_base(tr, tgt), _default(0), _current(0) {}\n    discrete_knob(combo_tree& tr)\n        : disc_knob_base(tr), _default(0), _current(0) {}\n\n"
      },
      {
        "file": "moses/moses/moses/representation/knobs.h",
        "line": 177,
        "type": "empty_function",
        "content": ": disc_knob_base(tr), _default(0), _current(0) {}",
        "context": "    discrete_knob(combo_tree& tr, combo_tree::iterator tgt)\n        : disc_knob_base(tr, tgt), _default(0), _current(0) {}\n    discrete_knob(combo_tree& tr)\n        : disc_knob_base(tr), _default(0), _current(0) {}\n\n    /// Do not allow setting to be set.\n    void disallow(int setting) {\n"
      },
      {
        "file": "moses/moses/moses/representation/scored_instance.h",
        "line": 38,
        "type": "empty_function",
        "content": "scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }",
        "context": "{\n    typedef tagged_item<instance, ScoreT> super;\n\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n"
      },
      {
        "file": "moses/moses/moses/representation/scored_instance.h",
        "line": 39,
        "type": "empty_function",
        "content": "scored_instance(const instance& i) : super(i) { }",
        "context": "    typedef tagged_item<instance, ScoreT> super;\n\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n"
      },
      {
        "file": "moses/moses/moses/representation/scored_instance.h",
        "line": 40,
        "type": "empty_function",
        "content": "scored_instance() { }",
        "context": "\n    scored_instance(const instance& i, const ScoreT& s) : super(i, s) { }\n    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n\n"
      },
      {
        "file": "moses/moses/moses/representation/scored_instance.h",
        "line": 42,
        "type": "empty_function",
        "content": "scored_instance(const std::pair<T1, T2>& p) : super(p) { }",
        "context": "    scored_instance(const instance& i) : super(i) { }\n    scored_instance() { }\n    template<class T1, class T2>\n    scored_instance(const std::pair<T1, T2>& p) : super(p) { }\n\n    bool operator<(const scored_instance& other) const\n    {\n"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.h",
        "line": 454,
        "type": "empty_function",
        "content": "{}",
        "context": "{\n    enum_filter_bscore(const CTable& ctt)\n        : enum_table_bscore(ctt), punish(1.0)\n    {}\n\n    behavioral_score operator()(const combo_tree& tr) const;\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.h",
        "line": 498,
        "type": "empty_function",
        "content": "{}",
        "context": "{\n    enum_graded_bscore(const CTable& ctt)\n        : enum_table_bscore(ctt), grading(0.9)\n    {}\n\n    behavioral_score operator()(const combo_tree&) const;\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 59,
        "type": "empty_function",
        "content": "bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};",
        "context": "/// A behavioral score is a vector of scores, one per sample of a dataset.\nstruct bscore_base\n{\n    bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};\n    virtual ~bscore_base() {};\n\n    /// Return the behavioral score for the combo_tree\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 60,
        "type": "empty_function",
        "content": "virtual ~bscore_base() {};",
        "context": "struct bscore_base\n{\n    bscore_base() : _return_weighted_score(false), _complexity_coef(0.0), _size(0) {};\n    virtual ~bscore_base() {};\n\n    /// Return the behavioral score for the combo_tree\n    virtual behavioral_score operator()(const combo_tree&) const = 0;\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 170,
        "type": "empty_function",
        "content": "virtual void ignore_cols(const std::set<arity_t>&) const {}",
        "context": "    /// new index set is ignored.  Thus, calling this with the empty set\n    /// will have the effect of restoring all columns that were previously\n    /// ignored.\n    virtual void ignore_cols(const std::set<arity_t>&) const {}\n\n    /// In case one wants to evaluate the fitness on a subset of the\n    /// data, one can provide a set of row indexes to ignore.\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 179,
        "type": "empty_function",
        "content": "virtual void ignore_rows(const std::set<unsigned>&) const {}",
        "context": "    /// previously ignored rows will be restored, before the\n    /// newly-specified rows are removed.  Thus, calling this with the\n    /// empty set has the effect of restoring all ignored rows.\n    virtual void ignore_rows(const std::set<unsigned>&) const {}\n\n    // Like ignore_rows but consider timestamps instead of indexes\n    virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.h",
        "line": 182,
        "type": "empty_function",
        "content": "virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}",
        "context": "    virtual void ignore_rows(const std::set<unsigned>&) const {}\n\n    // Like ignore_rows but consider timestamps instead of indexes\n    virtual void ignore_rows_at_times(const std::set<TTable::value_type>&) const {}\n\n    // Return the uncompressed size of the CTable\n    virtual unsigned get_ctable_usize() const {\n"
      },
      {
        "file": "moses/scripts/parse_log.py",
        "line": 16,
        "type": "empty_function",
        "content": "header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)",
        "context": "    # Define the regex for header and content\n    timestamp_re = r'\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}:\\d{3}\\]'\n    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n"
      },
      {
        "file": "moses/scripts/parse_log.py",
        "line": 17,
        "type": "empty_function",
        "content": "content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)",
        "context": "    timestamp_re = r'\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}:\\d{3}\\]'\n    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n"
      },
      {
        "file": "moses/scripts/parse_log.py",
        "line": 18,
        "type": "empty_function",
        "content": "all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)",
        "context": "    info_re = r'\\[INFO\\]'\n    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n    all_content_cre = re.compile(all_content_re)\n"
      },
      {
        "file": "moses/scripts/parse_log.py",
        "line": 19,
        "type": "empty_function",
        "content": "all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)",
        "context": "    header_re = r'{}: # (\\w+(?:\\t\\w+)+)'.format(prefix)\n    content_re = r'{}: ([^#\\t]+(?:\\t.+))+'.format(prefix)\n    all_header_re = r'(?:{} {} )?{}'.format(timestamp_re, info_re, header_re)\n    all_content_re = r'({}) {} {}'.format(timestamp_re, info_re, content_re)\n    all_header_cre = re.compile(all_header_re)\n    all_content_cre = re.compile(all_content_re)\n\n"
      },
      {
        "file": "neural-symbolic-integration/src/NeuralSymbolicBridge.cc",
        "line": 77,
        "type": "empty_function",
        "content": "return SymbolicRepresentation{};",
        "context": "    const std::string& target_mapping) {\n    \n    if (!integration_active_.load()) {\n        return SymbolicRepresentation{};\n    }\n    \n    auto start_time = std::chrono::high_resolution_clock::now();\n"
      },
      {
        "file": "neural-symbolic-integration/src/NeuralSymbolicBridge.cc",
        "line": 128,
        "type": "empty_function",
        "content": "return NeuralRepresentation{};",
        "context": "    const std::string& target_mapping) {\n    \n    if (!integration_active_.load()) {\n        return NeuralRepresentation{};\n    }\n    \n    auto start_time = std::chrono::high_resolution_clock::now();\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 128,
        "type": "stub_function",
        "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
        "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 129,
        "type": "stub_function",
        "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
        "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n"
      },
      {
        "file": "opencog/opencog/main/LGParser.cc",
        "line": 179,
        "type": "empty_function",
        "content": "size_t sentence_hash = std::hash<std::string>{}(sentence);",
        "context": "    std::vector<std::string> words = tokenize(sentence);\n    \n    // Create unique parse identifier\n    size_t sentence_hash = std::hash<std::string>{}(sentence);\n    std::string parse_id = \"parse_\" + std::to_string(sentence_hash);\n    \n    // Create parse node\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 136,
        "type": "stub_function",
        "content": "// Stub types when Link Grammar is not available",
        "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 138,
        "type": "stub_function",
        "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
        "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n"
      },
      {
        "file": "opencog/opencog/main/LGParser.h",
        "line": 139,
        "type": "stub_function",
        "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
        "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n"
      },
      {
        "file": "opencog/opencog/main/UnsupervisedLearner.cc",
        "line": 759,
        "type": "empty_function",
        "content": "std::to_string(std::hash<std::vector<Handle>>{}(instances));",
        "context": "    \n    // Create concept node\n    std::string concept_name = concept_type + \"_concept_\" + \n                              std::to_string(std::hash<std::vector<Handle>>{}(instances));\n    Handle concept = atomspace_->add_node(CONCEPT_NODE, concept_name);\n    \n    // Add concept properties\n"
      },
      {
        "file": "scripts/recursive_todo_resolver.py",
        "line": 213,
        "type": "empty_function",
        "content": "synergy_scores = {}",
        "context": "    \n    def _group_by_cognitive_synergy(self, todos: List[TODOItem]) -> Dict[str, float]:\n        \"\"\"Group related TODOs for maximum cognitive synergy\"\"\"\n        synergy_scores = {}\n        \n        # Create synergy clusters\n        synergy_clusters = defaultdict(list)\n"
      },
      {
        "file": "scripts/recursive_todo_resolver.py",
        "line": 256,
        "type": "empty_function",
        "content": "attention_scores = {}",
        "context": "    \n    def _compute_attention_scores(self, todos: List[TODOItem]) -> Dict[str, float]:\n        \"\"\"Compute attention scores using ECAN-inspired attention allocation\"\"\"\n        attention_scores = {}\n        \n        # Simulate ECAN-style Short-Term Importance (STI) allocation\n        # Inspired by AdvancedRecursiveAttentionAllocator in ggml-tensor-kernel\n"
      },
      {
        "file": "scripts/recursive_todo_resolver.py",
        "line": 787,
        "type": "empty_function",
        "content": "self.progress_data[\"resolutions\"] = {}",
        "context": "        \n        # Add resolution tracking\n        if \"resolutions\" not in self.progress_data:\n            self.progress_data[\"resolutions\"] = {}\n        self.progress_data[\"resolutions\"][todo_key] = {\n            \"resolved_at\": datetime.now().isoformat(),\n            \"resolution_note\": resolution_note,\n"
      },
      {
        "file": "scripts/recursive_todo_resolver.py",
        "line": 915,
        "type": "empty_function",
        "content": "self.progress_data['github_issues'] = {}",
        "context": "            if created_issue:\n                # Store issue URL in progress data for future reference\n                if 'github_issues' not in self.progress_data:\n                    self.progress_data['github_issues'] = {}\n                self.progress_data['github_issues'][self.progress_data['current_iteration']] = {\n                    'issue_number': created_issue['number'],\n                    'issue_url': created_issue['html_url'],\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpaceTimeMap.h",
        "line": 27,
        "type": "empty_function",
        "content": "Point3D(double x = 0.0, double y = 0.0, double z = 0.0) : x(x), y(y), z(z) {}",
        "context": "{\n    double x, y, z;\n    \n    Point3D(double x = 0.0, double y = 0.0, double z = 0.0) : x(x), y(y), z(z) {}\n    \n    // Distance calculations\n    double distance(const Point3D& other) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpaceTimeMap.h",
        "line": 48,
        "type": "empty_function",
        "content": "TimePoint(double t = 0.0) : timestamp(t) {}",
        "context": "{\n    double timestamp;  // Unix timestamp with fractional seconds\n    \n    TimePoint(double t = 0.0) : timestamp(t) {}\n    \n    // Temporal operations\n    double duration(const TimePoint& other) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpaceTimeMap.h",
        "line": 68,
        "type": "empty_function",
        "content": ": location(loc), time(t) {}",
        "context": "    TimePoint time;\n    \n    SpaceTimeCoord(const Point3D& loc = Point3D(), const TimePoint& t = TimePoint())\n        : location(loc), time(t) {}\n    \n    // Spacetime distance (considering both spatial and temporal dimensions)\n    double spacetimeDistance(const SpaceTimeCoord& other, double timeWeight = 1.0) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpatialReasoning.h",
        "line": 44,
        "type": "empty_function",
        "content": ": min(min), max(max) {}",
        "context": "    Point3D max;\n    \n    BoundingBox(const Point3D& min = Point3D(), const Point3D& max = Point3D()) \n        : min(min), max(max) {}\n    \n    bool contains(const Point3D& point) const;\n    bool intersects(const BoundingBox& other) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpatialReasoning.h",
        "line": 63,
        "type": "empty_function",
        "content": "SpatialRegion(const std::vector<Point3D>& vertices = {});",
        "context": "    BoundingBox boundingBox;\n    \npublic:\n    SpatialRegion(const std::vector<Point3D>& vertices = {});\n    \n    // Shape operations\n    bool contains(const Point3D& point) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpatialReasoning.h",
        "line": 104,
        "type": "empty_function",
        "content": "const std::vector<Handle>& obstacles = {}) const;",
        "context": "    \n    // Path and navigation\n    std::vector<Point3D> calculatePath(const Point3D& start, const Point3D& goal, \n                                      const std::vector<Handle>& obstacles = {}) const;\n    bool isPathClear(const Point3D& start, const Point3D& end, \n                     const std::vector<Handle>& obstacles = {}) const;\n    \n"
      },
      {
        "file": "spacetime/opencog/spacetime/SpatialReasoning.h",
        "line": 106,
        "type": "empty_function",
        "content": "const std::vector<Handle>& obstacles = {}) const;",
        "context": "    std::vector<Point3D> calculatePath(const Point3D& start, const Point3D& goal, \n                                      const std::vector<Handle>& obstacles = {}) const;\n    bool isPathClear(const Point3D& start, const Point3D& end, \n                     const std::vector<Handle>& obstacles = {}) const;\n    \n    // Spatial queries\n    std::vector<Handle> getNearestObjects(Handle reference, size_t count = 5) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/TemporalReasoning.h",
        "line": 45,
        "type": "empty_function",
        "content": ": start(start), end(end) {}",
        "context": "    TimePoint end;\n    \n    TimeInterval(const TimePoint& start = TimePoint(), const TimePoint& end = TimePoint())\n        : start(start), end(end) {}\n    \n    double duration() const { return end.timestamp - start.timestamp; }\n    bool contains(const TimePoint& time) const;\n"
      },
      {
        "file": "spacetime/opencog/spacetime/TemporalReasoning.h",
        "line": 69,
        "type": "empty_function",
        "content": ": atom(atom), interval(interval), eventType(eventType) {}",
        "context": "    TemporalEvent(Handle atom = Handle::UNDEFINED, \n                  const TimeInterval& interval = TimeInterval(),\n                  const std::string& eventType = \"\")\n        : atom(atom), interval(interval), eventType(eventType) {}\n};\n\n/**\n"
      },
      {
        "file": "spacetime/opencog/spacetime/TemporalReasoning.h",
        "line": 82,
        "type": "empty_function",
        "content": "TemporalSequence(const std::vector<TemporalEvent>& events = {});",
        "context": "    double sequenceScore = 0.0;\n    \npublic:\n    TemporalSequence(const std::vector<TemporalEvent>& events = {});\n    \n    // Sequence operations\n    void addEvent(const TemporalEvent& event);\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 116,
        "type": "empty_function",
        "content": "return {};",
        "context": "std::vector<Handle> SpaceTimeAtom::findNearbyAtoms(Handle reference, double radius) const\n{\n    if (!spaceTimeMap || !spaceTimeMap->hasCoordinate(reference)) {\n        return {};\n    }\n    \n    Point3D refLocation = spaceTimeMap->getLocation(reference);\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 128,
        "type": "empty_function",
        "content": "return {};",
        "context": "    if (spaceTimeMap) {\n        return spaceTimeMap->getNearbyAtoms(center, radius);\n    }\n    return {};\n}\n\nSpatialRelation SpaceTimeAtom::getSpatialRelation(Handle atom1, Handle atom2) const\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 144,
        "type": "empty_function",
        "content": "return {};",
        "context": "    if (spaceTimeMap) {\n        return spaceTimeMap->getAtomsInTimeRange(start, end);\n    }\n    return {};\n}\n\nstd::vector<Handle> SpaceTimeAtom::findSimultaneousAtoms(Handle reference, double tolerance) const\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 150,
        "type": "empty_function",
        "content": "return {};",
        "context": "std::vector<Handle> SpaceTimeAtom::findSimultaneousAtoms(Handle reference, double tolerance) const\n{\n    if (!spaceTimeMap || !spaceTimeMap->hasCoordinate(reference)) {\n        return {};\n    }\n    \n    TimePoint refTime = spaceTimeMap->getTime(reference);\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 172,
        "type": "empty_function",
        "content": "return {};",
        "context": "    if (spaceTimeMap) {\n        return spaceTimeMap->getAtomsInSpaceTimeRegion(center, spatialRadius, temporalRadius);\n    }\n    return {};\n}\n\nstd::vector<TemporalSequence> SpaceTimeAtom::findTemporalPatterns(const std::vector<Handle>& atoms) const\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 180,
        "type": "empty_function",
        "content": "return {};",
        "context": "    if (temporalReasoning) {\n        return temporalReasoning->findTemporalPatterns(atoms);\n    }\n    return {};\n}\n\nstd::vector<Handle> SpaceTimeAtom::predictNextInSequence(const TemporalSequence& sequence) const\n"
      },
      {
        "file": "spacetime/src/SpaceTimeAtom.cc",
        "line": 188,
        "type": "empty_function",
        "content": "return {};",
        "context": "    if (temporalReasoning) {\n        return temporalReasoning->predictNext(sequence);\n    }\n    return {};\n}\n\nsize_t SpaceTimeAtom::getManagedAtomCount() const\n"
      },
      {
        "file": "spacetime/src/TemporalReasoning.cc",
        "line": 262,
        "type": "empty_function",
        "content": "if (!spaceTimeMap) return {};",
        "context": "\nstd::vector<Handle> TemporalReasoning::getObjectsDuring(const TimeInterval& interval) const\n{\n    if (!spaceTimeMap) return {};\n    \n    return spaceTimeMap->getAtomsInTimeRange(interval.start, interval.end);\n}\n"
      },
      {
        "file": "spacetime/src/TemporalSequence.cc",
        "line": 28,
        "type": "empty_function",
        "content": ": timestamp(ts), event_type(type), value(val) {}",
        "context": "    std::map<std::string, double> attributes;\n    \n    TemporalEvent(double ts, const std::string& type, double val = 0.0)\n        : timestamp(ts), event_type(type), value(val) {}\n};\n\n// Temporal sequence class\n"
      },
      {
        "file": "spacetime/src/TemporalSequence.cc",
        "line": 114,
        "type": "empty_function",
        "content": "if (timestamps.size() < 3) return {};",
        "context": "            }\n        }\n        \n        if (timestamps.size() < 3) return {};\n        \n        // Calculate inter-event intervals\n        std::vector<double> intervals;\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 55,
        "type": "empty_function",
        "content": "self.components: Dict[str, ComponentInfo] = {}",
        "context": "    \"\"\"Interactive explorer for cognitive architecture\"\"\"\n    \n    def __init__(self):\n        self.components: Dict[str, ComponentInfo] = {}\n        self.cognitive_patterns: List[CognitivePattern] = []\n        self.architecture_graph: Dict[str, List[str]] = {}\n        self.tensor_evolution: Dict[str, List[Dict]] = {}\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 57,
        "type": "empty_function",
        "content": "self.architecture_graph: Dict[str, List[str]] = {}",
        "context": "    def __init__(self):\n        self.components: Dict[str, ComponentInfo] = {}\n        self.cognitive_patterns: List[CognitivePattern] = []\n        self.architecture_graph: Dict[str, List[str]] = {}\n        self.tensor_evolution: Dict[str, List[Dict]] = {}\n        self.documentation_index: Dict[str, List[str]] = {}\n        \n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 58,
        "type": "empty_function",
        "content": "self.tensor_evolution: Dict[str, List[Dict]] = {}",
        "context": "        self.components: Dict[str, ComponentInfo] = {}\n        self.cognitive_patterns: List[CognitivePattern] = []\n        self.architecture_graph: Dict[str, List[str]] = {}\n        self.tensor_evolution: Dict[str, List[Dict]] = {}\n        self.documentation_index: Dict[str, List[str]] = {}\n        \n    def discover_architecture(self):\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 59,
        "type": "empty_function",
        "content": "self.documentation_index: Dict[str, List[str]] = {}",
        "context": "        self.cognitive_patterns: List[CognitivePattern] = []\n        self.architecture_graph: Dict[str, List[str]] = {}\n        self.tensor_evolution: Dict[str, List[Dict]] = {}\n        self.documentation_index: Dict[str, List[str]] = {}\n        \n    def discover_architecture(self):\n        \"\"\"Discover and analyze the cognitive architecture\"\"\"\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 110,
        "type": "empty_function",
        "content": "extensions = {}",
        "context": "            total_size = sum(f.stat().st_size for f in files if f.is_file())\n            \n            # Determine primary language\n            extensions = {}\n            for f in files:\n                if f.is_file() and f.suffix:\n                    extensions[f.suffix] = extensions.get(f.suffix, 0) + 1\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 179,
        "type": "empty_function",
        "content": "signatures = {}",
        "context": "    \n    def _extract_tensor_signatures(self, path: Path) -> Dict[str, Any]:\n        \"\"\"Extract tensor signatures from component\"\"\"\n        signatures = {}\n        \n        try:\n            # Look for tensor-related files\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 242,
        "type": "empty_function",
        "content": "phase_groups = {}",
        "context": "        patterns = []\n        \n        # Pattern 1: Phase Integration Patterns\n        phase_groups = {}\n        for comp_name, comp_info in self.components.items():\n            phase = comp_info.phase\n            if phase not in phase_groups:\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 263,
        "type": "empty_function",
        "content": "language_groups = {}",
        "context": "                patterns.append(pattern)\n        \n        # Pattern 2: Language Diversity Patterns\n        language_groups = {}\n        for comp_name, comp_info in self.components.items():\n            lang = comp_info.primary_language\n            if lang not in language_groups:\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 284,
        "type": "empty_function",
        "content": "function_overlap = {}",
        "context": "                patterns.append(pattern)\n        \n        # Pattern 3: Cognitive Function Clustering\n        function_overlap = {}\n        for comp_name, comp_info in self.components.items():\n            for func in comp_info.cognitive_functions:\n                if func not in function_overlap:\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 346,
        "type": "empty_function",
        "content": "phases = {}",
        "context": "        flowchart.append(\"\")\n        \n        # Group by phases\n        phases = {}\n        for comp_name, comp_info in self.components.items():\n            phase = comp_info.phase\n            if phase not in phases:\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 476,
        "type": "empty_function",
        "content": "phase_distribution = {}",
        "context": "        report.append(f\"   Language Diversity: {len(languages)} languages\")\n        \n        # Phase distribution\n        phase_distribution = {}\n        for comp in self.components.values():\n            phase_distribution[comp.phase] = phase_distribution.get(comp.phase, 0) + 1\n        report.append(f\"   Phase Distribution: {dict(phase_distribution)}\")\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 566,
        "type": "empty_function",
        "content": "phases = {}",
        "context": "        print(f\"\\n\ud83d\udce6 COMPONENTS ({len(self.components)} total):\")\n        \n        # Group by phase\n        phases = {}\n        for comp_name, comp_info in self.components.items():\n            phase = comp_info.phase\n            if phase not in phases:\n"
      },
      {
        "file": "tests/phase-vi-comprehensive-testing.py",
        "line": 47,
        "type": "empty_function",
        "content": "self.performance_metrics = {}",
        "context": "    \n    def __post_init__(self):\n        if self.performance_metrics is None:\n            self.performance_metrics = {}\n        if self.cognitive_metrics is None:\n            self.cognitive_metrics = {}\n\n"
      },
      {
        "file": "tests/phase-vi-comprehensive-testing.py",
        "line": 49,
        "type": "empty_function",
        "content": "self.cognitive_metrics = {}",
        "context": "        if self.performance_metrics is None:\n            self.performance_metrics = {}\n        if self.cognitive_metrics is None:\n            self.cognitive_metrics = {}\n\n@dataclass\nclass CognitiveLoadMetrics:\n"
      },
      {
        "file": "tests/phase-vi-comprehensive-testing.py",
        "line": 69,
        "type": "empty_function",
        "content": "self.cognitive_metrics: Dict[str, Any] = {}",
        "context": "    \n    def __init__(self):\n        self.test_results: List[TestResult] = []\n        self.cognitive_metrics: Dict[str, Any] = {}\n        self.performance_baselines: Dict[str, float] = {}\n        self.stress_test_limits: Dict[str, int] = {\n            'max_atoms': 10000,\n"
      },
      {
        "file": "tests/phase-vi-comprehensive-testing.py",
        "line": 70,
        "type": "empty_function",
        "content": "self.performance_baselines: Dict[str, float] = {}",
        "context": "    def __init__(self):\n        self.test_results: List[TestResult] = []\n        self.cognitive_metrics: Dict[str, Any] = {}\n        self.performance_baselines: Dict[str, float] = {}\n        self.stress_test_limits: Dict[str, int] = {\n            'max_atoms': 10000,\n            'max_threads': 32,\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 325,
        "type": "empty_function",
        "content": "integration_results = {}",
        "context": "            (\"Neural-Symbolic Bridge\", self._test_neural_symbolic_integration)\n        ]\n        \n        integration_results = {}\n        \n        for test_name, test_func in integration_tests:\n            print(f\"Testing {test_name}...\")\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 540,
        "type": "empty_function",
        "content": "relevance = atom.get(\"properties\", {}).get(\"relevance\", 0.5)",
        "context": "        # Focus on high-relevance atoms\n        patterns = []\n        for i, atom in enumerate(atoms):\n            relevance = atom.get(\"properties\", {}).get(\"relevance\", 0.5)\n            if relevance > 0.7:  # High attention threshold\n                patterns.append(f\"attention_pattern_{i}\")\n        return patterns[:10]  # Attention has limited capacity\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 775,
        "type": "empty_function",
        "content": "tasks = {}",
        "context": "        total_atoms = len(self.test_data[\"atoms\"])\n        atoms_per_agent = total_atoms // scenario[\"agents\"]\n        \n        tasks = {}\n        for i, agent in enumerate(agents):\n            start_idx = i * atoms_per_agent\n            end_idx = min((i + 1) * atoms_per_agent, total_atoms)\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 790,
        "type": "empty_function",
        "content": "agent_results = {}",
        "context": "    \n    def _execute_coordinated_recognition(self, tasks: Dict, requirements: List[str]) -> Dict:\n        \"\"\"Execute coordinated multi-agent pattern recognition\"\"\"\n        agent_results = {}\n        coordination_events = []\n        \n        # Each agent processes their assigned atoms\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 908,
        "type": "empty_function",
        "content": "results = {}",
        "context": "        # Simulate AtomSpace operations\n        operations_tested = [\"add_node\", \"add_link\", \"query_patterns\", \"truth_value_update\"]\n        \n        results = {}\n        for operation in operations_tested:\n            # Simulate operation success/performance\n            success_rate = 0.95  # High success rate for core operations\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 927,
        "type": "empty_function",
        "content": "results = {}",
        "context": "        # Simulate URE rule execution\n        rule_types = [\"forward_chaining\", \"backward_chaining\", \"pattern_matching\"]\n        \n        results = {}\n        for rule_type in rule_types:\n            # Simulate rule execution metrics\n            execution_success = 0.88\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 946,
        "type": "empty_function",
        "content": "results = {}",
        "context": "        # Simulate ECAN attention operations\n        attention_operations = [\"allocate_attention\", \"update_weights\", \"economic_flow\"]\n        \n        results = {}\n        for operation in attention_operations:\n            # Simulate attention system performance\n            efficiency = 0.92\n"
      },
      {
        "file": "tests/integration/test_aprfe_comprehensive.py",
        "line": 965,
        "type": "empty_function",
        "content": "results = {}",
        "context": "        # Simulate neural-symbolic conversion operations\n        conversion_types = [\"neural_to_symbolic\", \"symbolic_to_neural\", \"bidirectional_mapping\"]\n        \n        results = {}\n        for conversion in conversion_types:\n            # Simulate conversion performance\n            accuracy = 0.85\n"
      },
      {
        "file": "tests/integration/test_attention_spreading_benchmarks.py",
        "line": 20,
        "type": "empty_function",
        "content": "self.benchmark_results = {}",
        "context": "    \"\"\"Benchmark suite for attention spreading performance\"\"\"\n    \n    def __init__(self):\n        self.benchmark_results = {}\n        \n    def setup_test_environment(self, num_atoms=1000, num_agents=5):\n        \"\"\"Set up benchmark test environment\"\"\"\n"
      },
      {
        "file": "tests/integration/test_attention_spreading_benchmarks.py",
        "line": 229,
        "type": "empty_function",
        "content": "initial_distribution = {}",
        "context": "        print(f\"\\n=== Attention Fairness Benchmark ===\")\n        \n        # Calculate initial attention distribution\n        initial_distribution = {}\n        for i, agent in enumerate(self.agents):\n            agent_total_attention = sum(self.atoms[idx][\"attention_value\"] \n                                      for idx in agent[\"focus_atoms\"] \n"
      },
      {
        "file": "tests/integration/test_attention_spreading_benchmarks.py",
        "line": 242,
        "type": "empty_function",
        "content": "current_distribution = {}",
        "context": "        \n        for cycle in range(cycles):\n            # Calculate current distribution\n            current_distribution = {}\n            for agent in self.agents:\n                agent_total_attention = sum(self.atoms[idx][\"attention_value\"] \n                                          for idx in agent[\"focus_atoms\"] \n"
      },
      {
        "file": "tests/integration/test_attention_spreading_benchmarks.py",
        "line": 282,
        "type": "empty_function",
        "content": "final_distribution = {}",
        "context": "        print(f\"\u2713 Fairness improvement: {fairness_improvement:+.3f}\")\n        print(f\"\u2713 Final agent distributions:\")\n        \n        final_distribution = {}\n        for agent in self.agents:\n            agent_total_attention = sum(self.atoms[idx][\"attention_value\"] \n                                      for idx in agent[\"focus_atoms\"] \n"
      },
      {
        "file": "tests/integration/test_phase2_ecan_attention.py",
        "line": 199,
        "type": "empty_function",
        "content": "conflicting_atoms = {}",
        "context": "        print(f\"\u2713 Generated {len(sync_messages)} synchronization messages\")\n        \n        # Test conflict resolution for overlapping atoms\n        conflicting_atoms = {}\n        for msg in sync_messages:\n            atom_id = msg[\"atom\"]\n            if atom_id not in conflicting_atoms:\n"
      },
      {
        "file": "tests/integration/test_phase2_ecan_attention.py",
        "line": 206,
        "type": "empty_function",
        "content": "resolved_values = {}",
        "context": "                conflicting_atoms[atom_id] = []\n            conflicting_atoms[atom_id].append(msg[\"value\"])\n            \n        resolved_values = {}\n        for atom_id, values in conflicting_atoms.items():\n            if len(values) > 1:\n                # Weighted average conflict resolution\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 43,
        "type": "empty_function",
        "content": "const Unify::Partitions Unify::empty_partitions({});",
        "context": "\nnamespace opencog {\n\nconst Unify::Partitions Unify::empty_partitions({});\n\nconst Unify::Partitions Unify::empty_partition_singleton({{}});\n\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 45,
        "type": "empty_function",
        "content": "const Unify::Partitions Unify::empty_partition_singleton({{}});",
        "context": "\nconst Unify::Partitions Unify::empty_partitions({});\n\nconst Unify::Partitions Unify::empty_partition_singleton({{}});\n\nUnify::CHandle::CHandle(const Handle& h, const Context& c)\n\t: handle(h), context(c) {}\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 48,
        "type": "empty_function",
        "content": ": handle(h), context(c) {}",
        "context": "const Unify::Partitions Unify::empty_partition_singleton({{}});\n\nUnify::CHandle::CHandle(const Handle& h, const Context& c)\n\t: handle(h), context(c) {}\n\nbool Unify::CHandle::is_variable() const\n{\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 147,
        "type": "empty_function",
        "content": ": Partitions(s ? empty_partition_singleton : empty_partitions) {}",
        "context": "}\n\nUnify::SolutionSet::SolutionSet(bool s)\n\t: Partitions(s ? empty_partition_singleton : empty_partitions) {}\n\nUnify::SolutionSet::SolutionSet(const Unify::Partitions& p)\n\t: Partitions(p) {}\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 150,
        "type": "empty_function",
        "content": ": Partitions(p) {}",
        "context": "\t: Partitions(s ? empty_partition_singleton : empty_partitions) {}\n\nUnify::SolutionSet::SolutionSet(const Unify::Partitions& p)\n\t: Partitions(p) {}\n\nbool Unify::SolutionSet::is_satisfiable() const\n{\n"
      },
      {
        "file": "unify/opencog/unify/Unify.cc",
        "line": 1210,
        "type": "empty_function",
        "content": "return {};",
        "context": "\t// This function is currently not used anywhere in the codebase\n\t// and its implementation would require complex type hierarchy analysis.\n\t// Return empty set for now as it's not critical for functionality.\n\treturn {};\n}\n\nTypeSet Unify::get_union_type(const Handle& h) const\n"
      },
      {
        "file": "ure/opencog/ure/ActionSelection.cc",
        "line": 37,
        "type": "empty_function",
        "content": ", _tsmp(_tvs) {}",
        "context": "\t: action2tv(a2tv)\n\t, _tvs(boost::adaptors::values(a2tv).begin(),\n\t       boost::adaptors::values(a2tv).end())\n\t, _tsmp(_tvs) {}\n\nHandleCounter ActionSelection::distribution()\n{\n"
      },
      {
        "file": "ure/opencog/ure/BetaDistribution.cc",
        "line": 35,
        "type": "empty_function",
        "content": "tv->get_count(), p_alpha, p_beta) {}",
        "context": "                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\nBetaDistribution::BetaDistribution(double pos_count, double count,\n                                   double p_alpha, double p_beta)\n"
      },
      {
        "file": "ure/opencog/ure/BetaDistribution.cc",
        "line": 39,
        "type": "empty_function",
        "content": ": _beta_distribution(p_alpha + pos_count, p_beta + count - pos_count) {}",
        "context": "\nBetaDistribution::BetaDistribution(double pos_count, double count,\n                                   double p_alpha, double p_beta)\n\t: _beta_distribution(p_alpha + pos_count, p_beta + count - pos_count) {}\n\ndouble BetaDistribution::operator()(RandGen& rng) const\n{\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 175,
        "type": "empty_function",
        "content": ": premises_as_clauses(false), _rule_alias(Handle::UNDEFINED), _exhausted(false) {}",
        "context": "}\n\nRule::Rule()\n\t: premises_as_clauses(false), _rule_alias(Handle::UNDEFINED), _exhausted(false) {}\n\nRule::Rule(const Handle& rule_member)\n\t: premises_as_clauses(false), _rule_alias(Handle::UNDEFINED), _exhausted(false)\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 532,
        "type": "empty_function",
        "content": "return {};",
        "context": "{\n\t// If the rule's handle has not been set yet\n\tif (not is_valid())\n\t\treturn {};\n\n\t// To guarantee that the rule variable does not have the same name\n\t// as any variable in the source. NOTE: This is a probabilistic\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 569,
        "type": "empty_function",
        "content": "return {};",
        "context": "{\n\t// If the rule's handle has not been set yet\n\tif (not is_valid())\n\t\treturn {};\n\n\t// To guarantee that the rule variable does not have the same name\n\t// as any variable in the target. NOTE: This is a probabilistic\n"
      },
      {
        "file": "ure/opencog/ure/ThompsonSampling.cc",
        "line": 38,
        "type": "empty_function",
        "content": ": _tvs(tvs), _bins(bins) {}",
        "context": "namespace opencog {\n\nThompsonSampling::ThompsonSampling(const TruthValueSeq& tvs, unsigned bins)\n\t: _tvs(tvs), _bins(bins) {}\n\nstd::vector<double> ThompsonSampling::distribution() const\n{\n"
      },
      {
        "file": "ure/opencog/ure/URESCM.cc",
        "line": 105,
        "type": "empty_function",
        "content": "URESCM::URESCM() : ModuleWrap(\"opencog ure\") {}",
        "context": "\nusing namespace opencog;\n\nURESCM::URESCM() : ModuleWrap(\"opencog ure\") {}\n\n/// This is called while (opencog ure) is the current module.\n/// Thus, all the definitions below happen in that module.\n"
      },
      {
        "file": "ure/opencog/ure/URESCM.cc",
        "line": 129,
        "type": "empty_function",
        "content": "HandleSeq focus_set = {};",
        "context": "                                   Handle focus_set_h)\n{\n\tAtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"cog-mandatory-args-fc\");\n\tHandleSeq focus_set = {};\n\n\t// A ListLink means that the variable declaration is undefined\n\tif (vardecl->get_type() == LIST_LINK)\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 91,
        "type": "empty_function",
        "content": "AndBIT::AndBIT() : complexity(0), exhausted(false), queried_as(nullptr) {}",
        "context": "// AndBIT //\n////////////\n\nAndBIT::AndBIT() : complexity(0), exhausted(false), queried_as(nullptr) {}\n\nAndBIT::AndBIT(AtomSpace& bit_as, const Handle& target, Handle vardecl,\n               const BITNodeFitness& fitness, const AtomSpace* qas)\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 124,
        "type": "empty_function",
        "content": "AndBIT::~AndBIT() {}",
        "context": "\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n\nAndBIT AndBIT::expand(const Handle& leaf,\n                      const RuleTypedSubstitutionPair& rule,\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 453,
        "type": "empty_function",
        "content": "return HandleSet{};",
        "context": "\t\t// not a leaf (maybe it could but it would over complicate the\n\t\t// rest and bring no benefit since we can always expand a\n\t\t// parent and-BIT that has no such ExecutionOutputLink).\n\t\treturn HandleSet{};\n\t}\n\n\t// Here it must be a leaf so return it\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 604,
        "type": "empty_function",
        "content": "return {};",
        "context": "\telse if (pattern->get_type() == PRESENT_LINK)\n\t\treturn pattern->getOutgoingSet();\n\telse\n\t\treturn {};\n}\n\nHandleSeq AndBIT::get_present_clauses(const HandleSeq& clauses)\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 624,
        "type": "empty_function",
        "content": "return {};",
        "context": "\tif (pattern->get_type() == AND_LINK)\n\t\treturn get_virtual_clauses(pattern->getOutgoingSet());\n\telse if (pattern->get_type() == PRESENT_LINK)\n\t\treturn {};\n\telse\n\t\treturn {pattern};\n}\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 828,
        "type": "empty_function",
        "content": "BIT::BIT() : _as(nullptr) {}",
        "context": "// BIT //\n/////////\n\nBIT::BIT() : _as(nullptr) {}\n\nBIT::BIT(AtomSpace& as,\n         const Handle& target,\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 841,
        "type": "empty_function",
        "content": "BIT::~BIT() {}",
        "context": "\tbit_as.clear_copy_on_write();\n}\n\nBIT::~BIT() {}\n\nbool BIT::empty() const\n{\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.h",
        "line": 172,
        "type": "empty_function",
        "content": "bool has_cycle(const Handle& h, HandleSet ancestors = {}) const;",
        "context": "\t * present in the same branch path, so is [14389148767193402296][1].\n\t */\n\tbool has_cycle() const;\n\tbool has_cycle(const Handle& h, HandleSet ancestors = {}) const;\n\n\t/**\n\t * Comparison operators. For operator< compare fcs by complexity, or by\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
        "line": 266,
        "type": "empty_function",
        "content": "} catch (...) {}",
        "context": "\t// it.\n\ttry {\n\t\tfulfill_fcs(andbit->fcs);\n\t} catch (...) {}\n}\n\nvoid BackwardChainer::fulfill_fcs(const Handle& fcs)\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/FCStat.h",
        "line": 41,
        "type": "empty_function",
        "content": ": hsource(h), rule(r), product(p) {}",
        "context": "\tHandleSet product;\n\n\tInferenceRecord(Handle h, const Rule& r, const HandleSet& p)\n\t\t: hsource(h), rule(r), product(p) {}\n};\n\nclass FCStat\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/FCStat.h",
        "line": 47,
        "type": "empty_function",
        "content": "FCStat(AtomSpace* trace_as) : _trace_as(trace_as) {}",
        "context": "class FCStat\n{\npublic:\n\tFCStat(AtomSpace* trace_as) : _trace_as(trace_as) {}\n\n\t/**\n\t * Record the inference step into memory, as well as in the\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 667,
        "type": "empty_function",
        "content": "catch (...) {}",
        "context": "\t\tHandle h = HandleCast(rhcpy->execute(&ref_as));\n\t\tadd_results(ref_as, h->getOutgoingSet());\n\t}\n\tcatch (...) {}\n\n\treturn results;\n}\n"
      },
      {
        "file": "ure/scripts/ure/extract-bc-trace.py",
        "line": 21,
        "type": "empty_function",
        "content": "iteration_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, iter_re)",
        "context": "debug_re = r'\\[DEBUG\\]'\nure_re = r'\\[URE\\]'\niter_re = r'Iteration (\\d+)'\niteration_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, iter_re)\niteration_cre = re.compile(iteration_re)\nselect_andbit_re = r'Selected and-BIT for expansion:'\nfrom_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)\n"
      },
      {
        "file": "ure/scripts/ure/extract-bc-trace.py",
        "line": 24,
        "type": "empty_function",
        "content": "from_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)",
        "context": "iteration_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, iter_re)\niteration_cre = re.compile(iteration_re)\nselect_andbit_re = r'Selected and-BIT for expansion:'\nfrom_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)\nfrom_cre = re.compile(from_re)\nexpand_andbit_re = r'Expanded forward chainer strategy:'\nto_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, expand_andbit_re)\n"
      },
      {
        "file": "ure/scripts/ure/extract-bc-trace.py",
        "line": 27,
        "type": "empty_function",
        "content": "to_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, expand_andbit_re)",
        "context": "from_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)\nfrom_cre = re.compile(from_re)\nexpand_andbit_re = r'Expanded forward chainer strategy:'\nto_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, expand_andbit_re)\nto_cre = re.compile(to_re)\nselect_bn_re = r'Selected BIT-node for expansion:'\ninter_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_bn_re)\n"
      },
      {
        "file": "ure/scripts/ure/extract-bc-trace.py",
        "line": 30,
        "type": "empty_function",
        "content": "inter_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_bn_re)",
        "context": "to_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, expand_andbit_re)\nto_cre = re.compile(to_re)\nselect_bn_re = r'Selected BIT-node for expansion:'\ninter_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_bn_re)\ninter_cre = re.compile(inter_re)\nhandle_re = r'\\) ; (\\[\\d+\\]\\[\\d+\\])'\nhandle_cre = re.compile(handle_re)\n"
      },
      {
        "file": "ure/scripts/ure/extract-values-from-trace.py",
        "line": 23,
        "type": "empty_function",
        "content": "from_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)",
        "context": "debug_re = r'\\[DEBUG\\]'\nure_re = r'\\[URE\\]'\nselect_andbit_re = r'Selected and-BIT for expansion:'\nfrom_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_andbit_re)\nfrom_cre = re.compile(from_re)\nexpand_andbit_re = r'Expanded forward chainer strategy:'\nselect_bn_re = r'Selected BIT-node for expansion:'\n"
      },
      {
        "file": "ure/scripts/ure/extract-values-from-trace.py",
        "line": 27,
        "type": "empty_function",
        "content": "inter_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_bn_re)",
        "context": "from_cre = re.compile(from_re)\nexpand_andbit_re = r'Expanded forward chainer strategy:'\nselect_bn_re = r'Selected BIT-node for expansion:'\ninter_re = r'({} )?{} {} {}'.format(timestamp_re, debug_re, ure_re, select_bn_re)\ninter_cre = re.compile(inter_re)\nhandle_re = r'\\) ; \\[(\\d+)\\]\\[\\d+\\]'\nhandle_cre = re.compile(handle_re)\n"
      }
    ],
    "low": [
      {
        "file": "analyze_issue_examples.py",
        "line": 14,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",",
        "context": "    \n    issue_examples = [\n        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 16,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",",
        "context": "        \"./atomspace/examples/atomspace/queue.scm:; XXX FIXME, this example is not yet complete and does not yet work...\",\n        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 17,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",",
        "context": "        \"./atomspace/opencog/atomspace/Transient.cc:/// XXX FIXME. Performance has not been recently measured; there\",\n        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 18,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomTable.cc:    // atom in the parent. What??? XXX NOT TRUE FIXME\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 19,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",",
        "context": "        \"./atomspace/opencog/atomspace/AtomSpace.cc:\t// Fixme maybe later someday, if/when this is needed.\",\n        \"./atomspace/opencog/atomspace/AtomSpace.cc:// XXX FIXME -- The recursive design of the depth() routine below makes\",\n        \"./atomspace/opencog/atomspace/AtomSpace.h:    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\",\n        \"./atomspace/opencog/cython/PythonEval.cc:    // XXX FIXME this does a lot of wasteful string copying.\",\n        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 23,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",",
        "context": "        \"./atomspace/opencog/cython/PyIncludeWrapper.h:// 0.15.1 and maybe other versions)  FIXME someday...\",\n        \"./atomspace/opencog/haskell/AtomSpace_CWrapper.h:     * XXX FIXME no one should be using Handle's to work with atoms,\",\n        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 25,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",",
        "context": "        \"./atomspace/opencog/haskell/PatternMatcher_CWrapper.h: * XXX FIXME: atoms must never be accessed by UUID except by the\",\n        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 26,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",",
        "context": "        \"./atomspace/opencog/ocaml/CamlWrap.cc:\t// XXX FIXME\",\n        \"./atomspace/opencog/guile/SchemeSmobAS.cc: * until a better permission system is invented. XXX FIXME.\",\n        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 28,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",",
        "context": "        \"./atomspace/opencog/guile/modules/ExecSCM.cc:// XXX FIXME: can we fix cython to not do this, already?\",\n        \"./atomspace/opencog/guile/SchemeSmobAtom.cc:// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\",\n        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 30,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",",
        "context": "        \"./atomspace/opencog/guile/SchemeSmobValue.cc: * XXX FIXME Clearly, a factory for values is called for.\",\n        \"./atomspace/opencog/guile/SchemeEval.cc:\t// XXX FIXME This lock is not needed, because in guile-2.2,\",\n        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 32,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",",
        "context": "        \"./atomspace/opencog/sheaf/attic/linear-parser.scm:  XXX FIXME WARNING DANGER: As written, this runs in exponential time\",\n        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 33,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternUtils.cc:\t\t// XXX FIXME Are the below needed?\",\n        \"./atomspace/opencog/atoms/pattern/BindLink.cc:\t// Shoot. XXX FIXME. Most of the unit tests require that the atom\",\n        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 35,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",",
        "context": "        \"./atomspace/opencog/atoms/pattern/PatternLink.cc:\t\t// XXX FIXME, more correct would be to loop over\",\n        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 36,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",",
        "context": "        \"./atomspace/opencog/atoms/truthvalue/FormulaTruthValue.cc:// XXX FIXME This update is not thread-safe.\",\n        \"./atomspace/opencog/atoms/core/TypeChoice.cc:\t\t// For now, just avoid throwing an exception. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 38,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",",
        "context": "        \"./atomspace/opencog/atoms/core/RandomChoice.cc:// XXX FIXME - fix this so it can also choose a single value\",\n        \"./atomspace/opencog/atoms/core/Variables.cc:\t// XXX FIXME URE calls us with broken handle!!\",\n        \"./atomspace/opencog/atoms/core/TypeUtils.cc:\t\t\t\t\\\"Not implemented! TODO XXX FIXME\\\");\",\n        \"./atomspace/opencog/atoms/value/FormulaStream.cc:// XXX FIXME The update here is not thread-safe...\",\n        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 42,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",",
        "context": "        \"./atomspace/opencog/atoms/execution/Instantiator.cc:/// cleanly separated from each other. (XXX FIXME, these need to be\",\n        \"./atomspace/opencog/atoms/join/JoinLink.cc:/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\",\n        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 44,
        "type": "fixme_comment",
        "content": "\"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"",
        "context": "        \"./atomspace/opencog/atoms/flow/FilterLink.cc:\t\t\t\t\t\t\\\"Globbing for Values not implemented! FIXME!\\\");\",\n        \"./atomspace/opencog/query/InitiateSearchMixin.cc:\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\",\n        \"./atomspace/opencog/query/RewriteMixin.cc:\t// See issue #950 and pull req #962. XXX FIXME later.\",\n        \"./atomspace/opencog/query/PatternMatchEngine.cc:/// XXX FIXME: this is currently a weak stop-gap measure to handle\"\n    ]\n    \n    # Categorize these specific examples\n"
      },
      {
        "file": "analyze_issue_examples.py",
        "line": 106,
        "type": "fixme_comment",
        "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
        "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n"
      },
      {
        "file": "document_bug_fixes.py",
        "line": 15,
        "type": "return_none",
        "content": "return None",
        "context": "            return f.readlines()\n    except Exception as e:\n        print(f\"Error reading {filepath}: {e}\")\n        return None\n\ndef write_file_lines(filepath, lines):\n    \"\"\"Write lines to file\"\"\"\n"
      },
      {
        "file": "entelechy_introspection.py",
        "line": 600,
        "type": "todo_comment",
        "content": "r'TODO.*list',  # TODO lists in docs",
        "context": "        \n        # Patterns to exclude (informational, not actionable)\n        exclude_patterns = [\n            r'TODO.*list',  # TODO lists in docs\n            r'GNU',         # GNU license references\n            r'Copyright',   # Copyright notices\n            r'from\\s+TODO', # References to TODO files/modules\n"
      },
      {
        "file": "entelechy_marker_analyzer.py",
        "line": 31,
        "type": "todo_comment",
        "content": "marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.",
        "context": "    \"\"\"Represents a single code marker (TODO, FIXME, etc.).\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB, PLACEHOLDER, etc.\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n"
      },
      {
        "file": "entelechy_marker_resolver.py",
        "line": 156,
        "type": "return_none",
        "content": "return None",
        "context": "    def _find_marker_data(self, file_path: str, line_number: int) -> Optional[Dict]:\n        \"\"\"Find marker data from analysis.\"\"\"\n        if not self.analysis_data:\n            return None\n        \n        for marker in self.analysis_data.get('markers', []):\n            if marker['file_path'] == file_path and marker['line_number'] == line_number:\n"
      },
      {
        "file": "entelechy_marker_resolver.py",
        "line": 161,
        "type": "return_none",
        "content": "return None",
        "context": "        for marker in self.analysis_data.get('markers', []):\n            if marker['file_path'] == file_path and marker['line_number'] == line_number:\n                return marker\n        return None\n    \n    def get_component_summary(self) -> Dict[str, Dict]:\n        \"\"\"Get summary of markers by component.\"\"\"\n"
      },
      {
        "file": "fixme_resolution_tracker.py",
        "line": 169,
        "type": "fixme_comment",
        "content": "report.append(\"# FIXME Resolution Progress Report\")",
        "context": "    def generate_next_steps_report(self) -> str:\n        \"\"\"Generate a report implementing the next steps from the catalog.\"\"\"\n        report = []\n        report.append(\"# FIXME Resolution Progress Report\")\n        report.append(f\"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        report.append(\"\")\n        \n"
      },
      {
        "file": "fragmentation_detector.py",
        "line": 22,
        "type": "todo_comment",
        "content": "marker_type: str  # TODO, FIXME, STUB",
        "context": "    \"\"\"Represents a specific code fragmentation\"\"\"\n    file_path: str\n    line_number: int\n    marker_type: str  # TODO, FIXME, STUB\n    content: str\n    context_before: List[str]\n    context_after: List[str]\n"
      },
      {
        "file": "implement_functional_fixes.py",
        "line": 42,
        "type": "todo_comment",
        "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
        "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n"
      },
      {
        "file": "implement_proper_functions.py",
        "line": 155,
        "type": "return_none",
        "content": "return None",
        "context": "            \n            return impl\n        \n        return None\n    \n    def generate_report(self):\n        \"\"\"Generate implementation report\"\"\"\n"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 83,
        "type": "todo_comment",
        "content": "echo \"   // TODO: Implement error handling for edge case X\"",
        "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 84,
        "type": "todo_comment",
        "content": "echo \"   // TODO(v2.0): Refactor to use new API\"",
        "context": "                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n            fi\n"
      },
      {
        "file": "setup_fixme_environment.py",
        "line": 250,
        "type": "fixme_comment",
        "content": "# FIXME Resolution Makefile Targets",
        "context": "        \n        makefile = self.repo_root / \"Makefile.fixme\"\n        makefile_content = dedent('''\n            # FIXME Resolution Makefile Targets\n            # Include this in your main Makefile with: include Makefile.fixme\n            \n            .PHONY: fixme-status fixme-easy-wins fixme-report fixme-setup\n"
      },
      {
        "file": "atomspace-restful/opencog/python/web/api/mappers.py",
        "line": 151,
        "type": "return_none",
        "content": "return None",
        "context": "    def get_atom(self, uid):\n        if (uid in self.atom_from_uid):\n            return self.atom_from_uid[uid]\n        return None\n\n    def remove(self, atom, uid):\n        del self.atom_from_uid[uid]\n"
      },
      {
        "file": "atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "fixme_comment",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 1004,
        "type": "fixme_comment",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1371,
        "type": "fixme_comment",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
        "line": 31,
        "type": "fixme_comment",
        "content": "// XXX FIXME: except for the error messages, most of this code is",
        "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/csv/table_read.h",
        "line": 38,
        "type": "todo_comment",
        "content": "// TODO: Should this be a StringValue?",
        "context": "\nnamespace opencog {\n\n// TODO: Should this be a StringValue?\ntypedef std::vector<std::string> string_seq;\n\n/**\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/ProxyNode.cc",
        "line": 141,
        "type": "fixme_comment",
        "content": "// XXX FIXME. Using this ProxyParametersLink thing is a kind of",
        "context": "// Get our configuration from the DefineLink we live in.\n// Hmm, perhaps this should be a StateLink?\n//\n// XXX FIXME. Using this ProxyParametersLink thing is a kind of\n// cheesy hack, to pass parameters to the ProxyNode. It vaguely\n// resembles the structure of an ExecutionLink, but instead of\n// writing (Execution (Predicate \"foo\") (List (args...)))\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/proxy/WriteBufferProxy.cc",
        "line": 195,
        "type": "fixme_comment",
        "content": "// XXX FIXME. Buffering these naively, like this, voilates the",
        "context": "void WriteBufferProxy::updateValue(const Handle& atom, const Handle& key,\n                                   const ValuePtr& delta)\n{\n\t// XXX FIXME. Buffering these naively, like this, voilates the\n\t// intent of how this method should work. However, for the\n\t// RocksStorageNode, doing this is harmless. And the\n\t// CogStorageNode is just a pass-through. So there are no\n"
      },
      {
        "file": "atomspace-storage/opencog/persist/sexcom/Commands.cc",
        "line": 165,
        "type": "fixme_comment",
        "content": "// FIXME read above comment.",
        "context": "// (cog-execute-cache! (GetLink ...) (Predicate \"key\") ...)\n// This is complicated, and subject to change...\n// XXX this should be nuked, and replaced by appropriate kind of proxy.\n// FIXME read above comment.\nstd::string Commands::cog_execute_cache(const std::string& cmd)\n{\n\tsize_t pos = 0;\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 42,
        "type": "fixme_comment",
        "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
        "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 79,
        "type": "fixme_comment",
        "content": "// XXX FIXME, this is to be removed, because UnionLink,",
        "context": "\t\t// well, in that case these are interpreted as intersection,\n\t\t// union and complement. Since it cannot inherit from\n\t\t// EVALUATABLE_LINK (cause it's a Node) we have to add it here.\n\t\t// XXX FIXME, this is to be removed, because UnionLink,\n\t\t// IntersectionLink takes the place of OrLink, AndLink.\n\t\tif (h->is_type(CONCEPT_NODE)) continue;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/Checkers.cc",
        "line": 93,
        "type": "fixme_comment",
        "content": "// XXX FIXME ... Perhaps IntersectionLink, UnionLink will",
        "context": "\t\t// want to forbid it in the future by maybe introducing a\n\t\t// specialized operator to explicitly map the higher order into\n\t\t// the lower order but as of today it is required.\n\t\t// XXX FIXME ... Perhaps IntersectionLink, UnionLink will\n\t\t// resolve this?\n\t\tif (h->is_type(SIMILARITY_LINK) or\n\t\t    h->is_type(MEMBER_LINK))\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 110,
        "type": "fixme_comment",
        "content": "// XXX FIXME - fix this so it can also choose a single value",
        "context": "///           AtomZ\n///\n\n// XXX FIXME - fix this so it can also choose a single value\n// out of a vector of values.\nValuePtr RandomChoiceLink::execute(AtomSpace* as, bool silent)\n{\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RandomChoice.cc",
        "line": 179,
        "type": "fixme_comment",
        "content": "// XXX FIXME, also allow a FloatValue!!",
        "context": "\t\tstd::vector<double> weights;\n\t\tfor (Handle h : ofirst->getOutgoingSet())\n\t\t{\n\t\t\t// XXX FIXME, also allow a FloatValue!!\n\t\t\tif (h->is_executable())\n\t\t\t\th = HandleCast(h->execute(as, silent));\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 296,
        "type": "todo_comment",
        "content": "// TODO: the following has no unit test!!! Yet it introduces a",
        "context": "\t// Base case\n\tif (h->is_node())\n\t{\n\t\t// TODO: the following has no unit test!!! Yet it introduces a\n\t\t// bug covered by RewriteLinkUTest::test_consume_quotations_4(),\n\t\t// thus this code is disabled till a unit test it created for it\n\t\t// and we understand what it fixes and how it fixes.\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.cc",
        "line": 340,
        "type": "todo_comment",
        "content": "// TODO: generalize with when Unquote and Quote are apart",
        "context": "\t\t\t// A succession of (Unquote (Quote ..)) is an involution\n\t\t\t// and thus can be remove.\n\t\t\t//\n\t\t\t// TODO: generalize with when Unquote and Quote are apart\n\t\t\tif (child->get_type() == QUOTE_LINK)\n\t\t\t{\n\t\t\t\tquotation.update(child->get_type());\n"
      },
      {
        "file": "atomspace/opencog/atoms/core/RewriteLink.h",
        "line": 224,
        "type": "todo_comment",
        "content": "// TODO: we probably want to",
        "context": "\t */\n\tHandle consume_quotations() const;\n\tstatic Handle consume_quotations(const Variables& variables, const Handle& h,\n\t                                 // TODO: we probably want to\n\t                                 // move quotation,\n\t                                 // needless_quotation,\n\t                                 // clause_root and more in\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 288,
        "type": "todo_comment",
        "content": "// TODO: what about globs?",
        "context": "\t\t\treturn expr;\n\n\t\t// If it is a quoted or shadowed variable don't substitute.\n\t\t// TODO: what about globs?\n\t\tif (VARIABLE_NODE == t and not context_cp.is_free_variable(expr))\n\t\t\treturn expr;\n\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 598,
        "type": "fixme_comment",
        "content": "// XXX FIXME Can we defer the addition to the atomspace to an even",
        "context": "\t// We do this here, instead of in walk_tree(), because adding\n\t// atoms to the atomspace is an expensive process.  We can save\n\t// some time by doing it just once, right here, in one big batch.\n\t// XXX FIXME Can we defer the addition to the atomspace to an even\n\t// later time??\n\tif (_as) return _as->add_atom(grounded);\n\treturn grounded;\n"
      },
      {
        "file": "atomspace/opencog/atoms/execution/Instantiator.cc",
        "line": 642,
        "type": "fixme_comment",
        "content": "// XXX FIXME, we need to get rid of this call entirely, and just",
        "context": "\tif (expr->is_type(NODE) and expr->is_executable())\n\t\treturn expr->execute(_as, silent);\n\n\t// XXX FIXME, we need to get rid of this call entirely, and just\n\t// return expr->execute(_as, silent) instead, like above.\n\t// However, assorted parts are still broken and don't work.\n\tValuePtr vp(instantiate(expr, GroundingMap(), silent));\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 69,
        "type": "todo_comment",
        "content": "// TODO: Handle executable _outgoing[0] by executing it first.",
        "context": "\n\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/CollectionOfLink.cc",
        "line": 70,
        "type": "todo_comment",
        "content": "// TODO: Support complex type signatures beyond simple TYPE_NODE.",
        "context": "\t_have_typespec = true;\n\n\t// TODO: Handle executable _outgoing[0] by executing it first.\n\t// TODO: Support complex type signatures beyond simple TYPE_NODE.\n\t// Current implementation assumes simple type specification.\n\tif (not _outgoing[0]->is_type(TYPE_NODE))\n\t\tthrow InvalidParamException(TRACE_INFO,\n"
      },
      {
        "file": "atomspace/opencog/atoms/flow/FormulaPredicateLink.cc",
        "line": 41,
        "type": "fixme_comment",
        "content": "/// XXX FIXME - in the future, some user is going to want to include",
        "context": "/// not typed, and there are *two* bodies, each body returning one\n/// component of the final truth value...\n///\n/// XXX FIXME - in the future, some user is going to want to include\n/// variable declarations, and/or an explicit Lambda in the body, for\n/// some reason that I cannot imagine.  The code below will then fail.\n/// For now, ignore this possibility.\n"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 549,
        "type": "todo_comment",
        "content": "/// TODO: it might be faster to use hash tables instead of rb-trees",
        "context": "/// think of any way of combining steps (2) and (3) that would avoid\n/// step (4) ... or even would reduce the work for stpe (4). Oh well.\n///\n/// TODO: it might be faster to use hash tables instead of rb-trees\n/// i.e. to use UnorderedHandleSet instead of HandleSet. XXX FIXME.\nHandleSet JoinLink::supremum(AtomSpace* as, bool silent,\n                             Traverse& trav) const\n"
      },
      {
        "file": "atomspace/opencog/atoms/join/JoinLink.cc",
        "line": 721,
        "type": "fixme_comment",
        "content": "// XXX FIXME this is really dumb, using a queue and then",
        "context": "\n\tHandleSet hs = container(as, jcb, silent);\n\n\t// XXX FIXME this is really dumb, using a queue and then\n\t// copying things into it. Whatever. Fix this.\n\tQueueValuePtr qvp(createQueueValue());\n\tfor (const Handle& h : hs)\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 146,
        "type": "fixme_comment",
        "content": "// XXX FIXME, more correct would be to loop over",
        "context": "\t{\n\t\t// The variables for that component are just the variables\n\t\t// that can be found in that component.\n\t\t// XXX FIXME, more correct would be to loop over\n\t\t// _pat.clause_variables and add those. Probably makes\n\t\t// no difference in most cases.\n\t\tFindAtoms fv(_variables.varset);\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 165,
        "type": "fixme_comment",
        "content": "// XXX FIXME, this handles `absents`, `always` and `grouping`",
        "context": "\t\tunbundle_clauses(h);\n\n\t\t// Each component consists of the assorted parts.\n\t\t// XXX FIXME, this handles `absents`, `always` and `grouping`\n\t\t// incorrectly.\n\t\tHandleSeq clseq;\n\t\tfor (const PatternTermPtr& ptm: _pat.pmandatory)\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1039,
        "type": "fixme_comment",
        "content": "/// XXX FIXME: the code here assumes that the situation is indeed",
        "context": "/// If the ImplicationLink is suitably simple, it can be added\n/// as an ordinary clause, and searched for as if it was \"present\".\n///\n/// XXX FIXME: the code here assumes that the situation is indeed\n/// simple: more complex cases are not handled correctly.  Doing this\n/// correctly would require iterating again, and examining the\n/// contents of the left and right side of the IdenticalLink... ugh.\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1255,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- this is wrong. What we really want is to",
        "context": "\t\t\t_pat.have_evaluatables = true;\n\t\t\tptm->addEvaluatable();\n\n\t\t\t// XXX FIXME -- this is wrong. What we really want is to\n\t\t\t// identify those clauses that bridge across multiple\n\t\t\t// components... not everything here does so. The\n\t\t\t// get_bridged_components() should be modified to\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
        "line": 1465,
        "type": "fixme_comment",
        "content": "// XXX FIXME: debug_log() above is more readable than the below.",
        "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternTerm.h",
        "line": 80,
        "type": "todo_comment",
        "content": "// TODO: it would probably be more efficient to swap which of these",
        "context": "\tHandle _handle;\n\tHandle _quote;\n\n\t// TODO: it would probably be more efficient to swap which of these\n\t// two is weak, since I think _outgoing is requested far more often\n\t// than _parent, and having it run faster would be a performance win.\n\tPatternTermPtr _parent;\n"
      },
      {
        "file": "atomspace/opencog/atoms/pattern/PatternUtils.cc",
        "line": 55,
        "type": "fixme_comment",
        "content": "// XXX FIXME Are the below needed?",
        "context": "\t\t      or nameserver().isA(clause->getOutgoingAtom(0)->get_type(),\n\t\t                          EVALUATABLE_LINK)))\n\n\t\t// XXX FIXME Are the below needed?\n\t\tor contains_atomtype(clause, DEFINED_PREDICATE_NODE)\n\t\tor contains_atomtype(clause, DEFINED_SCHEMA_NODE)\n\t\tor is_black_box(clause);\n"
      },
      {
        "file": "atomspace/opencog/atoms/reduct/DecimateLink.cc",
        "line": 65,
        "type": "fixme_comment",
        "content": "// XXX FIXME ... both the NumberNode and the FloatValue variations",
        "context": "\t\treturn do_execute(vmask, vi);\n\t}\n\n\t// XXX FIXME ... both the NumberNode and the FloatValue variations\n\t// below make a copy of the mask.  Instead of making a copy, create\n\t// something more efficient/faster. It is, after all, a simple\n\t// test...\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 138,
        "type": "todo_comment",
        "content": "// TODO: this should probably be moved to a method on class Atom.",
        "context": "        }\n\n        // Check the values...\n        // TODO: this should probably be moved to a method on class Atom.\n        if (check_values)\n        {\n            HandleSet keys_first = atom_first->getKeys();\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 272,
        "type": "fixme_comment",
        "content": "// Fixme maybe later someday, if/when this is needed.",
        "context": "\t// having one AtomSpace be placed as a member into many others,\n\t// except that we don't have any viable mechanisms for such multiple\n\t// membership, and so I don't know how to treat this right now.\n\t// Fixme maybe later someday, if/when this is needed.\n\tif (not (nullptr == _atom_space or as == nullptr))\n\t\tthrow RuntimeException(TRACE_INFO,\n\t\t\t\"At this time, an AtomSpace can only be placed in one other\\n\"\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.cc",
        "line": 283,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- The recursive design of the depth() routine below makes",
        "context": "}\n\n// ====================================================================\n// XXX FIXME -- The recursive design of the depth() routine below makes\n// it into a bottleneck, when the stack of AtomSpaces exceeds a few\n// hundred. In particular, the recursion is on the C stack, and I don't\n// believe the compiler has optimized them to be tail-recursive. (If\n"
      },
      {
        "file": "atomspace/opencog/atomspace/AtomSpace.h",
        "line": 524,
        "type": "fixme_comment",
        "content": "// XXX FIXME Users should call StorageNode::add_nocheck() instead.",
        "context": "\n    /* ----------------------------------------------------------- */\n    // Not for public use! Only StorageNodes get to call this!\n    // XXX FIXME Users should call StorageNode::add_nocheck() instead.\n    Handle storage_add_nocheck(const Handle& h) { return add(h); }\n};\n\n"
      },
      {
        "file": "atomspace/opencog/atomspace/Transient.cc",
        "line": 43,
        "type": "fixme_comment",
        "content": "/// XXX FIXME. Performance has not been recently measured; there",
        "context": "/// cheaper to just have a cache of empty atomspaces, hanging around,\n/// and ready to go. The code in this section implements this.\n///\n/// XXX FIXME. Performance has not been recently measured; there\n/// have been a lot of redesigns since when this utility was created.\n/// It is not at all clear that the code here takes less CPU/RAM than\n/// simply creating new AtomSpaces on the fly. For now, we keep this\n"
      },
      {
        "file": "atomspace/opencog/cython/PythonEval.cc",
        "line": 1427,
        "type": "fixme_comment",
        "content": "// XXX FIXME this does a lot of wasteful string copying.",
        "context": "\nvoid PythonEval::eval_expr(const std::string& partial_expr)\n{\n    // XXX FIXME this does a lot of wasteful string copying.\n    std::string expr = partial_expr;\n    size_t nl = expr.find_first_of(\"\\n\\r\");\n    while (std::string::npos != nl)\n"
      },
      {
        "file": "atomspace/opencog/guile/SchemeSmobAtom.cc",
        "line": 84,
        "type": "fixme_comment",
        "content": "// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.",
        "context": "\n/* ============================================================== */\n\n// XXX FIXME. Work around the despicable, horrible guile UTF8 handling.\n// I am flabbergasted. The guile people are smart, but they could not have\n// possibly picked a crappier string handling design. Fuck me. See\n// https://stackoverflow.com/questions/79329532/c-c-encode-binary-into-utf8\n"
      },
      {
        "file": "atomspace/opencog/guile/modules/ExecSCM.cc",
        "line": 73,
        "type": "fixme_comment",
        "content": "// XXX FIXME: can we fix cython to not do this, already?",
        "context": "// NOTE HACK ALERT This needs to be static, in order for python to\n// work correctly.  The problem is that python keeps creating and\n// destroying this class, but it expects things to stick around.\n// XXX FIXME: can we fix cython to not do this, already?\n// Oh well. I guess that's OK, since the definition is meant to be\n// for the lifetime of the process, anyway.\nstd::vector<FunctionWrap*>* ExecSCM::_binders = nullptr;\n"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 126,
        "type": "fixme_comment",
        "content": "// XXX FIXME; we should be using ptm->isVariable() instead !?",
        "context": "\tType t = h->get_type();\n\tif (_nameserver.isNode(t))\n\t{\n\t\t// XXX FIXME; we should be using ptm->isVariable() instead !?\n\t\tif (VARIABLE_NODE != t and GLOB_NODE != t and SIGN_NODE != t)\n\t\t{\n\t\t\twidth = h->getIncomingSetSize();\n"
      },
      {
        "file": "atomspace/opencog/query/InitiateSearchMixin.cc",
        "line": 382,
        "type": "todo_comment",
        "content": "// TODO -- weed out duplicates!",
        "context": "\t}\n\telse\n\t{\n\t\t// TODO -- weed out duplicates!\n\t}\n\treturn true;\n}\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 284,
        "type": "fixme_comment",
        "content": "/// XXX FIXME: this is currently a weak stop-gap measure to handle",
        "context": "/// Compare the contents of a Present term in the pattern to the\n/// proposed grounding. The term `ptm` points at the Present term.\n///\n/// XXX FIXME: this is currently a weak stop-gap measure to handle\n/// the special case of Present terms embedded in Choice terms.\n/// Present terms that are NOT in a Choice are handled by the\n/// do_next_clause() system, which assumes that Present terms happen\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1532,
        "type": "fixme_comment",
        "content": "// XXX FIXME - this is not very elegant. We should probably",
        "context": "\t// If this is some other rando variable that is not part of\n\t// search pattern, i.e. if is is a scoped variable, then\n\t// accept a match to any other alpha-equivalent variable.\n\t// XXX FIXME - this is not very elegant. We should probably\n\t// have a distinct `scoped_link_compare()` function to handle\n\t// this. Right now, the scope_match() callback uses a rather\n\t// screwy and indirect trick to check alpha conversion.\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 1982,
        "type": "fixme_comment",
        "content": "// XXX FIXME: Issue #3016 - Unification with unordered AndLinks",
        "context": "/// form; see `explore_sparse_branches()`.\n///\n//\n// XXX FIXME: Issue #3016 - Unification with unordered AndLinks\n// The current implementation of unordered link permutation exploration\n// in IdenticalLinks stops after finding the first valid permutation \n// instead of continuing to find all possible permutations. This is \n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2049,
        "type": "fixme_comment",
        "content": "/// XXX FIXME: Right now, this code handles graphs that have only one",
        "context": "/// functional group, and the glob will end up holding the moiety that\n/// is not a part of the functional group.\n///\n/// XXX FIXME: Right now, this code handles graphs that have only one\n/// single sparse search.   Nested sparse searches are not supported;\n/// to implement those, its \"easy\": implement the same flow control as\n/// the unordered_explore steppers. I'm lzay, today, so I am not doing\n"
      },
      {
        "file": "atomspace/opencog/query/PatternMatchEngine.cc",
        "line": 2223,
        "type": "fixme_comment",
        "content": "/// XXX FIXME -- do the above.",
        "context": "/// -- build a connectivity map, just like the one for clauses\n/// -- build a clause_variables struct, but just for this term\n/// -- search for the thinnest joint, just like `get_next_clause`\n/// XXX FIXME -- do the above.\n///\nbool PatternMatchEngine::next_untried_present(const PatternTermPtr& parent,\n                                              const PatternTermPtr& clause,\n"
      },
      {
        "file": "atomspace/opencog/query/Recognizer.cc",
        "line": 126,
        "type": "todo_comment",
        "content": "// TODO: Change to something better if possible...",
        "context": "\t// mis-matched types are a dead-end.\n\tif (lpat->get_type() != lsoln->get_type()) return false;\n\n\t// TODO: Change to something better if possible...\n\t// What is happening here is to manually call the\n\t// fuzzy_match callback immediately if and only if\n\t// lsoln has one or more GlobNodes AND lpat and lsoln\n"
      },
      {
        "file": "atomspace/opencog/query/RewriteMixin.cc",
        "line": 164,
        "type": "fixme_comment",
        "content": "/// XXX FIXME now I see how it can be done. The groupings should",
        "context": "/// to dribble in. Perhaps the engine search could be modified in some\n/// clever way to find groupings in a single batch; but for now, I don't\n/// see how this could be done.\n/// XXX FIXME now I see how it can be done. The groupings should\n/// be converted to marginals, and handled the same way. So this\n/// needs a rewrite. Good thing that almost no one uses this ...\nbool RewriteMixin::propose_grouping(const GroundingMap &var_soln,\n"
      },
      {
        "file": "atomspace/opencog/query/SatisfyMixin.cc",
        "line": 583,
        "type": "fixme_comment",
        "content": "// XXX FIXME terrible hack.",
        "context": "\t\t// pure absent is found.\n\t\tif (is_pure_absent)\n\t\t{\n\t\t\t// XXX FIXME terrible hack.\n\t\t\tTermMatchMixin* intu =\n\t\t\t\tdynamic_cast<TermMatchMixin*>(this);\n\t\t\tif (intu->optionals_present()) return false;\n"
      },
      {
        "file": "atomspace/opencog/query/TermMatchMixin.cc",
        "line": 710,
        "type": "fixme_comment",
        "content": "// XXX FIXME: worse: this cannot possibly be right when",
        "context": "\t\t// possibilities?  And if they failed to do so, can we even do\n\t\t// anything about that here? Seems like we can't do anything...\n\t\t//\n\t\t// XXX FIXME: worse: this cannot possibly be right when\n\t\t// the ChoiceLink contains presentLinks.\n\t\tfor (const Handle& h : oset)\n\t\t{\n"
      },
      {
        "file": "atomspace/tests/cython/atomspace/test_atomspace.py",
        "line": 362,
        "type": "fixme_comment",
        "content": "# XXX FIXME is testing the name of the bottom type",
        "context": "    def test_get_type_name(self):\n        self.assertEqual(get_type_name(types.Node), \"Node\")\n        self.assertEqual(get_type_name(2231), \"\")\n        # XXX FIXME is testing the name of the bottom type\n        # a sane thing to do?\n        self.assertEqual(get_type_name(types.NO_TYPE), \"*** Bottom Type! ***\")\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 324,
        "type": "return_none",
        "content": "return None",
        "context": "        \"\"\"\n        # Check structural constraints\n        if not self._check_structural_constraints(template, binding, shard_atoms, shard_links):\n            return None\n        \n        # Check truth value constraints\n        if not self._check_truth_constraints(template, binding, shard_atoms, shard_links):\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 328,
        "type": "return_none",
        "content": "return None",
        "context": "        \n        # Check truth value constraints\n        if not self._check_truth_constraints(template, binding, shard_atoms, shard_links):\n            return None\n        \n        # Check custom constraints\n        if not self._check_custom_constraints(template, binding, shard_atoms, shard_links):\n"
      },
      {
        "file": "cognitive-das/pattern_matcher.py",
        "line": 332,
        "type": "return_none",
        "content": "return None",
        "context": "        \n        # Check custom constraints\n        if not self._check_custom_constraints(template, binding, shard_atoms, shard_links):\n            return None\n        \n        # Calculate match confidence\n        confidence = self._calculate_match_confidence(template, binding, shard_atoms, shard_links)\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 280,
        "type": "return_none",
        "content": "return None",
        "context": "    def _parse_single_field(self, field_string: str) -> Optional[QueryField]:\n        \"\"\"Parse a single field string\"\"\"\n        if not field_string:\n            return None\n        \n        # Parse field name and alias\n        field_match = re.match(r'^(?:(\\w+):\\s*)?(\\w+)', field_string)\n"
      },
      {
        "file": "cognitive-gnn/query_parser.py",
        "line": 285,
        "type": "return_none",
        "content": "return None",
        "context": "        # Parse field name and alias\n        field_match = re.match(r'^(?:(\\w+):\\s*)?(\\w+)', field_string)\n        if not field_match:\n            return None\n        \n        alias = field_match.group(1)\n        field_name = field_match.group(2)\n"
      },
      {
        "file": "cognitive-gnn/test_phase_alpha.py",
        "line": 422,
        "type": "return_none",
        "content": "return None",
        "context": "            elif isinstance(obj, list):\n                return [make_serializable(item) for item in obj]\n            elif obj is None:\n                return None\n            else:\n                return str(obj)  # Convert unknown types to string\n        \n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 139,
        "type": "return_none",
        "content": "return None",
        "context": "        # Get membrane configuration\n        membrane_data = self._get_membrane_data(membrane_id)\n        if not membrane_data:\n            return None\n        \n        tensor_shape = membrane_data.get('tensor_shape', [3, 3, 3])\n        tensor_field = np.zeros(tensor_shape, dtype=np.float32)\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 384,
        "type": "return_none",
        "content": "return None",
        "context": "        if membrane_id == self.membrane_config.get('enterprise_id'):\n            return self.membrane_config\n        \n        return None\n    \n    def _generate_membrane_markdown(self, membrane_id: str) -> str:\n        \"\"\"Generate markdown representation of membrane\"\"\"\n"
      },
      {
        "file": "cognitive-membrane-sync/membrane_bridge.py",
        "line": 472,
        "type": "return_none",
        "content": "return None",
        "context": "            return f\"scheme_result_{function_name}\"\n        except Exception as e:\n            logger.error(f\"\u274c Failed to call Scheme function {function_name}: {e}\")\n            return None\n\n\ndef main():\n"
      },
      {
        "file": "cogserver/opencog/cogserver/server/CogServer.cc",
        "line": 125,
        "type": "fixme_comment",
        "content": "// XXX FIXME. terrible terrible hack. What we should be",
        "context": "        while (0 < getRequestQueueSize())\n            runLoopStep();\n\n        // XXX FIXME. terrible terrible hack. What we should be\n        // doing is running in our own thread, waiting on a semaphore,\n        // until some request is queued. Spinning is .. just wrong.\n        usleep(20000);\n"
      },
      {
        "file": "components/core/atomspace-restful/opencog/python/web/api/mappers.py",
        "line": 151,
        "type": "return_none",
        "content": "return None",
        "context": "    def get_atom(self, uid):\n        if (uid in self.atom_from_uid):\n            return self.atom_from_uid[uid]\n        return None\n\n    def remove(self, atom, uid):\n        del self.atom_from_uid[uid]\n"
      },
      {
        "file": "components/core/atomspace-restful/opencog/python/web/api/utilities.py",
        "line": 17,
        "type": "fixme_comment",
        "content": "# FIXME: Should this moved to the atomspace repo and be part",
        "context": "# https://github.com/opencog/opencog/pull/2012 and,\n# https://github.com/opencog/atomspace/pull/611\n# NOTE: This is similar to scheme `cog-node`.\n# FIXME: Should this moved to the atomspace repo and be part\n# of opencog.atomspace module?\ndef get_atoms_by_name(z_type, name, atomspace):\n    return filter(lambda x: x.name == name, atomspace.get_atoms_by_type(z_type))\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoIO.cc",
        "line": 944,
        "type": "fixme_comment",
        "content": "// XXX FIXME. We would like to call",
        "context": "\nvoid MonoStorage::storeAtomSpace(const AtomSpace* table)\n{\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksIO.cc",
        "line": 1283,
        "type": "fixme_comment",
        "content": "// XXX FIXME. We would like to call",
        "context": "\t                        and nullptr != getAtomSpace())\n\t\tconvertForFrames(HandleCast(getAtomSpace()));\n\n\t// XXX FIXME. We would like to call\n\t// Options::PrepareForBulkLoad() here, but its too late, this\n\t// can only be set when opening the DB. Should we maybe close\n\t// and reopen the DB? This would be ... conducive of weird bugs.\n"
      },
      {
        "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksPersistSCM.cc",
        "line": 82,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- are open and close actually needed for anything?",
        "context": "    _storage = nullptr;\n}\n\n// XXX FIXME -- are open and close actually needed for anything?\nvoid RocksPersistSCM::do_open(const std::string& uri)\n{\n    if (_storage)\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/Fuzzy.cc",
        "line": 81,
        "type": "todo_comment",
        "content": "// TODO: Extend to find similar links as well",
        "context": "    {\n        if (h->is_node())\n        {\n            // TODO: Extend to find similar links as well\n            if (lp->get_type() == SIMILARITY_LINK)\n                sl.emplace_back(lp->get_handle());\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/nlp/fuzzy/FuzzyMatchBasic.cc",
        "line": 106,
        "type": "todo_comment",
        "content": "// TODO: May use Truth Value instead",
        "context": "\tdouble similarity = common_nodes.size();\n\n\t// Roughly estimate how \"rare\" each node is by using 1 / incoming set size\n\t// TODO: May use Truth Value instead\n\t// for (const Handle& common_node : common_nodes)\n\t// \tsimilarity += 1.0 / common_node->getIncomingSetSize();\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 41,
        "type": "todo_comment",
        "content": "// TODO:",
        "context": "TruthValuePtr OpenPsiImplicator::check_satisfiability(const Handle& rule,\n    OpenPsiRules& opr)\n{\n  // TODO:\n  // Solve for multithreaded access. Create a rule class and lock\n  // the rule when updating the cache.\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.cc",
        "line": 49,
        "type": "todo_comment",
        "content": "// TODO: Add cache per atomspace.",
        "context": "  Handle query_body = query->get_pattern().body;\n\n  // Always update cache to clear any previous result.\n  // TODO: Add cache per atomspace.\n  _satisfiability_cache.erase(query_body);\n  _pattern_seen.insert(query_body);\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiImplicator.h",
        "line": 44,
        "type": "todo_comment",
        "content": "// TODO Why would one need to reset during psi-loop?",
        "context": "  friend class OpenPsiSatisfier;\n\n  // Needed for resetting private cache.\n  // TODO Why would one need to reset during psi-loop?\n  friend class ::OpenPsiImplicatorUTest;\n\npublic:\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 68,
        "type": "todo_comment",
        "content": "// TODO: Test thoroughly, or develop an alternative. See discussion",
        "context": "      _psi_rules[rule] = std::make_tuple(context, action, goal, query);\n  } else {\n    // This is for backward compatability.\n    // TODO: Test thoroughly, or develop an alternative. See discussion\n    // @ https://github.com/opencog/opencog/pull/2899 for what the\n    // alternative might be.\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
        "line": 101,
        "type": "todo_comment",
        "content": "// TODO But why make the add_category public then?",
        "context": "{\n  _as->add_link(MEMBER_LINK, rule, category);\n  // Add the category just in case it hasn't been declared.\n  // TODO But why make the add_category public then?\n  add_category(category);\n  _category_index[category].insert(rule);\n\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 105,
        "type": "todo_comment",
        "content": "// TODO:add predicate to check for membership of category.",
        "context": "   * @param new_category The node reprsenting the new category.\n   * @return ConceptNode that represents the category.\n   */\n   // TODO:add predicate to check for membership of category.\n  Handle add_category(const Handle& new_category);\n\n  /**\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 126,
        "type": "todo_comment",
        "content": "// TODO Should these entries be a member of Rules class?",
        "context": "   * where queryis a PatternLink that isn't added to the atomspace, and\n   * is used to check if the rule is satisfiable.\n   */\n  // TODO Should these entries be a member of Rules class?\n  typedef std::tuple<HandleSeq, Handle, Handle, PatternLinkPtr> PsiTuple;\n\n  /**\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.h",
        "line": 136,
        "type": "todo_comment",
        "content": "// TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,",
        "context": "   */\n  std::map<Handle, PsiTuple> _psi_rules;\n\n  // TODO: Using names that are prefixed with \"OpenPsi: \" might be a bad idea,\n  // because it might hinder interoperability with other components that\n  // expect an explicit ontological representation. For historic reasons we\n  // continue using such convention but should be replaced with graph that\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 91,
        "type": "todo_comment",
        "content": "// TODO: Should this be a singleton? What could be the issues that need",
        "context": "  const Handle& goal, const TruthValuePtr stv, const Handle& category)\n{\n  AtomSpacePtr asp = SchemeSmob::ss_get_env_as(\"psi-rule\");\n  // TODO: Should this be a singleton? What could be the issues that need\n  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSCM.cc",
        "line": 95,
        "type": "todo_comment",
        "content": "// TODO: Add to multiple categories using scheme rest list.",
        "context": "  // to be handled? How to handle multiple atomspace, maybe a singleton per\n  // atomspace?\n  Handle rule = openpsi_cache(asp.get()).add_rule(context, action, goal, stv);\n  // TODO: Add to multiple categories using scheme rest list.\n  openpsi_cache(asp.get()).add_to_category(rule, category);\n  return rule;\n}\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 42,
        "type": "todo_comment",
        "content": "// TODO: Saperated component patterns aren't handled by this function",
        "context": "bool OpenPsiSatisfier::grounding(const HandleMap &var_soln,\n                                  const HandleMap &term_soln)\n{\n  // TODO: Saperated component patterns aren't handled by this function\n  // as PMCGroundings is used instead. Update to handle such cases.\n\n  // The psi-rule weight calculations could be done here.\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 56,
        "type": "todo_comment",
        "content": "// TODO: If we are here it means the suggested groundings doesn't have",
        "context": "      }\n    }\n\n    // TODO: If we are here it means the suggested groundings doesn't have\n    // VariableNodes, and can be cached. This doesn't account for terms\n    // that are under QuoteLink, or other similar type links. How should\n    // such cases be handled?\n"
      },
      {
        "file": "components/integration/opencog/opencog/openpsi/OpenPsiSatisfier.cc",
        "line": 76,
        "type": "todo_comment",
        "content": "// TODO: This happens when InitiateSearchCB::no_search has groundings.",
        "context": "    _implicator -> _satisfiability_cache[_pattern_body] = var_soln;\n    return true;\n  } else {\n    // TODO: This happens when InitiateSearchCB::no_search has groundings.\n    // Cases for when this happens hasn't been tested yet. Explore the\n    // behavior and find a better solution. For now, log it and continue\n    // searching.\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 93,
        "type": "fixme_comment",
        "content": "// XXX FIXME This lock is not needed, because in guile-2.2,",
        "context": "\tif (_in_server) return;\n\n\t// Lock to prevent racey setting of the output port.\n\t// XXX FIXME This lock is not needed, because in guile-2.2,\n\t// at least, every thread has its own output port, and so its\n\t// impossible for two different threads to compete to set the\n\t// same outport.  Not too sure about guile-2.0, though... so\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1028,
        "type": "todo_comment",
        "content": "// TODO: it would be nice to pass exceptions on through, but",
        "context": "\t}\n\texpr = scm_cons(sfunc, expr);\n\n\t// TODO: it would be nice to pass exceptions on through, but\n\t// this currently breaks unit tests.\n\t// if (_in_eval)\n\t//    return scm_eval(expr, scm_interaction_environment());\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1057,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- idealy we should avoid catch-and-rethrow.",
        "context": "\t\t{\n\t\t\t// Rethrow.  It would be better to just allow exceptions\n\t\t\t// to pass on through, but thus breaks some unit tests.\n\t\t\t// XXX FIXME -- idealy we should avoid catch-and-rethrow.\n\t\t\t// At any rate, we must not return a TV of any sort, here.\n\t\t\tthrow RuntimeException(TRACE_INFO, \"%s\", _error_msg.c_str());\n\t\t}\n"
      },
      {
        "file": "components/language/learn/attic/run-ull-2019/SchemeEval.cc",
        "line": 1180,
        "type": "fixme_comment",
        "content": "// XXX FIXME only a subset is needed.",
        "context": "\nvoid SchemeEval::init_scheme(void)\n{\n\t// XXX FIXME only a subset is needed.\n\tSchemeEval sch;\n}\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 239,
        "type": "fixme_comment",
        "content": "// XXX FIXME this does not smell right; optionals should get",
        "context": "\n    if (m_type == CONNECTOR_type)\n    {\n        // XXX FIXME this does not smell right; optionals should get\n        // blown up into pairs of disjuncts, one with and one without.\n        if (m_string == \"OPTIONAL\") return { optnl };\n\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictExpContainer.cc",
        "line": 268,
        "type": "fixme_comment",
        "content": "// XXX FIXME ... using an std::map would be more efficient.",
        "context": "    // remove repeated atoms from OR\n    if (m_type == OR_type)\n    {\n        // XXX FIXME ... using an std::map would be more efficient.\n        std::sort(outgoing.begin(), outgoing.end());\n        outgoing.erase(std::unique(outgoing.begin(),\n                                   outgoing.end()),\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 46,
        "type": "fixme_comment",
        "content": "// FIXME XXX -- Optionals are handled incorrectly here;",
        "context": "\n    std::vector<LGDictExpContainer> subcontainers;\n\n    // FIXME XXX -- Optionals are handled incorrectly here;\n    // they are denoted by a null Exp pointer in an OR_list!\n    // Ignoring all the nulls is just ... wrong.\n#if (LINK_MAJOR_VERSION == 5) &&  (LINK_MINOR_VERSION < 7)\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictReader.cc",
        "line": 103,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- if dn_head is null, then we should check regexes.",
        "context": "\n    HandleSeq outgoing;\n\n// XXX FIXME -- if dn_head is null, then we should check regexes.\n// Currently, LG does not do this automatically, but it almost surely\n// should. i.e. the LG public API needs to also handle regexes\n// automatically.\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 229,
        "type": "fixme_comment",
        "content": "// XXX FIXME. This should be part of the LgDictNode but since",
        "context": "\t// Set up the dictionary config, if any.\n\t// This must happen before ldn->get_dictionary() because the\n\t// setup is stateful. This seems buggy, but is adequate for now.\n\t// XXX FIXME. This should be part of the LgDictNode but since\n\t// LgDictNode is a node, not a link, its hard to pass args.\n\t// We would need to wrap it with a StateLink, or maybe use the\n\t// new-fangled \"sensory API\". Sheesh.\n"
      },
      {
        "file": "components/language/lg-atomese/opencog/nlp/lg-parse/LGParseLink.cc",
        "line": 338,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- We should fish parse options out of the atomspace.",
        "context": "\t\t\tparse_options_set_linkage_limit(opts, max_linkages);\n\t}\n\n\t// XXX FIXME -- We should fish parse options out of the atomspace.\n\t// Something like this, maybe:\n\t//     EvaluationLink\n\t//         PredicateNode \"LG ParseTime\"\n"
      },
      {
        "file": "components/learning/moses/examples/example-progs/continmax.cc",
        "line": 67,
        "type": "todo_comment",
        "content": "// TODO: Expand documentation to match style of onemax/nmax examples.",
        "context": "// -- the number that is -log_2(epsilon) where epsilon is the smallest\n//    distinction between continuous variables what will be drawn.\n//\n// TODO: Expand documentation to match style of onemax/nmax examples.\n// Add parameter descriptions, usage examples, and expected output.\n\nint main(int argc, char** argv)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "todo_comment",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "todo_comment",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "todo_comment",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "todo_comment",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "fixme_comment",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "todo_comment",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "todo_comment",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 955,
        "type": "todo_comment",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1078,
        "type": "todo_comment",
        "content": "// TODO: this could definitely be optimized",
        "context": "\n    if (is_sparse) {\n        // fallback on the old loader\n        // TODO: this could definitely be optimized\n        OC_ASSERT(timestamp_feature.empty(), \"Timestamp feature not implemented\");\n        return istreamTable_OLD(in, tab, target_feature, ignore_features);\n    } else {\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
        "line": 1256,
        "type": "todo_comment",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
      },
      {
        "file": "components/learning/moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "todo_comment",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "todo_comment",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "todo_comment",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
      },
      {
        "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "fixme_comment",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "components/learning/moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "todo_comment",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "fixme_comment",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "fixme_comment",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "fixme_comment",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "todo_comment",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "fixme_comment",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "fixme_comment",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "components/learning/moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "todo_comment",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "todo_comment",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/mpi_moses.cc",
        "line": 482,
        "type": "todo_comment",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "todo_comment",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "todo_comment",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 197,
        "type": "todo_comment",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.cc",
        "line": 236,
        "type": "todo_comment",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 154,
        "type": "todo_comment",
        "content": "// TODO: pso description",
        "context": "// Particle Swarm //\n////////////////////\n\n// TODO: pso description\nstruct particle_swarm : optimizer_base\n{\n    particle_swarm(const optim_parameters& op = optim_parameters(),\n"
      },
      {
        "file": "components/learning/moses/moses/moses/optimization/particle-swarm.h",
        "line": 315,
        "type": "todo_comment",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 316,
        "type": "todo_comment",
        "content": "/// TODO: measure and compare the resulting performance.",
        "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 489,
        "type": "todo_comment",
        "content": "// TODO: should bias the selection of these, so that",
        "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 581,
        "type": "todo_comment",
        "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
        "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1011,
        "type": "todo_comment",
        "content": "// TODO: implement support for enumerated types in the input.",
        "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1181,
        "type": "todo_comment",
        "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
        "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
        "line": 1342,
        "type": "fixme_comment",
        "content": "//FIXME: now just attaches to the first output",
        "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n"
      },
      {
        "file": "components/learning/moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "fixme_comment",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "todo_comment",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/scoring_base.cc",
        "line": 108,
        "type": "fixme_comment",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "components/learning/moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "todo_comment",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 32,
        "type": "fixme_comment",
        "content": "log = OrderedDict()  # FIXME: log \u00bb response",
        "context": "    algorithm = kwa('kmeans', 'clustering', **kwargs)\n    verbose = kwa('none', 'verbose', **kwargs)\n\n    log = OrderedDict()  # FIXME: log \u00bb response\n    log.update({'category_learner': 'v.0.7.81231'})\n\n    cdf = pd.DataFrame(columns = ['cluster', 'cluster_words'])\n"
      },
      {
        "file": "language-learning/src/grammar_learner/category_learner.py",
        "line": 53,
        "type": "fixme_comment",
        "content": "except:  # FIXME",
        "context": "        try:\n            dim = vector_space_dim(links, dict_path, tmpath, dim_max, sv_min,\n                                   verbose)\n        except:  # FIXME\n            dim = dim_max\n        log.update({'vector_space_dim': dim})\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/clustering.py",
        "line": 361,
        "type": "todo_comment",
        "content": "# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids",
        "context": "# 80809 update: (30,60,3,[3]) - old range + repeat / (120,30,3) -- search opt\n# 80825 random_clusters\n# 81022 refactoring\n# TODO: n_clusters \u21d2 best_clusters: return best clusters (word lists), centroids\n# 81231 cleanup\n# 90104 resolve Turtle MST LW crash: 1 cluster\n# 90209 group_links: add min_word_count to 80925 legacy version\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 14,
        "type": "fixme_comment",
        "content": "nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?",
        "context": "    rights = Counter()  # right words in links\n    links = Counter()   # tuples: (left_word, right_word)\n    lw = Counter()      # linked words\n    nlw = Counter()     # non-linked words  # FIXME: not used \u00bb DEL?\n    nlws = set()        # a set of non-linked words in a sentence in a loop\n    nnlws = 0           # number of non-linked word occasions in all sentences\n    sentence = []       # a list of words (used within loops)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 37,
        "type": "fixme_comment",
        "content": "nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned",
        "context": "                if len(nlws) > 0:  # indices of non-parsed words in sentence\n                    nnlws += len(nlws)  # number of non-linked words\n                    for j in nlws:\n                        nlw[sentence[j]] += 1  # FIXME:DEL? nlw not returned\n                    # nlws = set()\n                # sentence = []\n                # Count only parsed words (excluding ###LEFT-WALL### and .)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 112,
        "type": "todo_comment",
        "content": "# TODO: update - see GitHub issue?",
        "context": "\n# 80802 poc05 restructured: moved here from pparser.py\n# 80829,31 unpws, unlws\n# TODO: update - see GitHub issue?\n# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n"
      },
      {
        "file": "language-learning/src/grammar_learner/corpus_stats.py",
        "line": 116,
        "type": "todo_comment",
        "content": "# TODO: update sentence length count to parsed words?",
        "context": "# 81231 cleanup\n# 90217 update for use with filtered dataset\n# 90219 count non-linked words, not marked as [not parsed] -- nlw, nlws, nnlws\n# TODO: update sentence length count to parsed words?\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 71,
        "type": "todo_comment",
        "content": "# TODO? sort by frequency?",
        "context": "        d = {x: (i + 1) for i, x in\n             enumerate(sorted(set([x for y in cats['disjuncts'] for x in y])))}\n        cats['djs'] = [set([d[x] for x in y]) for y in cats['disjuncts']]\n        # TODO? sort by frequency?\n\n    return cats, sorted(set(similarities), reverse = True)\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 90,
        "type": "todo_comment",
        "content": "# TODO? define order of children?",
        "context": "            return []\n        else:\n            x = []\n            # TODO? define order of children?\n            for j in children[i]:\n                x.append(j)\n                y = branch(j, children)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 133,
        "type": "todo_comment",
        "content": "else:  # 81130: prune clusters with empty dj sets  # TODO: update",
        "context": "                    new_dj.append(ordnung.index(abs(index)) * sign(index))\n                new_rule.append(tuple(new_dj))\n            new_cats['disjuncts'][rule] = set(new_rule)\n        else:  # 81130: prune clusters with empty dj sets  # TODO: update\n            print(('rule', rule, '- 0 djs in new_cats[disjuncts][rule]:',\n                   new_cats['disjuncts'][rule]))\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 179,
        "type": "todo_comment",
        "content": "# TODO: list of merged clusters - to delete",
        "context": "    if aggregation == 'jaccard':\n        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 180,
        "type": "todo_comment",
        "content": "# TODO: delete merged clusters",
        "context": "        threshold = merge_threshold\n        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        # TODO: list of merged clusters - to delete\n        # TODO: delete merged clusters\n        z = len(similarities)\n        sims = similarities\n        while z > 1 and threshold > aggr_threshold:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 206,
        "type": "todo_comment",
        "content": "# TODO: delete merged clusters?",
        "context": "    cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n    sims = [x for x in similarities]  # if x < threshold]\n    threshold = max(sims) - 0.01\n    # TODO: delete merged clusters?\n\n    z = len(similarities)\n    while z > 1 and threshold > aggr_threshold:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 215,
        "type": "todo_comment",
        "content": "# Renumber connectors in disjuncts # TODO: for all clusters?",
        "context": "        threshold = max(sims) - 0.01\n        z = len(sims)\n\n    # Renumber connectors in disjuncts # TODO: for all clusters?\n    clusters = [i for i, x in enumerate(cats['cluster'])\n                if i > 0 and x is not None]\n\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 277,
        "type": "todo_comment",
        "content": "# TODO: delete merged clusters?",
        "context": "        cats, similarities = aggregate(categories, threshold, jaccard, verbose)\n        sims = [x for x in similarities]  # if x < threshold]\n        threshold = max(sims) - 0.01\n        # TODO: delete merged clusters?\n        z = len(similarities)\n        while z > 1 and threshold > aggr_threshold:\n            cats, similarities = aggregate(cats, threshold, jaccard, verbose)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 342,
        "type": "todo_comment",
        "content": "# new_cluster_id = len(cats['top'])  # TODO?",
        "context": "    merges = [x for i, x in enumerate(merges) if i not in merged]\n    for mset in merges:\n        new_cluster_id = len(cats['parent'])\n        # new_cluster_id = len(cats['top'])  # TODO?\n        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 346,
        "type": "todo_comment",
        "content": "cats['parent'].append(0)  # TODO? append(None) & use top?",
        "context": "        # cats['cluster'].append(cluster_id(new_cluster_id, new_cluster_id))\n        cats['cluster'].append(None)  # 81123\n        cats['top'].append(0)  # 81123\n        cats['parent'].append(0)  # TODO? append(None) & use top?\n        cats['children'].append(mset)\n        cats['words'].append(set())\n        cats['disjuncts'].append(set())\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 356,
        "type": "todo_comment",
        "content": "cats['parent'][cluster] = new_cluster_id  # TODO: don't change",
        "context": "\n        for cluster in mset:\n            cats['top'][cluster] = new_cluster_id  # 81123\n            cats['parent'][cluster] = new_cluster_id  # TODO: don't change\n            cats['words'][new_cluster_id].update(cats['words'][cluster])\n            cats['disjuncts'][new_cluster_id].update(cats['disjuncts'][cluster])\n            cats['djs'][new_cluster_id].update(cats['djs'][cluster])\n"
      },
      {
        "file": "language-learning/src/grammar_learner/generalization.py",
        "line": 414,
        "type": "todo_comment",
        "content": "# TODO: aggregate_cosine?",
        "context": "# 80725 POC 0.1-0.4 deleted, 0.5 restructured\n# 80802 poc05.py restructured, cats2list moved to category_learner.py,\n# cats2list copied to poc05.py for tmp compatibility\n# TODO: aggregate_cosine?\n# 80802 fix compatibility with dj_counts & max_disjuncts, delete ...05.py?\n# 81121 generalise_rules\n# 81217 FIXME? generalize_categories [F] with new reorder (Turtle tests)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 27,
        "type": "fixme_comment",
        "content": "if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!",
        "context": "def calc_pmi(counts, cds):  # Calculates e^PMI; PMI without the log().\n    sum_w = np.array(counts.sum(axis=1))[:, 0]\n    sum_c = np.array(counts.sum(axis=0))[0, :]\n    if cds != 1: sum_c = sum_c ** cds   # FIXME: cds = 1.0 ?!\n    sum_total = sum_c.sum()\n    sum_w = np.reciprocal(sum_w)\n    sum_c = np.reciprocal(sum_c)\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 138,
        "type": "fixme_comment",
        "content": "print('SVDEmbedding: transpose')    #FIXME:DEL",
        "context": "    # Context embeddings can be created with \"transpose\".\n    def __init__(self, path, normalize=True, eig=0.0, transpose=False):\n        if transpose:\n            print('SVDEmbedding: transpose')    #FIXME:DEL\n            ut = np.load(path + '.vt.npy')\n            self.wi, self.iw = load_vocabulary(path + '.contexts.vocab')\n        else:\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 358,
        "type": "todo_comment",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    logger.info(f'SVD matrix (3 files .npy) saved: {len(ut[0])} vectors, ut: {len(ut)} s: {len(s)} vt:{len(vt)}')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 439,
        "type": "todo_comment",
        "content": "svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM",
        "context": "    list2tsv(explicit.ic, svd_path + '.contexts.vocab')\n\n    '''SVD => vectors.txt'''\n    svd = SVDEmbedding(svd_path, True, eig)   # TODO: move code here, RAM2RAM\n    if len(svd.m[0]) < dim: dim = len(svd.m[0])   # 80216\n    vectors_df = pd.DataFrame(columns=['word'] + list(range(1,dim+1)))\n    for i, w in enumerate(svd.iw):\n"
      },
      {
        "file": "language-learning/src/grammar_learner/hyperwords.py",
        "line": 466,
        "type": "todo_comment",
        "content": "# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?",
        "context": "# Notes:\n\n# 80329 added vector_space_dim\n# TODO: refactor, control disk writes, ... PPMI \u21d2 +frequency?\n# 90221 minor updates for Grammar Learner tutorial\n"
      },
      {
        "file": "language-learning/src/grammar_learner/pqa_table.py",
        "line": 641,
        "type": "fixme_comment",
        "content": "continue  # FIXME: check case",
        "context": "                     linkage, affinity, gen, ' ---', 'fail',\n                     ' ---', ' ---', ' ---', ' ---', ' ---', ' ---']\n            details.append(dline)\n            continue  # FIXME: check case\n        if kwargs['linkage_limit'] > 0:\n            start = time.time()\n            a, f1, precision, q = pqa_meter(re['grammar_file'],\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 33,
        "type": "todo_comment",
        "content": "# TODO: cleanup here or in a separate constructor?",
        "context": "            if us[-1] != '\\n' :  us += '\\n'\n        us += s\n        if us[-1] != '\\n' :  us += '\\n'\n    # TODO: cleanup here or in a separate constructor?\n    re = OrderedDict([('read_files', UTC()),\n                      ('input_path', kwargs['input_path']),\n                      ('read_files_number', len(files)),\n"
      },
      {
        "file": "language-learning/src/grammar_learner/preprocessing.py",
        "line": 141,
        "type": "fixme_comment",
        "content": "# else:  # FIXME: raise error / assert ?",
        "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n"
      },
      {
        "file": "language-learning/src/grammar_learner/read_files.py",
        "line": 266,
        "type": "return_none",
        "content": "return None",
        "context": "    # Get the path parameter\n    if param_name not in kwargs:\n        logger.warning(f'Parameter \"{param_name}\" not in kwargs')\n        return None\n    \n    path = kwargs[param_name]\n    \n"
      },
      {
        "file": "language-learning/src/grammar_learner/read_files.py",
        "line": 298,
        "type": "return_none",
        "content": "return None",
        "context": "                return path\n            else:\n                logger.warning(f'Path does not exist: {path}')\n                return None\n                \n    except Exception as e:\n        logger.error(f'Error checking path {path}: {e}')\n"
      },
      {
        "file": "language-learning/src/grammar_learner/read_files.py",
        "line": 302,
        "type": "return_none",
        "content": "return None",
        "context": "                \n    except Exception as e:\n        logger.error(f'Error checking path {path}: {e}')\n        return None\n\n# Module history:\n# - Added logging support\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 25,
        "type": "todo_comment",
        "content": "elif clustering == 'group':  # TODO: call ILE clustering?",
        "context": "            clustering = ('kmeans', 'k-means++', 10)\n        elif clustering in ['mean_shift', 'mean shift', 'meanshift']:\n            clustering = ('mean_shift', 2)  # Note: 'auto' bandwidth not yet implemented\n        elif clustering == 'group':  # TODO: call ILE clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 29,
        "type": "todo_comment",
        "content": "elif clustering == 'random':  # TODO: call random clustering?",
        "context": "            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'ILE grouping not supported in skl_clustering'}, []\n        elif clustering == 'random':  # TODO: call random clustering?\n            return [], {'clustering': 'skl_clustering error',\n                        'clustering_error':\n                            'random not supported in skl_clustering'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 56,
        "type": "todo_comment",
        "content": "# TODO: int / dict",
        "context": "            if len(clustering) > 3:  # connectivity\n                if type(clustering[3]) is int and clustering[3] > 0:\n                    neighbors = clustering[3]\n                    # TODO: int / dict \n                    connectivity = kneighbors_graph(cd, neighbors,\n                                                    include_self=False)\n            if len(clustering) > 4:  # compute_full_tree\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 111,
        "type": "fixme_comment",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['silhouette_index'] = float(\n                silhouette_score(cd, labels, metric=clustering_metric[1]))\n        except:  # FIXME\n            metrics['silhouette_index'] = 0.0\n        try:\n            metrics['variance_ratio'] = float(\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 116,
        "type": "fixme_comment",
        "content": "except:  # FIXME",
        "context": "        try:\n            metrics['variance_ratio'] = float(\n                calinski_harabaz_score(cd, labels))\n        except:  # FIXME\n            metrics['variance_ratio'] = 0.0\n        # try:\n        #   metrics['davies_bouldin_score'] = float(\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 124,
        "type": "fixme_comment",
        "content": "except:  # else:  # FIXME",
        "context": "        # except: metrics['davies_bouldin_score'] = 0.0\n\n        return labels, metrics, centroids\n    except:  # else:  # FIXME\n        print('except: skl_clustering error')\n        return np.asarray(range(cd.shape[0])), \\\n               {'clustering': 'skl_clustering error'}, []\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 172,
        "type": "todo_comment",
        "content": "elif len(crange) == 3:  # TODO: replace with SGD?",
        "context": "                    l, m, c = skl_clustering(cd, crange[0], **kwargs)\n                    if m['silhouette_index'] > metrics['silhouette_index']:\n                        labels, metrics, centroids = l, m, c\n        elif len(crange) == 3:  # TODO: replace with SGD?\n            n_min = min(crange[0], crange[1])\n            n_max = max(crange[0], crange[1])\n            labels, metrics, centroids = \\\n"
      },
      {
        "file": "language-learning/src/grammar_learner/skl_clustering.py",
        "line": 208,
        "type": "fixme_comment",
        "content": "# FIXME: try...except",
        "context": "# 181203 cleanup\n# 190118 cleanup: remove debug printing\n# 190425 fix n_clusters > n_words case\n# FIXME: try...except\n"
      },
      {
        "file": "language-learning/src/grammar_learner/widgets.py",
        "line": 70,
        "type": "todo_comment",
        "content": "#  TODO: To be reviewed and changed if necessary",
        "context": "                tree.append(['', m+1, cats[j][2], cats[j][3]])\n        else:\n            print('WTF?', k, v)\n    #  TODO: To be reviewed and changed if necessary\n    if verbose not in ['none', 'min']:\n        display(html_table([['Code', 'Parent', 'Id', 'Words']] + tree))\n\n"
      },
      {
        "file": "language-learning/src/grammar_tester/grammartester.py",
        "line": 141,
        "type": "return_none",
        "content": "return None",
        "context": "\n        if self._is_dir_corpus:\n            if args[CORP_ARG_REFF] is None:\n                return None\n\n            ref_path = args[CORP_ARG_REFF] + corpus_file_path[len(args[CORP_ARG_CORP]):]\n\n"
      },
      {
        "file": "language-learning/src/grammar_tester/psparse.py",
        "line": 426,
        "type": "return_none",
        "content": "return None",
        "context": "    logging.getLogger(__name__ + \".get_sentence_text\").debug(f\"Unable to find echoed sentence in postscript \"\n                                                             f\"parse:\\n{text}\")\n\n    return None\n\n\ndef get_linkage_cost(text: str):  # -> Optional[int, Tuple[int, str, int]]:\n"
      },
      {
        "file": "language-learning/src/grammar_tester/psparse.py",
        "line": 440,
        "type": "return_none",
        "content": "return None",
        "context": "    data = pattern.findall(text)\n\n    if data is None or len(data) < 1:\n        return None\n\n    # if len(data) > 1:\n    #     raise LGParseError(f\"Found more than one linkage in: {text}\")\n"
      },
      {
        "file": "language-learning/src/pipeline/pipelinetreenode.py",
        "line": 62,
        "type": "return_none",
        "content": "return None",
        "context": "        :return:            None\n        \"\"\"\n        if node is None:\n            return None\n\n        if job is not None:\n            try:\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 26,
        "type": "fixme_comment",
        "content": "def setUp(self):    # FIXME: should run before every test, but would not?!",
        "context": "\nclass TestGrammarLearner(unittest.TestCase):\n\n    def setUp(self):    # FIXME: should run before every test, but would not?!\n        input_parses = module_path + '/tests/data/POC-Turtle/MST_fixed_manually/'\n        batch_dir = module_path + '/output/Test_Grammar_Learner_' + str(UTC())[:10] + '/'\n        kwargs = {  # defaults\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 65,
        "type": "fixme_comment",
        "content": "# 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester",
        "context": "        # Additional (optional) parameters for parse_metrics (_abiity & _quality):\n        # 'test_corpus': module_path + '/data/POC-Turtle/poc-turtle-corpus.txt',\n        # 'reference_path': module_path + '/data/POC-Turtle/poc-turtle-parses-expected.txt',\n        # 'template_path': 'poc-turtle',  # FIXME: changed in June 2018 Grammar Tester\n        pass\n\n    '''Legacy ~ POC.0.3 test ~ as it was before 2018-09-29\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 212,
        "type": "todo_comment",
        "content": "# TODO: Remove these commented lines in next cleanup cycle.",
        "context": "        }\n        re = learn_grammar(**kwargs)\n        # NOTE: Legacy test code commented out for historical reference.\n        # TODO: Remove these commented lines in next cleanup cycle.\n        # a, q, qa = pqa_meter(re['grammar_file'], outpath, cp, rp, **kwargs)\n        # print('parse-ability, parse-quality:', a, q)\n        # assert a*q > 0.99\n"
      },
      {
        "file": "language-learning/tests/test_grammar_learner.py",
        "line": 310,
        "type": "fixme_comment",
        "content": "# FIXME: check with further test_grammar updates and delete.",
        "context": "            'verbose'       :   'min'\n        }\n        # Sometimes pqa_meter(with test_grammar updated 2018-10-19) returns pa,recall = 0,0\n        # FIXME: check with further test_grammar updates and delete.\n        x = 0.\n        n = 0\n        while x < 0.1 :\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/descriptions.cc",
        "line": 45,
        "type": "todo_comment",
        "content": "// ToDo: would be nice to have a more Caml/Haskell style syntax here,",
        "context": "// with builtins as indicies, within the singleton class builtin_properties.\n// This array should not have any other usages.\n//\n// ToDo: would be nice to have a more Caml/Haskell style syntax here,\n// right?\nstatic const builtin_description bd[] =\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 505,
        "type": "todo_comment",
        "content": "// TODO",
        "context": "        size_t tmp = c_last;\n        std::cout << pc << std::endl;\n        // WARNING: Use the boost namespace (see above)\n        // TODO\n        // hash_combine(tmp, boost::hash_value(*pc));\n        return tmp;\n    }\n"
      },
      {
        "file": "moses/moses/comboreduct/combo/vertex.h",
        "line": 795,
        "type": "todo_comment",
        "content": "//TODO",
        "context": "\ninline bool may_have_side_effects(combo_tree::iterator /*it*/)\n{\n    //TODO\n    return false;\n}\n\n"
      },
      {
        "file": "moses/moses/comboreduct/main/action-reductor.cc",
        "line": 93,
        "type": "todo_comment",
        "content": "// TODO -- replace this by cond",
        "context": "    cout << \"output type \" << ba2->get_output_type_tree() << endl;\n\n#if 0\n    // TODO -- replace this by cond\n    cout << \"6----------------\" << endl;\n\n    cout << \"arity \" << (int)get_arity(id::boolean_if) << endl;\n"
      },
      {
        "file": "moses/moses/comboreduct/main/eval-table.cc",
        "line": 147,
        "type": "fixme_comment",
        "content": "// XXX FIXME",
        "context": "    }\n\n    // HERE WE ARE ASSUMING THAT THE INPUT FILE HAS A HEADER!!!\n// XXX FIXME\n    vector<string> header = get_header(pa.input_table_file);\n\n    // Add to ignore_values (header - all_unique_variables - target feature)\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/contin_rules.cc",
        "line": 963,
        "type": "todo_comment",
        "content": "// TODO:  sin(*(-1 x)) -> -sin(x)",
        "context": "// or more generally\n// sin(sum x_i + sum c_j) -> sin(sum x_i + ((sum c_j)+pi)%2pi -pi\n//\n// TODO:  sin(*(-1 x)) -> -sin(x)\n// The above is frequently seen in real-life ...\nvoid reduce_sin::operator()(combo_tree& tr, combo_tree::iterator it) const\n{\n"
      },
      {
        "file": "moses/moses/comboreduct/reduct/mixed_rules.cc",
        "line": 1228,
        "type": "todo_comment",
        "content": "//check if 0<-(y+pi) -> false //TODO",
        "context": "                }\n            }\n            else if(*copy_tr.begin()==id::logical_false) {\n                //check if 0<-(y+pi) -> false //TODO\n                combo_tree copy2_tr = tr.subtree(sib_it(it), tr.next_sibling(sib_it(it)));\n                //copy old assumptions, begin\n                sib_it bna = copy2_tr.begin(); //before new assumption\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 934,
        "type": "todo_comment",
        "content": "// TODO could be simplified, optimized, etc",
        "context": "            // It is sparse\n            is_sparse = is_sparse || string::npos != line.find(sparse_delim);\n            if (is_sparse) { // just get out\n                // TODO could be simplified, optimized, etc\n                in.seekg(beg);\n                in.clear();         // in case it has reached the eof\n                return in;\n"
      },
      {
        "file": "moses/moses/comboreduct/table/table_io.cc",
        "line": 1245,
        "type": "todo_comment",
        "content": "// TODO: implement timestamp support",
        "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n"
      },
      {
        "file": "moses/moses/comboreduct/type_checker/type_tree.h",
        "line": 235,
        "type": "todo_comment",
        "content": "// TODO : lambda",
        "context": "//\n// intersection of ill_formed and T is ill_formed\n//\n// TODO : lambda\n//\n// Of course the case if T1 inherit T2 then interection of T1 and T2\n// is T1 is also implemented. If the interection is ill_formed or\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 441,
        "type": "todo_comment",
        "content": "// TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT",
        "context": "                // dynamically selected, it might be less that the global target;\n                // that is, the deme might not be able to reach the best score.)\n                //\n                // TODO: DO NOT CHANGE THE MAX SCORE IF USER SET IT: BUT THAT\n                // OPTION ISN'T GLOBAL WHAT TO DO?\n                //\n                // But why would we want to over-ride the best-possible score?\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 457,
        "type": "todo_comment",
        "content": "// TODO: re-enable that once best_possible_bscore is fixed",
        "context": "                              \"terminate deme search. Except I think this \"\n                              \"is fixed now. It needs review and testing.\");\n\n                // TODO: re-enable that once best_possible_bscore is fixed\n                // I think its now fixed, but I'm not sure.  It needs to be\n                // reviewed and tested.\n#if THIS_IS_DISABLED_UNTIL_ABOVE_IS_FIXED\n"
      },
      {
        "file": "moses/moses/moses/deme/deme_expander.cc",
        "line": 502,
        "type": "fixme_comment",
        "content": "// XXX FIXME this is a bug .. the user may have specified that",
        "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n"
      },
      {
        "file": "moses/moses/moses/eda/replacement.h",
        "line": 62,
        "type": "todo_comment",
        "content": "// TODO: I think it might be a little more efficent to use the",
        "context": "// Replace the most similar individual, where similarity is determined by\n// the hamming distance.\n//\n// TODO: I think it might be a little more efficent to use the\n// hamming_distance as a sort comparison operator, and hand off the whole\n// thing to std:nth_element, and let that class figure out who is close or\n// not.  This avoids the use of doubly-nested loops, and multiple redundant\n"
      },
      {
        "file": "moses/moses/moses/main/problem-params.h",
        "line": 46,
        "type": "fixme_comment",
        "content": "// XXX FIXME TODO The structure below should be split into multiple",
        "context": "\nnamespace opencog { namespace moses {\n\n// XXX FIXME TODO The structure below should be split into multiple\n// parts, with each sub-part responsible for picking out the argv's\n// that it cares about. Unfortunately, this requires getting rid of\n// boost::program_options (because boost::program_options does not\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 138,
        "type": "fixme_comment",
        "content": "// XXX FIXME -- the multiple tables should be merged into one.",
        "context": "    }\n    logger().info(\"Number of rows in tables = %d\", num_rows);\n\n    // XXX FIXME -- the multiple tables should be merged into one.\n    ctable = _ctables.front();\n    table = _tables.front();\n\n"
      },
      {
        "file": "moses/moses/moses/main/table-problems.cc",
        "line": 150,
        "type": "fixme_comment",
        "content": "// XXX FIXME .. check that they all have the same signature.",
        "context": "    arity = table.get_arity();\n\n    // Check that all input data files have the same arity\n    // XXX FIXME .. check that they all have the same signature.\n    if (_tables.size() > 1) {\n        for (size_t i = 1; i < _tables.size(); ++i) {\n            combo::arity_t test_arity = _tables[i].get_arity();\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 261,
        "type": "fixme_comment",
        "content": "// XXX FIXME: we should use a pointer set for scored_combo_tree_set",
        "context": "        logger().debug(\"Compute behavioral score of %d selected candidates\",\n                       candidates.size());\n\n        // XXX FIXME: we should use a pointer set for scored_combo_tree_set\n        // This would avoid some pointless copying here and a few other\n        // places.  This is easier said than done, because the stupid\n        // domination code is so snarky and icky.  Domination should die.\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 404,
        "type": "todo_comment",
        "content": "// TODO: Make population cap size-sensitive to exemplar complexity.",
        "context": "    // formula was arrived at via some ad-hoc experimentation.  A default\n    // value of _params.cap_coef=50 seems to work well.\n    //\n    // TODO: Make population cap size-sensitive to exemplar complexity.\n    // Large exemplars should result in smaller population sizes to maintain\n    // efficiency. Consider implementing adaptive sizing based on exemplar metrics.\n    //\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/merging.cc",
        "line": 552,
        "type": "fixme_comment",
        "content": "// XXX FIXME looks to me like it++ can often be collaed twice within this loop!",
        "context": "                    }\n                }\n\n// XXX FIXME looks to me like it++ can often be collaed twice within this loop!\n                prev_it = it++;\n            }\n\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.cc",
        "line": 222,
        "type": "fixme_comment",
        "content": "// XXX FIXME should probably not recompute every time ...",
        "context": "    if (not _params.do_boosting)\n        return _best_cscore;\n\n    // XXX FIXME should probably not recompute every time ...\n    // need to figure who is calling this method, and what they are expecting.\n    return _cscorer.get_cscore(_ensemble.get_ensemble());\n}\n"
      },
      {
        "file": "moses/moses/moses/metapopulation/metapopulation.h",
        "line": 535,
        "type": "todo_comment",
        "content": "// TODO: we may want to output the visited status as well",
        "context": "    // metapopulation. This function is used for fine logging to\n    // deeply probe the metapopulation.\n    //\n    // TODO: we may want to output the visited status as well\n    std::ostream& ostream_metapop(std::ostream&, int n = INT_MAX) const;\n\nprivate:\n"
      },
      {
        "file": "moses/moses/moses/moses/local_moses.cc",
        "line": 180,
        "type": "todo_comment",
        "content": "// TODO use the option of the output",
        "context": "                   << \"\\t\" << ds.max;  // max distance\n\n                // diversity stats over all best n candidates of the metapopulation\n                // TODO use the option of the output\n                auto best_ds = mp.gather_diversity_stats(pa.max_cnd_output);\n                ss << \"\\t\" << best_ds.count // number of pairs of candidates\n                   << \"\\t\" << best_ds.mean  // average distance\n"
      },
      {
        "file": "moses/moses/moses/moses/mpi_moses.cc",
        "line": 486,
        "type": "todo_comment",
        "content": "// TODO: Optimize statistics printing frequency to reduce output volume.",
        "context": "                thread_count--;\n                });\n\n// TODO: Optimize statistics printing frequency to reduce output volume.\n        // Consider printing detailed stats every N iterations instead of every iteration.\n        // Print stats in a way that makes them easy to graph.\n        // (columns of tab-seprated numbers)\n"
      },
      {
        "file": "moses/moses/moses/moses/partial.cc",
        "line": 96,
        "type": "todo_comment",
        "content": "// TODO: Improve generation tracking by getting actual number",
        "context": "\n        _moses_params.max_evals -= _num_evals;\n\n        // TODO: Improve generation tracking by getting actual number\n        // of generations run from MOSES and subtracting it here.\n        // Currently no easy API exists to retrieve this information.\n        _moses_params.max_gens -= _num_gens;\n"
      },
      {
        "file": "moses/moses/moses/moses/types.h",
        "line": 210,
        "type": "todo_comment",
        "content": "// TODO this should be a std::valarray not std::vector but I am too",
        "context": "/// in reference to a particular table of data.  Exactly which tree it\n/// is, and which table, is implicit.\n//\n// TODO this should be a std::valarray not std::vector but I am too\n// lazy to make the switch right now.\nstruct behavioral_score : public std::vector<score_t>\n{\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 198,
        "type": "todo_comment",
        "content": "// TODO: work in a better way to identify convergence.",
        "context": "            break;\n        }\n\n        // TODO: work in a better way to identify convergence.\n        not_improving = (has_improved) ? 0 : not_improving + 1;\n        if (not_improving > 3) {\n            logger().debug(\"Terminate Local Search: Convergence.\");\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.cc",
        "line": 237,
        "type": "todo_comment",
        "content": "// TODO: Explanation",
        "context": "        \"complexity\";\n}\n\n// TODO: Explanation\n// There's no explanation for this, it's just a temporary solution.\n// Maybe use adaptative pso, something like LPSO (Lander).\nunsigned particle_swarm::calc_swarm_size(const field_set& fs) {\n"
      },
      {
        "file": "moses/moses/moses/optimization/particle-swarm.h",
        "line": 347,
        "type": "todo_comment",
        "content": "// TODO: Wind dispersion, but test without first",
        "context": "    void update_cont_particle(instance& temp, const instance& personal,\n            const instance& global, velocity::iterator vel, const field_set& fs);\n\n    // TODO: Wind dispersion, but test without first\n    // Make it later is easy.\n\npublic:\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 317,
        "type": "todo_comment",
        "content": "/// TODO: measure and compare the resulting performance.",
        "context": "/// can be rather incredibly costly, especially when the exemplars start\n/// getting large.  So the real question is: is the performance cost of\n/// this routine worth the eventual savings when scoring instances?\n/// TODO: measure and compare the resulting performance.\n//\n// Notes to self: hmm. in 5-parity problem, about 2/3 of knobs are\n// disallowed! viz of 6738 probes, 4007 knobs are completely disallowed.\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 490,
        "type": "todo_comment",
        "content": "// TODO: should bias the selection of these, so that",
        "context": "        }\n    }\n\n    // TODO: should bias the selection of these, so that\n    // larger subtrees are preferred .. !? why?\n\n    unsigned max_pairs = permitted_perms.size();\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 582,
        "type": "todo_comment",
        "content": "// TODO: Benchmark and clarify optimal breakeven point across different problem sizes.",
        "context": "    // The number of 30K is a wild guesstimate, based on recent\n    // measurements of relatively simple exemplars; its maybe even\n    // too low.  For large exemplars, it might be too big !?\n    // TODO: Benchmark and clarify optimal breakeven point across different problem sizes.\n#define BREAKEVEN 30000\n    size_t np = perms.size();\n    int nthr = 1 + np / BREAKEVEN;\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1012,
        "type": "todo_comment",
        "content": "// TODO: implement support for enumerated types in the input.",
        "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1182,
        "type": "todo_comment",
        "content": "//TODO: should bias the selection of these (and possibly choose larger subtrees)",
        "context": "        perms.push_back(tr);\n\n    //and n random pairs out of the total  2 * choose(n,2) = n * (n - 1) of these\n    //TODO: should bias the selection of these (and possibly choose larger subtrees)\n    lazy_random_selector randpair(n * (n - 1));\n\n    dorepeat(n) {\n"
      },
      {
        "file": "moses/moses/moses/representation/build_knobs.cc",
        "line": 1343,
        "type": "fixme_comment",
        "content": "//FIXME: now just attaches to the first output",
        "context": "    cout << \"Created node: \" << new_node << endl;\n\n    //now attach the subtree to the hidden nodes\n    //FIXME: now just attaches to the first output\n    sib_it first_hidden = it.begin();\n\n    _exemplar.insert_subtree(first_hidden.begin(),new_node.begin());\n"
      },
      {
        "file": "moses/moses/moses/representation/instance_scorer.h",
        "line": 89,
        "type": "fixme_comment",
        "content": "// XXX FIXME, calling score_tree above does not throw the exception; this should be done",
        "context": "            combo_tree tr = _rep.get_candidate(inst, _reduce);\n            return _cscorer.get_cscore(tr);\n        } catch (...) {\n// XXX FIXME, calling score_tree above does not throw the exception; this should be done\n// differntly, maybe call bscorer directly, then ascorer...\n// ??? Huh? why couldn't we evaluate a tree anyway?  why would we want an exception here?\n            combo_tree raw_tr = _rep.get_candidate(inst, false);\n"
      },
      {
        "file": "moses/moses/moses/scoring/bscores.cc",
        "line": 570,
        "type": "todo_comment",
        "content": "// TODO",
        "context": "    OC_ASSERT(*it == id::cond, \"Error: unexpected candidate!\");\n\n    // Evaluate the bscore components for all rows of the ctable\n    // TODO\n    sib_it predicate = it.begin();\n    for (const CTable::value_type& vct : _ctable) {\n        const CTable::counter_t& c = vct.second;\n"
      },
      {
        "file": "moses/moses/moses/scoring/scoring_base.cc",
        "line": 152,
        "type": "fixme_comment",
        "content": "// XXX FIXME complexity_t should be a double not an int ...",
        "context": "        norm += w;\n    }\n\n    // XXX FIXME complexity_t should be a double not an int ...\n    return (complexity_t) floor (cpxy / norm + 0.5);\n}\n\n"
      },
      {
        "file": "moses/moses/moses/scoring/time_dispersion.cc",
        "line": 43,
        "type": "todo_comment",
        "content": "// TODO multipler other than 1 is not supported yet",
        "context": "      _granularity(granularity), _multiplier(multiplier),\n      _pressure(time_dispersion_pressure), _exponent(time_dispersion_exponent)\n{\n    // TODO multipler other than 1 is not supported yet\n    OC_ASSERT(_multiplier == 1, \"Multiplier other than 1 is not supported yet\");\n\n    // Set of timestamp classes\n"
      },
      {
        "file": "scripts/github_issue_creator.py",
        "line": 33,
        "type": "return_none",
        "content": "return None",
        "context": "        if not self.github_token:\n            print(\"\u26a0\ufe0f  No GITHUB_TOKEN found in environment. Skipping automatic issue creation.\")\n            print(\"   To enable automatic issue creation, set GITHUB_TOKEN environment variable.\")\n            return None\n        \n        # Extract title from content\n        lines = batch_content.split('\\n')\n"
      },
      {
        "file": "scripts/github_issue_creator.py",
        "line": 72,
        "type": "return_none",
        "content": "return None",
        "context": "            print(f\"\u274c Failed to create GitHub issue: {e}\")\n            if hasattr(e, 'response') and e.response is not None:\n                print(f\"   Response: {e.response.text}\")\n            return None\n    \n    def update_issue_with_completion(self, issue_number: int, todo_key: str, pr_link: str) -> bool:\n        \"\"\"Update an issue to mark a TODO as completed\"\"\"\n"
      },
      {
        "file": "scripts/recursive_todo_resolver.py",
        "line": 897,
        "type": "return_none",
        "content": "return None",
        "context": "        \n        if not batch:\n            print(\"\ud83c\udf89 No more TODOs to process!\")\n            return None\n        \n        # Step 4: Generate actionable issues\n        issue_content = self.generate_actionable_issues(batch)\n"
      },
      {
        "file": "scripts/test_recursive_todo_resolution.py",
        "line": 28,
        "type": "return_none",
        "content": "return None",
        "context": "    if result.returncode != 0:\n        print(f\"\u274c Command failed: {cmd}\")\n        print(f\"Error: {result.stderr}\")\n        return None\n    \n    print(f\"\u2705 {description} - Success\")\n    return result.stdout\n"
      },
      {
        "file": "tests/cognitive-architecture-explorer.py",
        "line": 152,
        "type": "return_none",
        "content": "return None",
        "context": "            )\n        except Exception as e:\n            print(f\"   Warning: Could not analyze {name}: {e}\")\n            return None\n    \n    def _extract_cognitive_functions(self, path: Path) -> List[str]:\n        \"\"\"Extract cognitive functions from component\"\"\"\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 48,
        "type": "todo_comment",
        "content": "// TODO: the notion of equality between 2 CHandles might one where",
        "context": "public:\n\t// Contextual Handle\n\t//\n\t// TODO: the notion of equality between 2 CHandles might one where\n\t// the Context isn't necessarily equal but where the 2 handles\n\t// (besides being equal) have the same quotation and same\n\t// (free inter shadow) variables.\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 159,
        "type": "todo_comment",
        "content": "// TODO: the type of a typed block is currently a handle of the",
        "context": "\t// the simplest satisfiable solution set.\n\tstatic const Partitions empty_partition_singleton;\n\n\t// TODO: the type of a typed block is currently a handle of the\n\t// variable or ground it is exists, instead of an actual type.\n\tstruct SolutionSet : Partitions\n\t{\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 188,
        "type": "todo_comment",
        "content": "// TODO: maybe we could simplify a great deal of code by replacing",
        "context": "\t// Subtitution values and their corresponding variable declaration\n\t// after substitution (cause some values may be variables).\n\t//\n\t// TODO: maybe we could simplify a great deal of code by replacing\n\t// Handle by Variables.\n\ttypedef std::map<HandleCHandleMap, Handle> TypedSubstitutions;\n\ttypedef std::pair<HandleCHandleMap, Handle> TypedSubstitution;\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 521,
        "type": "todo_comment",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t// Memoization cache for unification results\n\tmutable std::map<std::pair<CHandle, CHandle>, SolutionSet> _unify_cache;\n\npublic:                         // TODO: being friend with UnifyUTest\n\t/**\n\t * Set Unify::_variables given the variable declarations of the\n\t * two terms to unify.\n"
      },
      {
        "file": "unify/opencog/unify/Unify.h",
        "line": 601,
        "type": "todo_comment",
        "content": "public:                         // TODO: being friend with UnifyUTest",
        "context": "\t */\n\tSolutionSet mkvarsol(CHandle lhs, CHandle rhs) const;\n\npublic:                         // TODO: being friend with UnifyUTest\n                                // somehow doesn't work\n\t/**\n\t * Join 2 solution sets. Generate the product of all consistent\n"
      },
      {
        "file": "unify/opencog/unify/atoms/UnifierLink.cc",
        "line": 141,
        "type": "fixme_comment",
        "content": "// XXX FIXME, Maybe. This seems to handle all of the cases I've",
        "context": "\t// I don't really understand what a solution set is.\n\t// This is my best guess.\n\n\t// XXX FIXME, Maybe. This seems to handle all of the cases I've\n\t// looked at so far. However, the unifier has all sorts of fancy\n\t// reduction code, and I don't understand what it is or why it\n\t// is needed. For example, Unfiy::typed_substitutions() and other\n"
      },
      {
        "file": "ure/opencog/ure/BetaDistribution.cc",
        "line": 33,
        "type": "todo_comment",
        "content": "// TODO should be replaced by tv->get_mode() once implemented",
        "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n"
      },
      {
        "file": "ure/opencog/ure/Rule.cc",
        "line": 58,
        "type": "todo_comment",
        "content": "// TODO: could certainly be optimized by not systematically",
        "context": "\nvoid RuleSet::expand_meta_rules(AtomSpace& as)\n{\n\t// TODO: could certainly be optimized by not systematically\n\t// recollecting and re-instantiating meta-rules.\n\tRuleSet meta_rules;\n\tfor (RulePtr rule : *this) {\n"
      },
      {
        "file": "ure/opencog/ure/Rule.h",
        "line": 373,
        "type": "todo_comment",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\t// True if the rule has already been applied.\n\tbool _exhausted;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n\n\t// Return a copy of the rule with the variables alpha-converted\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 121,
        "type": "todo_comment",
        "content": "set_leaf2bitnode();         // TODO: might differ till needed to optimize",
        "context": "AndBIT::AndBIT(const Handle& f, double cpx, const AtomSpace* qas)\n\t: fcs(f), complexity(cpx), exhausted(false), queried_as(qas)\n{\n\tset_leaf2bitnode();         // TODO: might differ till needed to optimize\n}\n\nAndBIT::~AndBIT() {}\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.cc",
        "line": 374,
        "type": "todo_comment",
        "content": "// TODO: is this merging necessary?",
        "context": "\tHandle nrewrite = expand_fcs_rewrite(nfcs_rewrite, rule.first);\n\n\t// Generate new vardecl\n\t// TODO: is this merging necessary?\n\tHandle merged_vardecl = merge_vardecl(nfcs_vardecl, rule_vardecl);\n\tHandle nvardecl = filter_vardecl(merged_vardecl, {npattern, nrewrite});\n\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BIT.h",
        "line": 72,
        "type": "todo_comment",
        "content": "// TODO: Maybe this should be moved to BackwardChainer",
        "context": "\n\t// Estimate the probability of usefulness of expanding this\n\t// BIT-Node.\n\t// TODO: Maybe this should be moved to BackwardChainer\n\tdouble operator()() const;\n\n\tstd::string to_string(const std::string& indent=\"\") const;\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.cc",
        "line": 288,
        "type": "todo_comment",
        "content": "// TODO: Maybe we could take advantage of the new read-only",
        "context": "\t// of concerns instead of the atoms themselves, and only modify\n\t// the atoms if there are existing results to copy back to _as.\n\t//\n\t// TODO: Maybe we could take advantage of the new read-only\n\t// capabilities of the AtomSpace.\n\tHandle hresult = HandleCast(fcs->execute(tmp_as.get()));\n\tHandleSeq results;\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/BackwardChainer.h",
        "line": 232,
        "type": "todo_comment",
        "content": "// TODO: perhaps move that under BIT",
        "context": "\t// Structure holding the Back Inference Tree\n\tBIT _bit;\n\n\t// TODO: perhaps move that under BIT\n\tAndBITFitness _andbit_fitness;\n\n\t// In charge of recording the inference traces\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/ControlPolicy.h",
        "line": 45,
        "type": "todo_comment",
        "content": "// TODO: maybe wrap that in a class, and use it in foward chainer",
        "context": "// selected rule fulfills the objective, which must be passed\n// to the BIT to calculate the and-BIT complexity.\n//\n// TODO: maybe wrap that in a class, and use it in foward chainer\ntypedef std::pair<RuleTypedSubstitutionPair, double> RuleSelection;\n\nclass ControlPolicy\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 75,
        "type": "todo_comment",
        "content": "// TODO: we may want to move the arguments in its own class if it",
        "context": "\t\tTrace\n\t};\n\n\t// TODO: we may want to move the arguments in its own class if it\n\t// grows bigger.\n\tAndBITFitness(FitnessType ft=Uniform,\n\t              const std::set<ContentHash>& tr=std::set<ContentHash>());\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/Fitness.h",
        "line": 92,
        "type": "todo_comment",
        "content": "// TODO: replace by class dedicated to hold the parameters",
        "context": "\tdouble operator()(const AndBIT& andbit) const;\n\nprivate:\n\t// TODO: replace by class dedicated to hold the parameters\n\tstd::set<ContentHash> _trace;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/backwardchainer/TraceRecorder.h",
        "line": 94,
        "type": "todo_comment",
        "content": "// TODO: the TV on the evaluation link should be more carefully",
        "context": "\t// is reported to the EvaluationLink, otherwise it is not\n\t// recorded.\n\t//\n\t// TODO: the TV on the evaluation link should be more carefully\n\t// thought. For instance maybe it was already proved to begin\n\t// with.\n\tvoid proof(const Handle& andbit_fcs, const Handle& target_result);\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/FCStat.h",
        "line": 76,
        "type": "todo_comment",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tstd::vector<InferenceRecord> _inf_rec;\n\tAtomSpace* _trace_as;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 101,
        "type": "todo_comment",
        "content": "// TODO: For now the FC follows the old standard. We may move to",
        "context": "\n\t// Set rules.\n\t_rules = _config.get_rules();\n\t// TODO: For now the FC follows the old standard. We may move to\n\t// the new standard when all rules have been ported to the new one.\n\tfor (RulePtr rule : _rules)\n\t\trule->premises_as_clauses = true;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 165,
        "type": "todo_comment",
        "content": "// TODO: if creating/destroying threads is too expensive, use a thread",
        "context": "\twhile (not termination()) do_step(_iteration++);\n}\n\n// TODO: if creating/destroying threads is too expensive, use a thread\n// pool (see boost::asio::thread_pool).\nvoid ForwardChainer::do_steps_multithread()\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 289,
        "type": "todo_comment",
        "content": "// TODO: This can be simplified but is let here until do_step is",
        "context": "\t\t// before being passed to the new source constructor, as this\n\t\t// one will take it into account.\n\t\t//\n\t\t// TODO: This can be simplified but is let here until do_step is\n\t\t// replaced by do_step_srpi.\n\t\tdouble weight = std::min(1.0, slc_sr.source->weight);\n\t\tdouble prob = success_plty / weight;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 372,
        "type": "todo_comment",
        "content": "// TODO: refine mutex",
        "context": "\nSourcePtr ForwardChainer::select_source(const std::string& msgprfx)\n{\n\t// TODO: refine mutex\n\tstd::unique_lock<std::mutex> lock(_part_mutex);\n\n\tstd::vector<double> weights = _sources.get_weights();\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 409,
        "type": "todo_comment",
        "content": "// TODO: This has the effect of deallocating the rules, which",
        "context": "\t\tif (_config.get_retry_exhausted_sources()) {\n\t\t\ture_logger().debug() << msgprfx\n\t\t\t                     << \"Reset all exhausted flags to retry them\";\n\t\t\t// TODO: This has the effect of deallocating the rules, which\n\t\t\t// might cause a memory corruption if another thread is\n\t\t\t// attempting to apply that rule at the same time.\n\t\t\t_sources.reset_exhausted();\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.cc",
        "line": 523,
        "type": "todo_comment",
        "content": "std::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine",
        "context": "\nRuleSet ForwardChainer::get_valid_rules(const Source& source)\n{\n\tstd::lock_guard<std::mutex> lock(_rules_mutex); // TODO: refine\n\n\t// Generate all valid rules\n\tRuleSet valid_rules;\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 237,
        "type": "todo_comment",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\n\tbool _search_focus_set;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/ForwardChainer.h",
        "line": 241,
        "type": "todo_comment",
        "content": "// TODO: use shared mutexes",
        "context": "\tmutable std::mutex _whole_mutex;\n\tmutable std::mutex _part_mutex;\n\n\t// TODO: use shared mutexes\n\tmutable std::mutex _rules_mutex;\n\n\t// Keep track of the number of threads to make sure\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.cc",
        "line": 48,
        "type": "todo_comment",
        "content": "// TODO:",
        "context": "\t// The minimum value is 1e-16 to not ignore completely the source\n\t// when the it is a default TV.\n\t//\n\t// TODO:\n\t// 1. Support more fitness functions\n\t// 2. Explicitely turn the fitness into a probability of success\n\tTruthValuePtr tv = bdy->getTruthValue();\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 54,
        "type": "todo_comment",
        "content": "// TODO: this class has thing in common with AndBIT, maybe their",
        "context": " *\n * 4. a flag call indicating if the source expansions have been exhausted.\n */\n// TODO: this class has thing in common with AndBIT, maybe their\n// common things could be placed in a parent class.\nclass Source : public boost::totally_ordered<Source>\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 151,
        "type": "todo_comment",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "\tRuleSet rules;\n\nprivate:\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 165,
        "type": "todo_comment",
        "content": "// TODO: this class has things in common with BIT, maybe their common",
        "context": "/**\n * Population of sources to forwardly expand. Primary owner.\n */\n// TODO: this class has things in common with BIT, maybe their common\n// things could be placed in a parent class.\nclass SourceSet\n{\n"
      },
      {
        "file": "ure/opencog/ure/forwardchainer/SourceSet.h",
        "line": 223,
        "type": "todo_comment",
        "content": "// TODO: subdivide in smaller and shared mutexes",
        "context": "private:\n\tconst UREConfig& _config;\n\n\t// TODO: subdivide in smaller and shared mutexes\n\tmutable std::mutex _mutex;\n};\n\n"
      }
    ]
  }
}