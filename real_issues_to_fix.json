{
  "critical": [
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 115,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 124,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    }
  ],
  "high_priority": [
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 115,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "    categories->emplace_back(i.first);\n  }\n\n  // TODO: Should this be a shared ptr to avoid memory leak?\n  return *categories;\n}\n\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    },
    {
      "file": "components/integration/opencog/opencog/openpsi/OpenPsiRules.cc",
      "line": 124,
      "type": "TODO",
      "content": "// TODO: Should this be a shared ptr to avoid memory leak?",
      "context": "  if(_psi_rules.count(rule)) {\n    return std::get<0>(_psi_rules[rule]);\n  } else {\n    // TODO: Should this be a shared ptr to avoid memory leak?\n    HandleSeq* hs = new HandleSeq();\n    return *hs;\n  }\n",
      "description": "Should this be a shared ptr to avoid memory leak?"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 19,
      "type": "NotImplementedError",
      "content": "\"\"\"Add error handling where NotImplementedError is raised\"\"\"",
      "context": "        self.fixes_failed = []\n        \n    def implement_error_handling(self, filepath, line_num, context):\n        \"\"\"Add error handling where NotImplementedError is raised\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:\n                lines = f.readlines()\n",
      "description": "NotImplementedError is raised\"\"\""
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 28,
      "type": "NotImplementedError",
      "content": "# Check if it's a NotImplementedError",
      "context": "            if line_idx >= len(lines):\n                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n",
      "description": "NotImplementedError\n"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 29,
      "type": "NotImplementedError",
      "content": "if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
      "context": "                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n                for i in range(max(0, line_idx - 10), line_idx):\n",
      "description": "NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 42,
      "type": "TODO",
      "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
      "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n",
      "description": "Implement {func_name} functionality\\n'"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 152,
      "type": "NotImplementedError",
      "content": "# Filter for NotImplementedError and validation TODOs",
      "context": "    \n    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n",
      "description": "NotImplementedError and validation TODOs"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 153,
      "type": "NotImplementedError",
      "content": "not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']",
      "context": "    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n",
      "description": "NotImplementedError']"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 158,
      "type": "NotImplementedError",
      "content": "print(f\"Found {len(not_implemented)} NotImplementedError instances\")",
      "context": "                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n    \n    print(f\"Found {len(not_implemented)} NotImplementedError instances\")\n    print(f\"Found {len(validation_todos)} validation TODOs\")\n    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n",
      "description": "NotImplementedError instances\")"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 163,
      "type": "NotImplementedError",
      "content": "# Process NotImplementedError instances",
      "context": "    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n",
      "description": "NotImplementedError instances"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 164,
      "type": "NotImplementedError",
      "content": "print(\"\\nProcessing NotImplementedError instances...\")",
      "context": "    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n        print(f\"  {i}/{min(5, len(not_implemented))}: {placeholder['file']}:{placeholder['line']}\")\n",
      "description": "NotImplementedError instances...\")"
    },
    {
      "file": "implement_scheme_stubs.py",
      "line": 134,
      "type": "NotImplementedError",
      "content": "'NotImplementedError' in p['content']]",
      "context": "    # Find all 'not-implemented' throws\n    not_implemented = [p for p in data['detailed_placeholders'] \n                      if 'not-implemented' in p['content'].lower() or \n                      'NotImplementedError' in p['content']]\n    \n    print(f\"Found {len(not_implemented)} not-implemented stubs\")\n    \n",
      "description": "NotImplementedError' in p['content']]"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 83,
      "type": "TODO",
      "content": "echo \"   // TODO: Implement error handling for edge case X\"",
      "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n",
      "description": "Implement error handling for edge case X\""
    },
    {
      "file": "atomspace-storage/opencog/persist/api/cython/PersistCython.cc",
      "line": 31,
      "type": "FIXME",
      "content": "// XXX FIXME: except for the error messages, most of this code is",
      "context": "\nnamespace opencog {\n\n// XXX FIXME: except for the error messages, most of this code is\n// mostly a cut-n-pate of what's in PersistSCM.cc\n\n// =====================================================================\n",
      "description": "except for the error messages, most of this code is"
    },
    {
      "file": "atomspace/opencog/atoms/core/Checkers.cc",
      "line": 42,
      "type": "FIXME",
      "content": "// XXX FIXME Much of the onfusion below is due to a bug: if the",
      "context": "/// This only performs a very simple kind of type checking;\n/// it does not check deep types, nor does it check arity.\n\n// XXX FIXME Much of the onfusion below is due to a bug: if the\n// types script says something like\n// FOOBAR <- FUNCTION_LINK,BOOL_INPUT_LINK,NUMBER_INPUT_LINK\n// then the Foobar function will fail if given a boolean input:\n",
      "description": "Much of the onfusion below is due to a bug: if the"
    },
    {
      "file": "atomspace/opencog/atoms/core/TypedVariableLink.cc",
      "line": 56,
      "type": "FIXME",
      "content": "VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug",
      "context": "\t    DEFINED_TYPE_NODE != dtype and\n\t    TYPE_CHOICE != dtype and\n\t    TYPE_INTERSECTION_LINK != dtype and\n\t    VARIABLE_NODE != dtype and // XXX FIXME this is wrong; URE-bug\n\t    SIGNATURE_LINK != dtype and\n\t    INTERVAL_LINK != dtype and\n\t    ARROW_LINK != dtype)\n",
      "description": "this is wrong; URE-bug"
    },
    {
      "file": "atomspace/opencog/atoms/core/Variables.cc",
      "line": 109,
      "type": "FIXME",
      "content": "// XXX FIXME URE calls us with broken handle!!",
      "context": " */\nvoid Variables::validate_vardecl(const Handle& hdecls)\n{\n\t// XXX FIXME URE calls us with broken handle!!\n\tif (nullptr == hdecls) return;\n\n\t// Expecting the declaration list to be either a single\n",
      "description": "URE calls us with broken handle!!"
    },
    {
      "file": "atomspace/opencog/atoms/pattern/PatternLink.cc",
      "line": 1465,
      "type": "FIXME",
      "content": "// XXX FIXME: debug_log() above is more readable than the below.",
      "context": "\nDEFINE_LINK_FACTORY(PatternLink, PATTERN_LINK)\n\n// XXX FIXME: debug_log() above is more readable than the below.\nstd::string PatternLink::to_long_string(const std::string& indent) const\n{\n\tstd::string indent_p = indent + oc_to_string_indent;\n",
      "description": "debug_log() above is more readable than the below."
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 692,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 696,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1256,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support"
    },
    {
      "file": "components/learning/moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
      "description": "this is a bug .. the user may have specified that"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1011,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input."
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1283,
      "type": "TODO",
      "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
      "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
      "description": "this below is clearly unfinished, broken, etc."
    },
    {
      "file": "language-learning/src/grammar_learner/preprocessing.py",
      "line": 141,
      "type": "FIXME",
      "content": "# else:  # FIXME: raise error / assert ?",
      "context": "    if 'corpus_stats' in re:\n        list2file(re['corpus_stats'], corpus_stats_file)\n        re.update({'corpus_stats_file': corpus_stats_file})\n    # else:  # FIXME: raise error / assert ?\n    #    return {'error': 'input_files'}, re\n\n    return links, re\n",
      "description": "raise error / assert ?"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 692,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "        auto it = filter.cbegin();\n        for (unsigned i = 0; i < seq.size(); ++i) {\n            if (it != filter.cend() && (typename F::value_type)i == *it) {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 696,
      "type": "TODO",
      "content": "// XXX TODO WARNING ERROR: builtin hardcoded shit!!!",
      "context": "                res.push_back(seq.get_at<builtin>(i));\n                ++it;\n            } else {\n                // XXX TODO WARNING ERROR: builtin hardcoded shit!!!\n                res.push_back(id::null_vertex);\n            }\n        }\n",
      "description": "WARNING ERROR: builtin hardcoded shit!!!"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 1245,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support"
    },
    {
      "file": "moses/moses/moses/deme/deme_expander.cc",
      "line": 502,
      "type": "FIXME",
      "content": "// XXX FIXME this is a bug .. the user may have specified that",
      "context": "    if (_params.fstor) {\n        // reset scorer to use all variables (important so that\n        // behavioral score is consistent across generations\n        // XXX FIXME this is a bug .. the user may have specified that\n        // certain incdexes should be ignored, and this just wipes\n        // those out...\n        _cscorer.ignore_cols(std::set<arity_t>());\n",
      "description": "this is a bug .. the user may have specified that"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1012,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input."
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1284,
      "type": "TODO",
      "content": "// XXX TODO this below is clearly unfinished, broken, etc.",
      "context": "    }\n}\n\n// XXX TODO this below is clearly unfinished, broken, etc.\n// and can't possibly work ... \nvoid build_knobs::ann_canonize(pre_it it)\n{\n",
      "description": "this below is clearly unfinished, broken, etc."
    },
    {
      "file": "ure/opencog/ure/BetaDistribution.cc",
      "line": 33,
      "type": "TODO",
      "content": "// TODO should be replaced by tv->get_mode() once implemented",
      "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n",
      "description": "should be replaced by tv->get_mode() once implemented"
    }
  ],
  "fixable": [
    {
      "file": "analyze_issue_examples.py",
      "line": 106,
      "type": "FIXME",
      "content": "markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty",
      "context": "    \n    categorized = process_issue_examples()\n    \n    markdown = \"\"\"# FIXME Instances from Issue #74 - Sorted by Implementation Difficulty\n\nThis document analyzes the specific FIXME instances mentioned in issue #74, categorized by implementation difficulty.\n\n",
      "description": "Instances from Issue #74 - Sorted by Implementation Difficulty",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 8,
      "type": "NotImplementedError",
      "content": "\"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"",
      "context": "from pathlib import Path\n\ndef find_stub_implementations(repo_root):\n    \"\"\"Find functions with only pass, ..., or NotImplementedError\"\"\"\n    stubs = []\n    \n    for pyfile in Path(repo_root).rglob(\"*.py\"):\n",
      "description": "NotImplementedError\"\"\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 59,
      "type": "NotImplementedError",
      "content": "elif 'raise NotImplementedError' in first_impl:",
      "context": "                            elif re.match(r'^\\s*\\.\\.\\.\\s*$', first_impl):\n                                is_stub = True\n                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n",
      "description": "raise NotImplementedError' in first_impl:",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_actual_stubs.py",
      "line": 61,
      "type": "NotImplementedError",
      "content": "stub_type = 'NotImplementedError'",
      "context": "                                stub_type = 'ellipsis'\n                            elif 'raise NotImplementedError' in first_impl:\n                                is_stub = True\n                                stub_type = 'NotImplementedError'\n                            elif re.match(r'^\\s*return\\s+None\\s*$', first_impl) and len(impl_lines) == 1:\n                                is_stub = True\n                                stub_type = 'return_none'\n",
      "description": "NotImplementedError'",
      "reason": "Error with description"
    },
    {
      "file": "find_placeholders.py",
      "line": 4,
      "type": "NotImplementedError",
      "content": "Finds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions",
      "context": "#!/usr/bin/env python3\n\"\"\"\nComprehensive Placeholder Detection Script\nFinds all TODO, FIXME, XXX, NotImplementedError, stub implementations, and empty functions\n\"\"\"\nimport os\nimport re\n",
      "description": "NotImplementedError, stub implementations, and empty functions",
      "reason": "Has implementation hints"
    },
    {
      "file": "find_placeholders.py",
      "line": 21,
      "type": "NotImplementedError",
      "content": "'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
      "context": "        self.patterns = {\n            'TODO': r'(//|#|;|/\\*)\\s*TODO[:\\s]',\n            'FIXME': r'(//|#|;|/\\*)\\s*(FIXME|XXX)[:\\s]',\n            'NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',\n            'pass_only': r'def\\s+\\w+\\([^)]*\\):\\s*pass\\s*$',\n            'empty_function': r'def\\s+\\w+\\([^)]*\\):\\s*\\.\\.\\.\\s*$',\n            'stub': r'(//|#|;)\\s*STUB[:\\s]',\n",
      "description": "NotImplementedError': r'(raise\\s+NotImplementedError|throw.*not.*implemented)',",
      "reason": "Has implementation hints"
    },
    {
      "file": "generate_progress_report.py",
      "line": 29,
      "type": "NotImplementedError",
      "content": "ni_count=analysis['by_type'].get('NotImplementedError', 0)",
      "context": "    fixme_count=analysis['by_type'].get('FIXME', 0)\n    todo_count=analysis['by_type'].get('TODO', 0)\n    stub_comment_count=analysis['by_type'].get('stub', 0)\n    ni_count=analysis['by_type'].get('NotImplementedError', 0)\n    stub_func_count=len(stubs)\n    total_fixes=impl_report['summary']['total_fixes_applied'] + feature_report['summary']['total_implementations']\n    obsolete_fixes_count=impl_report['summary']['by_type'].get('obsolete_comment', 0)\n",
      "description": "NotImplementedError', 0)",
      "reason": "Has implementation hints"
    },
    {
      "file": "generate_progress_report.py",
      "line": 60,
      "type": "NotImplementedError",
      "content": "| **NotImplementedError** | {ni_count}    |",
      "context": "| **FIXME**             | {fixme_count} |\n| **TODO**              | {todo_count}  |\n| **Stub Comments**     | {stub_comment_count} |\n| **NotImplementedError** | {ni_count}    |\n| **Total**             | **{total_placeholders}** |\n\nAdditionally, **{stub_func_count}** actual stub functions (with `pass` or similar) were found, one of which was a candidate for implementation.\n",
      "description": "NotImplementedError** | {ni_count}    |",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 19,
      "type": "NotImplementedError",
      "content": "\"\"\"Add error handling where NotImplementedError is raised\"\"\"",
      "context": "        self.fixes_failed = []\n        \n    def implement_error_handling(self, filepath, line_num, context):\n        \"\"\"Add error handling where NotImplementedError is raised\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:\n                lines = f.readlines()\n",
      "description": "NotImplementedError is raised\"\"\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 28,
      "type": "NotImplementedError",
      "content": "# Check if it's a NotImplementedError",
      "context": "            if line_idx >= len(lines):\n                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n",
      "description": "NotImplementedError\n",
      "reason": "Error with description"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 29,
      "type": "NotImplementedError",
      "content": "if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
      "context": "                return False\n            \n            # Check if it's a NotImplementedError\n            if 'NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():\n                # Look for function definition\n                func_name = None\n                for i in range(max(0, line_idx - 10), line_idx):\n",
      "description": "NotImplementedError' in lines[line_idx] or 'not implemented' in lines[line_idx].lower():",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 42,
      "type": "TODO",
      "content": "new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'",
      "context": "                if func_name:\n                    # Add a basic implementation with logging\n                    indent = len(lines[line_idx]) - len(lines[line_idx].lstrip())\n                    new_impl = ' ' * indent + f'# TODO: Implement {func_name} functionality\\n'\n                    new_impl += ' ' * indent + f'logger.warning(f\"{func_name} not fully implemented\")\\n'\n                    new_impl += ' ' * indent + 'return None  # Placeholder return\\n'\n                    \n",
      "description": "Implement {func_name} functionality\\n'",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 152,
      "type": "NotImplementedError",
      "content": "# Filter for NotImplementedError and validation TODOs",
      "context": "    \n    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n",
      "description": "NotImplementedError and validation TODOs",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 153,
      "type": "NotImplementedError",
      "content": "not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']",
      "context": "    placeholders = data['detailed_placeholders']\n    \n    # Filter for NotImplementedError and validation TODOs\n    not_implemented = [p for p in placeholders if p['type'] == 'NotImplementedError']\n    validation_todos = [p for p in placeholders \n                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n",
      "description": "NotImplementedError']",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 158,
      "type": "NotImplementedError",
      "content": "print(f\"Found {len(not_implemented)} NotImplementedError instances\")",
      "context": "                       if p['type'] == 'TODO' and \n                       any(kw in p['content'].lower() for kw in ['check', 'validate', 'verify'])]\n    \n    print(f\"Found {len(not_implemented)} NotImplementedError instances\")\n    print(f\"Found {len(validation_todos)} validation TODOs\")\n    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n",
      "description": "NotImplementedError instances\")",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 163,
      "type": "NotImplementedError",
      "content": "# Process NotImplementedError instances",
      "context": "    \n    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n",
      "description": "NotImplementedError instances",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_functional_fixes.py",
      "line": 164,
      "type": "NotImplementedError",
      "content": "print(\"\\nProcessing NotImplementedError instances...\")",
      "context": "    fixer = FunctionalFixer('/home/ubuntu/opencog-unified')\n    \n    # Process NotImplementedError instances\n    print(\"\\nProcessing NotImplementedError instances...\")\n    for i, placeholder in enumerate(not_implemented[:5], 1):\n        filepath = fixer.repo_root / placeholder['file']\n        print(f\"  {i}/{min(5, len(not_implemented))}: {placeholder['file']}:{placeholder['line']}\")\n",
      "description": "NotImplementedError instances...\")",
      "reason": "Has implementation hints"
    },
    {
      "file": "implement_scheme_stubs.py",
      "line": 134,
      "type": "NotImplementedError",
      "content": "'NotImplementedError' in p['content']]",
      "context": "    # Find all 'not-implemented' throws\n    not_implemented = [p for p in data['detailed_placeholders'] \n                      if 'not-implemented' in p['content'].lower() or \n                      'NotImplementedError' in p['content']]\n    \n    print(f\"Found {len(not_implemented)} not-implemented stubs\")\n    \n",
      "description": "NotImplementedError' in p['content']]",
      "reason": "Has implementation hints"
    },
    {
      "file": "setup_fixme_environment.py",
      "line": 83,
      "type": "TODO",
      "content": "echo \"   // TODO: Implement error handling for edge case X\"",
      "context": "            if [ $new_fixmes -eq 1 ]; then\n                echo \"\"\n                echo \"\ud83d\udca1 Tip: Use descriptive TODO comments instead:\"\n                echo \"   // TODO: Implement error handling for edge case X\"\n                echo \"   // TODO(v2.0): Refactor to use new API\"\n                echo \"\"\n                exit 1\n",
      "description": "Implement error handling for edge case X\"",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 15,
      "type": "NotImplementedError",
      "content": "'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),",
      "context": "    patterns = {\n        'FIXME': re.compile(r'(//|#)\\s*(XXX\\s+)?FIXME[:\\s]*(.*)', re.IGNORECASE),\n        'TODO': re.compile(r'(//|#)\\s*(XXX\\s+)?TODO[:\\s]*(.*)', re.IGNORECASE),\n        'NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),\n        'stub': re.compile(r'(//|#)\\s*stub[:\\s]*(.*)', re.IGNORECASE),\n        'pass_placeholder': re.compile(r'pass\\s*#\\s*placeholder', re.IGNORECASE),\n        'empty_function': re.compile(r'^\\s*(def|void|int|bool|float|double)\\s+\\w+\\([^)]*\\)\\s*{\\s*}\\s*$'),\n",
      "description": "NotImplementedError': re.compile(r'(raise\\s+)?NotImplementedError\\s*\\(?(.*)\\)?'),",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 106,
      "type": "NotImplementedError",
      "content": "# Check for NotImplementedError with description",
      "context": "        # Check if it has clear implementation hints\n        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n",
      "description": "NotImplementedError with description",
      "reason": "Has implementation hints"
    },
    {
      "file": "analyze_placeholders.py",
      "line": 107,
      "type": "NotImplementedError",
      "content": "elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:",
      "context": "        elif 'implement' in p['description'].lower() and len(p['description']) > 20:\n            fixable.append({**p, 'reason': 'Has implementation hints'})\n        # Check for NotImplementedError with description\n        elif p['type'] == 'NotImplementedError' and len(p['description']) > 5:\n            fixable.append({**p, 'reason': 'Error with description'})\n        else:\n            needs_research.append(p)\n",
      "description": "NotImplementedError' and len(p['description']) > 5:",
      "reason": "Has implementation hints"
    },
    {
      "file": "atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
      "line": 109,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
      "line": 136,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void) { \n\t\t\tkill_data(); \n\t\t\tif (_rfile) {\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "cogutil/opencog/util/zipf.h",
      "line": 90,
      "type": "empty_function",
      "content": "void reset() {}",
      "context": "\t\t\tif (-0.5 >= q)\n\t\t\t\tthrow std::runtime_error(\"Range error: Parameter q must be greater than -0.5!\");\n\t\t}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
      "description": "\t\tvoid reset() {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "cogutil/opencog/util/zipf.h",
      "line": 233,
      "type": "empty_function",
      "content": "void reset() {}",
      "context": "\t\t\t_q(q),\n\t\t\t_dist(_pdf.begin(), _pdf.end())\n\t\t{}\n\t\tvoid reset() {}\n\n\t\tIntType operator()(std::mt19937& rng)\n\t\t{\n",
      "description": "\t\tvoid reset() {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/monospace/MonoStorage.h",
      "line": 107,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/core/atomspace-rocks/opencog/persist/rocks/RocksStorage.h",
      "line": 136,
      "type": "empty_function",
      "content": "void create(void) {}",
      "context": "\t\tvoid close(void);\n\t\tbool connected(void); // connection to DB is alive\n\n\t\tvoid create(void) {}\n\t\tvoid destroy(void);\n\t\tvoid erase(void) { kill_data(); }\n\n",
      "description": "\t\tvoid create(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/language/lg-atomese/opencog/nlp/lg-dict/LGDictNode.cc",
      "line": 132,
      "type": "empty_function",
      "content": "void opencog_nlp_lgparse_init(void) {}",
      "context": "\n/* This allows guile to load this shared library */\nextern \"C\" {\n\tvoid opencog_nlp_lgparse_init(void) {}\n};\n",
      "description": "\tvoid opencog_nlp_lgparse_init(void) {}\n",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 667,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
      "description": "// stub out, for performance.",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 697,
      "type": "stub",
      "content": "// stubbed out for performance",
      "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
      "description": "// stubbed out for performance",
      "reason": "Simple stub implementation"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable",
      "reason": "Has implementation hints"
    },
    {
      "file": "components/learning/moses/moses/comboreduct/table/table_io.cc",
      "line": 1256,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support",
      "reason": "Has implementation hints"
    },
    {
      "file": "components/learning/moses/moses/moses/representation/build_knobs.cc",
      "line": 1011,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input.",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 669,
      "type": "stub",
      "content": "// stub out, for performance.",
      "context": "                              make_counting_iterator(current.end()));\n\n#if DEBUG\n        // stub out, for performance.\n        OC_ASSERT(std::is_sorted(dominant.begin(),dominant.end(), comp),\n                  \"dominant subtree_set should be sorted (reduce_and)\");\n#endif\n",
      "description": "// stub out, for performance.",
      "reason": "Simple stub implementation"
    },
    {
      "file": "moses/moses/comboreduct/reduct/logical_rules.cc",
      "line": 699,
      "type": "stub",
      "content": "// stubbed out for performance",
      "context": "            tr.validate();\n\n#if DEBUG\n            // stubbed out for performance\n            OC_ASSERT(std::is_sorted(command.begin(),command.end(),comp),\n                      \"command subtree_set should be sorted (reduce_and)\");\n            OC_ASSERT(std::is_sorted(handle_set.begin(),handle_set.end(),comp),\n",
      "description": "// stubbed out for performance",
      "reason": "Simple stub implementation"
    },
    {
      "file": "moses/moses/comboreduct/table/table.h",
      "line": 1134,
      "type": "TODO",
      "content": "// XXX TODO to implement enum support, cut-n-paste from CTable",
      "context": "template<typename FeatureSet>\ndouble mutualInformation(const ITable& it, const OTable& ot, const FeatureSet& fs)\n{\n    // XXX TODO to implement enum support, cut-n-paste from CTable\n    // mutual info code, below.\n    type_node otype = ot.get_type();\n    OC_ASSERT(id::boolean_type == otype, \"Only boolean types supported\");\n",
      "description": "to implement enum support, cut-n-paste from CTable",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/comboreduct/table/table_io.cc",
      "line": 1245,
      "type": "TODO",
      "content": "// TODO: implement timestamp support",
      "context": "// ==================================================================\n\n// Parse a CTable row\n// TODO: implement timestamp support\nCTable::value_type parseCTableRow(const type_tree& tt, const std::string& row_str)\n{\n    // split the string between input and output\n",
      "description": "implement timestamp support",
      "reason": "Has implementation hints"
    },
    {
      "file": "moses/moses/moses/representation/build_knobs.cc",
      "line": 1012,
      "type": "TODO",
      "content": "// TODO: implement support for enumerated types in the input.",
      "context": "// ***********************************************************************\n// Enumerated types.\n// For now, we only handle enumerated types on output, and not on input.\n// TODO: implement support for enumerated types in the input.\n\n/// enum_canonize: make sure that the exemplar is in canonical form.\n/// The canonical form will be of the form\n",
      "description": "implement support for enumerated types in the input.",
      "reason": "Has implementation hints"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 128,
      "type": "stub",
      "content": "lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility",
      "context": "#else\n        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n",
      "description": "// Stub: minimal allocation for compatibility",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.cc",
      "line": 129,
      "type": "stub",
      "content": "lg_options_ = new int(2);    // Stub: minimal allocation for compatibility",
      "context": "        // Fallback stub implementation when Link Grammar library is not available\n        // These stubs maintain API compatibility while indicating library absence\n        lg_dictionary_ = new int(1); // Stub: minimal allocation for compatibility\n        lg_options_ = new int(2);    // Stub: minimal allocation for compatibility\n        \n        logger().warn(\"Link Grammar library not available. Using fallback parser with limited functionality.\");\n        \n",
      "description": "// Stub: minimal allocation for compatibility",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 136,
      "type": "stub",
      "content": "// Stub types when Link Grammar is not available",
      "context": "    Dictionary lg_dictionary_;\n    Parse_Options lg_options_;\n#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n",
      "description": "// Stub types when Link Grammar is not available",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 138,
      "type": "stub",
      "content": "void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
      "context": "#else\n    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n",
      "description": "// Stub: would be Dictionary if HAVE_LINK_GRAMMAR",
      "reason": "Simple stub implementation"
    },
    {
      "file": "opencog/opencog/main/LGParser.h",
      "line": 139,
      "type": "stub",
      "content": "void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
      "context": "    // Stub types when Link Grammar is not available\n    // Using void* to maintain API compatibility while indicating unavailability\n    void* lg_dictionary_;  // Stub: would be Dictionary if HAVE_LINK_GRAMMAR\n    void* lg_options_;     // Stub: would be Parse_Options if HAVE_LINK_GRAMMAR\n#endif\n    \n    /**\n",
      "description": "// Stub: would be Parse_Options if HAVE_LINK_GRAMMAR",
      "reason": "Simple stub implementation"
    },
    {
      "file": "ure/opencog/ure/BetaDistribution.cc",
      "line": 33,
      "type": "TODO",
      "content": "// TODO should be replaced by tv->get_mode() once implemented",
      "context": "\nBetaDistribution::BetaDistribution(const TruthValuePtr& tv,\n                                   double p_alpha, double p_beta)\n\t// TODO should be replaced by tv->get_mode() once implemented\n\t: BetaDistribution(tv->get_mean() * tv->get_count(),\n\t                   tv->get_count(), p_alpha, p_beta) {}\n\n",
      "description": "should be replaced by tv->get_mode() once implemented",
      "reason": "Has implementation hints"
    }
  ]
}